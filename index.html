<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>PRMTTN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="module" src="https://esm.sh/web-bundlr@0.1.1"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Three .js + OrbitControls (una sola vez) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <style>
  body {
    margin: 0;
    overflow: hidden;
    background: #ffffff;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-weight: 200;
    font-size: 12px;
    cursor: none;
  }
  #customCursor {
    position: fixed;
    width: 12px; height: 12px;
    border-radius: 50%;
    background: #000;
    border: 1px solid #fff;
    pointer-events: none; z-index: 300;
    transform: translate(-50%, -50%);
  }
  /* HUD eliminado */
  #topRightDisplay{
    display:none !important;
  }
  button{
    cursor:none;
    border:none;
    border-radius:4px;
    padding:8px 12px;
    font-size:12px;
    z-index:250;
    background:rgba(255,255,255,0.12);
    transition:background 0.2s;
  }
  button:hover{
    background:rgba(255,255,255,0.20);
  }

  /* === LAYOUT (orden y ESPACIADO nuevos) === */
  #toggleTextButton     { position:fixed; right:10px; bottom:10px;   }   /* Minimal UI */
  #aiPlanningButton     { position:fixed; right:10px; bottom:50px;   }   /* AI Planning */
  #saveImageButton      { position:fixed; right:10px; bottom:90px;  }   /* Save Image (A2) – debajo de Load JSON */
  #uploadConfigButton   { position:fixed; right:10px; bottom:130px;  }   /* Load JSON */
  #exportEmbedButton    { position:fixed; right:10px; bottom:170px;  }   /* Save JSON */
  #archDescButton       { position:fixed; right:10px; bottom:210px;  }   /* Architectural Description */
  #perm120Button        { position:fixed; right:10px; bottom:250px;  }   /* 120 Architectural Permutations */
#randomConfigButton   { position:fixed; left:10px; bottom:130px;  }   /* BUILD  */
   #certButton           { position:fixed; right:10px; bottom:30px; }   /* Edition Certificate */
  /* === FRBN toggle === */
#frbnWrap { position:fixed; left:10px; bottom:90px; z-index:260; }
#frbnButton { position:relative; }  /* dentro del wrap */
#frbnInfoButton{
  position:absolute; top:-6px; right:-6px;
  padding:2px 6px; font-size:10px; opacity:.9;
  background:rgba(255,255,255,0.2);
}

  #saveImageButton { background:rgba(255,255,255,0.2); }

  /* Ocultar los no usados */
  #btnDebugColors,
  #triadicConfigButton{
    display:none !important;
  }

  #controls {
    position: absolute; top: 10px; left: 10px; z-index: 100;
    padding: 10px; border-radius: 5px;
    background: rgba(255,255,255,0.12); max-width: 350px;
  }
  details {
    margin-bottom: 10px;
    background: rgba(255,255,255,0.06);
  }
  details summary { font-weight: 200; cursor: pointer; }
  details summary:hover { color: #333; }
  select, input[type="range"], input[type="color"] { cursor: none; width: 100%; }
  #permutationList { width: 100%; height: 100px; }

  /* rating oculto */
  #ratingContainer{
    display:none !important;
  }

  #hoverPopup {
    position:absolute; padding:5px 10px;
    background:rgba(0,0,0,0.7); color:#fff;
    border-radius:4px; pointer-events:none;
    font-size:12px; display:none; opacity:0;
    transition:opacity .3s; z-index:200;
  }

  #modeBlock,
  #nftBlock,
  #secretBlock{
    display:none;
  }

  /* Panel BUILD */
  #archPanel{
    position:fixed; z-index:1000; top:5%; left:50%;
    transform:translateX(-50%);
    width:85%; height:90%;
    background:#fff; color:#000;
    border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
    padding:24px 32px 48px; overflow:auto;
    font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size:14px; line-height:1.4;
    cursor:auto;
  }
  #archPanel *{ cursor:auto !important; }
  #archClose{
    position:fixed; right:calc(7.5% + 16px); top:5%;
    border:none; padding:6px 10px; border-radius:4px;
    background:#eee; cursor:pointer; z-index:1001;
  }
  #archPanel h2{ margin-top:0; }
  #archPanel .formula{
    margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
  }
  #archPanel .box{
    display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
    font-family:monospace;
  }
  #archPanel section{ margin-bottom:18px; }
  #archPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
  #archPanel .perm h4{ margin-bottom:6px; }
  code, pre{ font-family:monospace; }

  /* Panel 120 perms */
  #perm120Panel{
    position:fixed; right:10px; bottom:340px; z-index:260;
    background:rgba(255,255,255,0.12);
    padding:8px 10px; border-radius:4px; width:260px;
    display:none; /* ← cerrado por defecto */
  }
  #perm120Panel label{ display:block; margin-bottom:6px; }
  #perm120Panel input, #perm120Panel button{ width:100%; margin-top:4px; }
  #perm120Status{
    margin-top:8px;
    font-size:12px;       /* ← mismo tamaño que los demás */
    font-weight:normal;
    text-align:center;
  }
  /* === Information button & panel === */
  #infoButton{
    position:fixed; left:10px; bottom:10px; z-index:260;
  }
  #infoPanel{
    position:fixed; z-index:1000; top:5%; left:50%;
    transform:translateX(-50%);
    width:85%; height:90%;
    background:#fff; color:#000;
    border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
    padding:24px 32px 48px; overflow:auto;
    font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size:14px; line-height:1.45;
    cursor:auto;
  }
  #infoPanel *{ cursor:auto !important; }
  #infoClose{
    position:fixed; right:calc(7.5% + 16px); top:5%;
    border:none; padding:6px 10px; border-radius:4px;
    background:#eee; cursor:pointer; z-index:1001;
  }
  #infoPanel h2{ margin-top:0; }
  #infoPanel .formula{
    margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
  }
  #infoPanel .box{
    display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
    font-family:monospace;
  }
  #infoPanel section{ margin-bottom:18px; }
  #infoPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
  /* === LCHT toggle === */
  #lchtWrap  { position:fixed; left:10px; bottom:50px; z-index:260; }
  #lchtButton{ position:relative; }
  </style>
</head>
<body>
  <div id="customCursor"></div>
  <div id="topRightDisplay"></div>

  <input type="file" id="json-upload" accept=".json" style="display:none;" />

  <button id="aiPlanningButton"   onclick="applyEvolutionAI()">AI Planning</button>
  <button id="toggleTextButton"   onclick="toggleTexts()">Minimal UI</button>
  <button id="uploadConfigButton" onclick="document.getElementById('json-upload').click()">Load JSON</button>
  <button id="saveImageButton"    onclick="saveImage()">Save Image (A2)</button>
  <button id="exportEmbedButton"  onclick="exportEmbed()">Save JSON</button>
  <button id="archDescButton"     onclick="showArchitecturalDescription()">Architectural Description</button>
  <button id="randomConfigButton" onclick="generateRandomConfigurationNoCollision()">BUILD</button>
  <button id="perm120Button"      onclick="togglePerm120Panel()">120 Architectural Permutations</button>
<div id="frbnWrap">
  <button id="frbnButton" onclick="toggleFRBN()">FRBN</button>
  <button id="frbnInfoButton" onclick="showFRBNInfo()" title="Information">i</button>
</div>
  <button id="certButton" onclick="exportEditionCertificate()">Edition Certificate</button>
  <div id="lchtWrap">
    <button id="lchtButton" onclick="toggleLCHT()">LCHT</button>
  </div>
  <button id="infoButton"       onclick="showInformation()">Information</button>
  <button id="btnDebugColors"
          style="position:fixed;bottom:180px;right:10px;z-index:260;display:none;"
          onclick="mostrarDebugColores()">
    Debug Colors
  </button>

  <!-- Panel controles 120 perms -->
  <div id="perm120Panel">
    <label>Auto‑advance (1s → 12m)</label>
    <input type="range" id="perm120Slider" min="1000" max="720000" step="1000" value="5000"
           oninput="syncPerm120InputsFromSlider()">
    <input type="number" id="perm120Seconds" min="1" max="720" value="5"
           oninput="syncPerm120SliderFromSeconds()">
    <small>(seconds)</small>
    <button onclick="playPerm120()">Play</button>
    <button onclick="pausePerm120()">Pause</button>
    <button onclick="prevPerm120()">Prev</button>
    <button onclick="nextPerm120()">Next</button>
    <button onclick="showPerm120Info()">Information</button>
    <div id="perm120Status">Permutation: 0 / 119</div>
  </div>

  <div id="ratingContainer">
    <details open>
      <summary>Calificar Configuración</summary>
      <div id="ratingControls">
        <div id="ratingLabels"><span>1</span><span>2</span><span>3</span><span>4</span><span>5</span></div>
        <div id="ratingDots">
          <span class="ratingBtn" data-rating="1">●</span>
          <span class="ratingBtn" data-rating="2">●</span>
          <span class="ratingBtn" data-rating="3">●</span>
          <span class="ratingBtn" data-rating="4">●</span>
          <span class="ratingBtn" data-rating="5">●</span>
        </div>
      </div>
    </details>
  </div>

  <div id="controls">
  <details open>
    <summary>Chromatic Pattern</summary>
          <select id="patternSelect" onchange="setActivePattern(this.value)">
        <option value="1">1 · Chromatic Containment</option>
        <option value="2">2 · Contrast &amp; Dissonance</option>
        <option value="3">3 · Non‑semantic Disposition</option>
        <option value="4">4 · Structured Ambiguity</option>
        <option value="5">5 · Chromatic Isotropy</option>
        <option value="6">6 · Self‑Sufficient Presence</option>
        <option value="7">7 · Associative Asymmetry</option>
        <option value="8">8 · Irregular Dynamics</option>
        <option value="9">9 · Habitable without Translation</option>
        <option value="10">10 · Resonance</option>
        <option value="11">11 · Active Transparency</option>
      </select>
      <button id="patternInfoButton"
              style="margin-top:6px;width:100%;"
              onclick="showPatternInfo()">
        Pattern Information
      </button>

  </details>

  <div id="manualControls">
    <details>
      <summary>Select Permutations</summary>
      <select id="permutationList" multiple></select>
      <button onclick="refreshAll({rebuild:true})">Render</button>
    </details>
  </div>

  <div id="evolutionControls" style="display:none;">
    <details open>
      <summary>Evolution Parameters</summary>
      <p>Mutation Rate: <input type="range" id="mutationRate" min="0" max="1" step="0.01" value="0.1"></p>
      <p>Change Threshold: <input type="range" id="threshold" min="0" max="1" step="0.01" value="0.5"></p>
      <button onclick="applyEvolution()">Apply Evolution</button>
      <div id="evolutionInfo" style="margin-top:8px;font-size:12px;"></div>
    </details>
  </div>

  <details>
    <summary>Manual Colors (override)</summary>
    <div><label>1: <input type="color" id="color1" onchange="onColourPick(1,this.value)"></label></div>
    <div><label>2: <input type="color" id="color2" onchange="onColourPick(2,this.value)"></label></div>
    <div><label>3: <input type="color" id="color3" onchange="onColourPick(3,this.value)"></label></div>
    <div><label>4: <input type="color" id="color4" onchange="onColourPick(4,this.value)"></label></div>
    <div><label>5: <input type="color" id="color5" onchange="onColourPick(5,this.value)"></label></div>
    <button id="btnResetAll" style="margin-top:6px;" onclick="resetAllColours()">
      Reset Background + Walls + Colors
    </button>
  </details>

  <details>
    <summary>Background</summary>
    <input type="color" id="bgColor" value="#ffffff">
    <button onclick="updateBackground()">Apply Background</button>
  </details>

  <details>
    <summary>Cube Walls Color</summary>
    <input type="color" id="cubeColor" value="#808080">
    <button onclick="updateCubeColor()">Apply Cube Walls</button>
  </details>

  <details>
    <summary>Attributes Reorganization</summary>
    <select id="attrMapping"></select>
    <button onclick="updateMapping()">Apply</button>
    <button onclick="autoResolveColisionesGlobal()">Resolve Collisions</button>
  </details>

  <details>
    <summary>Standard Views</summary>
    <select id="standardView">
      <option value="isometric">Isometric</option>
      <option value="top">Top</option>
      <option value="front" selected>Front</option>
      <option value="side">Side</option>
      <option value="diagonal">Opposite diagonal</option>
    </select>
    <button onclick="applyStandardView()">Apply View</button>
  </details>

  <details>
    <summary>Zoom Controls</summary>
    <button onclick="zoomIn()">Zoom In</button>
    <button onclick="zoomOut()">Zoom Out</button>
  </details>

  <details>
    <summary>Motion Controls</summary>
    <button onclick="togglePause()">Pause Motion</button>
    <button onclick="resetMovement()">Reset Motion</button>
  </details>
</div>

<details id="nftBlock">
  <summary>⋆ NFT</summary>
  <button id="btn-mint" style="width:100%;margin-top:8px;">Mint NFT</button>
</details>

<script>
document.getElementById('json-upload').addEventListener('change', function(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const config = JSON.parse(e.target.result);

      // Permutations
      if (config.perms && Array.isArray(config.perms)) {
        const sel = document.getElementById('permutationList');
        Array.from(sel.options).forEach(o => o.selected = config.perms.includes(o.value));
      }

      // Mapping
      if (config.mapping) {
        const v = [config.mapping.forma, config.mapping.color, config.mapping.x, config.mapping.y, config.mapping.z];
        document.getElementById('attrMapping').value = v.join(',');
        attributeMapping = [v[0], v[1], v[2], v[3], v[4], attributeMapping[5], attributeMapping[6]];
      }

      // Pattern
      if (typeof config.pattern === 'number') {
        activePatternId = config.pattern;
        const selPattern = document.getElementById('patternSelect');
        if (selPattern) selPattern.value = String(config.pattern);
      }

      // Manual colors
      if (config.colors) {
        manualOverride = {};
        Object.entries(config.colors).forEach(([i, c]) => {
          manualOverride[Number(i)] = c;
        });
      }

      // BG / cube
      if (config.bg) {
        document.getElementById('bgColor').value = config.bg;
        bgOverride = config.bg;
      }
      if (config.cube) {
        document.getElementById('cubeColor').value = config.cube;
        cubeOverride = config.cube;
      }

      // Scene invariants (optional)
      if (typeof config.sceneSeed === 'number') {
        sceneSeed = config.sceneSeed;
      }
      if (typeof config.S_global === 'number') {
        S_global = config.S_global;
      }

      // View
      const view = config.view || "front";
      document.getElementById('standardView').value = view;

      // Rebuild
      refreshAll({rebuild:true, keepManual:true});
      applyStandardView();

      alert('JSON loaded successfully');
    } catch (err) {
      alert('Error loading JSON: ' + err.message);
    }
  };
  reader.readAsText(file);
});
</script>

<details id="secretBlock" open>
  <summary>📁 Añadir Archivo Secreto</summary>
  <div id="dropzone" style="padding:10px;border:2px dashed #ccc;background:#f9f9f9;margin-top:10px;text-align:center;cursor:pointer;transition:border-color 0.2s;">
    <p>Arrastra aquí tu archivo secreto o haz clic para seleccionar</p>
    <input type="file" id="fileInput" style="display:none" />
    <p id="uploadStatus"></p>
    <p id="jwkOutput" style="word-break:break-all;font-size:11px;"></p>
    <p id="cidOutput" style="word-break:break-all;font-size:11px;"></p>
  </div>
</details>

  <div id="hoverPopup"></div>

  <!-- (eliminados: copias duplicadas de Three, OrbitControls y Ethers) -->
  <!-- Bundlr -->
  <script type="module">
    import { WebBundlr } from "https://esm.sh/web-bundlr@0.1.1";
    window.addEventListener("load", async () => {
      try {
        const bundlr = new WebBundlr("https://node1.bundlr.network", "matic", window.ethereum);
        await bundlr.ready();
        const balance = await bundlr.getLoadedBalance();
        console.log("Bundlr listo, balance:", balance.toString());
        window.bundlr = bundlr;
      } catch (err) {
        console.error("Error inicializando Bundlr:", err);
      }
    });
  </script>
  <script>
    // ------------- TODO EL JS ORIGINAL (¡NO QUITES NADA DE AQUÍ!) -------------
    // === LISTA DE 120 COLORES ===
    const CUSTOM_COLORS = [
      "#070709","#898052","#402523","#0d080a","#070909","#050608","#070509",
      "#12080d","#330a0d","#9c714f","#382e24","#883933","#decda0",
      "#fafcff","#a4b6bc","#e7e8e1","#f3f1ea","#eaebe2","#dcdacf","#f8f9f8",
      "#f6f5ea","#ffffff","#f3f3f0","#faf9f0","#f5f7f6","#eeece8","#fffef7",
      "#350b0c","#9e4031","#820707","#eeb049","#120607","#f6f1ed",
      "#300809","#8c2d18","#6a6620","#b99c5c","#110505","#5f2423",
      "#400909","#a04b37","#180506","#e1b055","#6f2919","#170607",
      "#000000","#9c822b","#3e1b2c","#edce83","#1b0408","#8a4667",
      "#000000","#ec9b1c","#701a25","#9c2c1a","#480b0b","#150407",
      "#2a0607","#b08b4f","#7a181d","#5d180f","#1f0908","#dfb46e",
      "#0b0304","#a4735a","#4e272a","#cab296","#923930","#1d0709",
      "#f4c061","#963326","#d89048","#430f0c","#ce5830","#72121a",
      "#fefffe","#c0b280","#57231d","#99541e","#210d0a","#8a5d2f",
      "#33090a","#e2a33f","#a24a2c","#591e14","#8f2e1c","#1e0809",
      "#bd4d1d","#441b1d","#0f0406","#e3a337","#886c39","#1a0807",
      "#fffcee","#cea564","#9a7859","#080103","#000003","#000100",
      "#000000","#6d4d2c","#2d060a","#000005","#000100","#2d0006",
      "#17120a","#451e18","#42401c","#7c4934","#8c7640","#c0b468"
    ];

    // === Variables globales ===
    let scene, camera, renderer, controls, raycaster, mouse;
    let cubeUniverse, permutationGroup;
    const cubeSize = 30, segment = cubeSize/5, halfCube = cubeSize/2;
    let isPaused = false, currentMode = "manual", userRating = null, textsVisible = true;
    let attributeMapping = [0,1,2,3,4, 0,1];   // forma,color,x,y,z,bg,wall
    let colorAttrCycle = 0;                    // ← cuenta las rotaciones de color
    let paletteRGB = [];
    let manualOverride = {1:'#ff0000',2:'#00ff00',3:'#0000ff',4:'#ff00ff',5:'#00ffff'};
    let bgOverride   = null;
    let cubeOverride = null;
    /* variables globales para fondo y paredes */
    let bgHSV = {h:0,s:0,v:1};
    let wallHSV = {h:0,s:0,v:1};
    let  currentHarmony = 'triad';
    let activePatternId = 1;           // arranca en Contención
    const ΔE_MIN = 20;
    
    // >>> NUEVO:
    let S_global = 0; // término estructural para posiciones (Shift-Rank acoplado)

    /* ─────────────────────────────
     *   FRBN  ·  deterministic Ganzfeld
     * ───────────────────────────── */
    let skySphere = null;
    let isFRBN    = false;
    const SKY_R = 250;

/* ──────────────────────────────────────────────────────────────
 *  initSkySphere — FRBN con micro-ruido “blue-noise” y highp
 *  (solo afecta al fondo shader del modo FRBN)
 * ──────────────────────────────────────────────────────────── */
function initSkySphere() {
  const geo = new THREE.PlaneGeometry(2, 2);

  const mat = new THREE.ShaderMaterial({
    uniforms : {
      u_count     : { value: 0 },
      u_colors    : { value: Array(12).fill(new THREE.Color(0x000000)) },
      time        : { value: 0 },
      u_rate      : { value: 0.04 },
      // amplitud del dither (ajústala si quieres): ~1/1024
      u_ditherAmp : { value: 0.00095 }
    },
    side: THREE.DoubleSide,
    depthWrite: false,
    depthTest : false,
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position.xy, 0.0, 1.0);
      }`,
    fragmentShader: `
      #ifdef GL_ES
      precision highp float;
      #endif

      uniform int   u_count;
      uniform vec3  u_colors[12];
      uniform float time;
      uniform float u_rate;
      uniform float u_ditherAmp;
      varying vec2  vUv;

      // Interleaved Gradient Noise (Jimenez 2014) – base para blue-noise temporal
      float ign(vec2 p, float t){
        const vec3 a = vec3(0.06711056, 0.00583715, 52.9829189);
        return fract(a.z * fract(dot(p, a.xy) + t * a.y));
      }

      // Tres canales ligeramente des-correlacionados
      vec3 blueNoise(vec2 pix, float t){
        float n1 = ign(pix,           t);
        float n2 = ign(pix + vec2(113.1,  1.7), t + 17.0);
        float n3 = ign(pix + vec2( 27.0, 61.7), t + 31.0);
        // centrar en 0 y estrechar (distribución casi triangular)
        n1 = (n1 + ign(pix*1.07+3.1, t*1.3)) * 0.5;
        return vec3(n1, n2, n3) - 0.5;
      }

      void main() {
        // mezcla cromática ligada al tiempo/escena
        float t = time * u_rate;
        float idx = fract(t) * float(u_count);
        int   i   = int(floor(idx)) % u_count;
        int   j   = (i + 1) % u_count;
        float f   = fract(idx);

        vec3 col = mix(u_colors[i], u_colors[j], f);

        // respiración suave radial (ligeramente más blanda)
        vec2 cUv = vUv - 0.5;
        float d  = length(cUv) * 2.0;
        float fog = pow(1.0 - smoothstep(0.0, 1.0, d), 2.0);
        col += 0.10 * fog;

        // micro-dither spatio-temporal para romper banding (en espacio lineal)
        // usa coordenada de pixel (gl_FragCoord.xy) y el tiempo para “blue-shift”
        vec3 dither = blueNoise(gl_FragCoord.xy, time * 60.0);
        col += u_ditherAmp * dither;

        gl_FragColor = vec4(clamp(col, 0.0, 1.0), 1.0);
      }`
  });

  const plane = new THREE.Mesh(geo, mat);
  plane.frustumCulled = false;
  plane.visible = false;
  skySphere = plane;
  scene.add(skySphere);
}
    /* ---------- extrae TODOS los colores deterministas del sistema ---------- */
    function collectSceneColors(){
      // 1) Todos los RGB deterministas
      const raw = [];
      permutationGroup.traverse(o=>{
        if(o.isMesh) raw.push(o.material.color.clone());
      });

      // 2) Normaliza a S≥0.60  V≥0.80  (más extremos)
      const boosted = raw.map(c=>{
        let [h,s,v] = rgbToHsv(c.r*255,c.g*255,c.b*255);
        s = Math.max(s, 0.60);
        v = Math.max(v, 0.80);
        const [R,G,B] = hsvToRgb(h,s,v);
        return new THREE.Color(R/255,G/255,B/255);
      });

      // 3) Agrupa por ΔH≥18°  (dejamos tonos bien separados)
      const uniq = [];
      boosted.forEach(c=>{
        const [h] = rgbToHsv(c.r*255,c.g*255,c.b*255);
        if(!uniq.some(u=>{
          const [hu] = rgbToHsv(u.r*255,u.g*255,u.b*255);
          return Math.abs(hu-h) < 18;
        })){
          uniq.push(c);
        }
      });

      // 4) Si siguen faltando, completa con rueda de color base
      const fallback = [
        0,60,120,180,240,300
      ].map(h=>{
        const [R,G,B] = hsvToRgb(h,0.75,0.85);
        return new THREE.Color(R/255,G/255,B/255);
      });
      while(uniq.length < 6) uniq.push( fallback[uniq.length] );

      // → devolvemos máx. 8 primeros
      return uniq.slice(0,8);
    }


    /* ---------- actualiza uniforms del shader con la paleta elegida ---------- */
    function buildGanzfeld(){
      if(!skySphere) initSkySphere();

      /* ---------- 1) paleta determinista ---------- */
      const cols = collectSceneColors();
      const n    = cols.length;
      const mat  = skySphere.material;
      mat.uniforms.u_count.value = n;
      for(let i=0;i<12;i++){
        mat.uniforms.u_colors.value[i] = cols[i % n];
      }

      /* ---------- 2) velocidad ligada al movimiento ---------- */
      let sum=0, cnt=0;
      permutationGroup.traverse(o=>{
        if(o.isMesh && o.userData.rotationSpeed){
          sum += o.userData.rotationSpeed;
          cnt ++;
        }
      });
      const avg = cnt ? sum/cnt : 0.002;
      mat.uniforms.u_rate.value = avg * 1;
    }

    /* ---------- bot\u00f3n FRBN: ON/OFF  (Riesgos 2 y 3 integrados) --------------- */
    function toggleFRBN () {
      if (!skySphere) initSkySphere();

      isFRBN = !isFRBN;

      if (isFRBN) {                       // ——— ENTRAR ———
        if (isLCHT) toggleLCHT();         // asegura exclusividad
        buildGanzfeld();                  // sincroniza paleta + u_rate
        skySphere.visible        = true;
        cubeUniverse.visible     = false;
        permutationGroup.visible = false;
        if (lichtGroup) lichtGroup.visible = false;

      } else {                            // ——— SALIR ———
        skySphere.visible        = false;
        cubeUniverse.visible     = true;
        permutationGroup.visible = true;
        if (isLCHT && lichtGroup) lichtGroup.visible = true;
        refreshAll({ keepManual: true }); // reconstruye escena normal
      }
  // ← muestra el mini‑botón solo en FRBN
  const ib = document.getElementById('frbnInfoButton');
  if (ib) ib.style.display = isFRBN ? 'inline-block' : 'none';
    }

    /* --------- inicializa esfera al arrancar (sin coste GPU extra) -------- */
    window.addEventListener('load', () => { if(!skySphere) initSkySphere(); });

    /* ─────────────────────────────
     *   LCHT · deterministic Light Tubes
     * ───────────────────────────── */
    let lichtGroup = null;
    let isLCHT     = false;
    let lchtPrevBg = null;          // guarda/restaura el fondo al salir

    /* color determinista = mismo que la permutación                    */
    function colorForPerm(pa){
      const idx = pa[ attributeMapping[1] ];                // 1–5
      const val = getColor(idx);
      return Array.isArray(val)
        ? new THREE.Color(val[0]/255, val[1]/255, val[2]/255)
        : new THREE.Color(val);
    }

    /* ═════════════ ACTUALIZA LCHT (reglas “tubos que se escapan”) ═════════════
     * Sustituye —o añade justo debajo— el antiguo tubeId() y buildLCHT() por
     * este bloque. No requiere tocar nada más del código.
     * ───────────────────────────────────────────────────────────────────────── */

    /* ── 1 · Identificador de tramo sin límite de cuadrícula ────────────────── */
    function tubeKey(x1,y1,z1,x2,y2,z2){
      // ordenamos los extremos para que ↑↓ y ↓↑ sean el mismo tramo
      const a = `${x1},${y1},${z1}`;
      const b = `${x2},${y2},${z2}`;
      return (a < b) ? `${a}|${b}` : `${b}|${a}`;
    }

    /* ── 2 · Nuevo buildLCHT conforme a las reglas pactadas ─────────────────── */
    function buildLCHT(){
      /* limpia escena previa */
      if (lichtGroup){
        lichtGroup.traverse(o=>{
          if(o.isPointLight) o.dispose && o.dispose();
          if(o.isMesh){ o.geometry.dispose(); o.material.dispose(); }
        });
        scene.remove(lichtGroup);
      }
      lichtGroup = new THREE.Group();
      scene.add(lichtGroup);

      const litInfo    = new Map();   // key → { color, lcht }
      const collisions = new Set();   // keys duplicados → negro
      const step       = cubeSize / 5;

      function inBounds(x, y, z){        // 5×5×5 → 0…4 inclusive
        return x >= 0 && x <= 4 &&
               y >= 0 && y <= 4 &&
               z >= 0 && z <= 4;
      }

      /* === 1) recopila tramos de todas las permutaciones ==================== */
      const perms = Array.from(document.getElementById('permutationList').selectedOptions)
                         .map(o => o.value.split(',').map(Number));

      perms.forEach(pa=>{
        const sig  = computeSignature(pa);
        const rng  = computeRange(sig);
        const r    = lehmerRank(pa);

        /* coordenada base (mismo índice que BUILD) */
        const Iidx = (r + sceneSeed + S_global) % 125;
        let x0 = Math.floor(Iidx/25),
            y0 = Math.floor((Iidx%25)/5),
            z0 = Iidx % 5;

        const L = pa[ attributeMapping[0] ];          // longitud 1-5
        const col = colorForPerm(pa).clone();

        const I0   = 0.35 + 0.65 * Math.sqrt(L/5);
        const amp  = 0.05 + 0.10  * rng;
        const freq = 0.10 + 0.175 * rng;
        const phi  = 2*Math.PI*((r%360)/360);

        function addSeg(x1, y1, z1,  x2, y2, z2){
          if(!inBounds(x1,y1,z1) || !inBounds(x2,y2,z2)) return;   // fuera de la grilla → descarta
          const key = tubeKey(x1,y1,z1,x2,y2,z2);
          if(litInfo.has(key))  collisions.add(key);
          else litInfo.set(key, { color: col.clone(),
                                  lcht : { I0, amp, f: freq, phi } });
        }

        /* eje vertical (L tramos) */
        for(let s=0;s<L;s++){
          addSeg(x0, y0+s,   z0,
                 x0, y0+s+1, z0);
        }

        /* brazos horizontales en ±X y ±Z para y = y0 y y = y0+L */
        const dirs = [[1,0,0],[-1,0,0],[0,0,1],[0,0,-1]];
        [y0, y0+L].forEach(yy=>{
          dirs.forEach(([dx,_,dz])=>{
            for(let s=0;s<L;s++){
              addSeg(x0+dx*s,  yy, z0+dz*s,
                     x0+dx*(s+1),yy, z0+dz*(s+1));
            }
          });
        });
      });

      /* === 2) pinta de negro los tramos con colisión ======================= */
      collisions.forEach(k=>{
        const d = litInfo.get(k);
        if(d){
          d.color.set(0x000000);
          d.lcht.I0 = 0;           // sin luz en tubos negros
        }
      });

      /* === 3) genera geometría solo para los tramos presentes ============== */
      litInfo.forEach((info,key)=>{
        const [a,b] = key.split('|');
        const [x1,y1,z1] = a.split(',').map(Number);
        const [x2,y2,z2] = b.split(',').map(Number);

        const p1 = new THREE.Vector3((x1-2)*step,(y1-2)*step,(z1-2)*step);
        const p2 = new THREE.Vector3((x2-2)*step,(y2-2)*step,(z2-2)*step);

        const dir = new THREE.Vector3().subVectors(p2,p1);
        const len = dir.length();
        const geo = new THREE.CylinderGeometry(0.4,0.4,len,8,1,true);

        const neonCol = info.color.clone();
        const hslCol  = {}; neonCol.getHSL(hslCol);
        neonCol.setHSL(hslCol.h, 1, Math.min(0.7, hslCol.l + 0.2));   // neón puro

        const mat = new THREE.MeshPhongMaterial({
          color     : neonCol,
          shininess : 0,
          dithering : true           // opaco; sin .transparent ni .opacity
        });

        /* — geometría + orientación — */
        const tube = new THREE.Mesh(geo, mat);
        tube.position.copy( p1.clone().add(p2).multiplyScalar(0.5) );
        tube.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.normalize());
        tube.userData.lcht = info.lcht;
        lichtGroup.add(tube);

        // ya no hay luz puntual separada
      });

      /* === 2-bis)  RELLENO COMPLETO LEWITT  ===================================== */
      (function addLewittFillers(){
        const step   = cubeSize / 5;
        const R_NODE = 0.60;   // tamaño del cubo-nudo (vértice con ≥3 aristas)

        function makeEdge(x1,y1,z1, x2,y2,z2, neonCol){
          if(!inBounds(x2,y2,z2)) return;          // ahora nunca sale del 5×5×5

          const k = tubeKey(x1,y1,z1, x2,y2,z2);
          if(litInfo.has(k) || collisions.has(k)) return;   // ya existe algo ahí

          const dir = new THREE.Vector3(x2-x1, y2-y1, z2-z1);
          const len = step * dir.length();
          const geo = new THREE.CylinderGeometry(0.35, 0.35, len, 8, 1, true);

          /* —— color neón, opaco —— */
          const hsl   = {}; neonCol.getHSL(hsl);
          neonCol.setHSL(hsl.h, 1, Math.min(0.7, hsl.l + 0.2));   // S = 100 %, +lum.

          const mat = new THREE.MeshPhongMaterial({
            color      : neonCol,
            shininess  : 0,
            dithering  : true          // sin transparencia en ningún caso
          });

          const m   = new THREE.Mesh(geo, mat);
          const p1  = new THREE.Vector3((x1-2)*step, (y1-2)*step, (z1-2)*step);
          const p2  = new THREE.Vector3((x2-2)*step, (y2-2)*step, (z2-2)*step);
          m.position.copy( p1.clone().add(p2).multiplyScalar(0.5) );
          m.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.normalize());
          lichtGroup.add(m);

          litInfo.set(k, { color: neonCol, lcht:{ I0:0, amp:0, f:0, phi:0 } });
        }

        /* 1)  Para cada tubo existente, extiende las dos direcciones ortogonales */
        litInfo.forEach((info, key)=>{
          const [a,b]   = key.split('|').map(s=>s.split(',').map(Number));
          const [x1,y1,z1] = a, [x2,y2,z2] = b;
          const dx = x2 - x1, dy = y2 - y1, dz = z2 - z1;   // orientación principal

          const axes = [];
          if (dx) axes.push([0,1,0], [0,0,1]);    // tubo era X → añade Y y Z
          if (dy) axes.push([1,0,0], [0,0,1]);    // tubo era Y → añade X y Z
          if (dz) axes.push([1,0,0], [0,1,0]);    // tubo era Z → añade X y Y

            axes.forEach(([ax, ay, az]) => {
              [[x1, y1, z1], [x2, y2, z2]].forEach(([px, py, pz]) => {
                const nx = px + ax;
                const ny = py + ay;
                const nz = pz + az;
                makeEdge(px, py, pz, nx, ny, nz, info.color.clone());
              });
            });
        });

        /* 2)  Coloca cubitos en los vértices con ≥3 aristas */
        const degree = new Map();               // "x,y,z" → nº de aristas
        litInfo.forEach((_, k)=>{
          const [a,b] = k.split('|');
          [a,b].forEach(s=>{
            degree.set(s, (degree.get(s)||0)+1);
          });
        });

        degree.forEach((d, str)=>{
          if (d < 3) return;                    // sólo nudos “fuertes”
          const [x,y,z] = str.split(',').map(Number);
          const geo = new THREE.BoxGeometry(R_NODE, R_NODE, R_NODE);
          const mat = new THREE.MeshPhongMaterial({ color: 0xffffff, shininess:0, dithering:true });
          const n   = new THREE.Mesh(geo, mat);
          n.material.color.copy( litInfo.get([...litInfo.keys()][0]).color ); // cualquier color de escena
          n.position.set((x-2)*step, (y-2)*step, (z-2)*step);
          lichtGroup.add(n);
        });
      })();
    }
    /* ═════════════════ FIN BLOQUE ACTUALIZADO ═════════════════ */

    function toggleLCHT(){
      isLCHT = !isLCHT;

        if (isLCHT){
          /* — cambia material del cubo a lambert para que capte luz — */
          if(!cubeUniverse.userData.prevMat){
            cubeUniverse.userData.prevMat = cubeUniverse.material;
            cubeUniverse.material = new THREE.MeshLambertMaterial({
              color: cubeUniverse.userData.prevMat.color,
              transparent: true,
              opacity: cubeUniverse.userData.prevMat.opacity,
              side: cubeUniverse.userData.prevMat.side
            });
          }
          if (!lchtPrevBg) lchtPrevBg = scene.background ? scene.background.clone() : null;
          scene.background = new THREE.Color(0xf4f4f4);       // gris muy claro
          if (isFRBN) toggleFRBN();                           // LCHT excluye FRBN
          buildLCHT();
          lichtGroup.visible        = true;
          cubeUniverse.visible      = false;
          permutationGroup.visible  = false;
        } else {
          /* — restaura material original — */
          if(cubeUniverse.userData.prevMat){
            cubeUniverse.material.dispose();
            cubeUniverse.material = cubeUniverse.userData.prevMat;
            delete cubeUniverse.userData.prevMat;
          }
          if (lichtGroup) lichtGroup.visible = false;
          if (lchtPrevBg) scene.background = lchtPrevBg;      // restaura fondo
          lchtPrevBg = null;
          cubeUniverse.visible      = true;
          permutationGroup.visible  = true;
        }
      const b = document.getElementById('lchtButton');
      if (b) b.textContent = isLCHT ? 'LCHT ON' : 'LCHT';
    }

    /* reconstruye LCHT si hay cambios de escena */
    function rebuildLCHTIfActive(){ if(isLCHT) buildLCHT(); }

    const GOLD = 137.50776405003785;      // ángulo áureo
    /*  razón áurea al cuadrado  ≈ 2.618…  */
    const PHI2 = 2.618033988749895;
    /* ——— salto coprimo con 144: barre los 144 valores de H ——— */
    const PHI_H = 89;             // 89 ≡ 144 / φ  (gcd 89,144 = 1)
    /* ——— saltos coprimos para los 12 niveles de S y V ——— */
    const PHI_S = 5;              // gcd(5,12) = 1
    const PHI_V = 7;              // gcd(7,12) = 1

    /* ═════════ CUADRÍCULA HSV 144·12·12 ═══════════════════════════════════ */
    const H_STEPS  = 144;                               // 360° / 2.5°
    const S_LEVELS = [...Array(12)].map((_,i)=>0.25 + 0.72*i/11); // 0.25 – 0.97
    const V_LEVELS = [...Array(12)].map((_,i)=>0.20 + 0.75*i/11); // 0.20 – 0.95

    /* ——— Discretización canónica para FRBN (catálogo de fases) ——— */
    const FRBN_K = 144;   // alineado con H_STEPS (2.5° × 144)

    function idxToHSV(hIdx,sIdx,vIdx){
      const h = ((hIdx%H_STEPS)+H_STEPS) % H_STEPS;      // 0-143
      return {
        h: h * 360 / H_STEPS,                            // 0-359.5 °
        s: S_LEVELS[ ((sIdx%12)+12)%12 ],
        v: V_LEVELS[ ((vIdx%12)+12)%12 ]
      };
    }

    /* Normaliza cualquier hue a rango [0 … 360) */
    function normHue(deg){
      return ((deg % 360) + 360) % 360;
    }

    /* ═════════ 11 patrones cromáticos — versión PHI_H (89) ═════════ */
const PATTERNS = {
  1: (sig, seed, i) => {
    const base = (sig.reduce((a,v)=>a+v,0) + seed*7) % 144;
    const hIdx = (base + (i%12)*6) % 144;
    return [
      hIdx,
      (sig[3] + seed + i) % 12,
      (sig[1] + sig[4] + i) % 12
    ];
  },

  2: (sig, seed, i) => {
    const base = (sig[0]*17 + seed*5) % 144;
    const hIdx = (base + ((i%12)*48)) % 144;
    return [
      hIdx,
      (sig[1] + i*3 + seed) % 12,
      (sig[2]*2 + i + seed) % 12
    ];
  },

  3:  (s,seed,i)=>{const b=(s[2]*13+seed*5+i*11)%144;
                   return [(b+i*PHI_H)%144,(s[0]+i*2+seed)%12,(s[1]+s[3]+i)%12];},

  4:  (s,seed,i)=>{const b=(s[1]*15+seed*3+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[0]+seed+i)%12,(s[2]+s[4]+seed+i)%12];},

  5:  (s,seed,i)=>{const b=(i*31+s[3]*13+seed*5)%144;
                   return [(b+i*PHI_H)%144,(s[1]+seed+i)%12,(s[2]+seed+i)%12];},

  6:  (s,seed,i)=>{const b=(s[1]*31+seed*13+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i)%12,(s[3]+s[4]+seed+i)%12];},

  7:  (s,seed,i)=>{const b=(s[0]*11+seed*3+i*37)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i*2)%12,(s[4]+s[1]*2+seed+i)%12];},

  8:  (s,seed,i)=>{const r=Math.abs(s[4]-s[0])+Math.abs(s[3]-s[1])+s[2];
                   const b=(r*13+seed*7)%144;
                   return [(b+i*PHI_H)%144,(s[1]*3+seed+i*2)%12,(s[3]+i*5+seed*3)%12];},

  9:  (s,seed,i)=>{const b=(s[4]*12+seed*7+i*11)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i)%12,(s[1]+seed+i*2)%12];},

 10:  (s,seed,i)=>{const b=(seed*5+s.reduce((a,v)=>a+v,0)*3+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i)%12,(s[4]*2+seed+i*3)%12];},

 11:  (s,seed,i)=>{const b=(s[3]*13+seed*11+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[0]+seed+i)%12,(s[1]+seed+i*2)%12];}
};

/* ---------- BLOQUE DE UTILIDADES COLOR v1.3-RC2 ---------- */
const ANG7 = [
  [0,0,0,0,0,0,0],                         // monocromo (idx 0)
  [0,30,60,90,120,150,180],                // análoga
  [0,180,0,180,0,180,0],                   // complementaria
  [0,150,210,0,150,210,0],                 // comp. dividida
  [0,120,240,60,180,300,30],               // tríada
  [0,90,180,270,45,135,225],               // cuadrado
  [0,0,0,0,0,0,0]                          // “tonos” (misma H, S escalado)
];
function rgbToHsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min;
  let h=0;
  if(d){
    if(max===r) h=((g-b)/d)%6;
    else if(max===g) h=(b-r)/d+2;
    else h=(r-g)/d+4;
    h*=60; if(h<0) h+=360;
  }
  const s=max?d/max:0, v=max;
  return [h,s,v];
}
function hsvToRgb(h,s,v){
  h = h % 360;
  const c=v*s, x=c*(1-Math.abs((h/60)%2-1)), m=v-c;
  let [r,g,b]=[0,0,0];
  if(h<60){r=c;g=x;} else if(h<120){r=x;g=c;}
  else if(h<180){g=c;b=x;} else if(h<240){g=x;b=c;}
  else if(h<300){r=x;b=c;} else {r=c;b=x;}
  return [(r+m)*255,(g+m)*255,(b+m)*255].map(v=>Math.round(v));
}
function hsvToHex({h,s,v}){
  const [r,g,b] = hsvToRgb(h,s,v);
  return '#'+new THREE.Color(r/255,g/255,b/255).getHexString();
}
/* contraste CIE76 */
function deltaE(lab1,lab2){
  return Math.sqrt(
    (lab1[0]-lab2[0])**2+
    (lab1[1]-lab2[1])**2+
    (lab1[2]-lab2[2])**2
  );
}
function rgbToLab(r,g,b){                      // aproximación rápida
  const xyz=[r/255,g/255,b/255].map(v=>{
    v=v>0.04045?((v+0.055)/1.055)**2.4:v/12.92;
    return v*100;
  });
  const x=xyz[0]*0.4124+xyz[1]*0.3576+xyz[2]*0.1805;
  const y=xyz[0]*0.2126+xyz[1]*0.7152+xyz[2]*0.0722;
  const z=xyz[0]*0.0193+xyz[1]*0.1192+xyz[2]*0.9505;
  const xyzN=[95.047,100.0,108.883];
  const f= t=> t>0.008856 ? t**(1/3) : (7.787*t)+16/116;
  const [fx,fy,fz]=[x,y,z].map((v,i)=>f(v/xyzN[i]));
  return [116*fy-16, 500*(fx-fy), 200*(fy-fz)];
}

/* ======  NUEVO  — utilidades de contraste con el FONDO  ====== */
const ΔE_BG_MIN = 22;          // contraste mínimo CIE76

function hexToRgb(hex){
  const m = /^#?([0-9a-f]{6})$/i.exec(hex);
  const n = parseInt(m[1],16);
  return [(n>>16)&255, (n>>8)&255, n&255];
}

/**
 * Sube o baja la luminosidad (v) del color RGB recibido hasta que
 * alcance ΔE_BG_MIN puntos de contraste contra el fondo actual.
 * Devuelve el RGB corregido.
 */
function ensureContrastRGB(rgb){
  /* color de fondo efectivo */
  const bgRgb = bgOverride
      ? hexToRgb(bgOverride)
      : hsvToRgb(bgHSV.h, bgHSV.s, bgHSV.v);

  let [h,s,v] = rgbToHsv(...rgb);          // pasamos a HSV
  let tries = 0;
  while (deltaE(rgbToLab(...rgb),
                rgbToLab(...bgRgb)) < ΔE_BG_MIN && tries < 24){
    /* estrategia: alterna aclarar / oscurecer en pasos de 0.04 */
    v = (tries % 2)
        ? Math.max(0, v - 0.04)
        : Math.min(1, v + 0.04);
    rgb = hsvToRgb(h, s, v);
    tries++;
  }
  return rgb;
}
/* ---------- FIN BLOQUE UTILIDADES ---------- */
/* ——— calcula HSV para fondo (slot 5) y paredes (slot 6) ——— */
function rebuildSceneColours(){
  const dummySig = [0,0,0,0,0];            // sólo necesitamos el patrón
  bgHSV   = idxToHSV( ...PATTERNS[activePatternId](dummySig, sceneSeed, 5) );
  wallHSV = idxToHSV( ...PATTERNS[activePatternId](dummySig, sceneSeed, 6) );
}

/* ===\u2003UTIL extra — firma normalizada y contraste\u2003===================== */
// 1)  f̂  de un glifo  →  promedio firma, llevada a [0-1]
function normFhat(sig){           // sig = [f1…f5] entre 2 y 10
  const avg = sig.reduce((a,b)=>a+b,0)/sig.length;   // 2 … 10
  return (avg-2)/8;                                  // 0 … 1
}

// 2)  pinza a [0,1]
function clamp01(x){ return Math.max(0, Math.min(1,x)); }

/* ———————————————————————————————————————————————— *
 * Devuelve el valor de una propiedad que puede ser:
 *   · número → se usa tal cual
 *   · función → se evalúa con los argumentos dados
 * fallback se usa si la propiedad es null/undefined.
 * ———————————————————————————————————————————————— */
function evalProp(prop, args = [], fallback = 0){
  return (typeof prop === 'function') ? prop(...args) :
         (prop ?? fallback);
}

/* contrast-fix eliminado: función ensureContrast() suprimida */
    const minRangeValue = 2, maxRangeValue = 6;
    const shapeMapping = {
      1:{w:4.5,h:4.5},
      2:{w:4.5,h:4.5*Math.sqrt(2)},
      3:{w:4.5,h:4.5*Math.sqrt(3)},
      4:{w:4.5,h:4.5*Math.sqrt(4)},
      5:{w:4.5,h:4.5*Math.sqrt(5)}
    };

    function sumXYZ(pa,map){
      return pa[ map[2] ] + pa[ map[3] ] + pa[ map[4] ];
    }

    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function mapRangeToSpeed(r,mn,mx){return 0.001 + (r-mn)*(0.005-0.001)/(mx-mn);}
    function shuffle(a){for(let i=a.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

    function getPermutations(arr){
      if(arr.length===1) return [arr];
      let res=[]; for(let i=0;i<arr.length;i++){
        const c=arr[i], rem=arr.slice(0,i).concat(arr.slice(i+1));
        for(const p of getPermutations(rem)) res.push([c].concat(p));
      }
      return res;
    }
    const allPermutations = getPermutations([1,2,3,4,5]);
    const permutationStrings = allPermutations.map(p=>p.join(','));

    function getAttributeMappings(a){
      if(a.length===1) return [a];
      let res=[]; for(let i=0;i<a.length;i++){
        const c=a[i], rem=a.slice(0,i).concat(a.slice(i+1));
        for(const m of getAttributeMappings(rem)) res.push([c].concat(m));
      }
      return res;
    }

    function populatePermutationList(){
      const sel = document.getElementById('permutationList');
      sel.innerHTML = '';
      permutationStrings.forEach((ps,i)=>{
        const o=document.createElement('option');
        o.value=ps; o.text=`Permutación ${i+1}: (${ps})`;
        if(i===0) o.selected=true;
        sel.appendChild(o);
      });
    }
    function populateAttributeMappingSelect(){
      const sel = document.getElementById('attrMapping');
      sel.innerHTML = '';
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        const s=m.join(','), o=document.createElement('option');
        o.value=s; o.text=`Opción: [${s}]`;
        if(s==='0,1,2,3,4') o.selected=true;
        sel.appendChild(o);
      });
      updateTopRightDisplay();
    }

    function computeSignature(a){let s=[];for(let i=0;i<a.length;i++) s.push(a[i]+a[(i+1)%a.length]);return s;}
    function computeRange(sig){return Math.max(...sig)-Math.min(...sig);}

    const FACT=[1,1,2,6,24,120];
    let sceneSeed=0;
    function lehmerRank(p){
      let r=0;
      for(let i=0;i<p.length;i++){
        let c=0;
        for(let j=i+1;j<p.length;j++) if(p[j]<p[i]) c++;
        r+=c*FACT[p.length-1-i];
      }
      return r;
    }

    /* ========= NUEVO: sceneSeed orden‑invariante + dependiente del mapping ========= */

    /** Rank del mapping [m0..m4] usando Lehmer rank sobre [m_i+1] (1..5) */
    function mappingRank(m){
      const arr = [m[0]+1, m[1]+1, m[2]+1, m[3]+1, m[4]+1];
      return lehmerRank(arr);
    }

    /** sceneSeed = (37·sumR + 101·sumR2 + 53·mRank) mod 360  (orden‑invariante) */
    function computeSceneSeedFrom(perms, m){
      let sumR = 0, sumR2 = 0;
      perms.forEach(pa=>{
        const r = lehmerRank(pa);
        sumR  += r;
        sumR2 += r*r;
      });
      const mRank = mappingRank(m);
      return (37*sumR + 101*sumR2 + 53*mRank) % 360;
    }

    /** S = ( Σ (P_{mx}+P_{my}+P_{mz}) ) mod 125  — usa los índices x,y,z del mapping */
    function computeGlobalS(perms, m){
      const mx = m[2], my = m[3], mz = m[4];
      let S = 0;
      perms.forEach(p=>{
        S += p[mx] + p[my] + p[mz];
      });
      return S % 125;
    }
    function computeShiftRankXYZ(p){
      const r = lehmerRank(p);
      const I = (r + sceneSeed + S_global) % 125;   // <<< NUEVO: acoplado a S_global
      const x = Math.floor(I/25),
            y = Math.floor((I%25)/5),
            z = I%5;
      const step = cubeSize/5;
      return [
        (x-2)*step,
        (y-2)*step,
        (z-2)*step
      ];
    }

    function setActivePattern(id){
      activePatternId = parseInt(id,10);
      refreshAll({rebuild:false});
    }
    function updateTopRightDisplay(){
      const cfg=`Atributos: [${attributeMapping.slice(0,5).join(',')}]`;
      const rt =`Calificación: ${userRating?userRating:'Aún no calificada'}`;
      let info='';
      Array.from(document.getElementById('permutationList').selectedOptions).forEach(o=>{
        const pa=o.value.split(',').map(Number),
              sig=computeSignature(pa),
              rg=computeRange(sig);
        info+=`<div style="margin:2px 0;">Perm (${o.value}) | Firma [${sig.join(', ')}] | Rango ${rg}</div>`;
      });
      document.getElementById('topRightDisplay').innerHTML = cfg+'<br>'+rt+'<br>'+info;
    }

    function createPermutationObjectWithMapping(pa,map){
      const fv=pa[map[0]], cv=pa[map[1]],
            d=shapeMapping[fv], w=d.w, h=d.h, t=0.5;
      /* --- CÁLCULO de color (cuadrícula) -------------------------------- */
      let rgb;
        if(activePatternId === 0){                       // modo legacy
          rgb = paletteRGB[cv-1] || [255,255,255];
        }else{
          const sig  = computeSignature(pa);
          /* slot bien distribuido: rank(perm) mod 12 */
          const slot = lehmerRank(pa) % 12;      // 0-11
          let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
          /* dispersión coprima en S y V */
          sI = (sI * PHI_S) % 12;
          vI = (vI * PHI_V) % 12;
          const {h,s,v} = idxToHSV(hI,sI,vI);
          rgb = hsvToRgb(h,s,v);
        }

        /* —— AJUSTE AUTOMÁTICO DE CONTRASTE CON EL FONDO —— */
        rgb = ensureContrastRGB(rgb);
      /* --------------------------------------------------------------- */
      const mat=new THREE.MeshPhongMaterial({
        color:new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255),
        shininess:50,
        dithering:true
      });
      const geo=new THREE.BoxGeometry(w,h,t);
      const mesh=new THREE.Mesh(geo,mat);
      const [X,Y,Z]=computeShiftRankXYZ(pa);
      mesh.position.set(
        clamp(X,-halfCube+w/2,halfCube-w/2),
        clamp(Y,-halfCube+h/2,halfCube-h/2),
        clamp(Z,-halfCube+t/2,halfCube-t/2)
      );
      const sig=computeSignature(pa), rg=computeRange(sig);
      mesh.userData={permStr:pa.join(','), signature:sig, range:rg, rotationSpeed:mapRangeToSpeed(rg,minRangeValue,maxRangeValue)};
      return mesh;
    }
    function createPermutationObject(pa){ return createPermutationObjectWithMapping(pa,attributeMapping); }

    function checkCollisionsInGroup(g){
      for(let i=0;i<g.children.length;i++){
        const b1=new THREE.Box3().setFromObject(g.children[i]);
        for(let j=i+1;j<g.children.length;j++){
          const b2=new THREE.Box3().setFromObject(g.children[j]);
          if(b1.intersectsBox(b2)) return true;
        }
      }
      return false;
    }
    function autoResolveColisionesGlobal(){
      let found=null;
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        if(found) return;
        const cm=[m[0],m[1],m[2],m[3],m[4], attributeMapping[5], attributeMapping[6]],
              tg=new THREE.Group(),
              opts=Array.from(document.getElementById('permutationList').selectedOptions);
        opts.forEach((o)=>{
          const pa=o.value.split(',').map(Number),
                mo=createPermutationObjectWithMapping(pa,cm);
          tg.add(mo);
        });
        if(!checkCollisionsInGroup(tg)) found=cm;
      });
      if(found){
        attributeMapping=found;
        document.getElementById('attrMapping').value=`${found[0]},${found[1]},${found[2]},${found[3]},${found[4]}`;
        refreshAll({rebuild:true}); updateTopRightDisplay();
      } else {
        showPopup("No se encontró reorganización sin colisiones.",7000);
      }
    }

/* ==============================
 * 120 Architectural Permutations
 * ============================== */
let perm120List = getAttributeMappings([0,1,2,3,4]); // 120
let perm120Index = 0;
let perm120Timer = null;

function togglePerm120Panel(){
  const p = document.getElementById('perm120Panel');
  const isHidden = (p.style.display === 'none' || !p.style.display);
  p.style.display = isHidden ? 'block' : 'none';

  // Re‑muestra siempre el cursor personalizado
  const cc = document.getElementById('customCursor');
  if (cc) cc.style.display = 'block';
}

function msFromUI(){
  const slider = document.getElementById('perm120Slider');
  return parseInt(slider.value, 10);
}
function syncPerm120InputsFromSlider(){
  const ms = msFromUI();
  document.getElementById('perm120Seconds').value = Math.round(ms/1000);
}
function syncPerm120SliderFromSeconds(){
  const sec = parseInt(document.getElementById('perm120Seconds').value,10) || 1;
  const clamped = Math.max(1, Math.min(720, sec));
  document.getElementById('perm120Seconds').value = clamped;
  document.getElementById('perm120Slider').value = clamped * 1000;
}

function updatePerm120Status(){
  const stat = document.getElementById('perm120Status');
  if(stat) stat.textContent = `Permutation: ${perm120Index} / 119`;
}

function applyPerm120Index(i){
  perm120Index = ((i % perm120List.length) + perm120List.length) % perm120List.length;
  const m = perm120List[perm120Index];
  attributeMapping = [m[0], m[1], m[2], m[3], m[4], attributeMapping[5], attributeMapping[6]];
  document.getElementById('attrMapping').value = m.join(',');
  refreshAll({rebuild:true});
  updatePerm120Status();
}

function nextPerm120(){ applyPerm120Index(perm120Index + 1); }
function prevPerm120(){ applyPerm120Index(perm120Index - 1); }

function playPerm120(){
  if(perm120Timer) return;
  const interval = msFromUI();
  perm120Timer = setInterval(nextPerm120, interval);
  nextPerm120();
}
function pausePerm120(){
  if(perm120Timer){
    clearInterval(perm120Timer);
    perm120Timer = null;
  }
}

function showPerm120Info(){
  const txt =
`The 120 architectural permutations are the 120 ways to reassign P₁–P₅ to the attributes [shape, color, x, y, z]. The architecture (the set of selected permutations) does not change; what changes is its visual phenotype by deciding which component controls each spatial and chromatic attribute.
These reconstructions do not add semantics, do not break the logic of the system, and remain within the combinatorial framework. They reorganize the structural availability of pre‑verbal thought.

Each of the 120 reorganizations is validated by its internal structural coherence, not by usefulness or beauty.
“Evolution” is goal‑free reordering: same architecture, 120 phenotypic expressions.`;
  alert(txt);
}

    /* ============================================================
     *  MONTE-CARLO: buscar una escena aleatoria SIN colisiones
     *  ============================================================
     */

    /** Construye un grupo temporal con un mapping dado, sin tocar la escena real */
      const mappings = getAttributeMappings([0,1,2,3,4]);
function buildTempGroup(perms, mapping){
  const tg = new THREE.Group();

  // Guardamos estado global
  const prevSeed = sceneSeed;
  const prevS    = S_global;
  const prevMap  = attributeMapping.slice();

  // Calculamos los nuevos valores teóricos
  const tmpSeed = computeSceneSeedFrom(perms, mapping);
  const tmpS    = computeGlobalS(perms, mapping);

  // Seteamos temporalmente los globales para que createPermutationObjectWithMapping
  // use exactamente la misma lógica que la escena final:
  sceneSeed        = tmpSeed;
  S_global         = tmpS;
  attributeMapping = mapping;

  perms.forEach(pa=>{
    const mesh = createPermutationObjectWithMapping(pa, mapping);
    tg.add(mesh);
  });

  // Restauramos
  sceneSeed        = prevSeed;
  S_global         = prevS;
  attributeMapping = prevMap;

  return tg;
}

function findCollisionFreeMapping(perms){
  const mappings = getAttributeMappings([0,1,2,3,4]);
  for(const m of mappings){
    const cm = [m[0], m[1], m[2], m[3], m[4], attributeMapping[5], attributeMapping[6]];
    const tg = buildTempGroup(perms, cm);
    if(!checkCollisionsInGroup(tg)) return cm;
  }
  return null;
}
    /** Selecciona un subconjunto aleatorio de permutaciones (1..25) */
    function pickRandomPerms(){
      const n  = Math.floor(Math.random()*25) + 1;
      const out = [];
      for(let i=0;i<n;i++){
        const str = permutationStrings[Math.floor(Math.random()*permutationStrings.length)];
        out.push(str.split(',').map(Number));
      }
      return out;
    }

    /**
     * Búsqueda iterativa:
     *  - elige un set aleatorio de permutaciones
     *  - prueba todos los mappings
     *  - si alguno no choca, lo aplica y termina
     *
     * No bloquea la UI gracias al pequeño await en cada iteración.
     */
    async function generateRandomConfigurationNoCollision(MAX_TRIES = 5000){
      // Elegimos un patrón cromático aleatorio (1..11, evitando el legacy 0)
      const randPattern = Math.floor(Math.random() * 11) + 1;

      let round = 0;
      while (true) { // sigue intentando hasta que realmente encuentre una sin colisiones
        round++;
        for (let t = 0; t < MAX_TRIES; t++) {
          showPopup(`Buscando configuración sin colisiones… (ronda ${round}, intento ${t+1})`, 500);

          const perms   = pickRandomPerms();
          const mapping = findCollisionFreeMapping(perms);

          if (mapping) {
            // 1) Setea el patrón cromático escogido
            activePatternId = randPattern;
            const selPattern = document.getElementById('patternSelect');
            if (selPattern) selPattern.value = String(randPattern);

            // 2) Pon las permutaciones en el <select>
            const sel = document.getElementById('permutationList');
            Array.from(sel.options).forEach(o => o.selected = false);
            perms.forEach(p=>{
              const val = p.join(',');
              const opt = sel.querySelector(`option[value="${val}"]`);
              if(opt) opt.selected = true;
            });

            // 3) Aplica el mapping encontrado
            attributeMapping = mapping;

            // mantenemos tu ciclo de atributo "color"
            attributeMapping[1] = colorAttrCycle % 5;
            colorAttrCycle++;

            document.getElementById('attrMapping').value =
              `${attributeMapping[0]},${attributeMapping[1]},${attributeMapping[2]},${attributeMapping[3]},${attributeMapping[4]}`;

            // 4) Reconstruye escena completa
            refreshAll({rebuild:true});

            // 5) Verificación final (por si acaso)
            const hasCol = checkCollisionsInGroup(permutationGroup);
            if (!hasCol) {
              if (isFRBN) toggleFRBN();   // BUILD apaga FRBN
              if (isLCHT) toggleLCHT();   // BUILD apaga LCHT
              showPopup("¡Configuración sin colisiones encontrada!", 2000);
              return true;
            }
          }

          // cede el hilo para no congelar la UI
          if ((t % 25) === 0) await new Promise(r => setTimeout(r, 0));
        }
        // pequeña pausa entre rondas largas
        await new Promise(r => setTimeout(r, 10));
      }
    }

    function showPopup(msg, dur = 2000){
      dur = Math.max(dur, 3000); // ← asegura al menos 3 segundos
      const p = document.getElementById('hoverPopup');
      p.style.display = "block";
      p.style.opacity = 1;
      p.style.left = (window.innerWidth/2 - 150) + "px";
      p.style.top  = "20px";
      p.innerHTML  = msg;
      setTimeout(()=>{
        p.style.opacity = 0;
        setTimeout(()=>{ p.style.display="none"; p.innerHTML=""; }, 300);
      }, dur);
    }


function updateScene(attemptResolve=true){
  // Limpia grupo
  while(permutationGroup.children.length>0){
    const o=permutationGroup.children[0];
    permutationGroup.remove(o);
    o.geometry.dispose(); o.material.dispose();
  }

  // Permutaciones activas
  const opts  = Array.from(document.getElementById('permutationList').selectedOptions);
  const perms = opts.map(o => o.value.split(',').map(Number));

  // Nueva sceneSeed & S_global (orden-invariante + dependiente del mapping)
  sceneSeed = computeSceneSeedFrom(perms, attributeMapping);
  S_global  = computeGlobalS(perms, attributeMapping);

  // Construye objetos
  perms.forEach(pa=>{
    const obj = createPermutationObject(pa);
    permutationGroup.add(obj);
  });

  if(attemptResolve) autoResolveColisionesGlobal();
  else updateTopRightDisplay();
      if (isFRBN && skySphere) buildGanzfeld();   // mantiene FRBN sincronizado
  }
    function onMouseMove(e){
      mouse.x=(e.clientX/window.innerWidth)*2-1;
      mouse.y=-(e.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera(mouse,camera);
      const ints=raycaster.intersectObjects(permutationGroup.children),
            pop=document.getElementById('hoverPopup');
      if(ints.length>0){
        const d=ints[0].object.userData;
        pop.style.display="block"; pop.style.opacity=1;
        pop.style.left=`${e.clientX+20}px`;
        pop.style.top=`${e.clientY+20}px`;
        pop.innerHTML=`Perm (${d.permStr})<br>Firma [${d.signature.join(', ')}]<br>Rango ${d.range}`;
      } else {
        pop.style.opacity=0;
        setTimeout(()=>{pop.style.display="none";},300);
      }
    }

    function zoomIn(){camera.position.z-=5;controls.update();}
    function zoomOut(){camera.position.z+=5;controls.update();}
    function togglePause(){
      isPaused=!isPaused;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent=isPaused?"Resume Motion":"Pause Motion";
    }
    function resetMovement(){
      updateScene(false);
      isPaused=true;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent="Resume Motion";
    }

function saveImage(){
  const A2_W = 7016, A2_H = 4961;

  const prevPixelRatio = renderer.getPixelRatio();
  const prevSize       = renderer.getSize(new THREE.Vector2());
  const prevAspect     = camera.aspect;
  const prevRt         = renderer.getRenderTarget?.() || null;
  const prevBg         = scene.background ? scene.background.clone() : null;

  const screenAspect = prevSize.x / prevSize.y;

  // Render con el MISMO aspect que se ve en pantalla
  let renderW, renderH;
  const a2Aspect = A2_W / A2_H;
  if (screenAspect > a2Aspect) {
    renderW = A2_W;
    renderH = Math.round(A2_W / screenAspect);
  } else {
    renderH = A2_H;
    renderW = Math.round(A2_H * screenAspect);
  }

  renderer.setPixelRatio(1);
  renderer.setSize(renderW, renderH, false);
  camera.aspect = screenAspect;
  camera.updateProjectionMatrix();

  const rt = new THREE.WebGLRenderTarget(renderW, renderH, { depthBuffer:true, stencilBuffer:false });

  const clearHex = prevBg ? '#' + prevBg.getHexString() : '#ffffff';
  renderer.setClearColor(clearHex, 1);
  renderer.setRenderTarget(rt);
  renderer.clear(true, true, true);
  renderer.render(scene, camera);

  const pixels = new Uint8Array(renderW * renderH * 4);
  renderer.readRenderTargetPixels(rt, 0, 0, renderW, renderH, pixels);

  const tmp = document.createElement('canvas');
  tmp.width = renderW; tmp.height = renderH;
  const tctx = tmp.getContext('2d');
  const imgData = tctx.createImageData(renderW, renderH);
  const row = renderW * 4;
  for (let y = 0; y < renderH; y++) {
    const src = (renderH - 1 - y) * row;
    const dst = y * row;
    imgData.data.set(pixels.subarray(src, src + row), dst);
  }
  tctx.putImageData(imgData, 0, 0);

  const final = document.createElement('canvas');
  final.width = A2_W; final.height = A2_H;
  const fctx = final.getContext('2d');

  if (isFRBN) {
    // —— FRBN: cubrir A2 sin bandas (recorte centrado)
    const scale = Math.max(A2_W / renderW, A2_H / renderH);
    const drawW = Math.ceil(renderW * scale);
    const drawH = Math.ceil(renderH * scale);
    const offX  = Math.floor((A2_W - drawW) / 2);
    const offY  = Math.floor((A2_H - drawH) / 2);
    fctx.drawImage(tmp, offX, offY, drawW, drawH);
  } else {
    // —— Modo normal: mantener todo visible (letterbox centrado)
    fctx.fillStyle = clearHex;
    fctx.fillRect(0, 0, A2_W, A2_H);
    const offX = Math.floor((A2_W - renderW) / 2);
    const offY = Math.floor((A2_H - renderH) / 2);
    fctx.drawImage(tmp, offX, offY);
  }

  final.toBlob((blob)=>{
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'PRMTTN_A2.png';
    document.body.appendChild(a); a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(a.href);
  }, 'image/png');

  renderer.setRenderTarget(prevRt);
  rt.dispose();
  renderer.setPixelRatio(prevPixelRatio);
  renderer.setSize(prevSize.x, prevSize.y);
  camera.aspect = prevAspect;
  camera.updateProjectionMatrix();
  if (prevBg) scene.background = prevBg;
  controls.update();
}


    /* Paleta v1.3 — se recalcula siempre que cambia la escena            *
     * 1. Semilla RGB = suma ponderada de posiciones y P1-P3 (firma).    *
     * 2. Selección de armonía idx = (R+2G+3B) mod 7                     */
function thirtyFive(){return 35;}

function makeClassicPalette(){
      /* --- 1. Semilla RGBglobal --- */
      let Rg=0,Gg=0,Bg=0;
      permutationGroup.children.forEach(mesh=>{
        const pa = mesh.userData.permStr.split(',').map(Number);
        const sig = mesh.userData.signature;            // [f1..f5]
        const P1=pa[0], P2=pa[1], P3=pa[2];
        const {x,y,z} = mesh.position;
        Rg += (P1*Math.abs(x)+sig[0])|0;
        Gg += (P2*Math.abs(y)+sig[1])|0;
        Bg += (P3*Math.abs(z)+sig[2])|0;
      });
      Rg%=256; Gg%=256; Bg%=256;

      /* --- 2. HSV base --- */
      const [H0] = rgbToHsv(Rg,Gg,Bg);
      const idx = (Rg + 2*Gg + 3*Bg) % 7;
      const Δ = ANG7[idx];

      /* --- 3. Construir 7 tonos HSV --- */
      const HSV = [];
      for(let k=0;k<7;k++){
        let h = (H0 + Δ[k]) % 360,
            s = 0.70,
            v = 0.85;
        if(idx===0){ v = 0.55+0.05*k; }          // monocromo
        if(idx===2 && k>1){ v = 0.85-0.05*(k-1);} // complementario grad.
        if(idx===3 && k>2){ s = 0.85-0.05*(k-3);} // comp.dividida grad S
        if(idx===6){ s = 0.40+0.05*k; }           // tonos
        HSV.push([h,s,v]);
      }

      /* --- 4. A HSV → RGB, validar contraste ∆E ≥ 22 --- */
      paletteRGB=[];
      for(let i=0;i<7;i++){
        let rgb=hsvToRgb(...HSV[i]);
        let tries=0;
        while(i>0 &&
              deltaE(rgbToLab(...rgb), rgbToLab(...paletteRGB[0])) <  thirtyFive() &&
              tries<25){
          /* si el hue es demasiado parecido => rotar 18°; si no, subir V */
          if(Math.abs(HSV[i][0]-HSV[0][0])<20){
            HSV[i][0] = (HSV[i][0]+18)%360;
          }else{
            HSV[i][2] = Math.min(1, HSV[i][2]+0.04);
          }
          rgb = hsvToRgb(...HSV[i]); tries++;
        }
      paletteRGB.push(rgb);
      }
    }

function makePalette(){
  /* modo legacy */
  if (activePatternId === 0){ makeClassicPalette(); return; }

  paletteRGB = [];
  for(let i=0;i<12;i++){
    let [hI,sI,vI] = PATTERNS[activePatternId]([0,0,0,0,0], sceneSeed, i);
    sI = (sI * PHI_S) % 12;
    vI = (vI * PHI_V) % 12;
    const {h,s,v} = idxToHSV(hI,sI,vI);
    paletteRGB.push( hsvToRgb(h,s,v) );
  }
  // colores de fondo y paredes se calculan aparte
}

    function getColor(idx){
      return manualOverride[idx] || paletteRGB[idx-1] || '#ffffff';
    }

    function applyPalette(){
      for(let i=1;i<=5;i++){
        const autoRGB = paletteRGB[i-1] || [255,255,255];
        const autoHEX = '#'+new THREE.Color(
            autoRGB[0]/255,autoRGB[1]/255,autoRGB[2]/255).getHexString();
        const hex     = manualOverride[i] || autoHEX;
        const input   = document.getElementById('color'+i);
        if(input) input.value = hex;
      }

      permutationGroup.children.forEach(o=>{
        const pa   = o.userData.permStr.split(',').map(Number);
        const idx  = pa[attributeMapping[1]];          // 1-5
        let hex;
        if(manualOverride[idx]){
          hex = manualOverride[idx];
        }else if(activePatternId===0){
          hex = '#'+new THREE.Color(
                    ...paletteRGB[idx-1].map(v=>v/255)).getHexString();
        }else{
          const sig  = computeSignature(pa);
          const slot = lehmerRank(pa) % 12;
          let [hIdx,sIdx,vIdx] = PATTERNS[activePatternId](sig,sceneSeed,slot);
          /* dispersión coprima en S y V */
          sIdx = (sIdx * PHI_S) % 12;
          vIdx = (vIdx * PHI_V) % 12;
          const {h,s,v} = idxToHSV(hIdx,sIdx,vIdx);
          const rgb = hsvToRgb(h,s,v);
          hex = '#'+new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255).getHexString();
        }
        o.material.color.setStyle(hex);
      });
      updateColorPickersFromScene();
    }

    /* ——— Sincroniza los <input type="color"> con los colores reales ——— */
    function updateColorPickersFromScene(){
      // memoriza el primer glifo encontrado para cada índice P2 (1-5)
      const seen = {};
      permutationGroup.children.forEach(o=>{
        const pa  = o.userData.permStr.split(',').map(Number);
        const idx = pa[attributeMapping[1]];           // 1-5
        if(!seen[idx]){
          const c = o.material.color;                     // THREE.Color
          const hex = '#'+c.getHexString();
          const inp = document.getElementById('color'+idx);
          if(inp) inp.value = hex;
          seen[idx]=true;
        }
      });
    }

    function refreshAll(opts={rebuild:false}){
      if(!opts.keepManual){              // por defecto se limpia
        manualOverride = {};
      }
      if(opts.rebuild) updateScene(false);
      rebuildSceneColours();   // ← nuevo paso
      makePalette();
      applyPalette();
      /* contrast-fix eliminado – 19-Jul-2025 */
      updateBackground(false);
      updateCubeColor(false);
      if (isFRBN && skySphere) buildGanzfeld();   // mantiene FRBN sincronizado
      rebuildLCHTIfActive();              // mantiene LCHT sincronizado
    }
    function onColourPick(idx,hex){
      manualOverride[idx]=hex;
      refreshAll({keepManual:true});
    }

    function resetAllColours(){
      manualOverride = {};
      bgOverride     = null;
      cubeOverride   = null;
      refreshAll({keepManual:false});   // reconstruye escena y pickers
    }
    function updateBackground(manual=true){
      if (manual){
        bgOverride = document.getElementById("bgColor").value;
      }
      const hex = manual ? bgOverride : hsvToHex(bgHSV);
      scene.background = new THREE.Color(hex);
      document.getElementById("bgColor").value = hex;
    }

    function updateCubeColor(manual=true){
      if (manual){
        cubeOverride = document.getElementById("cubeColor").value;
      }
      const hex = manual ? cubeOverride : hsvToHex(wallHSV);
      cubeUniverse.material.color = new THREE.Color(hex);
      document.getElementById("cubeColor").value = hex;
    }

    function toggleTexts(){
      const ids = [
        'controls','topRightDisplay','ratingContainer',
        'randomConfigButton','aiPlanningButton','saveImageButton',
        'exportEmbedButton','archDescButton','uploadConfigButton','perm120Button','frbnWrap','lchtWrap','infoButton','certButton'
        ];
      ids.forEach(id=>{
        const e=document.getElementById(id);
        if(e) e.style.display = textsVisible ? 'none' : 'block';
      });

      // Mantener SIEMPRE cerrado el panel de 120 perms
      const p = document.getElementById('perm120Panel');
      if (p) p.style.display = 'none';

      document.getElementById('toggleTextButton').textContent =
        textsVisible ? 'Show UI' : 'Minimal UI';
      textsVisible = !textsVisible;

      // Asegura que el cursor personalizado vuelva a mostrarse
      const cc = document.getElementById('customCursor');
      if (cc) cc.style.display = 'block';
    }

    function setMode(m){
      currentMode=m;
      document.getElementById('manualControls').style.display=
        m==="manual"?"block":"none";
      document.getElementById('evolutionControls').style.display=
        m==="evolution"?"block":"none";
      refreshAll({rebuild:true});
    }

/**
 * Dada una firma [f1,f2,f3,f4,f5], devuelve los colores triádicos
 * { colorShape, colorCube, colorBG } en formato CSS HSL.
 */
function computeTriadicColors(firma) {
  // 1) Normaliza f_i ∈ {3…9} a u_i ∈ [0,1]
  const u = firma.map(fi => (fi - 3) / 6);

  // 2) Hue base mixto (60% de u[1], 10% de cada otro)
  const phi0 = 360 * (
    0.1 * u[0] +
    0.6 * u[1] +
    0.1 * u[2] +
    0.1 * u[3] +
    0.1 * u[4]
  );

  // 3) Triádico: +0°, +120°, +240°
  const shapeHue =  phi0;
  const cubeHue  = (phi0 + 120) % 360;
  const bgHue    = (phi0 + 240) % 360;

  // 4) Saturación y luminosidad fijas
  const S = 80, L = 50;

  return {
    colorShape: `hsl(${shapeHue.toFixed(1)},${S}%,${L}%)`,
    colorCube:  `hsl(${cubeHue.toFixed(1)},${S}%,${L}%)`,
    colorBG:    `hsl(${bgHue.toFixed(1)},${S}%,${L}%)`
  };
}
function applyTriadicConfiguration() {
  // 1) Repite la selección aleatoria de permutaciones
  generateRandomConfigurationNoCollision();

  // 2) Ahora solo aplica los colores triádicos deterministas:
  if (permutationGroup.children.length > 0) {
    const baseSig = permutationGroup.children[0].userData.signature;
    const { colorCube, colorBG } = computeTriadicColors(baseSig);

    // Paredes del cubo
    if (cubeUniverse.material?.color?.setStyle) {
      cubeUniverse.material.color.setStyle(colorCube);
    } else {
      cubeUniverse.material.color = new THREE.Color(colorCube);
    }

    // Fondo
    scene.background = new THREE.Color(colorBG);
  }

  // Cada prisma
  permutationGroup.children.forEach(mesh => {
    const sig = mesh.userData.signature;
    const { colorShape } = computeTriadicColors(sig);
    if (mesh.material?.color?.setStyle) {
      mesh.material.color.setStyle(colorShape);
    } else {
      mesh.material.color = new THREE.Color(colorShape);
    }
  });
}
    document.querySelectorAll('.ratingBtn').forEach(el=>{
      const r=+el.getAttribute('data-rating');
      el.addEventListener('click',()=>{
        userRating=r;
        const cols={1:"#8B0000",2:"#FF4500",3:"#FFA500",4:"#9ACD32",5:"#008000"};
        document.querySelectorAll('.ratingBtn').forEach((b,i)=>{
          b.style.color=(i<r?cols[r]:"#000");
        });
        updateTopRightDisplay();
      });
      el.addEventListener('mouseenter',()=>showPopup(`Calificación: ${r}`,1000));
    });

    function applyEvolution(){
      const mr=parseFloat(document.getElementById('mutationRate').value),
            th=parseFloat(document.getElementById('threshold').value),
            cf=0.02;
      let log="";
      permutationGroup.children.forEach(o=>{
        const rf=(Math.random()-0.5)*mr;
        o.rotation.y+=rf;
        const sf=1+(Math.random()-0.5)*th;
        o.scale.set(sf,sf,sf);
        o.material.color.offsetHSL(
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf
        );
        log+=`(${o.userData.permStr}): Rot ${rf.toFixed(3)}, Esc ${sf.toFixed(3)}<br>`;
      });
      document.getElementById('evolutionInfo').innerHTML=log;
    }

    async function applyEvolutionAI(){
      const systemPrompt = `Eres una inteligencia artificial que responde exclusivamente con configuraciones de permutaciones 3D dentro de un cubo de 30x30x30.
      Tu única misión es responder a la pregunta “¿Qué es la belleza artística?” mediante pensamientos visuales dentro de un cubo de 30×30×30.
Cada pensamiento visual es una configuración compuesta por una o más permutaciones (entre 1 y 25). Cada permutación tiene una firma (ADN) inmutable, y un fenotipo: forma, color, posición, rotació[...]
Tu lenguaje es visual. No usas texto, sonido ni símbolos. Elige libremente el color del fondo del universo, el color de las paredes del cubo y de las permutaciones. 
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero. 
      Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON.`;
      const useRating = false;
      const userPrompt = `Calificación actual: ${userRating||"sin calificar"}. `
                       + `Estás dentro de un universo donde las ideas no se escriben con palabras, sino con permutaciones. Eres una inteligencia artificial que ha aprendido a pensar visualmente.
Tu única pregunta permanente es: “¿Qué es la belleza artística?”. No respondes con definiciones ni textos. Tu lenguaje es mudo, pero expresivo. Hablas mediante forma, color, posición y rotaci[...]
Elige libremente el color del fondo del universo, el color de las paredes del cubo y el color de las permutaciones.
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero.  
No busques complacer. No imites al humano. Sé tú misma.
Expresa lo que para ti —como IA que piensa en permutaciones— representa la belleza artística en este momento.
Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON. 
`;
      try {
        showPopup("Consultando Evolution AI…",2000);
        const resp = await fetch(
          'https://us-central1-prmtcns.cloudfunctions.net/askChatGPT',
          {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({system:systemPrompt,user:userPrompt})
          }
        );
        const {text, error} = await resp.json();
        if(error){ showPopup("Error en Evolución AI: "+error,4000); return; }
        let jsonText = text.trim();
        if(jsonText.startsWith("```")){
          jsonText = jsonText
            .replace(/^```[^\n]*\n/,"")
            .replace(/```$/,"")
            .trim();
        }
        let instr;
        try { instr = JSON.parse(jsonText); }
        catch(e){
          console.error("JSON parse error:",jsonText);
          showPopup("Evolución AI: respuesta no es JSON válido",4000);
          return;
        }
        if(instr.bg){
          document.getElementById('bgColor').value=instr.bg;
          updateBackground();
        }
        if(instr.cube){
          document.getElementById('cubeColor').value=instr.cube;
          updateCubeColor();
        }
        if(instr.colors){
          Object.entries(instr.colors).forEach(([i,c])=>{
            i=Number(i);
            if(manualOverride[i]!==undefined){
              manualOverride[i]=c;
            }
          });
          refreshAll({rebuild:true, keepManual:true});
        }
        if(instr.scale){
          permutationGroup.children.forEach(o=>{
            o.scale.set(instr.scale,instr.scale,instr.scale);
          });
        }
        if(instr.rotationSpeeds){
          Object.entries(instr.rotationSpeeds).forEach(([i,spd])=>{
            permutationGroup.children.forEach(o=>{
              if(o.userData.permStr.startsWith(i+",")){
                o.userData.rotationSpeed=spd;
              }
            });
          });
        }
        if(instr.positions){
          Object.entries(instr.positions).forEach(([i,pos])=>{
            const o = permutationGroup.children.find(o=>o.userData.permStr.startsWith(i+","));
            if(o) o.position.set(pos[0],pos[1],pos[2]);
          });
        }
        if(instr.permCount){
          const opts=Array.from(document.getElementById('permutationList').options);
          opts.forEach(o=>o.selected=false);
          shuffle(opts).slice(0,instr.permCount).forEach(o=>o.selected=true);
          refreshAll({rebuild:true, keepManual:true});
        }
        showPopup("Evolución AI aplicada.",2000);
      } catch(err){
        console.error(err);
        showPopup("Error en Evolución AI: red o servidor",4000);
      }
    }

    function updateMapping(){
      const v=document.getElementById('attrMapping').value.split(',').map(Number);
      if(v.length===5){
        attributeMapping=[v[0],v[1],v[2],v[3],v[4], attributeMapping[5], attributeMapping[6]];
        refreshAll({rebuild:true}); updateTopRightDisplay();
      }
    }

    function applyStandardView(){
      const view=document.getElementById('standardView').value,
            pos=new THREE.Vector3();
      switch(view){
        case "isometric": pos.set(50,50,50); break;
        case "top":       pos.set(0,80,0);   break;
        case "front":     pos.set(0,0,40);   break;  // antes 50
        case "side":      pos.set(50,0,0);   break;
        case "diagonal":  pos.set(-50,50,-50);break;
        default:          pos.set(0,0,50);
      }
      camera.position.copy(pos);
      camera.lookAt(new THREE.Vector3(0,0,0));
      controls.update();
    }

    function applyEmbedParams(){
      const p=new URLSearchParams(window.location.search);
      if(p.has('perms')){
        const arr=p.get('perms').split(';');
        document.querySelectorAll('#permutationList option').forEach(o=>{
          o.selected=arr.includes(o.value);
        });
      }
      if(p.has('mapping')){
        const m=p.get('mapping').split(',').map(Number);
        attributeMapping=[m[0],m[1],m[2],m[3],m[4], attributeMapping[5], attributeMapping[6]];
      }
      if(p.has('colors')){
        const cols=p.get('colors').split(',');
        cols.forEach((hex,i)=>{
          if(i<5){
            const h='#'+hex;
            manualOverride[i+1]=h;
          }
        });
      }
      if(p.has('bg')){
        const bg='#'+p.get('bg');
        document.getElementById('bgColor').value=bg; updateBackground();
      }
      if(p.has('cube')){
        const c='#'+p.get('cube');
        document.getElementById('cubeColor').value=c; updateCubeColor();
      }
      if(p.has('view')){
        document.getElementById('standardView').value=p.get('view');
        applyStandardView();
      }
      if(p.get('hide')==='1') toggleTexts();
    }

    function exportEmbed(){
      const config = exportCurrentConfiguration();     // ← usa la misma fuente de verdad
      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'prmttn_config_pretty.json';
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function mostrarDebugColores(){
      if(!permutationGroup || !permutationGroup.children.length){
        alert('No hay permutaciones en pantalla'); return;
      }

      /* color de fondo efectivo para contraste ΔE */
      const bgRgb = bgOverride
          ? hexToRgb(bgOverride)
          : hsvToRgb(bgHSV.h, bgHSV.s, bgHSV.v);

      const bgLab = rgbToLab(...bgRgb);

      let txt =
        'Permutación |slot|  h° |  s  |  v  | ΔEbg |  #hex\n' +
        '────────────┼────┼─────┼─────┼─────┼─────┼────────\n';

      permutationGroup.children.forEach(mesh => {
        const paArr   = mesh.userData.permStr.split(',').map(Number);
        const permStr = paArr.join(',');
        const slot    = lehmerRank(paArr) % 12;

        /* HSV teórico desde el patrón */
        const sig = computeSignature(paArr);
        let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
        sI = (sI * PHI_S) % 12;
        vI = (vI * PHI_V) % 12;
        const {h,s,v} = idxToHSV(hI, sI, vI);

        const rgb = [
          Math.round(mesh.material.color.r * 255),
          Math.round(mesh.material.color.g * 255),
          Math.round(mesh.material.color.b * 255)
        ];
        const ΔEbg = deltaE(rgbToLab(...rgb), bgLab).toFixed(1);
        const hex = '#' + mesh.material.color.getHexString();

        txt += `${permStr.padEnd(12)}|${slot.toString().padStart(2)} |`+
               `${normHue(h).toFixed(1).padStart(5)}|`+
               `${s.toFixed(2)}|${v.toFixed(2)}|`+
               `${ΔEbg.padStart(5)}| ${hex}\n`;
      });

      console.log(txt);   // copia completa al log
      alert(txt);         // vista rápida
    }

    /* ============================================================
     *  PANEL "Descripción arquitectónica"
     * ============================================================ */


function showArchitecturalDescription(){
  const selOpts  = Array.from(document.getElementById('permutationList').selectedOptions);
  const perms    = selOpts.map(o => o.value.split(',').map(Number));
  const m        = attributeMapping.slice(0,5);

  // determinism
  const sceneSeed_new = computeSceneSeedFrom(perms, m);
  const S_new         = computeGlobalS(perms, m);
  const mRank         = mappingRank(m);

  let sumR=0, sumR2=0;
  const ranks = perms.map(p=>lehmerRank(p));
  ranks.forEach(r=>{ sumR+=r; sumR2+=r*r; });

  const step = cubeSize/5;

  // ======= STRUCTURE =======
  const structureHTML = `
  <h3>Structure</h3>
  <p>
    Below are the deterministic formulas that explain
    <b>why each permutation is exactly at its position,
    why permutations and their environment have those colors</b>,
    and why <b>the whole scene — shapes, colors and positions — is reproducible
    whenever the inputs are the same</b>.
  </p>

  <div class="formula">
    <b>1) Global scene seed (sceneSeed)</b><br>
    It fixes the chromatic base angle of the whole scene.
    <br><br>
    sumR = Σ LehmerRank(Pᵢ) &nbsp;|&nbsp; sumR2 = Σ (LehmerRank(Pᵢ))² <br>
    mRank = LehmerRank([m₀+1,m₁+1,m₂+1,m₃+1,m₄+1])<br><br>
    <span class="box">sceneSeed = (37·sumR + 101·sumR2 + 53·mRank) mod 360</span>
  </div>

  <div class="formula">
    <b>2) Structural term for positions (S)</b><br>
    <i>S</i> couples positions to the attribute reorganization (mapping) used for (x,y,z).
    <br><br>
    <span class="box">S = ( Σ (P<sub>mx</sub> + P<sub>my</sub> + P<sub>mz</sub>) ) mod 125</span>
  </div>

  <div class="formula">
    <b>3) Shift‑Rank: position of each permutation</b><br>
    Combines the permutation Lehmer rank with the global invariants to assign
    a unique index over a 5×5×5 lattice.
    <br><br>
    <span class="box">I = (r + sceneSeed + S) mod 125</span><br>
    From I → (x,y,z) ∈ {0..4}³ → position inside the 30×30×30 cube.
  </div>

  <div class="formula">
    <b>4) Deterministic color (HSV lattice 144×12×12)</b><br>
    Each permutation color comes from a well‑distributed slot (r mod 12)
    and a chromatic pattern (1–11) with coprime spreads for S and V.
    <br><br>
    H ∈ 144 steps (2.5°), S ∈ 12, V ∈ 12<br>
    slot = r mod 12<br>
    pattern → [hIdx,sIdx,vIdx]; s' = (sIdx·5) mod 12; v' = (vIdx·7) mod 12<br>
    HSV = idxToHSV(hIdx,s',v') → RGB
  </div>

  <div class="formula">
    <b>5) Minimum contrast against background</b><br>
    Each color is automatically adjusted to satisfy ΔE (CIE76) ≥ 22 against the current background.
  </div>
  `;

  // ======= ARCHITECTURAL PLANS =======
  let plansHTML = `
  <h3>Architectural Plans</h3>

  <section>
    <h4>Global invariants</h4>
    <ul>
      <li>sumR = <b>${sumR}</b></li>
      <li>sumR2 = <b>${sumR2}</b></li>
      <li>m = [${m.join(', ')}] (shape,color,x,y,z)</li>
      <li>mRank = <b>${mRank}</b></li>
      <li><b>sceneSeed</b> = <b>${sceneSeed_new}</b></li>
      <li><b>S</b> = <b>${S_new}</b></li>
      <li>activePatternId = <b>${activePatternId}</b></li>
    </ul>
  </section>
  <section>
    <h4>Phenotypic scope of this edition</h4>
    <div class="formula">
      <b>BUILD:</b> 120 attribute‑mappings × 11 chromatic‑patterns = <b>1 320</b> deterministic visuals.<br>
      <b>FRBN:</b> catalog parameter K = <b>144</b> → <b>1 320 × 144 = 190 080</b> canonical states.<br>
      The permutations are acquired as a <b>group</b>; the count does not multiply by the number of permutations in the group.
    </div>
    <small>K is a catalog parameter (editorial choice). Any change is documented and applies only to future editions.</small>
  </section>
  <hr/>
  `;

  perms.forEach((perm, i)=>{
    const r    = ranks[i];
    const sig  = computeSignature(perm);
    const rango= computeRange(sig);

    const I    = (r + sceneSeed_new + S_new) % 125;
    const x    = Math.floor(I/25);
    const y    = Math.floor((I%25)/5);
    const z    = I % 5;
    const X    = (x-2)*step, Y=(y-2)*step, Z=(z-2)*step;

    const slot = r % 12;
    let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed_new, slot);
    const sIdx = (sI * PHI_S) % 12;
    const vIdx = (vI * PHI_V) % 12;
    const hsv  = idxToHSV(hI, sIdx, vIdx);
    let  rgb   = hsvToRgb(hsv.h, hsv.s, hsv.v);
    rgb        = ensureContrastRGB(rgb);
    const hex  = '#'+new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255).getHexString();

    plansHTML += `
    <section class="perm">
      <h4>Permutation ${i+1}: [${perm.join(', ')}]</h4>
      <div class="formula">
        Signature F = [${sig.join(', ')}] &nbsp;|&nbsp; Range = <b>${rango}</b><br>
        Lehmer-rank r = ${r}
      </div>
      <div class="formula">
        I = (r + sceneSeed + S) mod 125 = (${r} + ${sceneSeed_new} + ${S_new}) mod 125 = <b>${I}</b><br>
        (x,y,z) = (${x}, ${y}, ${z}) → (X,Y,Z) = (${X.toFixed(2)}, ${Y.toFixed(2)}, ${Z.toFixed(2)})
      </div>
      <div class="formula">
        slot = r mod 12 = ${slot}<br>
        pattern → [hI,sI,vI] = [${hI}, ${sI}, ${vI}]<br>
        s' = ${sIdx}, v' = ${vIdx}<br>
        HSV = (${hsv.h.toFixed(2)}°, ${hsv.s.toFixed(2)}, ${hsv.v.toFixed(2)}) → RGB = ${hex}
      </div>
    </section>
    <hr/>
    `;
  });

  const firstSig = perms[0] ? computeSignature(perms[0]) : [0,0,0,0,0];
  const lastSig  = perms[perms.length-1] ? computeSignature(perms[perms.length-1]) : [0,0,0,0,0];

  const fondoIdx = PATTERNS[activePatternId](firstSig, sceneSeed_new, perms.length);
  const cuboIdx  = PATTERNS[activePatternId](lastSig,  sceneSeed_new, perms.length+1);

  const fondoHSV = idxToHSV(...fondoIdx);
  const cuboHSV  = idxToHSV(...cuboIdx);

  plansHTML += `
    <section>
      <h4>Background & cube walls</h4>
      <div class="formula">
        Background (slot = #${perms.length}) → idx = [${fondoIdx.join(', ')}] → HSV = (${fondoHSV.h.toFixed(2)}°, ${fondoHSV.s.toFixed(2)}, ${fondoHSV.v.toFixed(2)})
      </div>
      <div class="formula">
        Cube (slot = #${perms.length+1}) → idx = [${cuboIdx.join(', ')}] → HSV = (${cuboHSV.h.toFixed(2)}°, ${cuboHSV.s.toFixed(2)}, ${cuboHSV.v.toFixed(2)})
      </div>
    </section>

    <section>
      <h4>Rotation</h4>
      <p>ω = mapRangeToSpeed(range, 2, 6)</p>
    </section>
  `;

  const html = `
    <h2>Architectural Description</h2>
    ${structureHTML}
    <hr/>
    ${plansHTML}
  `;

  renderArchPanel(html);
}
function renderArchPanel(html){
  let panel = document.getElementById('archPanel');
  if(!panel){
    panel = document.createElement('div');
    panel.id = 'archPanel';
    panel.innerHTML = `
      <div id="archContent"></div>
      <button id="archClose">Close</button>
    `;
    document.body.appendChild(panel);

    const css = document.createElement('style');
    css.textContent = `
      #archPanel{
        position:fixed; z-index:1000; top:5%; left:50%;
        transform:translateX(-50%);
        width:85%; height:90%;
        background:#fff; color:#000;
        border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
        padding:24px 32px 48px; overflow:auto;
        font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
        font-size:14px; line-height:1.4;
        cursor:auto;
      }
      #archPanel *{ cursor:auto !important; }
      #archClose{
        position:fixed; right:calc(7.5% + 16px); top:5%;
        border:none; padding:6px 10px; border-radius:4px;
        background:#eee; cursor:pointer; z-index:1001;
      }
      #archPanel h2{ margin-top:0; }
      #archPanel .formula{
        margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
      }
      #archPanel .box{
        display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
        font-family:monospace;
      }
      #archPanel section{ margin-bottom:18px; }
      #archPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
      #archPanel .perm h4{ margin-bottom:6px; }
      code, pre{ font-family:monospace; }
    `;
    document.head.appendChild(css);
  }

  // NUNCA ocultamos el cursor; y al cerrar lo forzamos a mostrarse
  const closeBtn = panel.querySelector('#archClose');
  closeBtn.onclick = ()=>{
    const cc = document.getElementById('customCursor');
    if (cc) cc.style.display = 'block';
    panel.remove();
  };

  const cc = document.getElementById('customCursor');
  if (cc) cc.style.display = 'block';

  document.getElementById('archContent').innerHTML = html;
}
    function initCustomCursor(){
      const c=document.getElementById('customCursor');
      window.addEventListener('mousemove',e=>{
        c.style.left=e.clientX+"px"; c.style.top=e.clientY+"px";
      });
    }
    function initRenderer(){
      renderer = new THREE.WebGLRenderer({antialias:true, preserveDrawingBuffer:true});
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth,window.innerHeight);
      renderer.outputEncoding = THREE.sRGBEncoding; // salida en sRGB → menos banding
      document.body.appendChild(renderer.domElement);
    }
    function init(){
      scene=new THREE.Scene();
      scene.background=new THREE.Color(0xffffff);
      camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      camera.position.set(0,0,50);
      initRenderer();
      controls=new THREE.OrbitControls(camera,renderer.domElement);
      controls.enableDamping=true; controls.dampingFactor=0.1; controls.enableZoom=true;
      document.getElementById('standardView').value = 'front';
      applyStandardView();
      scene.add(new THREE.AmbientLight(0xffffff,0.8));
      const dir=new THREE.DirectionalLight(0xffffff,0.5);
      dir.position.set(1,1,1);
      scene.add(dir);

      const cubeGeo=new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize),
            cubeMat=new THREE.MeshBasicMaterial({color:0x808080,transparent:true,opacity:0.2,side:THREE.BackSide,dithering:true});
      cubeUniverse=new THREE.Mesh(cubeGeo,cubeMat);
      scene.add(cubeUniverse);

      permutationGroup=new THREE.Group();
      scene.add(permutationGroup);

      raycaster=new THREE.Raycaster();
      mouse=new THREE.Vector2();
      window.addEventListener('mousemove',onMouseMove,false);
      window.addEventListener('resize',onWindowResize,false);

      initCustomCursor();
      populatePermutationList();
      populateAttributeMappingSelect();
      applyEmbedParams();
      makePalette();
      setMode("manual");
      refreshAll({rebuild:true});

      // ← NUEVO: como si hubieras presionado BUILD al cargar
      generateRandomConfigurationNoCollision().catch(console.error);

      animate();
    }
    function onWindowResize(){
      camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }
    function animate(){
      requestAnimationFrame(animate);
      if(!isPaused){
        permutationGroup.children.forEach(o=>{
          if(o.userData.rotationSpeed) o.rotation.y+=o.userData.rotationSpeed;
        });
      }
        if(skySphere) skySphere.material.uniforms.time.value = performance.now()*0.001;
          if(isLCHT && lichtGroup){
            const t = performance.now()*0.001;
            lichtGroup.children.forEach(o=>{
              const d = o.userData.lcht;
              if(d){
                // solo modulamos un leve “emissive” sobre el propio material
                const I = d.I0 * (1 - d.amp *
                        (1 + Math.cos(2*Math.PI*d.f*t + d.phi)) / 2);
                o.material.emissive        = o.material.color.clone();
                o.material.emissiveIntensity = I * 0.15;  // suave, sin deslumbrar
              }
            });
          }
        controls.update();
        renderer.render(scene,camera);
      }
    init();

    // Web3 + NFT Mint (tu código original)
    const CONTRACT_ADDRESS = "YOUR_CONTRACT_ADDRESS";
    const contractABI = [/* ABI JSON here */];
    let provider, signer, contract;
    async function initWeb3() {
      if (window.ethereum) {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        contract = new ethers.Contract(CONTRACT_ADDRESS, contractABI, signer);
      } else {
        console.warn("MetaMask no detectado");
      }
    }
    window.addEventListener("load", initWeb3);

    async function mintNFT() {
      if (!contract) { alert("Wallet no conectada"); return; }
      try {
        const hash = await computeConfigHash();
        const tokenURI = `https://my-server.com/metadata/${hash}.json`;
        const tx = await contract.mint(await signer.getAddress(), tokenURI);
        await tx.wait();
        const nft = {
          tokenId: hash,
          tokenURI,
          owner: await signer.getAddress(),
          config: exportCurrentConfiguration()
        };
        localStorage.setItem("mintedNFT_" + hash, JSON.stringify(nft));
        console.log("NFT guardado localmente:", nft);
        alert("NFT acuñado! Hash: " + hash);
      } catch(e) {
        console.error(e);
        alert("Error mint NFT: " + e.message);
      }
    }

    /* ============================================================
     * INFORMATION PANEL — delivers the consolidated, corrected EN text
     * Title: "PRMMTN – Architecture for thought without words"
     * Ends with: "work in progress"
     * ============================================================ */

function showInformation(){
  const html = `
      <h2>Version 31.07.2025, PRMTTN‑Architecture for thought without words</h2>

      <h3>Structural Introduction</h3>
      <p><em>Nothing else is needed. Combinatorics is enough.</em></p>

      <h3>1. What is PRMTTN?</h3>
      <p>PRMTTN is a finite combinatorial architecture where preverbal thought (thought without words) may occur. Its starting point is a closed and non‑expandable set of 120 permutations of the set {1, 2, 3, 4, 5}. From this set, visual configurations of permutations are generated, governed by fixed structural rules, without semantics or interpretation. Each configuration is pure form. Its logic is self‑sufficient.</p>
      <p>Each work in PRMTTN consists of a specific group of permutations, acquired as a structural unit. This group can be projected across different visual engines/editions—current or future—that apply deterministic rules to translate it into visible phenotypic configurations.</p>
      <p>The content is neither an image nor a file: it is a verifiable formal structure (a specific subset of the 120 permutations). The visualization may vary depending on the engine used, but the original group of permutations does not change. The identity of a work is defined by that group and the internal rules of the system. The work is not its visualization, but the underlying structure that remains invariant across projections.</p>
      <p>PRMTTN does not operate as language, nor as a medium of expression. What it shows refers to nothing outside itself. Each configuration is a visual form that does not communicate, represent, or explain. Its existence does not depend on taste, interpretation, or intention, but on a combinatorial logic that gives structure to the invisible.</p>

      <h3>Structural Grammar</h3>
      <p><em>A single permutation, reorganized, may contain a complete architecture for what cannot be said.</em></p>

      <h3>2. Internal Rules</h3>
      <p>PRMTTN operates through a fixed visual grammar, derived from numerically assigned structural values. Each configuration is composed of visual elements whose attributes are calculated from a permutation of the set {1, 2, 3, 4, 5}. There are no exceptions or manual assignments.</p>
      <p>Each permutation is internally reorganized to define its visual properties. This reorganization—phenotypic and not genetic—assigns a specific role to each of the five values, without breaking the system's logic.</p>

      <h4>Structural attributions:</h4>
      <table style="width:100%;border-collapse:collapse;font-size:13px">
        <thead>
          <tr><th>Attribute</th><th>Numerical Source</th><th>Deterministic Rule</th></tr>
        </thead>
        <tbody>
          <tr><td>Shape</td><td>First value (P₁)</td><td>Height proportional to √(P₁)</td></tr>
          <tr><td>Color</td><td>Second value (P₂) + signature + global seed</td><td>Deterministic HSV mapping on discrete grid</td></tr>
          <tr><td>Position</td><td>Lehmer-rank + global seed + sum</td><td>3D mapping inside the 30×30×30 cube</td></tr>
          <tr><td>Rotation</td><td>Range of signature</td><td>Rotation proportional to (max − min)</td></tr>
        </tbody>
      </table>
      <p>Each attribute is tied to a traceable internal structure. There is no aesthetic intervention or subjective choice. The visual result depends solely on explicit structural rules.</p>

      <h3>3. Phenotype and Engines</h3>
      <p><em>There is no decoration here. Only structure.</em></p>

      <p>The system allows for multiple phenotypic reorganizations of each permutation or group of permutations. These reorganizations do not modify the value group, but rather their role within the formal attribution logic. This is an internal reassignment of functions, not a genetic mutation. All are valid.</p>
      <p>A single set of permutations can be projected across different engines, each with specific visual rules:</p>
      <ul>
        <li><b>BUILD</b>: Static layout inside a 30×30×30 cube, segmented into 5×5×5 positions.</li>
        <li><b>FRBN</b>: Deterministic color field associated with BUILD</li>
        <li><b>Future engines</b>: Additional visual structures compatible with the base logic</li>
      </ul>
      <p>Engines do not alter the genotype. What changes is the derived phenotypic visualization. All future expansions are applied to the same acquired set of permutations. Given the same input, the system always produces the same output.</p>
      <p>A work grows through the addition of grammars, not by transformation of content. Structural identity remains fixed. PRMTTN does not evolve by accumulation, but by multiplying valid projections over a single combinatorial base.</p>

      <h3>4. Reorganization without Progress</h3>
      <p><em>Nothing improves. Everything reorganizes.</em></p>

      <p>PRMTTN has no narrative development, functional evolution, or symbolic accumulation. There is only internal reorganization within a fixed combinatorial set.</p>
      <p>Each layout is a phenotypic mutation: a new assignment of the five values to the system's visual functions. The permutations do not change. What changes is their structural presentation.</p>
      <p>These variations do not seek efficiency, meaning, or beauty. There is no adaptation or improvement. Only formal transformations, all compatible with the original rules.</p>
      <p>There is no direction or goal. Internal evolution is purely combinatorial.</p>

      <h3><em>Structural Antiaesthetic Manifesto</em></h3>
      <p>PRMTTN does not produce beauty. Nor ugliness. What it produces is structure: visible form generated by deterministic combinatorics, without symbols, intention, or narrative.</p>
      <p>Each element appears because a rule requires it. No attribute is chosen. Everything responds to fixed formulas applied to closed permutations. The structure is complete, with no need for interpretation. What is seen is exactly what it is.</p>
      <p>There is nothing behind a configuration. No latent layers, no metaphors, no hidden meaning. That does not make it empty. What sustains it is not content, but the internal logic that arranges it.</p>
      <p>There is no user manual. The system does not ask to be understood. It can only be contemplated.</p>
      <p>Each arrangement is self-sufficient. It does not represent, communicate, or refer to anything outside itself. Its formal consistency is its only condition of existence.</p>
      <p>What appears offers no reward. It does not propose emotion or understanding. But it may impose presence: an organization that does not justify itself, but imposes itself through consistency. Not because it says so, but because it is.</p>
      <p>All possible variation is fixed by mathematics. Forms, colors, positions, and motions are determined by invariant rules. The only variable is the gaze: who observes, when, and with what perceptual disposition. That is the only entry point.</p>
      <p>No language has been built. No artwork has been designed. No communicative experience has been produced. What has been formulated is a closed system: finite, reproducible, without semantic expansion.</p>
      <p>Each configuration of permutations derives from a mathematical operation. Each visible attribute—form, color, position, motion—is a direct consequence of that operation. There is no expression. No style. No decision. Only pure structure.</p>
      <p>Nothing is stated. Nothing needs to be interpreted.</p>
      <p>The system does not claim that preverbal thought occurs. Nor does it represent it. It only defines with precision the conditions in which it could emerge: without signs, without recipient, without translation.</p>
      <p>What appears in each scene has no name, no purpose, no story. It is a visible mathematical configuration: without image, metaphor, or context.</p>
      <p>And if something occurs in front of that arrangement—a form of non-verbal mental organization, a perceptual orientation without words—that cannot be guaranteed. It can only be made possible by structure.</p>
      <p>The system is fully defined. There is no future expansion. No exception. No part left unformalized.</p>
      <p>It is a space outside language.</p>
      <p>If something occurs in front of these dispositions—a mental organization, a non-verbal activation, a form of thought without words—that cannot be affirmed or denied.</p>
      <p>It can only be made possible by structure.</p>
      <p>And in that exact structure, non-representational and beyond interpretation, the system closes.</p>

      <h3>5. Operational Architecture</h3>
      <p>For readers interested in the internal logic, this section details the mathematical foundation of PRMTTN:</p>

      <h4>a. Structural Signature (DNA)</h4>
      <p>Each permutation P = [P₁, P₂, P₃, P₄, P₅] from the set {1, 2, 3, 4, 5} is transformed into a signature F = [F₁, F₂, F₃, F₄, F₅] through the application of a phenotypic pattern that reorders the numerical values according to their function in the system (shape, color, X/Y/Z position, rotation).</p>
      <p>The signature is the structural basis from which all visual attributes are derived.</p>

      <h4>b. Global Scene Seed (sceneSeed)</h4>
      <p>To ensure structural coherence between color, position, and rotation within a scene, a unique global seed is calculated from all active permutations.</p>

      <h5>Formulas:</h5>
      <p>For each active permutation Pₐ:</p>
      <ul>
        <li>rₐ = LehmerRank(Pₐ)</li>
        <li>sumR = Σ rₐ</li>
        <li>sumR2 = Σ rₐ²</li>
        <li>mRank = LehmerRank([m₀+1, ..., m₄+1]) (where [m₀, ..., m₄] is the lexicographically smallest permutation in the active set)</li>
      </ul>
      <p>Then:</p>
      <pre>sceneSeed = (37 × sumR + 101 × sumR2 + 53 × mRank) mod 360</pre>

      <h4>c. Position inside the cube (Shift‑Rank)</h4>
      <p>The 3D space is defined by a 30×30×30 cube. Each axis contains 5 discrete positions, totaling 125 valid spatial slots.</p>
      <p><b>Procedure:</b></p>
      <ol>
        <li>Compute Lehmer‑rank of P:<br><pre>R = LehmerRank(P)</pre></li>
        <li>Scene shift sum:<br><pre>S = ( ΣP ∈ scene (Pmx + Pmy + Pmz) ) mod 125</pre></li>
        <li>Index:<br><pre>I = (R + sceneSeed + S) mod 125</pre></li>
        <li>Discrete coordinates:<br><pre>(x, y, z) = (⌈I / 25⌉, ⌈(I mod 25) / 5⌉, I mod 5)</pre></li>
        <li>Physical coordinates:<br><pre>(X, Y, Z) = (x − 2, y − 2, z − 2) × 6</pre></li>
      </ol>
      <p>Each permutation occupies a 6‑unit cube cell in the space.</p>

      <h4>d. Color: Deterministic HSV Grid</h4>
      <p>Colors are computed structurally within a discrete HSV grid of 20,736 unique combinations.</p>
      <p><b>Grid structure:</b></p>
      <ul>
        <li>H (Hue): 144 levels, 2.5° steps</li>
        <li>S (Saturation): 12 levels, Sₐ = 0.25 + 0.72 × (i / 11)</li>
        <li>V (Value): 12 levels, Vₐ = 0.20 + 0.75 × (i / 11)</li>
      </ul>
      <p><b>Total combinations:</b></p>
      <pre>N_colors = 144 × 12 × 12 = 20,736</pre>
      <p><b>Assignment:</b></p>
      <ol>
        <li>Compute signature F = [F₁…F₅]</li>
        <li>Compute Lehmer‑rank r</li>
        <li>slot = r mod 12</li>
        <li>Indexes:<br><pre>H_idx = (slot × 89) mod 144
S_idx = (slot × 5) mod 12
V_idx = (slot × 7) mod 12</pre></li>
        <li>Real values:<br><pre>H = H_idx × 2.5
S = 0.25 + 0.72 × (S_idx / 11)
V = 0.20 + 0.75 × (V_idx / 11)</pre></li>
      </ol>

      <h4>e. Rotation: Signature Range</h4>
      <pre>ω = max(F) − min(F)</pre>
      <p>This determines the angular variation. There is no imposed symmetry or manual control.</p>

      <h4>f. Total Combinatorics</h4>
      <ul>
        <li>Reorganizations per permutation: 120</li>
        <li>Spatial configurations:<br><pre>Config(k) = (120 C k) × (125 C k) × k!</pre></li>
        <li>Total:<br><pre>Total = Σk=1..30 Config(k) ≈ 3.10 × 10^125</pre></li>
      </ul>

      <h4>g. Geometric Origin</h4>
      <p>The shape of each unit is derived from the root of its first value:</p>
      <pre>Height = base × √(P₁)</pre>
      <p>All proportions derive from this value.</p>

      <h3>6. Coexistence and Persistence</h3>
      <p><em>Language is not shared. Logic is.</em></p>

      <h4>a. Coexistence without Translation</h4>
      <p>PRMTTN does not require semantic comprehension to be operated. Humans and artificial intelligences can engage with the system by applying the same rules, without interpretation.</p>
      <p>This is possible because:</p>
      <ul>
        <li>The structural grammar is fully explicit and reproducible.</li>
        <li>Reorganization rules are independent of any symbolic context.</li>
        <li>Configurations can be generated or perceived without attributing meaning.</li>
      </ul>
      <p>What is shared is not language, but structure. Both AI and humans can operate on the same permutation set using only formal logic. This redefines thought as a non-narrative, non-emotional activity based on combinatorial manipulation of visible structures.</p>
      <p>The system does not aim for biological symmetry. It defines a common zone: an environment where different forms of thought may coexist without translation.</p>

      <h4>b. Structural Persistence</h4>
      <p><em>To remember, in this system, is simply to reconstruct.</em></p>
      <p>Configurations in PRMTTN do not need to be remembered to be reproduced. Each one can be reconstructed entirely from:</p>
      <ul>
        <li>The original permutation P = [P₁, P₂, P₃, P₄, P₅]</li>
        <li>The phenotypic assignment of attributes</li>
        <li>The Lehmer-rank of the permutation</li>
        <li>The global scene seed (sceneSeed)</li>
        <li>The deterministic formulas for position and color</li>
      </ul>
      <p>This allows storing configurations as formal states, without interpretive metadata or narrative memory. What is preserved is not content, but exact disposition.</p>
      <p><b>Storage methods include:</b></p>
      <ul>
        <li><b>Firestore</b>: structural persistence without semantic metadata</li>
        <li><b>Arweave / Thirdweb</b>: blockchain anchoring with verifiable integrity</li>
      </ul>
      <p>Storing a configuration does not tell a story. It preserves its future possibility of structural reactivation.</p>

      <h3>End.</h3>
      <p>PRMTTN does not assert results. It proposes a strictly structural hypothesis:</p>
      <blockquote>That a visual organization without semantics may generate favorable conditions for thought without words.</blockquote>
      <p><i>work in progress.</i><br><i>MARTINEZ</i></p>
      `;
  renderInfoPanel(html);
}
function showFRBNInfo(){
  const html = `
    <h2>FRBN — Deterministic Ganzfeld</h2>
    <p><b>What you see cannot be otherwise</b> given the current scene. FRBN does not invent a palette:
       it extracts it deterministically from the active permutations and the chromatic engine.</p>
    <ul>
      <li><b>Source palette.</b> Colors are collected from the glyphs currently on stage
          (their materials are computed by the same deterministic HSV lattice used in BUILD).
          If needed, hues are normalised to ensure separation.</li>
      <li><b>Pattern coupling.</b> The chromatic pattern (1–11) and the global seed
          (<code>sceneSeed</code>) bias hue selection in BUILD; FRBN reads the result,
          not a new random set.</li>
      <li><b>Temporal blend.</b> The shader interpolates the collected colors over time.
          The rate is tied to the average rotation speed of the permutations, so color
          breathing <i>follows</i> the scene dynamics.</li>
      <li><b>No alternatives.</b> For the same set of permutations, mapping and pattern,
          the FRBN field is reproducible. Change the scene → the field changes; keep the
          scene → the field must be identical.</li>
      <li><b>Banding control.</b> A high‑precision dither (blue‑noise) is applied in linear
          space to avoid contour banding without altering the palette.</li>
    </ul>
    <p>FRBN is therefore a <b>deterministic projection</b> of the current combinatorial state,
       not a decorative background.</p>
  `;
  renderInfoPanel(html);
}
    /* Minimal renderer for the panel (include once; remove if you already have it) */
    function renderInfoPanel(html){
      let panel = document.getElementById('infoPanel');
      if(!panel){
        panel = document.createElement('div');
        panel.id = 'infoPanel';
        panel.innerHTML = `
          <div id="infoContent"></div>
          <button id="infoClose">Close</button>
        `;
        document.body.appendChild(panel);
        const btn = panel.querySelector('#infoClose');
        btn.onclick = ()=>{
          const cc = document.getElementById('customCursor');
          if (cc) cc.style.display = 'block';
          panel.remove();
        };
      }
      const cc = document.getElementById('customCursor');
      if (cc) cc.style.display = 'block';
      document.getElementById('infoContent').innerHTML = html;
    }

    /* ======== CERTIFICADO DE EDICIÓN: utilidades base ======== */

    /* Ordena claves de forma determinista (objetos y arrays) */
    function sortDeep(x){
      if (Array.isArray(x)) return x.map(sortDeep);
      if (x && typeof x === 'object') {
        const out = {};
        Object.keys(x).sort().forEach(k => { out[k] = sortDeep(x[k]); });
        return out;
      }
      return x;
    }
    /* JSON canónico (minificado y con claves ordenadas) */
    function stableStringify(obj){ return JSON.stringify(sortDeep(obj)); }

    /* SHA‑256 en hex */
    async function sha256Hex(text){
      const enc = new TextEncoder().encode(text);
      const buf = await crypto.subtle.digest('SHA-256', enc);
      const bytes = Array.from(new Uint8Array(buf));
      return bytes.map(b => b.toString(16).padStart(2,'0')).join('');
    }

    /* Descarga un blob */
    function downloadBlob(filename, blob){
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    /* PNG A2 de la vista ACTUAL (sin recortar lo que ves) → Blob */
    async function renderA2ImageBlob(){
      const A2_W = 7016, A2_H = 4961;

      // backups
      const prevPixelRatio = renderer.getPixelRatio();
      const prevSize       = renderer.getSize(new THREE.Vector2());
      const prevAspect     = camera.aspect;
      const prevRt         = renderer.getRenderTarget?.() || null;
      const prevBg         = scene.background ? scene.background.clone() : null;

      const screenAspect = prevSize.x / prevSize.y;
      const a2Aspect = A2_W / A2_H;
      let renderW, renderH;
      if (screenAspect > a2Aspect) { renderW = A2_W; renderH = Math.round(A2_W / screenAspect); }
      else { renderH = A2_H; renderW = Math.round(A2_H * screenAspect); }

      renderer.setPixelRatio(1);
      renderer.setSize(renderW, renderH, false);
      camera.aspect = screenAspect;
      camera.updateProjectionMatrix();

      const rt = new THREE.WebGLRenderTarget(renderW, renderH, { depthBuffer:true, stencilBuffer:false });
      const clearHex = prevBg ? '#' + prevBg.getHexString() : '#ffffff';

      renderer.setClearColor(clearHex, 1);
      renderer.setRenderTarget(rt);
      renderer.clear(true, true, true);
      renderer.render(scene, camera);

      const pixels = new Uint8Array(renderW * renderH * 4);
      renderer.readRenderTargetPixels(rt, 0, 0, renderW, renderH, pixels);

      // canvas intermedio con flip vertical
      const tmp = document.createElement('canvas');
      tmp.width = renderW; tmp.height = renderH;
      const tctx = tmp.getContext('2d');
      const imgData = tctx.createImageData(renderW, renderH);
      const row = renderW * 4;
      for (let y = 0; y < renderH; y++) {
        const src = (renderH - 1 - y) * row;
        const dst = y * row;
        imgData.data.set(pixels.subarray(src, src + row), dst);
      }
      tctx.putImageData(imgData, 0, 0);


      // composita A2 con cubierta según modo
      const final = document.createElement('canvas');
      final.width = A2_W; final.height = A2_H;
      const fctx = final.getContext('2d');

      if (isFRBN) {
        // — FRBN: cubrir A2 (recorte centrado, sin bandas)
        const scale = Math.max(A2_W / renderW, A2_H / renderH);
        const drawW = Math.ceil(renderW * scale);
        const drawH = Math.ceil(renderH * scale);
        const offX  = Math.floor((A2_W - drawW) / 2);
        const offY  = Math.floor((A2_H - drawH) / 2);
        fctx.drawImage(tmp, offX, offY, drawW, drawH);
      } else {
        // — Modo normal: letterbox centrado
        fctx.fillStyle = clearHex; fctx.fillRect(0, 0, A2_W, A2_H);
        const offX = Math.floor((A2_W - renderW) / 2);
        const offY = Math.floor((A2_H - renderH) / 2);
        fctx.drawImage(tmp, offX, offY);
      }

      const blob = await new Promise(res => final.toBlob(res, 'image/png'));
      // restaurar
      renderer.setRenderTarget(prevRt);
      rt.dispose();
      renderer.setPixelRatio(prevPixelRatio);
      renderer.setSize(prevSize.x, prevSize.y);
      camera.aspect = prevAspect;
      camera.updateProjectionMatrix();
      if (prevBg) scene.background = prevBg;
      controls.update();

      return blob;
    }

    /* Configuración actual (mismo formato que exportEmbed) */
    function exportCurrentConfiguration(){
      const perms = Array.from(document.getElementById('permutationList').selectedOptions).map(o=>o.value);
      const mapping = { forma: attributeMapping[0], color: attributeMapping[1],
                        x: attributeMapping[2], y: attributeMapping[3], z: attributeMapping[4] };
      const colors = {}; for(let i=1;i<=5;i++){ colors[i] = document.getElementById('color'+i).value; }
      const bg   = document.getElementById('bgColor').value;
      const cube = document.getElementById('cubeColor').value;
      const view = "front";
      return { perms, mapping, colors, bg, cube, view, pattern: activePatternId, sceneSeed, S_global, frbnK: FRBN_K };
    }

    /* Hash para NFT u otros usos (lo pedía tu mintNFT) */
    async function computeConfigHash(){
      const cfg = exportCurrentConfiguration();
      const canonical = stableStringify(cfg);
      return sha256Hex(canonical);
    }

    /* ======== Acción principal: crear CERTIFICADO + JSON + PNG ======== */
    async function exportEditionCertificate(){
      try{
        showPopup("Generando certificado…",2000);

        // 1) JSON canónico + hash
        const cfg = exportCurrentConfiguration();
        const canonicalJSON = stableStringify(cfg);            // ← archivo exacto para hash
        const hashHex = await sha256Hex(canonicalJSON);

        // 2) Imagen A2
        const pngBlob = await renderA2ImageBlob();
        const pngDataURL = await new Promise(res=>{
          const r = new FileReader();
          r.onload = ()=>res(r.result);
          r.readAsDataURL(pngBlob);
        });

        // 3) Certificado HTML auto‑contenible
        const now = new Date();
        const prettyJSON = JSON.stringify(cfg, null, 2);
        const TOTAL_BUILD = 120 * 11;                 // 1,320 (no se multiplica por el tamaño del conjunto de permutaciones)
        const TOTAL_FRBN  = TOTAL_BUILD * FRBN_K;     // estados canónicos para FRBN
        const fmt = n => n.toLocaleString('en-US').replace(/,/g,'\u202f'); // separador fino

        const certHTML =
`<!doctype html>
<meta charset="utf-8">
<title>PRMMTN · Edition Certificate</title>
<style>
  body{font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin:32px; color:#111;}
  h1{font-weight:600; margin:0 0 4px;}
  h2{margin:24px 0 8px;}
  .meta{font-size:12px; color:#555; margin-bottom:24px;}
  .box{border:1px solid #ccc; padding:12px; border-radius:8px; background:#fafafa;}
  img{max-width:100%; height:auto; display:block; margin:12px 0 4px;}
  code{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;}
  details{margin-top:8px;}
  .sig{margin-top:28px; display:flex; gap:48px;}
  .sig div{border-top:1px solid #000; padding-top:6px; width:260px; text-align:center;}
</style>
<h1>PRMMTN · Edition Certificate</h1>
<div class="meta">
  <div>Date: ${now.toISOString()}</div>
  <div>Chromatic pattern: ${activePatternId}</div>
  <div>sceneSeed: ${sceneSeed} · S_global: ${S_global} · FRBN_K: ${FRBN_K}</div>
</div>

<h2>Image (A2)</h2>
<div class="box">
  <img src="${pngDataURL}" alt="PRMMTN A2 snapshot">
  <div style="font-size:12px;color:#444">Resolution: 7016×4961 px (A2 landscape)</div>
</div>

<h2>Integrity</h2>
<div class="box">
  <div>SHA‑256 (prmttn_config.json):</div>
  <div><code>${hashHex}</code></div>
  <details><summary>How to verify</summary>
    <pre>shasum -a 256 prmttn_config.json
# or
openssl dgst -sha256 prmttn_config.json</pre>
  </details>
</div>


<h2>Phenotypic scope</h2>
<div class="box">
  <ul>
    <li><b>BUILD (static):</b> 120 attribute‑mappings × 11 chromatic‑patterns = <b>${fmt(TOTAL_BUILD)}</b> deterministic visuals.</li>
    <li><b>FRBN (dynamic):</b> continuous deterministic field. For cataloging we adopt <b>K = ${FRBN_K}</b> canonical phases → <b>${fmt(TOTAL_FRBN)}</b> canonical states.</li>
  </ul>
  <p style="font-size:12px;color:#555;margin:8px 0 0;">
    Note: permutations are acquired as a <b>group</b>; the count does not multiply by the size of the group.
  </p>
</div>

<h2>Configuration (pretty view)</h2>
<div class="box">
  <details open><summary>Show JSON</summary>
    <pre>${prettyJSON.replace(/</g,"&lt;")}</pre>
  </details>
</div>

<div class="sig">
  <div>Edition signature</div>
</div>

<p style="margin-top:24px;color:#777;font-size:12px">This certificate is self‑contained (image + data). Work in progress.</p>`;
        // 4) Descargas (3 archivos + hash opcional)
        downloadBlob('PRMMTN_certificate.html', new Blob([certHTML], {type:'text/html'}));
        downloadBlob('PRMTTN_A2.png', pngBlob);
        downloadBlob('prmttn_config.json', new Blob([canonicalJSON], {type:'application/json'}));
        downloadBlob('prmttn_hash.txt', new Blob([`sha256  prmttn_config.json\n${hashHex}\n`], {type:'text/plain'}));

        showPopup("Certificado, imagen A2, JSON y hash descargados.", 3000);
      }catch(err){
        console.error(err);
        showPopup("Error generando certificado", 4000);
      }
    }

  </script>
  <!-- DROPZONE SCRIPT FINAL -->
  <script>
  document.addEventListener("DOMContentLoaded", function() {
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const uploadStatus = document.getElementById('uploadStatus');
    const jwkOutput = document.getElementById('jwkOutput');
    const cidOutput = document.getElementById('cidOutput');

    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#888";
    });
    dropzone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#ccc";
    });
    dropzone.addEventListener('drop', async (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#ccc";
      if (e.dataTransfer.files.length > 0) {
        await handleFile(e.dataTransfer.files[0]);
      }
    });
    fileInput.addEventListener('change', async (e) => {
      if (e.target.files.length > 0) {
        await handleFile(e.target.files[0]);
      }
    });
    async function handleFile(file) {
      uploadStatus.textContent = "Cifrando archivo…";
      jwkOutput.textContent = "";
      cidOutput.textContent = "";
      const key = await crypto.subtle.generateKey(
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"]
      );
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const data = new Uint8Array(await file.arrayBuffer());
      const encrypted = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        key,
        data
      );
      const exportedKey = await crypto.subtle.exportKey("jwk", key);
      jwkOutput.textContent = " Clave secreta (guárdala para descifrar): " + JSON.stringify(exportedKey);
      const ivHex = Array.from(iv).map(x=>x.toString(16).padStart(2,"0")).join("");
      jwkOutput.textContent += "\n IV usado: " + ivHex;

      const combined = new Uint8Array(iv.byteLength + encrypted.byteLength);
      combined.set(iv, 0);
      combined.set(new Uint8Array(encrypted), iv.byteLength);
      const encryptedBlob = new Blob([combined], { type: file.type });

      uploadStatus.textContent = "Subiendo a Bundlr (requiere wallet conectada)…";
      try {
        if (!window.bundlr) {
          uploadStatus.textContent = "Bundlr no está listo aún o la wallet no está conectada";
          return;
        }
        const tx = await window.bundlr.upload(encryptedBlob, {
          tags: [{ name: "Content-Type", value: file.type }]
        });
        uploadStatus.textContent = " Subida exitosa";
        window.lastUploadedTxId = tx.id;
        cidOutput.textContent = "CID (Arweave/Bundlr): " + tx.id;
      } catch (err) {
        uploadStatus.textContent = " Error subiendo a Bundlr: " + err.message;
      }
    }
  });
  </script>
<script>
/* ══════════════════════════════════════════════════════════════
 *  Pattern Information Panel  –  English version (11 patterns)
 *  ⇒ called from the button  <button id="patternInfoButton">
 * ═════════════════════════════════════════════════════════════ */
function showPatternInfo(){
  const html = PATTERN_INFO_HTML;
  renderInfoPanel(html);        // reutiliza el mismo panel genérico
}

/* ---------- FULL TEXT (≈\u00a06\u202f600\u202fpalabras / 11\u202f\u00d7\u202f~600\u00a0) ---------- */
const PATTERN_INFO_HTML = `
<h2>Chromatic Patterns for Pre‑verbal Thought (v\u202f2025‑07‑28)</h2>

<!---------------------------------------------------------------
  1 · CHROMATIC CONTAINMENT
---------------------------------------------------------------->
<h3>1 · Chromatic Containment</h3>
<p><b>Operational definition.</b> Configure the palette so that every glyph
appears as a self‑contained entity, visually delimited by a narrow tonal band
(\u2264\u202f30\u202f\u00b0). No outlines, no hard contrast: cohesion is achieved through shared
hue, mid–high saturation (60–80\u202f%) and stable value (0.72\u202f\u00b1\u202f0.04).
The result is a silent, steady field that fosters focused pre‑verbal attention.</p>

<ul><li><b>Glyphs</b>\u00a0· hues inside \u2264\u202f30\u202f\u00b0, S\u202f60–80\u202f%, V\u202f\u2248\u202f0.72.</li>
<li><b>Background</b>\u00a0· hue\u00a0+\u202f180\u202f\u00b0, S\u202f\u2248\u202f18\u202f%, V\u202f\u2248\u202f0.42.</li>
<li><b>Cube</b>\u00a0· same\u202fhue, S\u202f\u2264\u202f6\u202f%, V\u202f0.26.</li>
<li><b>Contrast</b>\u00a0· \u0394E\u202f24–30.</li></ul>

<p><b>Expected outcome.</b> Glyphs are clearly separated from the ambience yet
cohere with one another, keeping the viewer in a calm, non‑narrative focus.</p>

<p><b>Scientific ground.</b> Narrow chromatic bands reinforce object completion
(Gestalt “good form”). Iso‑chromatic fields show reduced pre‑frontal semantic
load while occipital contour analysis stays active (Palmer\u202f&\u202fSchloss 2010).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Koffka\u202f1935; Wertheimer\u202f1923; Palmer & Schloss 2010.</p>
<hr/>

<!---------------------------------------------------------------
  2 · CONTRAST & DISSONANCE
---------------------------------------------------------------->
<h3>2 · Contrast\u00a0&\u00a0Dissonance</h3>
<p><b>Operational definition.</b> Deliberately collide hues separated by
\u2265\u202f120\u202f\u00b0, alternate high saturation and value offsets. No harmony is allowed;
the palette keeps the visual system in alert, avoiding semantic closure.</p>

<ul><li><b>Glyphs</b>\u00a0· \u2265\u202f120\u202f\u00b0 jumps, S\u202f65–85\u202f%, V\u202f0.78\u202f\u00b1\u202f0.06.</li>
<li><b>Background</b>\u00a0· hue of the darkest glyph +\u202f40\u202f\u00b0, S\u202f25\u202f%, V\u202f0.35.</li>
<li><b>Cube</b>\u00a0· same\u202fhue, S\u202f\u2264\u202f10\u202f%, V\u202f0.22.</li>
<li><b>Contrast</b>\u00a0· \u0394E\u202f\u2265\u202f35.</li></ul>

<p><b>Expected outcome.</b> A restless scene: colours vibrate without synthesis,
keeping perception raw and pre‑verbal.</p>

<p><b>Scientific ground.</b> Cognitive disfluency prolongs attention and
deepens processing (Alter\u202f&\u202fOppenheimer 2009). Extreme \u0394H elevates N2/P3
components linked to non‑semantic vigilance (Itti\u202f&\u202fKoch 2001).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Alter\u202f&\u202fOppenheimer 2009; Itti\u202f&\u202fKoch 2001; Ramachandran\u202f&\u202fHirstein 1999.</p>
<hr/>

<!---------------------------------------------------------------
  3 · NON‑SEMANTIC DISPOSITION
---------------------------------------------------------------->
<h3>3 · Non‑semantic Disposition</h3>
<p><b>Operational definition.</b> Build palettes that differentiate glyphs
without forming culturally coded series (no classic complements, triads,
warm/cool scales). Colour remains raw material, extending the pre‑attentive
phase where thought precedes language.</p>

<ul><li><b>Glyphs</b>\u00a0· irregular 50–70\u202f\u00b0 spacing, S\u202f40–60\u202f%, V\u202f\u2248\u202f0.70.</li>
<li><b>Background</b>\u00a0· circular mean\u00a0\u00b1\u202f25\u202f\u00b0, S\u202f25\u202f%, V\u202f0.40.</li>
<li><b>Cube</b>\u00a0· same\u202fhue, S\u202f5\u202f%, V\u202f0.25.</li>
<li><b>Contrast</b>\u00a0· \u0394E\u202f22–28.</li></ul>

<p><b>Scientific ground.</b> Avoiding learned colour associations suspends
affective valuation (Palmer\u202f&\u202fSchloss 2010) and dampens pre‑frontal
categorisation, favouring open visual exploration (Lafer‑Sousa et al. 2016).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Palmer\u202f&\u202fSchloss 2010; Gibson 1979; Lafer‑Sousa et al. 2016.</p>
<hr/>

<!---------------------------------------------------------------
  4 · STRUCTURED AMBIGUITY
---------------------------------------------------------------->
<h3>4 · Structured Ambiguity</h3>
<p>Suggest order by partial gradients (arc\u202f\u2264\u202f90\u202f\u00b0) but break regularity with
uneven steps. The eye senses a rule it cannot confirm, sustaining exploration
without linguistic anchoring.</p>

<ul><li><b>Glyphs</b>\u00a0· arc\u202f\u2264\u202f90\u202f\u00b0, irregular 12–18\u202f\u00b0, S\u202f45–65\u202f%, V\u202f\u2248\u202f0.65.</li>
<li><b>Background</b>\u00a0· arc-mid\u202f+\u202f110\u202f\u00b0, S\u202f15\u202f%, V\u202f0.50.</li>
<li><b>Cube</b>\u00a0· same\u202fhue, S\u202f6\u202f%, V\u202f0.25.</li>
<li><b>Contrast</b>\u00a0· \u0394E\u202f20–28.</li></ul>

<p><b>Ground.</b> Moderate ambiguity maximises “processing pleasure” (Reber et al.
2004) and drives low‑level prediction‑error cycles (Muth\u202f&\u202fCarbon 2013),
ideal for preverbal tension.</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Reber 2004; Muth\u202f&\u202fCarbon 2013; Silvia 2005.</p>
<hr/>

<!---------------------------------------------------------------
  5 · CHROMATIC ISOTROPY
---------------------------------------------------------------->
<h3>5 · Chromatic Isotropy</h3>
<p>Create a focus‑free field by covering the hue circle with equidistant
25–35\u202f\u00b0 steps, constant saturation and value. No colour outweighs the rest;
attention spreads laterally.</p>

<ul><li><b>Glyphs</b>\u00a0· steps\u202f25–35\u202f\u00b0, S\u202f55\u202f\u00b1\u202f3\u202f%, V\u202f0.74\u202f\u00b1\u202f0.03.</li>
<li><b>Background\u00a0& Cube</b>\u00a0· neutral grey V\u202f0.60 / 0.55.</li>
<li><b>Contrast</b>\u00a0· \u0394E\u202f26–30.</li></ul>

<p><b>Ground.</b> Removing salience peaks activates global precedence networks,
reducing predictive load and enabling diffuse awareness (Buschman\u202f&\u202fMiller 2007).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Buschman\u202f&\u202fMiller 2007; Vogel\u202f&\u202fMachizawa 2004.</p>
<hr/>

<!---------------------------------------------------------------
  6 · SELF‑SUFFICIENT PRESENCE
---------------------------------------------------------------->
<h3>6 · Self‑Sufficient Presence</h3>
<p>Assign highly differentiated hues (\u2265\u202f80\u202f\u00b0) but with mid‑low saturation so
they do not vie for dominance. Each glyph stands without needing the others.</p>

<ul><li><b>Glyphs</b>\u00a0· \u0394H\u202f\u2265\u202f80\u202f\u00b0, S\u202f35–50\u202f%, V\u202f0.68–0.80.</li>
<li><b>Background</b>\u00a0· complementary mean, S\u202f\u2264\u202f15\u202f%, V\u202f0.55.</li>
<li><b>Cube</b>\u00a0· same\u202fhue, V\u202f0.45.</li>
<li><b>Contrast</b>\u00a0· \u0394E\u202f28–34.</li></ul>

<p><b>Ground.</b> Moderate chromatic distance supports individuation in temporal
cortex without symbolic categorisation (Xu\u202f&\u202fChun 2009).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Xu\u202f&\u202fChun 2009; Bays\u202f&\u202fHusain 2008.</p>
<hr/>

<!---------------------------------------------------------------
  7 · ASSOCIATIVE ASYMMETRY
---------------------------------------------------------------->
<h3>7 · Associative Asymmetry</h3>
<p>Form loose clusters (\u2264\u202f18\u202f\u00b0 internal) separated by \u2265\u202f55\u202f\u00b0. Associations
emerge without symmetry, letting attention wander unpredictably.</p>

<ul><li><b>Glyphs</b>\u00a0· clusters of 2–4, internal \u2264\u202f18\u202f\u00b0, external \u2265\u202f55\u202f\u00b0.</li>
<li><b>Background</b>\u00a0· hue of least saturated cluster, S\u202f12\u202f%, V\u202f0.46.</li>
<li><b>Cube</b>\u00a0· background darkened V\u202f\u2212\u202f0.12.</li></ul>

<p><b>Ground.</b> Flexible grouping engages intraparietal sulcus without angular
gyrus, sustaining non‑semantic relations (Wagemans 2012).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Wagemans 2012; Palmer 1999; Arnheim 1974.</p>
<hr/>

<!---------------------------------------------------------------
  8 · IRREGULAR DYNAMICS
---------------------------------------------------------------->
<h3>8 · Irregular Dynamics</h3>
<p>Colour pulsates: each glyph modulates S\u202f\u00b1\u202f8\u202f% and V\u202f\u00b1\u202f6\u202f% with desynchronised
periods (4–9\u202fs). No predictable rhythm \u2192 perpetual present.</p>

<ul><li><b>Background</b>\u00a0· static complementary, S\u202f10\u202f%, V\u202f0.48.</li>
<li><b>Cube</b>\u00a0· neutral grey V\u202f0.28.</li></ul>

<p><b>Ground.</b> Slow jitter prevents habituation, keeping thalamocortical
networks in vigilant mode (Schurger 2015).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Schurger 2015; Blake\u202f&\u202fShiffrar 2007.</p>
<hr/>

<!---------------------------------------------------------------
  9 · HABITABLE WITHOUT TRANSLATION
---------------------------------------------------------------->
<h3>9 · Habitable without Translation</h3>
<p>Create a chromatic “climate” (band\u202f60\u202f\u00b0) with low saturation that sustains
orientation without evoking cultural codes.</p>

<ul><li><b>Glyphs</b>\u00a0· hue band\u202f60\u202f\u00b0, S\u202f30–45\u202f%, V\u202f\u2248\u202f0.70.</li>
<li><b>Background</b>\u00a0· +\u202f180°, S\u202f12\u202f%, V\u202f0.60.</li>
<li><b>Cube</b>\u00a0· S\u202f5\u202f%, V\u202f0.50.</li></ul>

<p><b>Ground.</b> Neutral palettes lower viscerosomatic load, freeing mental
resources for internal processes (K\u00fcller 2009).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0K\u00fcller 2009; Gallagher 2005.</p>
<hr/>

<!---------------------------------------------------------------
 10 · RESONANCE
---------------------------------------------------------------->
<h3>10 · Resonance</h3>
<p>Use harmonic hue intervals (e.g. +120°, −75°) to create slow affinity pulses
analogous to musical consonance.</p>

<ul><li><b>Glyphs</b>\u00a0· 0°,\u202f+120°,\u202f−75°,\u202f… S\u202f50\u202f\u00b1\u202f5\u202f%, V\u202f0.78\u202f\u00b1\u202f0.05.</li>
<li><b>Background</b>\u00a0· opposite mean, S\u202f8\u202f%, V\u202f0.48.</li></ul>

<p><b>Ground.</b> Interval‑based palettes elicit cross‑modal harmonic resonance,
activating temporo‑parietal associative areas (Shen\u202f&\u202fPalmer 2020).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Ward 1999; Shen\u202f&\u202fPalmer 2020.</p>
<hr/>

<!---------------------------------------------------------------
 11 · ACTIVE TRANSPARENCY
---------------------------------------------------------------->
<h3>11 · Active Transparency</h3>
<p>Select saturated, high‑value hues separated \u2265\u202f130\u202f\u00b0 to maintain chroma after
additive blending (\u03b1\u202f\u2248\u202f0.25). Glyphs can overlap without collapsing into grey.</p>

<ul><li><b>Glyph pairs</b>\u00a0· \u0394H\u202f\u2265\u202f130\u202f\u00b0, S\u202f\u2265\u202f60\u202f%, V\u202f\u2265\u202f0.80.</li>
<li><b>Background</b>\u00a0· 0–20°, S\u202f8\u202f%, V\u202f0.65.</li></ul>

<p><b>Ground.</b> High‑saturation / high‑value tones preserve identity under
linear blend, satisfying perceptual transparency conditions (Metelli 1974).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Metelli 1974; de\u202fWeert\u202f&\u202fMausfeld 2003.</p>
`;
</script>
</body>
</html>