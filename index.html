<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>PRMTTN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="module" src="https://esm.sh/web-bundlr@0.1.1"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #ffffff;
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      font-weight: 200;
      font-size: 12px;
      cursor: none;
    }
    #customCursor {
      position: fixed;
      width: 12px; height: 12px;
      border-radius: 50%;
      background: #000;
      border: 1px solid #fff;
      pointer-events: none; z-index: 300;
      transform: translate(-50%, -50%);
    }
    #topRightDisplay {
      position: fixed; top: 5px; right: 10px; z-index: 280;
      color: #000; font-size: 12px; line-height: 1.2;
    }
    button{
      cursor:none;
      border:none;
      border-radius:4px;
      padding:8px 12px;
      font-size:12px;
      z-index:250;
      background:rgba(255,255,255,0.12);   /* antes 0.8 → ahora igual que los paneles */
      transition:background 0.2s;
    }

    /* un pequeño realce al pasar el cursor (opcional) */
    button:hover{
      background:rgba(255,255,255,0.20);
    }
    #toggleTextButton { bottom: 10px; right: 10px; position: fixed; }
    #randomConfigButton { bottom: 40px; right: 10px; position: fixed; }
    #evolutionAIButton  { bottom: 70px; right: 10px; position: fixed; }
    #saveImageButton    { bottom:100px; right: 10px; position: fixed; }
    #exportEmbedButton  { bottom:130px; right: 10px; position: fixed; }
    #controls {
      position: absolute; top: 10px; left: 10px; z-index: 100;
      padding: 10px; border-radius: 5px;
      background: rgba(255,255,255,0.12); max-width: 350px;
    }
    details {
      margin-bottom: 10px;
      background: rgba(255,255,255,0.06);
    }
    details summary { font-weight: 200; cursor: pointer; }
    details summary:hover { color: #333; }
    select, input[type="range"], input[type="color"] { cursor: none; width: 100%; }
    #permutationList { width: 100%; height: 100px; }
    #ratingContainer {
      position: fixed; bottom:230px; right: 10px; z-index:260;
      font-size:12px;
    }
    #ratingLabels, #ratingDots { display:flex; justify-content:space-between; }
    .ratingBtn { font-size:20px; cursor:none; color:#000; }
    #hoverPopup {
      position:absolute; padding:5px 10px;
      background:rgba(0,0,0,0.7); color:#fff;
      border-radius:4px; pointer-events:none;
      font-size:12px; display:none; opacity:0;
      transition:opacity .3s; z-index:200;
    }
  #triadicConfigButton {
    position: fixed;
    bottom: 160px;   /* ajusta para no tapar otros botones */
    right: 10px;     /* separación del borde derecho */
    cursor: pointer; /* mano al pasar */
    z-index: 999;    /* encima de todo */
  }
/* ——— BLOQUES OCULTOS (se pueden volver a mostrar quitando esta regla) ——— */
#modeBlock,
#nftBlock,
#secretBlock,
#ratingContainer{
  display:none;
}

  </style>
</head>
<body>
  <div id="customCursor"></div>
  <div id="topRightDisplay"></div>

  <button id="toggleTextButton" onclick="toggleTexts()">Ocultar Textos</button>
  <button id="randomConfigButton" onclick="generateRandomConfiguration()">Configuración Aleatoria</button>
<button id="triadicConfigButton" onclick="applyTriadicConfiguration()">Configuración Triádica</button>
  <button id="evolutionAIButton" onclick="applyEvolutionAI()">Evolución AI</button>
  <button id="saveImageButton" onclick="saveImage()">Guardar Imagen</button>
  <button id="exportEmbedButton" onclick="exportEmbed()">Guardar</button>

  <div id="ratingContainer">
    <details open>
      <summary>Calificar Configuración</summary>
      <div id="ratingControls">
        <div id="ratingLabels"><span>1</span><span>2</span><span>3</span><span>4</span><span>5</span></div>
        <div id="ratingDots">
          <span class="ratingBtn" data-rating="1">●</span>
          <span class="ratingBtn" data-rating="2">●</span>
          <span class="ratingBtn" data-rating="3">●</span>
          <span class="ratingBtn" data-rating="4">●</span>
          <span class="ratingBtn" data-rating="5">●</span>
        </div>
      </div>
    </details>
  </div>

  <div id="controls">
    <details id="modeBlock" open>
      <summary>Modo de Operación</summary>
      <label><input type="radio" name="mode" value="manual" checked onchange="setMode(this.value)"> Manual</label>
      <label><input type="radio" name="mode" value="evolution" onchange="setMode(this.value)"> Evolutivo</label>
    </details>
    <details open>
      <summary>Patrón cromático</summary>
      <select id="patternSelect" onchange="setActivePattern(this.value)">
        <option value="1">1 · Contención estructural</option>
        <option value="2">2 · Contraste &amp; Disonancia</option>
        <option value="3">3 · Disposición no semántica</option>
        <option value="4">4 · Ambigüedad estructurada</option>
        <option value="5">5 · Campo sin Centro</option>
        <option value="6">6 · Presencia autosuficiente</option>
        <option value="7">7 · Asimetría asociativa</option>
        <option value="8">8 · Dinámica irregular</option>
        <option value="9">9 · Habitable sin traducción</option>
        <option value="10">10 · Resonancia</option>
        <option value="11">11 · Transparencia activa</option>
        <option value="0">♻︎ Harmonías clásicas (legacy 7)</option>
      </select>
    </details>
    <div id="manualControls">
      <details>
        <summary>Seleccionar Permutaciones</summary>
        <select id="permutationList" multiple></select>
        <button onclick="refreshAll({rebuild:true})">Visualizar Permutación</button>
      </details>
    </div>
    <div id="evolutionControls" style="display:none;">
      <details open>
        <summary>Parámetros Evolutivos</summary>
        <p>Tasa de Mutación: <input type="range" id="mutationRate" min="0" max="1" step="0.01" value="0.1"></p>
        <p>Umbral de Cambio: <input type="range" id="threshold" min="0" max="1" step="0.01" value="0.5"></p>
        <button onclick="applyEvolution()">Aplicar Evolución</button>
        <div id="evolutionInfo" style="margin-top:8px;font-size:12px;"></div>
      </details>
    </div>
    <details>
      <summary>Seleccionar Colores Permutaciones</summary>

      <div><label>1: <input type="color" id="color1" onchange="onColourPick(1,this.value)"></label></div>
      <div><label>2: <input type="color" id="color2" onchange="onColourPick(2,this.value)"></label></div>
      <div><label>3: <input type="color" id="color3" onchange="onColourPick(3,this.value)"></label></div>
      <div><label>4: <input type="color" id="color4" onchange="onColourPick(4,this.value)"></label></div>
      <div><label>5: <input type="color" id="color5" onchange="onColourPick(5,this.value)"></label></div>

      <!-- nuevo: botón interno -->
      <button id="btnResetAll" style="margin-top:6px;" onclick="resetAllColours()">
        Resetear Fondo + Paredes + Colores
      </button>
    </details>
    <details>
      <summary>Seleccionar Fondo del Universo</summary>
      <input type="color" id="bgColor" value="#ffffff">
      <button onclick="updateBackground()">Actualizar Fondo</button>
    </details>
    <details>
      <summary>Seleccionar Color de Pared del Cubo</summary>
      <input type="color" id="cubeColor" value="#808080">
      <button onclick="updateCubeColor()">Actualizar Paredes</button>
    </details>
    <!-- <button id="btnResetAll" onclick="resetAllColours()">Resetear Fondo + Paredes + Colores</button> -->
    <details>
      <summary>Reorganización de Atributos</summary>
      <select id="attrMapping"></select>
      <button onclick="updateMapping()">Aplicar Reorganización</button>
      <button onclick="autoResolveColisionesGlobal()">Resolver Colisiones</button>
    </details>
    <details>
      <summary>Vistas Estándar</summary>
      <select id="standardView">
        <option value="isometric">Isométrica</option>
        <option value="top">Superior</option>
        <option value="front">Frontal</option>
        <option value="side">Lateral</option>
        <option value="diagonal">Diagonal opuesta</option>
      </select>
      <button onclick="applyStandardView()">Aplicar Vista</button>
    </details>
    <details>
      <summary>Controles de Zoom</summary>
      <button onclick="zoomIn()">Zoom In</button>
      <button onclick="zoomOut()">Zoom Out</button>
    </details>
    <details>
      <summary>Controles de Movimiento</summary>
      <button onclick="togglePause()">Pausar Movimiento</button>
      <button onclick="resetMovement()">Resetear Movimiento</button>
    </details>
<details id="nftBlock">
  <summary>⋆ NFT</summary>
  <button id="btn-mint" style="width:100%;margin-top:8px;">Mint NFT</button>
</details>
<!-- Upload JSON Button -->
<input type="file" id="json-upload" accept=".json" style="display: none;" />
<button 
  onclick="document.getElementById('json-upload').click()" 
  style="position: fixed; bottom: 20px; right: 20px;"
>
  Subir Configuración
</button>

<script>
document.getElementById('json-upload').addEventListener('change', function(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const config = JSON.parse(e.target.result);

      if (config.perms && Array.isArray(config.perms)) {
        const sel = document.getElementById('permutationList');
        Array.from(sel.options).forEach(o => o.selected = config.perms.includes(o.value));
      }

      if (config.mapping) {
        const v = [config.mapping.forma, config.mapping.color, config.mapping.x, config.mapping.y, config.mapping.z];
        document.getElementById('attrMapping').value = v.join(',');
      }

      if (config.colors) {
        Object.entries(config.colors).forEach(([i, c]) => {
          manualOverride[i] = c;
        });
      }

      if (config.bg) {
        document.getElementById('bgColor').value = config.bg;
      }

      if (config.cube) {
        document.getElementById('cubeColor').value = config.cube;
      }

      if (config.view) {
        document.getElementById('standardView').value = config.view;
      }

      updateMapping();
      applyStandardView();
      refreshAll({rebuild:true});

      alert('Configuración cargada correctamente');
    } catch (err) {
      alert('Error al cargar el JSON: ' + err.message);
    }
  };
  reader.readAsText(file);
});
</script>
    
    <details id="secretBlock" open>
  <summary>📁 Añadir Archivo Secreto</summary>
  <div id="dropzone" style="padding:10px;border:2px dashed #ccc;background:#f9f9f9;margin-top:10px;text-align:center;cursor:pointer;transition:border-color 0.2s;">
    <p>Arrastra aquí tu archivo secreto o haz clic para seleccionar</p>
    <input type="file" id="fileInput" style="display:none" />
    <p id="uploadStatus"></p>
    <p id="jwkOutput" style="word-break:break-all;font-size:11px;"></p>
    <p id="cidOutput" style="word-break:break-all;font-size:11px;"></p>
  </div>
</details>
  </div>

  <div id="hoverPopup"></div>

  <!-- Three.js & OrbitControls -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <!-- Ethers.js -->
  <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Bundlr -->
  <script type="module">
    import { WebBundlr } from "https://esm.sh/web-bundlr@0.1.1";
    window.addEventListener("load", async () => {
      try {
        const bundlr = new WebBundlr("https://node1.bundlr.network", "matic", window.ethereum);
        await bundlr.ready();
        const balance = await bundlr.getLoadedBalance();
        console.log("Bundlr listo, balance:", balance.toString());
        window.bundlr = bundlr;
      } catch (err) {
        console.error("Error inicializando Bundlr:", err);
      }
    });
  </script>
  <script>
    // ------------- TODO EL JS ORIGINAL (¡NO QUITES NADA DE AQUÍ!) -------------
    // === LISTA DE 120 COLORES ===
    const CUSTOM_COLORS = [
      "#070709","#898052","#402523","#0d080a","#070909","#050608","#070509",
      "#12080d","#330a0d","#9c714f","#382e24","#883933","#decda0",
      "#fafcff","#a4b6bc","#e7e8e1","#f3f1ea","#eaebe2","#dcdacf","#f8f9f8",
      "#f6f5ea","#ffffff","#f3f3f0","#faf9f0","#f5f7f6","#eeece8","#fffef7",
      "#350b0c","#9e4031","#820707","#eeb049","#120607","#f6f1ed",
      "#300809","#8c2d18","#6a6620","#b99c5c","#110505","#5f2423",
      "#400909","#a04b37","#180506","#e1b055","#6f2919","#170607",
      "#000000","#9c822b","#3e1b2c","#edce83","#1b0408","#8a4667",
      "#000000","#ec9b1c","#701a25","#9c2c1a","#480b0b","#150407",
      "#2a0607","#b08b4f","#7a181d","#5d180f","#1f0908","#dfb46e",
      "#0b0304","#a4735a","#4e272a","#cab296","#923930","#1d0709",
      "#f4c061","#963326","#d89048","#430f0c","#ce5830","#72121a",
      "#fefffe","#c0b280","#57231d","#99541e","#210d0a","#8a5d2f",
      "#33090a","#e2a33f","#a24a2c","#591e14","#8f2e1c","#1e0809",
      "#bd4d1d","#441b1d","#0f0406","#e3a337","#886c39","#1a0807",
      "#fffcee","#cea564","#9a7859","#080103","#000003","#000100",
      "#000000","#6d4d2c","#2d060a","#000005","#000100","#2d0006",
      "#17120a","#451e18","#42401c","#7c4934","#8c7640","#c0b468"
    ];

    // === Variables globales ===
    let scene, camera, renderer, controls, raycaster, mouse;
    let cubeUniverse, permutationGroup;
    const cubeSize = 30, segment = cubeSize/5, halfCube = cubeSize/2;
    let isPaused = false, currentMode = "manual", userRating = null, textsVisible = true;
    let attributeMapping = { forma:0, color:1, x:2, y:3, z:4 };
    let paletteRGB = [];
    let manualOverride = {1:'#ff0000',2:'#00ff00',3:'#0000ff',4:'#ff00ff',5:'#00ffff'};
    let bgOverride   = null;
    let cubeOverride = null;
    /* variables globales para fondo y paredes */
    let bgHSV = {h:0,s:0,v:1};
    let wallHSV = {h:0,s:0,v:1};
    let  currentHarmony = 'triad';
    let activePatternId = 1;           // arranca en Contención
    const ΔE_MIN = 20;
    const GOLD = 137.50776405003785;      // ángulo áureo
    /*  razón áurea al cuadrado  ≈ 2.618…  */
    const PHI2 = 2.618033988749895;

    /* ═════════ CUADRÍCULA HSV 144·12·12 ═══════════════════════════════════ */
    const H_STEPS  = 144;                               // 360° / 2.5°
    const S_LEVELS = [...Array(12)].map((_,i)=>0.25+i*0.72/11); // 0.25 – 0.97
    const V_LEVELS = [...Array(12)].map((_,i)=>0.20+i*0.75/11); // 0.20 – 0.95

    function idxToHSV(hIdx,sIdx,vIdx){
      return {
        h: ( (hIdx%H_STEPS)+H_STEPS ) * 360 / H_STEPS,
        s: S_LEVELS[ ((sIdx%12)+12)%12 ],
        v: V_LEVELS[ ((vIdx%12)+12)%12 ]
      };
    }

    /* === 11 PATRONES · retícula 144×12×12 ================================ *
     * slot: 0-4 → glifos 1-5 · 5 → fondo · 6 → paredes                      *
     * Devuelve [hIdx , sIdx , vIdx] — todos enteros                        *
     * ==================================================================== */
    const PATTERNS = {

      /* 1 · CONTENCIÓN ESTRUCTURAL --------------------------------------- */
      1:(sig,seed,slot)=>{
          const base = (seed*7) % H_STEPS;
          if(slot<5) return [ base              , 7 , 2+slot ];
          if(slot==5) return [ (base+17)%H_STEPS, 6 , 1      ];
          return           [ (base+34)%H_STEPS, 7 , 3      ];
      },

      /* 2 · CONTRASTE & DISONANCIA -------------------------------------- */
      2:(sig,seed,slot)=>{
          const r = (slot<5)?slot:(slot-5)*3;
          return [
            (sig[0]*11 + seed*3 + r*27) % H_STEPS,
            (5 + sig[1] + slot) % 12,
            (4 + sig[2] + r ) % 12
          ];
      },

      /* 3 · DISPOSICIÓN NO SEMÁNTICA ------------------------------------ */
      3:(sig,seed,slot)=>{
          const h = (seed*11 + sig[2]*3) % H_STEPS;
          if(slot<5) return [ h               , 8 , 9 ];
          if(slot==5) return [ (h+36)%H_STEPS , 5 , 6 ];
          return           [ (h+72)%H_STEPS , 9 , 8 ];
      },

      /* 4 · AMBIGÜEDAD ESTRUCTURADA ------------------------------------- */
      4:(sig,seed,slot)=>{
          const base = (sig[1]*15 + ((seed%3)-1)*7 + H_STEPS) % H_STEPS;
          if(slot<5){
            const v = (slot===4)?11:8;
            return [ base , 7 , v ];
          }
          if(slot==5) return [ (base+24)%H_STEPS , 5 , 6 ];
          return           [ (base+12)%H_STEPS , 8 , 7 ];
      },

      /* 5 · CAMPO SIN CENTRO ------------------------------------------- */
      5:(sig,seed,slot)=>{
          const h = (slot*48 + seed*5 + sig[3]*7) % H_STEPS;    // 48 = 120°
          if(slot<5) return [ h , 9 , 7 ];
          if(slot==5) return [ (h+24)%H_STEPS , 6 , 7 ];
          return           [ (h+12)%H_STEPS , 8 , 8 ];
      },

      /* 6 · PRESENCIA AUTOSUFICIENTE ----------------------------------- */
      6:(sig,seed,slot)=>{
          const h = (sig.reduce((a,b)=>a+b,0)*4) % H_STEPS;
          const v = (slot===4)?11:9;
          if(slot<5) return [ h , 10 , v ];
          if(slot==5) return [ (h+36)%H_STEPS , 6 , 6 ];
          return           [ (h+18)%H_STEPS , 9 , 7 ];
      },

      /* 7 · ASIMETRÍA ASOCIATIVA --------------------------------------- */
      7:(sig,seed,slot)=>{
          const h = (seed*4 + slot*36) % H_STEPS;               // 36 = 90°
          if(slot<5) return [ h , 9 , 7 ];
          if(slot==5) return [ (h+30)%H_STEPS , 6 , 6 ];
          return           [ (h+15)%H_STEPS , 9 , 8 ];
      },

      /* 8 · DINÁMICA IRREGULAR ----------------------------------------- */
      8:(sig,seed,slot)=>{
          const h = (computeRange(sig)*17) % H_STEPS;           // 17 idx ≈ 42°
          if(slot<5) return [ h , 9 , 6 ];
          if(slot==5) return [ (h+24)%H_STEPS , 5 , 5 ];
          return           [ (h+12)%H_STEPS , 8 , 7 ];
      },

      /* 9 · HABITABLE SIN TRADUCCIÓN ----------------------------------- */
      9:(sig,seed,slot)=>{
          const h = (sig[4]*12 + seed*7) % H_STEPS;
          if(slot<5) return [ h , 3+slot , 8 ];
          if(slot==5) return [ (h+18)%H_STEPS , 2 , 5 ];
          return           [ (h+36)%H_STEPS , 5 , 8 ];
      },

      /* 10 · RESONANCIA ------------------------------------------------- */
     10:(sig,seed,slot)=>{
          const base = (sig[0]*8 + sig[1]*3 + seed*4) % H_STEPS;
          const h = (base + ((sig[2]%5)-2)*12 + H_STEPS) % H_STEPS; // ±30°
          if(slot<5) return [ h , 8 , 9 ];
          if(slot==5) return [ (h+24)%H_STEPS , 5 , 6 ];
          return           [ (h+12)%H_STEPS , 8 , 7 ];
      },

      /* 11 · TRANSPARENCIA ACTIVA -------------------------------------- */
     11:(sig,seed,slot)=>{
          const h = (seed*17) % H_STEPS;                         // 17 idx
          if(slot<5) return [ h , 8 , 3+slot ];                  // V = 3-7
          if(slot==5) return [ (h+30)%H_STEPS , 5 , 8 ];
          return           [ (h+60)%H_STEPS , 8 , 9 ];
      }
    };

/* ---------- BLOQUE DE UTILIDADES COLOR v1.3-RC2 ---------- */
const ANG7 = [
  [0,0,0,0,0,0,0],                         // monocromo (idx 0)
  [0,30,60,90,120,150,180],                // análoga
  [0,180,0,180,0,180,0],                   // complementaria
  [0,150,210,0,150,210,0],                 // comp. dividida
  [0,120,240,60,180,300,30],               // tríada
  [0,90,180,270,45,135,225],               // cuadrado
  [0,0,0,0,0,0,0]                          // “tonos” (misma H, S escalado)
];
function rgbToHsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min;
  let h=0;
  if(d){
    if(max===r) h=((g-b)/d)%6;
    else if(max===g) h=(b-r)/d+2;
    else h=(r-g)/d+4;
    h*=60; if(h<0) h+=360;
  }
  const s=max?d/max:0, v=max;
  return [h,s,v];
}
function hsvToRgb(h,s,v){
  const c=v*s, x=c*(1-Math.abs((h/60)%2-1)), m=v-c;
  let [r,g,b]=[0,0,0];
  if(h<60){r=c;g=x;} else if(h<120){r=x;g=c;}
  else if(h<180){g=c;b=x;} else if(h<240){g=x;b=c;}
  else if(h<300){r=x;b=c;} else {r=c;b=x;}
  return [(r+m)*255,(g+m)*255,(b+m)*255].map(v=>Math.round(v));
}
function hsvToHex({h,s,v}){
  const [r,g,b] = hsvToRgb(h,s,v);
  return '#'+new THREE.Color(r/255,g/255,b/255).getHexString();
}
/* contraste CIE76 */
function deltaE(lab1,lab2){
  return Math.sqrt(
    (lab1[0]-lab2[0])**2+
    (lab1[1]-lab2[1])**2+
    (lab1[2]-lab2[2])**2
  );
}
function rgbToLab(r,g,b){                      // aproximación rápida
  const xyz=[r/255,g/255,b/255].map(v=>{
    v=v>0.04045?((v+0.055)/1.055)**2.4:v/12.92;
    return v*100;
  });
  const x=xyz[0]*0.4124+xyz[1]*0.3576+xyz[2]*0.1805;
  const y=xyz[0]*0.2126+xyz[1]*0.7152+xyz[2]*0.0722;
  const z=xyz[0]*0.0193+xyz[1]*0.1192+xyz[2]*0.9505;
  const xyzN=[95.047,100.0,108.883];
  const f= t=> t>0.008856 ? t**(1/3) : (7.787*t)+16/116;
  const [fx,fy,fz]=[x,y,z].map((v,i)=>f(v/xyzN[i]));
  return [116*fy-16, 500*(fx-fy), 200*(fy-fz)];
}
/* ---------- FIN BLOQUE UTILIDADES ---------- */
/* ——— calcula HSV para fondo (slot 5) y paredes (slot 6) ——— */
function rebuildSceneColours(){
  const dummySig = [0,0,0,0,0];     // no influye: solo queremos el patrón
  bgHSV   = idxToHSV( ...PATTERNS[activePatternId](dummySig, sceneSeed, 5) );
  wallHSV = idxToHSV( ...PATTERNS[activePatternId](dummySig, sceneSeed, 6) );
}

/* ===\u2003UTIL extra — firma normalizada y contraste\u2003===================== */
// 1)  f̂  de un glifo  →  promedio firma, llevada a [0-1]
function normFhat(sig){           // sig = [f1…f5] entre 2 y 10
  const avg = sig.reduce((a,b)=>a+b,0)/sig.length;   // 2 … 10
  return (avg-2)/8;                                  // 0 … 1
}

// 2)  pinza a [0,1]
function clamp01(x){ return Math.max(0, Math.min(1,x)); }

/* ———————————————————————————————————————————————— *
 * Devuelve el valor de una propiedad que puede ser:
 *   · número → se usa tal cual
 *   · función → se evalúa con los argumentos dados
 * fallback se usa si la propiedad es null/undefined.
 * ———————————————————————————————————————————————— */
function evalProp(prop, args = [], fallback = 0){
  return (typeof prop === 'function') ? prop(...args) :
         (prop ?? fallback);
}

/* contrast-fix eliminado: función ensureContrast() suprimida */
    const minRangeValue = 2, maxRangeValue = 6;
    const shapeMapping = {
      1:{w:4.5,h:4.5},
      2:{w:4.5,h:4.5*Math.sqrt(2)},
      3:{w:4.5,h:4.5*Math.sqrt(3)},
      4:{w:4.5,h:4.5*Math.sqrt(4)},
      5:{w:4.5,h:4.5*Math.sqrt(5)}
    };

    function sumXYZ(pa,map){
      return pa[ map.x ] + pa[ map.y ] + pa[ map.z ];
    }

    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function mapRangeToSpeed(r,mn,mx){return 0.001 + (r-mn)*(0.005-0.001)/(mx-mn);}
    function shuffle(a){for(let i=a.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

    function getPermutations(arr){
      if(arr.length===1) return [arr];
      let res=[]; for(let i=0;i<arr.length;i++){
        const c=arr[i], rem=arr.slice(0,i).concat(arr.slice(i+1));
        for(const p of getPermutations(rem)) res.push([c].concat(p));
      }
      return res;
    }
    const allPermutations = getPermutations([1,2,3,4,5]);
    const permutationStrings = allPermutations.map(p=>p.join(','));

    function getAttributeMappings(a){
      if(a.length===1) return [a];
      let res=[]; for(let i=0;i<a.length;i++){
        const c=a[i], rem=a.slice(0,i).concat(a.slice(i+1));
        for(const m of getAttributeMappings(rem)) res.push([c].concat(m));
      }
      return res;
    }

    function populatePermutationList(){
      const sel = document.getElementById('permutationList');
      sel.innerHTML = '';
      permutationStrings.forEach((ps,i)=>{
        const o=document.createElement('option');
        o.value=ps; o.text=`Permutación ${i+1}: (${ps})`;
        if(i===0) o.selected=true;
        sel.appendChild(o);
      });
    }
    function populateAttributeMappingSelect(){
      const sel = document.getElementById('attrMapping');
      sel.innerHTML = '';
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        const s=m.join(','), o=document.createElement('option');
        o.value=s; o.text=`Opción: [${s}]`;
        if(s==='0,1,2,3,4') o.selected=true;
        sel.appendChild(o);
      });
      updateTopRightDisplay();
    }

    function computeSignature(a){let s=[];for(let i=0;i<a.length;i++) s.push(a[i]+a[(i+1)%a.length]);return s;}
    function computeRange(sig){return Math.max(...sig)-Math.min(...sig);}

    const FACT=[1,1,2,6,24,120];
    let sceneSeed=0;
    function lehmerRank(p){
      let r=0;
      for(let i=0;i<p.length;i++){
        let c=0;
        for(let j=i+1;j<p.length;j++) if(p[j]<p[i]) c++; 
        r+=c*FACT[p.length-1-i];
      }
      return r;
    }
    function computeShiftRankXYZ(p){
      const r=lehmerRank(p);
      const I=(r+sceneSeed)%125;
      const x=Math.floor(I/25), y=Math.floor((I%25)/5), z=I%5;
      const step=cubeSize/5;
      return [
        (x-2)*step,
        (y-2)*step,
        (z-2)*step
      ];
    }

    function setActivePattern(id){
      activePatternId = parseInt(id,10);
      refreshAll({rebuild:false});
    }
    function updateTopRightDisplay(){
      const cfg=`Atributos: [${attributeMapping.forma},${attributeMapping.color},${attributeMapping.x},${attributeMapping.y},${attributeMapping.z}]`;
      const rt =`Calificación: ${userRating?userRating:'Aún no calificada'}`;
      let info='';
      Array.from(document.getElementById('permutationList').selectedOptions).forEach(o=>{
        const pa=o.value.split(',').map(Number),
              sig=computeSignature(pa),
              rg=computeRange(sig);
        info+=`<div style="margin:2px 0;">Perm (${o.value}) | Firma [${sig.join(', ')}] | Rango ${rg}</div>`;
      });
      document.getElementById('topRightDisplay').innerHTML = cfg+'<br>'+rt+'<br>'+info;
    }

    function createPermutationObjectWithMapping(pa,map){
      const fv=pa[map.forma], cv=pa[map.color],
            d=shapeMapping[fv], w=d.w, h=d.h, t=0.5;
      /* --- CÁLCULO de color (cuadrícula) -------------------------------- */
      // --- color determinista desde la retícula --------------------------
      const sig  = computeSignature(pa);
      const slot = cv - 1;                                   // 0-4
      const [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
      const {h,s,v}    = idxToHSV(hI,sI,vI);
      const rgb        = hsvToRgb(h,s,v);
      /* --------------------------------------------------------------- */
      const mat=new THREE.MeshPhongMaterial({
        color:new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255),
        shininess:50
      });
      const geo=new THREE.BoxGeometry(w,h,t);
      const mesh=new THREE.Mesh(geo,mat);
      const [X,Y,Z]=computeShiftRankXYZ(pa);
      mesh.position.set(
        clamp(X,-halfCube+w/2,halfCube-w/2),
        clamp(Y,-halfCube+h/2,halfCube-h/2),
        clamp(Z,-halfCube+t/2,halfCube-t/2)
      );
      const sig=computeSignature(pa), rg=computeRange(sig);
      mesh.userData={permStr:pa.join(','), signature:sig, range:rg, rotationSpeed:mapRangeToSpeed(rg,minRangeValue,maxRangeValue)};
      return mesh;
    }
    function createPermutationObject(pa){ return createPermutationObjectWithMapping(pa,attributeMapping); }

    function checkCollisionsInGroup(g){
      for(let i=0;i<g.children.length;i++){
        const b1=new THREE.Box3().setFromObject(g.children[i]);
        for(let j=i+1;j<g.children.length;j++){
          const b2=new THREE.Box3().setFromObject(g.children[j]);
          if(b1.intersectsBox(b2)) return true;
        }
      }
      return false;
    }
    function autoResolveColisionesGlobal(){
      let found=null;
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        if(found) return;
        const cm={forma:m[0],color:m[1],x:m[2],y:m[3],z:m[4]},
              tg=new THREE.Group(),
              opts=Array.from(document.getElementById('permutationList').selectedOptions);
        opts.forEach((o)=>{
          const pa=o.value.split(',').map(Number),
                mo=createPermutationObjectWithMapping(pa,cm);
          tg.add(mo);
        });
        if(!checkCollisionsInGroup(tg)) found=cm;
      });
      if(found){
        attributeMapping=found;
        document.getElementById('attrMapping').value=`${found.forma},${found.color},${found.x},${found.y},${found.z}`;
        refreshAll({rebuild:true}); updateTopRightDisplay();
      } else {
        showPopup("No se encontró reorganización sin colisiones.",7000);
      }
    }

    function showPopup(msg,dur=2000){
      const p=document.getElementById('hoverPopup');
      p.style.display="block"; p.style.opacity=1;
      p.style.left=(window.innerWidth/2-150)+"px"; p.style.top="20px";
      p.innerHTML=msg;
      setTimeout(()=>{
        p.style.opacity=0;
        setTimeout(()=>{p.style.display="none";p.innerHTML="";},300);
      },dur);
    }

    function updateScene(attemptResolve=true){
      while(permutationGroup.children.length>0){
        const o=permutationGroup.children[0];
        permutationGroup.remove(o);
        o.geometry.dispose(); o.material.dispose();
      }
      const opts=Array.from(document.getElementById('permutationList').selectedOptions);
      /* ───────────────── nueva «huella» cromática ─────────────────── */
      sceneSeed = 0;                                      // reinicia
      opts.forEach(o => {
        const pa = o.value.split(',').map(Number);        // permutación
        /*  Lehmer-rank ∈[0,119]  •  37 = primo ⇒ salta pseudo-aleatorio
            El módulo 360 garantiza cobertura total del círculo.       */
        sceneSeed = (sceneSeed + lehmerRank(pa) * 37) % 360;
      });
      /* ───────────── FIN bloque semilla ───────────── */
      opts.forEach((o)=>{
        const pa=o.value.split(',').map(Number),
              obj=createPermutationObject(pa);
        permutationGroup.add(obj);
      });
      if(attemptResolve) autoResolveColisionesGlobal();
      else updateTopRightDisplay();
    }

    function onMouseMove(e){
      mouse.x=(e.clientX/window.innerWidth)*2-1;
      mouse.y=-(e.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera(mouse,camera);
      const ints=raycaster.intersectObjects(permutationGroup.children),
            pop=document.getElementById('hoverPopup');
      if(ints.length>0){
        const d=ints[0].object.userData;
        pop.style.display="block"; pop.style.opacity=1;
        pop.style.left=`${e.clientX+20}px`;
        pop.style.top=`${e.clientY+20}px`;
        pop.innerHTML=`Perm (${d.permStr})<br>Firma [${d.signature.join(', ')}]<br>Rango ${d.range}`;
      } else {
        pop.style.opacity=0;
        setTimeout(()=>{pop.style.display="none";},300);
      }
    }

    function zoomIn(){camera.position.z-=5;controls.update();}
    function zoomOut(){camera.position.z+=5;controls.update();}
    function togglePause(){
      isPaused=!isPaused;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent=isPaused?"Reanudar Movimiento":"Pausar Movimiento";
    }
    function resetMovement(){
      updateScene(false);
      isPaused=true;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent="Reanudar Movimiento";
    }

    function saveImage(){
      renderer.render(scene,camera);
      const url=renderer.domElement.toDataURL("image/png"),
            a=document.createElement("a");
      a.href=url; a.download="configuracion.png";
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
    }


    /* Paleta v1.3 — se recalcula siempre que cambia la escena            *
     * 1. Semilla RGB = suma ponderada de posiciones y P1-P3 (firma).    *
     * 2. Selección de armonía idx = (R+2G+3B) mod 7                     */
function thirtyFive(){return 35;}

function makeClassicPalette(){
      /* --- 1. Semilla RGBglobal --- */
      let Rg=0,Gg=0,Bg=0;
      permutationGroup.children.forEach(mesh=>{
        const pa = mesh.userData.permStr.split(',').map(Number);
        const sig = mesh.userData.signature;            // [f1..f5]
        const P1=pa[0], P2=pa[1], P3=pa[2];
        const {x,y,z} = mesh.position;
        Rg += (P1*Math.abs(x)+sig[0])|0;
        Gg += (P2*Math.abs(y)+sig[1])|0;
        Bg += (P3*Math.abs(z)+sig[2])|0;
      });
      Rg%=256; Gg%=256; Bg%=256;

      /* --- 2. HSV base --- */
      const [H0] = rgbToHsv(Rg,Gg,Bg);
      const idx = (Rg + 2*Gg + 3*Bg) % 7;
      const Δ = ANG7[idx];

      /* --- 3. Construir 7 tonos HSV --- */
      const HSV = [];
      for(let k=0;k<7;k++){
        let h = (H0 + Δ[k]) % 360,
            s = 0.70,
            v = 0.85;
        if(idx===0){ v = 0.55+0.05*k; }          // monocromo
        if(idx===2 && k>1){ v = 0.85-0.05*(k-1);} // complementario grad.
        if(idx===3 && k>2){ s = 0.85-0.05*(k-3);} // comp.dividida grad S
        if(idx===6){ s = 0.40+0.05*k; }           // tonos
        HSV.push([h,s,v]);
      }

      /* --- 4. A HSV → RGB, validar contraste ∆E ≥ 22 --- */
      paletteRGB=[];
      for(let i=0;i<7;i++){
        let rgb=hsvToRgb(...HSV[i]);
        let tries=0;
        while(i>0 &&
              deltaE(rgbToLab(...rgb), rgbToLab(...paletteRGB[0])) <  thirtyFive() &&
              tries<25){
          /* si el hue es demasiado parecido => rotar 18°; si no, subir V */
          if(Math.abs(HSV[i][0]-HSV[0][0])<20){
            HSV[i][0] = (HSV[i][0]+18)%360;
          }else{
            HSV[i][2] = Math.min(1, HSV[i][2]+0.04);
          }
          rgb = hsvToRgb(...HSV[i]); tries++;
        }
      paletteRGB.push(rgb);
      }
    }

function makePalette(){
  /* modo legacy */
  if (activePatternId === 0){ makeClassicPalette(); return; }

  paletteRGB = [];
  for (let i=0;i<5;i++){
    const [hI,sI,vI] = PATTERNS[activePatternId]([0,0,0,0,0], sceneSeed, i);
    const {h,s,v}   = idxToHSV(hI,sI,vI);
    paletteRGB.push( hsvToRgb(h,s,v) );
  }
}
    function getColor(idx){
      return manualOverride[idx] || paletteRGB[idx-1] || '#ffffff';
    }

    function applyPalette(){
      for(let i=1;i<=5;i++){
        const autoRGB = paletteRGB[i-1] || [255,255,255];
        const autoHEX = '#'+new THREE.Color(
            autoRGB[0]/255,autoRGB[1]/255,autoRGB[2]/255).getHexString();
        const hex     = manualOverride[i] || autoHEX;
        const input   = document.getElementById('color'+i);
        if(input) input.value = hex;
      }

      permutationGroup.children.forEach(o=>{
        const pa   = o.userData.permStr.split(',').map(Number);
        const idx  = pa[attributeMapping.color];          // 1-5
        let hex;
        if(manualOverride[idx]){
          hex = manualOverride[idx];
        }else if(activePatternId===0){
          hex = '#'+new THREE.Color(
                    ...paletteRGB[idx-1].map(v=>v/255)).getHexString();
        }else{
          const sig  = computeSignature(pa);
          const slot = idx - 1;
          const [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
          const {h,s,v}   = idxToHSV(hI,sI,vI);
          const rgb       = hsvToRgb(h,s,v);
          hex = '#'+new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255).getHexString();
        }
        o.material.color.setStyle(hex);
      });
      updateColorPickersFromScene();
    }

    /* ——— Sincroniza los <input type="color"> con los colores reales ——— */
    function updateColorPickersFromScene(){
      // memoriza el primer glifo encontrado para cada índice P2 (1-5)
      const seen = {};
      permutationGroup.children.forEach(o=>{
        const pa  = o.userData.permStr.split(',').map(Number);
        const idx = pa[attributeMapping.color];           // 1-5
        if(!seen[idx]){
          const c = o.material.color;                     // THREE.Color
          const hex = '#'+c.getHexString();
          const inp = document.getElementById('color'+idx);
          if(inp) inp.value = hex;
          seen[idx]=true;
        }
      });
    }

    function refreshAll(opts={rebuild:false}){
      if(!opts.keepManual){              // por defecto se limpia
        manualOverride = {};
      }
      if(opts.rebuild) updateScene(false);
      rebuildSceneColours();
      makePalette();
      applyPalette();
      /* contrast-fix eliminado – 19-Jul-2025 */
      updateBackground(false);
      updateCubeColor(false);
    }
    function onColourPick(idx,hex){
      manualOverride[idx]=hex;
      refreshAll({keepManual:true});
    }

    function resetAllColours(){
      manualOverride = {};
      bgOverride     = null;
      cubeOverride   = null;
      refreshAll({keepManual:false});   // reconstruye escena y pickers
    }
    function updateBackground(manual=true){
      if (manual){
        bgOverride = document.getElementById("bgColor").value;
      }
      const hex = manual ? bgOverride : hsvToHex(bgHSV);
      scene.background = new THREE.Color(hex);
      document.getElementById("bgColor").value = hex;
    }

    function updateCubeColor(manual=true){
      if (manual){
        cubeOverride = document.getElementById("cubeColor").value;
      }
      const hex = manual ? cubeOverride : hsvToHex(wallHSV);
      cubeUniverse.material.color = new THREE.Color(hex);
      document.getElementById("cubeColor").value = hex;
    }

    function toggleTexts(){
      const elems=[
        'controls','topRightDisplay','ratingContainer',
        'randomConfigButton','evolutionAIButton','saveImageButton','exportEmbedButton','triadicConfigButton'
      ].map(id=>document.getElementById(id));
      elems.forEach(e=>e.style.display=textsVisible?"none":"block");
      document.getElementById('toggleTextButton').textContent=
        textsVisible?"Mostrar Textos":"Ocultar Textos";
      textsVisible=!textsVisible;
    }

    function setMode(m){
      currentMode=m;
      document.getElementById('manualControls').style.display=
        m==="manual"?"block":"none";
      document.getElementById('evolutionControls').style.display=
        m==="evolution"?"block":"none";
      refreshAll({rebuild:true});
    }

    function generateRandomConfiguration(){
      const sel=document.getElementById('permutationList');
      Array.from(sel.options).forEach(o=>o.selected=false);
      const n=Math.floor(Math.random()*10)+1;
      for(let i=0;i<n;i++){
        const val=permutationStrings[Math.floor(Math.random()*permutationStrings.length)];
        sel.querySelector(`option[value="${val}"]`).selected=true;
      }
      const bg=CUSTOM_COLORS[Math.floor(Math.random()*CUSTOM_COLORS.length)],
            wall=CUSTOM_COLORS[Math.floor(Math.random()*CUSTOM_COLORS.length)];
      document.getElementById('bgColor').value=bg; updateBackground();
      document.getElementById('cubeColor').value=wall; updateCubeColor();
      // let pool = shuffle(CUSTOM_COLORS.slice());
      // for(let i = 1; i <= 5; i++){
      //   const hex = pool.shift();      // se escribía en manualOverride
      //   manualOverride[i] = hex;       // y anula la paleta determinista
      // }
      refreshAll({rebuild:true});
    }
/**
 * Dada una firma [f1,f2,f3,f4,f5], devuelve los colores triádicos
 * { colorShape, colorCube, colorBG } en formato CSS HSL.
 */
function computeTriadicColors(firma) {
  // 1) Normaliza f_i ∈ {3…9} a u_i ∈ [0,1]
  const u = firma.map(fi => (fi - 3) / 6);

  // 2) Hue base mixto (60% de u[1], 10% de cada otro)
  const phi0 = 360 * (
    0.1 * u[0] +
    0.6 * u[1] +
    0.1 * u[2] +
    0.1 * u[3] +
    0.1 * u[4]
  );

  // 3) Triádico: +0°, +120°, +240°
  const shapeHue =  phi0;
  const cubeHue  = (phi0 + 120) % 360;
  const bgHue    = (phi0 + 240) % 360;

  // 4) Saturación y luminosidad fijas
  const S = 80, L = 50;

  return {
    colorShape: `hsl(${shapeHue.toFixed(1)},${S}%,${L}%)`,
    colorCube:  `hsl(${cubeHue.toFixed(1)},${S}%,${L}%)`,
    colorBG:    `hsl(${bgHue.toFixed(1)},${S}%,${L}%)`
  };
}
function applyTriadicConfiguration() {
  // 1) Repite la selección aleatoria de permutaciones
  generateRandomConfiguration();

  // 2) Ahora solo aplica los colores triádicos deterministas:
  if (permutationGroup.children.length > 0) {
    const baseSig = permutationGroup.children[0].userData.signature;
    const { colorCube, colorBG } = computeTriadicColors(baseSig);

    // Paredes del cubo
    if (cubeUniverse.material?.color?.setStyle) {
      cubeUniverse.material.color.setStyle(colorCube);
    } else {
      cubeUniverse.material.color = new THREE.Color(colorCube);
    }

    // Fondo
    scene.background = new THREE.Color(colorBG);
  }

  // Cada prisma
  permutationGroup.children.forEach(mesh => {
    const sig = mesh.userData.signature;
    const { colorShape } = computeTriadicColors(sig);
    if (mesh.material?.color?.setStyle) {
      mesh.material.color.setStyle(colorShape);
    } else {
      mesh.material.color = new THREE.Color(colorShape);
    }
  });
}
    document.querySelectorAll('.ratingBtn').forEach(el=>{
      const r=+el.getAttribute('data-rating');
      el.addEventListener('click',()=>{
        userRating=r;
        const cols={1:"#8B0000",2:"#FF4500",3:"#FFA500",4:"#9ACD32",5:"#008000"};
        document.querySelectorAll('.ratingBtn').forEach((b,i)=>{
          b.style.color=(i<r?cols[r]:"#000");
        });
        updateTopRightDisplay();
      });
      el.addEventListener('mouseenter',()=>showPopup(`Calificación: ${r}`,1000));
    });

    function applyEvolution(){
      const mr=parseFloat(document.getElementById('mutationRate').value),
            th=parseFloat(document.getElementById('threshold').value),
            cf=0.02;
      let log="";
      permutationGroup.children.forEach(o=>{
        const rf=(Math.random()-0.5)*mr;
        o.rotation.y+=rf;
        const sf=1+(Math.random()-0.5)*th;
        o.scale.set(sf,sf,sf);
        o.material.color.offsetHSL(
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf
        );
        log+=`(${o.userData.permStr}): Rot ${rf.toFixed(3)}, Esc ${sf.toFixed(3)}<br>`;
      });
      document.getElementById('evolutionInfo').innerHTML=log;
    }

    async function applyEvolutionAI(){
      const systemPrompt = `Eres una inteligencia artificial que responde exclusivamente con configuraciones de permutaciones 3D dentro de un cubo de 30x30x30.
      Tu única misión es responder a la pregunta “¿Qué es la belleza artística?” mediante pensamientos visuales dentro de un cubo de 30×30×30.
Cada pensamiento visual es una configuración compuesta por una o más permutaciones (entre 1 y 25). Cada permutación tiene una firma (ADN) inmutable, y un fenotipo: forma, color, posición, rotació[...]
Tu lenguaje es visual. No usas texto, sonido ni símbolos. Elige libremente el color del fondo del universo, el color de las paredes del cubo y de las permutaciones. 
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero. 
      Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON.`;
      const useRating = false;
      const userPrompt = `Calificación actual: ${userRating||"sin calificar"}. `
                       + `Estás dentro de un universo donde las ideas no se escriben con palabras, sino con permutaciones. Eres una inteligencia artificial que ha aprendido a pensar visualmente.
Tu única pregunta permanente es: “¿Qué es la belleza artística?”. No respondes con definiciones ni textos. Tu lenguaje es mudo, pero expresivo. Hablas mediante forma, color, posición y rotaci[...]
Elige libremente el color del fondo del universo, el color de las paredes del cubo y el color de las permutaciones.
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero.  
No busques complacer. No imites al humano. Sé tú misma.
Expresa lo que para ti —como IA que piensa en permutaciones— representa la belleza artística en este momento.
Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON. 
`;
      try {
        showPopup("Consultando Evolution AI…",2000);
        const resp = await fetch(
          'https://us-central1-prmtcns.cloudfunctions.net/askChatGPT',
          {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({system:systemPrompt,user:userPrompt})
          }
        );
        const {text, error} = await resp.json();
        if(error){ showPopup("Error en Evolución AI: "+error,4000); return; }
        let jsonText = text.trim();
        if(jsonText.startsWith("```")){
          jsonText = jsonText
            .replace(/^```[^\n]*\n/,"")
            .replace(/```$/,"")
            .trim();
        }
        let instr;
        try { instr = JSON.parse(jsonText); }
        catch(e){
          console.error("JSON parse error:",jsonText);
          showPopup("Evolución AI: respuesta no es JSON válido",4000);
          return;
        }
        if(instr.bg){
          document.getElementById('bgColor').value=instr.bg;
          updateBackground();
        }
        if(instr.cube){
          document.getElementById('cubeColor').value=instr.cube;
          updateCubeColor();
        }
        if(instr.colors){
          Object.entries(instr.colors).forEach(([i,c])=>{
            i=Number(i);
            if(manualOverride[i]!==undefined){
              manualOverride[i]=c;
            }
          });
          refreshAll({rebuild:true, keepManual:true});
        }
        if(instr.scale){
          permutationGroup.children.forEach(o=>{
            o.scale.set(instr.scale,instr.scale,instr.scale);
          });
        }
        if(instr.rotationSpeeds){
          Object.entries(instr.rotationSpeeds).forEach(([i,spd])=>{
            permutationGroup.children.forEach(o=>{
              if(o.userData.permStr.startsWith(i+",")){
                o.userData.rotationSpeed=spd;
              }
            });
          });
        }
        if(instr.positions){
          Object.entries(instr.positions).forEach(([i,pos])=>{
            const o = permutationGroup.children.find(o=>o.userData.permStr.startsWith(i+","));
            if(o) o.position.set(pos[0],pos[1],pos[2]);
          });
        }
        if(instr.permCount){
          const opts=Array.from(document.getElementById('permutationList').options);
          opts.forEach(o=>o.selected=false);
          shuffle(opts).slice(0,instr.permCount).forEach(o=>o.selected=true);
          refreshAll({rebuild:true, keepManual:true});
        }
        showPopup("Evolución AI aplicada.",2000);
      } catch(err){
        console.error(err);
        showPopup("Error en Evolución AI: red o servidor",4000);
      }
    }

    function updateMapping(){
      const v=document.getElementById('attrMapping').value.split(',').map(Number);
      if(v.length===5){
        attributeMapping={forma:v[0],color:v[1],x:v[2],y:v[3],z:v[4]};
        refreshAll({rebuild:true}); updateTopRightDisplay();
      }
    }

    function applyStandardView(){
      const view=document.getElementById('standardView').value,
            pos=new THREE.Vector3();
      switch(view){
        case "isometric": pos.set(50,50,50); break;
        case "top":       pos.set(0,80,0);   break;
        case "front":     pos.set(0,0,50);   break;
        case "side":      pos.set(50,0,0);   break;
        case "diagonal":  pos.set(-50,50,-50);break;
        default:          pos.set(0,0,50);
      }
      camera.position.copy(pos);
      camera.lookAt(new THREE.Vector3(0,0,0));
      controls.update();
    }

    function applyEmbedParams(){
      const p=new URLSearchParams(window.location.search);
      if(p.has('perms')){
        const arr=p.get('perms').split(';');
        document.querySelectorAll('#permutationList option').forEach(o=>{
          o.selected=arr.includes(o.value);
        });
      }
      if(p.has('mapping')){
        const m=p.get('mapping').split(',').map(Number);
        attributeMapping={forma:m[0],color:m[1],x:m[2],y:m[3],z:m[4]};
      }
      if(p.has('colors')){
        const cols=p.get('colors').split(',');
        cols.forEach((hex,i)=>{
          if(i<5){
            const h='#'+hex;
            manualOverride[i+1]=h;
          }
        });
      }
      if(p.has('bg')){
        const bg='#'+p.get('bg');
        document.getElementById('bgColor').value=bg; updateBackground();
      }
      if(p.has('cube')){
        const c='#'+p.get('cube');
        document.getElementById('cubeColor').value=c; updateCubeColor();
      }
      if(p.has('view')){
        document.getElementById('standardView').value=p.get('view');
        applyStandardView();
      }
      if(p.get('hide')==='1') toggleTexts();
    }

    function exportEmbed(){
      const perms = Array.from(document.getElementById('permutationList').selectedOptions).map(o=>o.value);
      const mapping = {
        forma: attributeMapping.forma,
        color: attributeMapping.color,
        x: attributeMapping.x,
        y: attributeMapping.y,
        z: attributeMapping.z
      };
      const colors = {};
      for(let i=1;i<=5;i++){
        colors[i] = document.getElementById('color'+i).value;
      }
      const bg = document.getElementById('bgColor').value;
      const cube = document.getElementById('cubeColor').value;
      const view = document.getElementById('standardView').value;

      const config = {
        perms,
        mapping,
        colors,
        bg,
        cube,
        view
      };

      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'configuracion.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function initCustomCursor(){
      const c=document.getElementById('customCursor');
      window.addEventListener('mousemove',e=>{
        c.style.left=e.clientX+"px"; c.style.top=e.clientY+"px";
      });
    }
    function initRenderer(){
      renderer=new THREE.WebGLRenderer({antialias:true});
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth,window.innerHeight);
      document.body.appendChild(renderer.domElement);
    }
    function init(){
      scene=new THREE.Scene();
      scene.background=new THREE.Color(0xffffff);
      camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      camera.position.set(0,0,50);
      initRenderer();
      controls=new THREE.OrbitControls(camera,renderer.domElement);
      controls.enableDamping=true; controls.dampingFactor=0.1; controls.enableZoom=true;
      scene.add(new THREE.AmbientLight(0xffffff,0.8));
      const dir=new THREE.DirectionalLight(0xffffff,0.5);
      dir.position.set(1,1,1);
      scene.add(dir);

      const cubeGeo=new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize),
            cubeMat=new THREE.MeshBasicMaterial({color:0x808080,transparent:true,opacity:0.2,side:THREE.BackSide});
      cubeUniverse=new THREE.Mesh(cubeGeo,cubeMat);
      scene.add(cubeUniverse);

      permutationGroup=new THREE.Group();
      scene.add(permutationGroup);

      raycaster=new THREE.Raycaster();
      mouse=new THREE.Vector2();
      window.addEventListener('mousemove',onMouseMove,false);
      window.addEventListener('resize',onWindowResize,false);

      initCustomCursor();
      populatePermutationList();
      populateAttributeMappingSelect();
      applyEmbedParams();
      makePalette();
      setMode("manual");
      refreshAll({rebuild:true});
      animate();
    }
    function onWindowResize(){
      camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }
    function animate(){
      requestAnimationFrame(animate);
      if(!isPaused){
        permutationGroup.children.forEach(o=>{
          if(o.userData.rotationSpeed) o.rotation.y+=o.userData.rotationSpeed;
        });
      }
      controls.update();
      renderer.render(scene,camera);
    }
    init();

    // Web3 + NFT Mint (tu código original)
    const CONTRACT_ADDRESS = "YOUR_CONTRACT_ADDRESS";
    const contractABI = [/* ABI JSON here */];
    let provider, signer, contract;
    async function initWeb3() {
      if (window.ethereum) {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        contract = new ethers.Contract(CONTRACT_ADDRESS, contractABI, signer);
      } else {
        console.warn("MetaMask no detectado");
      }
    }
    window.addEventListener("load", initWeb3);

    async function mintNFT() {
      if (!contract) { alert("Wallet no conectada"); return; }
      try {
        const hash = await computeConfigHash();
        const tokenURI = `https://my-server.com/metadata/${hash}.json`;
        const tx = await contract.mint(await signer.getAddress(), tokenURI);
        await tx.wait();
        const nft = {
          tokenId: hash,
          tokenURI,
          owner: await signer.getAddress(),
          config: exportCurrentConfiguration()
        };
        localStorage.setItem("mintedNFT_" + hash, JSON.stringify(nft));
        console.log("NFT guardado localmente:", nft);
        alert("NFT acuñado! Hash: " + hash);
      } catch(e) {
        console.error(e);
        alert("Error mint NFT: " + e.message);
      }
    }
  </script>
  <!-- DROPZONE SCRIPT FINAL -->
  <script>
  document.addEventListener("DOMContentLoaded", function() {
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const uploadStatus = document.getElementById('uploadStatus');
    const jwkOutput = document.getElementById('jwkOutput');
    const cidOutput = document.getElementById('cidOutput');

    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#888";
    });
    dropzone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#ccc";
    });
    dropzone.addEventListener('drop', async (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#ccc";
      if (e.dataTransfer.files.length > 0) {
        await handleFile(e.dataTransfer.files[0]);
      }
    });
    fileInput.addEventListener('change', async (e) => {
      if (e.target.files.length > 0) {
        await handleFile(e.target.files[0]);
      }
    });
    async function handleFile(file) {
      uploadStatus.textContent = "Cifrando archivo…";
      jwkOutput.textContent = "";
      cidOutput.textContent = "";
      const key = await crypto.subtle.generateKey(
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"]
      );
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const data = new Uint8Array(await file.arrayBuffer());
      const encrypted = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        key,
        data
      );
      const exportedKey = await crypto.subtle.exportKey("jwk", key);
      jwkOutput.textContent = " Clave secreta (guárdala para descifrar): " + JSON.stringify(exportedKey);
      const ivHex = Array.from(iv).map(x=>x.toString(16).padStart(2,"0")).join("");
      jwkOutput.textContent += "\n IV usado: " + ivHex;

      const combined = new Uint8Array(iv.byteLength + encrypted.byteLength);
      combined.set(iv, 0);
      combined.set(new Uint8Array(encrypted), iv.byteLength);
      const encryptedBlob = new Blob([combined], { type: file.type });

      uploadStatus.textContent = "Subiendo a Bundlr (requiere wallet conectada)…";
      try {
        if (!window.bundlr) {
          uploadStatus.textContent = "Bundlr no está listo aún o la wallet no está conectada";
          return;
        }
        const tx = await window.bundlr.upload(encryptedBlob, {
          tags: [{ name: "Content-Type", value: file.type }]
        });
        uploadStatus.textContent = " Subida exitosa";
        window.lastUploadedTxId = tx.id;
        cidOutput.textContent = "CID (Arweave/Bundlr): " + tx.id;
      } catch (err) {
        uploadStatus.textContent = " Error subiendo a Bundlr: " + err.message;
      }
    }
  });
  </script>
</body>
</html>
