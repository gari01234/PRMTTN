<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>PRMTTN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="module" src="https://esm.sh/web-bundlr@0.1.1"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #ffffff;
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      font-weight: 200;
      font-size: 12px;
      cursor: none;
    }
    #customCursor {
      position: fixed;
      width: 12px; height: 12px;
      border-radius: 50%;
      background: #000;
      border: 1px solid #fff;
      pointer-events: none; z-index: 300;
      transform: translate(-50%, -50%);
    }
    #topRightDisplay {
      position: fixed; top: 5px; right: 10px; z-index: 280;
      color: #000; font-size: 12px; line-height: 1.2;
    }
    button{
      cursor:none;
      border:none;
      border-radius:4px;
      padding:8px 12px;
      font-size:12px;
      z-index:250;
      background:rgba(255,255,255,0.12);   /* antes 0.8 ‚Üí ahora igual que los paneles */
      transition:background 0.2s;
    }

    /* un peque√±o realce al pasar el cursor (opcional) */
    button:hover{
      background:rgba(255,255,255,0.20);
    }
    #toggleTextButton { bottom: 10px; right: 10px; position: fixed; }
    #randomConfigButton { bottom: 40px; right: 10px; position: fixed; }
    #evolutionAIButton  { bottom: 70px; right: 10px; position: fixed; }
    #saveImageButton    { bottom:100px; right: 10px; position: fixed; }
    #exportEmbedButton  { bottom:130px; right: 10px; position: fixed; }
    #controls {
      position: absolute; top: 10px; left: 10px; z-index: 100;
      padding: 10px; border-radius: 5px;
      background: rgba(255,255,255,0.12); max-width: 350px;
    }
    details {
      margin-bottom: 10px;
      background: rgba(255,255,255,0.06);
    }
    details summary { font-weight: 200; cursor: pointer; }
    details summary:hover { color: #333; }
    select, input[type="range"], input[type="color"] { cursor: none; width: 100%; }
    #permutationList { width: 100%; height: 100px; }
    #ratingContainer {
      position: fixed; bottom:230px; right: 10px; z-index:260;
      font-size:12px;
    }
    #ratingLabels, #ratingDots { display:flex; justify-content:space-between; }
    .ratingBtn { font-size:20px; cursor:none; color:#000; }
    #hoverPopup {
      position:absolute; padding:5px 10px;
      background:rgba(0,0,0,0.7); color:#fff;
      border-radius:4px; pointer-events:none;
      font-size:12px; display:none; opacity:0;
      transition:opacity .3s; z-index:200;
    }
  #triadicConfigButton {
    position: fixed;
    bottom: 160px;   /* ajusta para no tapar otros botones */
    right: 10px;     /* separaci√≥n del borde derecho */
    cursor: pointer; /* mano al pasar */
    z-index: 999;    /* encima de todo */
  }
/* ‚Äî‚Äî‚Äî BLOQUES OCULTOS (se pueden volver a mostrar quitando esta regla) ‚Äî‚Äî‚Äî */
#modeBlock,
#nftBlock,
#secretBlock,
#ratingContainer{
  display:none;
}

  </style>
</head>
<body>
  <div id="customCursor"></div>
  <div id="topRightDisplay"></div>

  <button id="toggleTextButton" onclick="toggleTexts()">Ocultar Textos</button>
  <button id="randomConfigButton" onclick="generateRandomConfiguration()">Configuraci√≥n Aleatoria</button>
<button id="triadicConfigButton" onclick="applyTriadicConfiguration()">Configuraci√≥n Tri√°dica</button>
  <button id="evolutionAIButton" onclick="applyEvolutionAI()">Evoluci√≥n AI</button>
  <button id="saveImageButton" onclick="saveImage()">Guardar Imagen</button>
  <button id="exportEmbedButton" onclick="exportEmbed()">Guardar</button>

  <div id="ratingContainer">
    <details open>
      <summary>Calificar Configuraci√≥n</summary>
      <div id="ratingControls">
        <div id="ratingLabels"><span>1</span><span>2</span><span>3</span><span>4</span><span>5</span></div>
        <div id="ratingDots">
          <span class="ratingBtn" data-rating="1">‚óè</span>
          <span class="ratingBtn" data-rating="2">‚óè</span>
          <span class="ratingBtn" data-rating="3">‚óè</span>
          <span class="ratingBtn" data-rating="4">‚óè</span>
          <span class="ratingBtn" data-rating="5">‚óè</span>
        </div>
      </div>
    </details>
  </div>

  <div id="controls">
    <details id="modeBlock" open>
      <summary>Modo de Operaci√≥n</summary>
      <label><input type="radio" name="mode" value="manual" checked onchange="setMode(this.value)"> Manual</label>
      <label><input type="radio" name="mode" value="evolution" onchange="setMode(this.value)"> Evolutivo</label>
    </details>
    <details open>
      <summary>Patr√≥n crom√°tico</summary>
      <select id="patternSelect" onchange="setActivePattern(this.value)">
        <option value="1">1 ¬∑ Contenci√≥n estructural</option>
        <option value="2">2 ¬∑ Contraste &amp; Disonancia</option>
        <option value="3">3 ¬∑ Disposici√≥n no sem√°ntica</option>
        <option value="4">4 ¬∑ Ambig√ºedad estructurada</option>
        <option value="5">5 ¬∑ Campo sin Centro</option>
        <option value="6">6 ¬∑ Presencia autosuficiente</option>
        <option value="7">7 ¬∑ Asimetr√≠a asociativa</option>
        <option value="8">8 ¬∑ Din√°mica irregular</option>
        <option value="9">9 ¬∑ Habitable sin traducci√≥n</option>
        <option value="10">10 ¬∑ Resonancia</option>
        <option value="11">11 ¬∑ Transparencia activa</option>
        <option value="0">‚ôªÔ∏é Harmon√≠as cl√°sicas (legacy 7)</option>
      </select>
    </details>
    <div id="manualControls">
      <details>
        <summary>Seleccionar Permutaciones</summary>
        <select id="permutationList" multiple></select>
        <button onclick="refreshAll({rebuild:true})">Visualizar Permutaci√≥n</button>
      </details>
    </div>
    <div id="evolutionControls" style="display:none;">
      <details open>
        <summary>Par√°metros Evolutivos</summary>
        <p>Tasa de Mutaci√≥n: <input type="range" id="mutationRate" min="0" max="1" step="0.01" value="0.1"></p>
        <p>Umbral de Cambio: <input type="range" id="threshold" min="0" max="1" step="0.01" value="0.5"></p>
        <button onclick="applyEvolution()">Aplicar Evoluci√≥n</button>
        <div id="evolutionInfo" style="margin-top:8px;font-size:12px;"></div>
      </details>
    </div>
    <details>
      <summary>Seleccionar Colores Permutaciones</summary>

      <div><label>1: <input type="color" id="color1" onchange="onColourPick(1,this.value)"></label></div>
      <div><label>2: <input type="color" id="color2" onchange="onColourPick(2,this.value)"></label></div>
      <div><label>3: <input type="color" id="color3" onchange="onColourPick(3,this.value)"></label></div>
      <div><label>4: <input type="color" id="color4" onchange="onColourPick(4,this.value)"></label></div>
      <div><label>5: <input type="color" id="color5" onchange="onColourPick(5,this.value)"></label></div>

      <!-- nuevo: bot√≥n interno -->
      <button id="btnResetAll" style="margin-top:6px;" onclick="resetAllColours()">
        Resetear Fondo + Paredes + Colores
      </button>
    </details>
    <details>
      <summary>Seleccionar Fondo del Universo</summary>
      <input type="color" id="bgColor" value="#ffffff">
      <button onclick="updateBackground()">Actualizar Fondo</button>
    </details>
    <details>
      <summary>Seleccionar Color de Pared del Cubo</summary>
      <input type="color" id="cubeColor" value="#808080">
      <button onclick="updateCubeColor()">Actualizar Paredes</button>
    </details>
    <!-- <button id="btnResetAll" onclick="resetAllColours()">Resetear Fondo + Paredes + Colores</button> -->
    <details>
      <summary>Reorganizaci√≥n de Atributos</summary>
      <select id="attrMapping"></select>
      <button onclick="updateMapping()">Aplicar Reorganizaci√≥n</button>
      <button onclick="autoResolveColisionesGlobal()">Resolver Colisiones</button>
    </details>
    <details>
      <summary>Vistas Est√°ndar</summary>
      <select id="standardView">
        <option value="isometric">Isom√©trica</option>
        <option value="top">Superior</option>
        <option value="front">Frontal</option>
        <option value="side">Lateral</option>
        <option value="diagonal">Diagonal opuesta</option>
      </select>
      <button onclick="applyStandardView()">Aplicar Vista</button>
    </details>
    <details>
      <summary>Controles de Zoom</summary>
      <button onclick="zoomIn()">Zoom In</button>
      <button onclick="zoomOut()">Zoom Out</button>
    </details>
    <details>
      <summary>Controles de Movimiento</summary>
      <button onclick="togglePause()">Pausar Movimiento</button>
      <button onclick="resetMovement()">Resetear Movimiento</button>
    </details>
<details id="nftBlock">
  <summary>‚ãÜ NFT</summary>
  <button id="btn-mint" style="width:100%;margin-top:8px;">Mint NFT</button>
</details>
<!-- Upload JSON Button -->
<input type="file" id="json-upload" accept=".json" style="display: none;" />
<button 
  onclick="document.getElementById('json-upload').click()" 
  style="position: fixed; bottom: 20px; right: 20px;"
>
  Subir Configuraci√≥n
</button>

<script>
document.getElementById('json-upload').addEventListener('change', function(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const config = JSON.parse(e.target.result);

      if (config.perms && Array.isArray(config.perms)) {
        const sel = document.getElementById('permutationList');
        Array.from(sel.options).forEach(o => o.selected = config.perms.includes(o.value));
      }

      if (config.mapping) {
        const v = [config.mapping.forma, config.mapping.color, config.mapping.x, config.mapping.y, config.mapping.z];
        document.getElementById('attrMapping').value = v.join(',');
      }

      if (config.colors) {
        Object.entries(config.colors).forEach(([i, c]) => {
          manualOverride[i] = c;
        });
      }

      if (config.bg) {
        document.getElementById('bgColor').value = config.bg;
      }

      if (config.cube) {
        document.getElementById('cubeColor').value = config.cube;
      }

      if (config.view) {
        document.getElementById('standardView').value = config.view;
      }

      updateMapping();
      applyStandardView();
      refreshAll({rebuild:true});

      alert('Configuraci√≥n cargada correctamente');
    } catch (err) {
      alert('Error al cargar el JSON: ' + err.message);
    }
  };
  reader.readAsText(file);
});
</script>
    
    <details id="secretBlock" open>
  <summary>üìÅ A√±adir Archivo Secreto</summary>
  <div id="dropzone" style="padding:10px;border:2px dashed #ccc;background:#f9f9f9;margin-top:10px;text-align:center;cursor:pointer;transition:border-color 0.2s;">
    <p>Arrastra aqu√≠ tu archivo secreto o haz clic para seleccionar</p>
    <input type="file" id="fileInput" style="display:none" />
    <p id="uploadStatus"></p>
    <p id="jwkOutput" style="word-break:break-all;font-size:11px;"></p>
    <p id="cidOutput" style="word-break:break-all;font-size:11px;"></p>
  </div>
</details>
  </div>

  <div id="hoverPopup"></div>

  <!-- Three.js & OrbitControls -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <!-- Ethers.js -->
  <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Bundlr -->
  <script type="module">
    import { WebBundlr } from "https://esm.sh/web-bundlr@0.1.1";
    window.addEventListener("load", async () => {
      try {
        const bundlr = new WebBundlr("https://node1.bundlr.network", "matic", window.ethereum);
        await bundlr.ready();
        const balance = await bundlr.getLoadedBalance();
        console.log("Bundlr listo, balance:", balance.toString());
        window.bundlr = bundlr;
      } catch (err) {
        console.error("Error inicializando Bundlr:", err);
      }
    });
  </script>
  <script>
    // ------------- TODO EL JS ORIGINAL (¬°NO QUITES NADA DE AQU√ç!) -------------
    // === LISTA DE 120 COLORES ===
    const CUSTOM_COLORS = [
      "#070709","#898052","#402523","#0d080a","#070909","#050608","#070509",
      "#12080d","#330a0d","#9c714f","#382e24","#883933","#decda0",
      "#fafcff","#a4b6bc","#e7e8e1","#f3f1ea","#eaebe2","#dcdacf","#f8f9f8",
      "#f6f5ea","#ffffff","#f3f3f0","#faf9f0","#f5f7f6","#eeece8","#fffef7",
      "#350b0c","#9e4031","#820707","#eeb049","#120607","#f6f1ed",
      "#300809","#8c2d18","#6a6620","#b99c5c","#110505","#5f2423",
      "#400909","#a04b37","#180506","#e1b055","#6f2919","#170607",
      "#000000","#9c822b","#3e1b2c","#edce83","#1b0408","#8a4667",
      "#000000","#ec9b1c","#701a25","#9c2c1a","#480b0b","#150407",
      "#2a0607","#b08b4f","#7a181d","#5d180f","#1f0908","#dfb46e",
      "#0b0304","#a4735a","#4e272a","#cab296","#923930","#1d0709",
      "#f4c061","#963326","#d89048","#430f0c","#ce5830","#72121a",
      "#fefffe","#c0b280","#57231d","#99541e","#210d0a","#8a5d2f",
      "#33090a","#e2a33f","#a24a2c","#591e14","#8f2e1c","#1e0809",
      "#bd4d1d","#441b1d","#0f0406","#e3a337","#886c39","#1a0807",
      "#fffcee","#cea564","#9a7859","#080103","#000003","#000100",
      "#000000","#6d4d2c","#2d060a","#000005","#000100","#2d0006",
      "#17120a","#451e18","#42401c","#7c4934","#8c7640","#c0b468"
    ];

    // === Variables globales ===
    let scene, camera, renderer, controls, raycaster, mouse;
    let cubeUniverse, permutationGroup;
    const cubeSize = 30, segment = cubeSize/5, halfCube = cubeSize/2;
    let isPaused = false, currentMode = "manual", userRating = null, textsVisible = true;
    let attributeMapping = { forma:0, color:1, x:2, y:3, z:4 };
    let paletteRGB = [];
    let manualOverride = {1:'#ff0000',2:'#00ff00',3:'#0000ff',4:'#ff00ff',5:'#00ffff'};
    let bgOverride   = null;
    let cubeOverride = null;
    /* variables globales para fondo y paredes */
    let bgHSV = {h:0,s:0,v:1};
    let wallHSV = {h:0,s:0,v:1};
    let  currentHarmony = 'triad';
    let activePatternId = 1;           // arranca en Contenci√≥n
    const ŒîE_MIN = 20;
    const GOLD = 137.50776405003785;      // √°ngulo √°ureo
    /*  raz√≥n √°urea al cuadrado  ‚âà 2.618‚Ä¶  */
    const PHI2 = 2.618033988749895;

    /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê CUADR√çCULA HSV 144¬∑12¬∑12 ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
    const H_STEPS  = 144;                               // 360¬∞ / 2.5¬∞
    const S_LEVELS = [...Array(12)].map((_,i)=>0.25+i*0.72/11); // 0.25 ‚Äì 0.97
    const V_LEVELS = [...Array(12)].map((_,i)=>0.20+i*0.75/11); // 0.20 ‚Äì 0.95

    function idxToHSV(hIdx,sIdx,vIdx){
      return {
        h: ( (hIdx%H_STEPS)+H_STEPS ) * 360 / H_STEPS,
        s: S_LEVELS[ ((sIdx%12)+12)%12 ],
        v: V_LEVELS[ ((vIdx%12)+12)%12 ]
      };
    }

    /* === 11 PATRONES ¬∑ ret√≠cula 144√ó12√ó12 ================================ *
     * slot: 0-4 ‚Üí glifos 1-5 ¬∑ 5 ‚Üí fondo ¬∑ 6 ‚Üí paredes                      *
     * Devuelve [hIdx , sIdx , vIdx] ‚Äî todos enteros                        *
     * ==================================================================== */
    const PATTERNS = {

      /* 1 ¬∑ CONTENCI√ìN ESTRUCTURAL --------------------------------------- */
      1:(sig,seed,slot)=>{
          const base = (seed*7) % H_STEPS;
          if(slot<5) return [ base              , 7 , 2+slot ];
          if(slot==5) return [ (base+17)%H_STEPS, 6 , 1      ];
          return           [ (base+34)%H_STEPS, 7 , 3      ];
      },

      /* 2 ¬∑ CONTRASTE & DISONANCIA -------------------------------------- */
      2:(sig,seed,slot)=>{
          const r = (slot<5)?slot:(slot-5)*3;
          return [
            (sig[0]*11 + seed*3 + r*27) % H_STEPS,
            (5 + sig[1] + slot) % 12,
            (4 + sig[2] + r ) % 12
          ];
      },

      /* 3 ¬∑ DISPOSICI√ìN NO SEM√ÅNTICA ------------------------------------ */
      3:(sig,seed,slot)=>{
          const h = (seed*11 + sig[2]*3) % H_STEPS;
          if(slot<5) return [ h               , 8 , 9 ];
          if(slot==5) return [ (h+36)%H_STEPS , 5 , 6 ];
          return           [ (h+72)%H_STEPS , 9 , 8 ];
      },

      /* 4 ¬∑ AMBIG√úEDAD ESTRUCTURADA ------------------------------------- */
      4:(sig,seed,slot)=>{
          const base = (sig[1]*15 + ((seed%3)-1)*7 + H_STEPS) % H_STEPS;
          if(slot<5){
            const v = (slot===4)?11:8;
            return [ base , 7 , v ];
          }
          if(slot==5) return [ (base+24)%H_STEPS , 5 , 6 ];
          return           [ (base+12)%H_STEPS , 8 , 7 ];
      },

      /* 5 ¬∑ CAMPO SIN CENTRO ------------------------------------------- */
      5:(sig,seed,slot)=>{
          const h = (slot*48 + seed*5 + sig[3]*7) % H_STEPS;    // 48 = 120¬∞
          if(slot<5) return [ h , 9 , 7 ];
          if(slot==5) return [ (h+24)%H_STEPS , 6 , 7 ];
          return           [ (h+12)%H_STEPS , 8 , 8 ];
      },

      /* 6 ¬∑ PRESENCIA AUTOSUFICIENTE ----------------------------------- */
      6:(sig,seed,slot)=>{
          const h = (sig.reduce((a,b)=>a+b,0)*4) % H_STEPS;
          const v = (slot===4)?11:9;
          if(slot<5) return [ h , 10 , v ];
          if(slot==5) return [ (h+36)%H_STEPS , 6 , 6 ];
          return           [ (h+18)%H_STEPS , 9 , 7 ];
      },

      /* 7 ¬∑ ASIMETR√çA ASOCIATIVA --------------------------------------- */
      7:(sig,seed,slot)=>{
          const h = (seed*4 + slot*36) % H_STEPS;               // 36 = 90¬∞
          if(slot<5) return [ h , 9 , 7 ];
          if(slot==5) return [ (h+30)%H_STEPS , 6 , 6 ];
          return           [ (h+15)%H_STEPS , 9 , 8 ];
      },

      /* 8 ¬∑ DIN√ÅMICA IRREGULAR ----------------------------------------- */
      8:(sig,seed,slot)=>{
          const h = (computeRange(sig)*17) % H_STEPS;           // 17 idx ‚âà 42¬∞
          if(slot<5) return [ h , 9 , 6 ];
          if(slot==5) return [ (h+24)%H_STEPS , 5 , 5 ];
          return           [ (h+12)%H_STEPS , 8 , 7 ];
      },

      /* 9 ¬∑ HABITABLE SIN TRADUCCI√ìN ----------------------------------- */
      9:(sig,seed,slot)=>{
          const h = (sig[4]*12 + seed*7) % H_STEPS;
          if(slot<5) return [ h , 3+slot , 8 ];
          if(slot==5) return [ (h+18)%H_STEPS , 2 , 5 ];
          return           [ (h+36)%H_STEPS , 5 , 8 ];
      },

      /* 10 ¬∑ RESONANCIA ------------------------------------------------- */
     10:(sig,seed,slot)=>{
          const base = (sig[0]*8 + sig[1]*3 + seed*4) % H_STEPS;
          const h = (base + ((sig[2]%5)-2)*12 + H_STEPS) % H_STEPS; // ¬±30¬∞
          if(slot<5) return [ h , 8 , 9 ];
          if(slot==5) return [ (h+24)%H_STEPS , 5 , 6 ];
          return           [ (h+12)%H_STEPS , 8 , 7 ];
      },

      /* 11 ¬∑ TRANSPARENCIA ACTIVA -------------------------------------- */
     11:(sig,seed,slot)=>{
          const h = (seed*17) % H_STEPS;                         // 17 idx
          if(slot<5) return [ h , 8 , 3+slot ];                  // V = 3-7
          if(slot==5) return [ (h+30)%H_STEPS , 5 , 8 ];
          return           [ (h+60)%H_STEPS , 8 , 9 ];
      }
    };

/* ---------- BLOQUE DE UTILIDADES COLOR v1.3-RC2 ---------- */
const ANG7 = [
  [0,0,0,0,0,0,0],                         // monocromo (idx 0)
  [0,30,60,90,120,150,180],                // an√°loga
  [0,180,0,180,0,180,0],                   // complementaria
  [0,150,210,0,150,210,0],                 // comp. dividida
  [0,120,240,60,180,300,30],               // tr√≠ada
  [0,90,180,270,45,135,225],               // cuadrado
  [0,0,0,0,0,0,0]                          // ‚Äútonos‚Äù (misma H, S escalado)
];
function rgbToHsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min;
  let h=0;
  if(d){
    if(max===r) h=((g-b)/d)%6;
    else if(max===g) h=(b-r)/d+2;
    else h=(r-g)/d+4;
    h*=60; if(h<0) h+=360;
  }
  const s=max?d/max:0, v=max;
  return [h,s,v];
}
function hsvToRgb(h,s,v){
  const c=v*s, x=c*(1-Math.abs((h/60)%2-1)), m=v-c;
  let [r,g,b]=[0,0,0];
  if(h<60){r=c;g=x;} else if(h<120){r=x;g=c;}
  else if(h<180){g=c;b=x;} else if(h<240){g=x;b=c;}
  else if(h<300){r=x;b=c;} else {r=c;b=x;}
  return [(r+m)*255,(g+m)*255,(b+m)*255].map(v=>Math.round(v));
}
function hsvToHex({h,s,v}){
  const [r,g,b] = hsvToRgb(h,s,v);
  return '#'+new THREE.Color(r/255,g/255,b/255).getHexString();
}
/* contraste CIE76 */
function deltaE(lab1,lab2){
  return Math.sqrt(
    (lab1[0]-lab2[0])**2+
    (lab1[1]-lab2[1])**2+
    (lab1[2]-lab2[2])**2
  );
}
function rgbToLab(r,g,b){                      // aproximaci√≥n r√°pida
  const xyz=[r/255,g/255,b/255].map(v=>{
    v=v>0.04045?((v+0.055)/1.055)**2.4:v/12.92;
    return v*100;
  });
  const x=xyz[0]*0.4124+xyz[1]*0.3576+xyz[2]*0.1805;
  const y=xyz[0]*0.2126+xyz[1]*0.7152+xyz[2]*0.0722;
  const z=xyz[0]*0.0193+xyz[1]*0.1192+xyz[2]*0.9505;
  const xyzN=[95.047,100.0,108.883];
  const f= t=> t>0.008856 ? t**(1/3) : (7.787*t)+16/116;
  const [fx,fy,fz]=[x,y,z].map((v,i)=>f(v/xyzN[i]));
  return [116*fy-16, 500*(fx-fy), 200*(fy-fz)];
}
/* ---------- FIN BLOQUE UTILIDADES ---------- */
/* ‚Äî‚Äî‚Äî calcula HSV para fondo (slot 5) y paredes (slot 6) ‚Äî‚Äî‚Äî */
function rebuildSceneColours(){
  const dummySig = [0,0,0,0,0];     // no influye: solo queremos el patr√≥n
  bgHSV   = idxToHSV( ...PATTERNS[activePatternId](dummySig, sceneSeed, 5) );
  wallHSV = idxToHSV( ...PATTERNS[activePatternId](dummySig, sceneSeed, 6) );
}

/* ===\u2003UTIL extra ‚Äî firma normalizada y contraste\u2003===================== */
// 1)  fÃÇ  de un glifo  ‚Üí  promedio firma, llevada a [0-1]
function normFhat(sig){           // sig = [f1‚Ä¶f5] entre 2 y 10
  const avg = sig.reduce((a,b)=>a+b,0)/sig.length;   // 2 ‚Ä¶ 10
  return (avg-2)/8;                                  // 0 ‚Ä¶ 1
}

// 2)  pinza a [0,1]
function clamp01(x){ return Math.max(0, Math.min(1,x)); }

/* ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî *
 * Devuelve el valor de una propiedad que puede ser:
 *   ¬∑ n√∫mero ‚Üí se usa tal cual
 *   ¬∑ funci√≥n ‚Üí se eval√∫a con los argumentos dados
 * fallback se usa si la propiedad es null/undefined.
 * ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî */
function evalProp(prop, args = [], fallback = 0){
  return (typeof prop === 'function') ? prop(...args) :
         (prop ?? fallback);
}

/* contrast-fix eliminado: funci√≥n ensureContrast() suprimida */
    const minRangeValue = 2, maxRangeValue = 6;
    const shapeMapping = {
      1:{w:4.5,h:4.5},
      2:{w:4.5,h:4.5*Math.sqrt(2)},
      3:{w:4.5,h:4.5*Math.sqrt(3)},
      4:{w:4.5,h:4.5*Math.sqrt(4)},
      5:{w:4.5,h:4.5*Math.sqrt(5)}
    };

    function sumXYZ(pa,map){
      return pa[ map.x ] + pa[ map.y ] + pa[ map.z ];
    }

    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function mapRangeToSpeed(r,mn,mx){return 0.001 + (r-mn)*(0.005-0.001)/(mx-mn);}
    function shuffle(a){for(let i=a.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

    function getPermutations(arr){
      if(arr.length===1) return [arr];
      let res=[]; for(let i=0;i<arr.length;i++){
        const c=arr[i], rem=arr.slice(0,i).concat(arr.slice(i+1));
        for(const p of getPermutations(rem)) res.push([c].concat(p));
      }
      return res;
    }
    const allPermutations = getPermutations([1,2,3,4,5]);
    const permutationStrings = allPermutations.map(p=>p.join(','));

    function getAttributeMappings(a){
      if(a.length===1) return [a];
      let res=[]; for(let i=0;i<a.length;i++){
        const c=a[i], rem=a.slice(0,i).concat(a.slice(i+1));
        for(const m of getAttributeMappings(rem)) res.push([c].concat(m));
      }
      return res;
    }

    function populatePermutationList(){
      const sel = document.getElementById('permutationList');
      sel.innerHTML = '';
      permutationStrings.forEach((ps,i)=>{
        const o=document.createElement('option');
        o.value=ps; o.text=`Permutaci√≥n ${i+1}: (${ps})`;
        if(i===0) o.selected=true;
        sel.appendChild(o);
      });
    }
    function populateAttributeMappingSelect(){
      const sel = document.getElementById('attrMapping');
      sel.innerHTML = '';
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        const s=m.join(','), o=document.createElement('option');
        o.value=s; o.text=`Opci√≥n: [${s}]`;
        if(s==='0,1,2,3,4') o.selected=true;
        sel.appendChild(o);
      });
      updateTopRightDisplay();
    }

    function computeSignature(a){let s=[];for(let i=0;i<a.length;i++) s.push(a[i]+a[(i+1)%a.length]);return s;}
    function computeRange(sig){return Math.max(...sig)-Math.min(...sig);}

    const FACT=[1,1,2,6,24,120];
    let sceneSeed=0;
    function lehmerRank(p){
      let r=0;
      for(let i=0;i<p.length;i++){
        let c=0;
        for(let j=i+1;j<p.length;j++) if(p[j]<p[i]) c++; 
        r+=c*FACT[p.length-1-i];
      }
      return r;
    }
    function computeShiftRankXYZ(p){
      const r=lehmerRank(p);
      const I=(r+sceneSeed)%125;
      const x=Math.floor(I/25), y=Math.floor((I%25)/5), z=I%5;
      const step=cubeSize/5;
      return [
        (x-2)*step,
        (y-2)*step,
        (z-2)*step
      ];
    }

    function setActivePattern(id){
      activePatternId = parseInt(id,10);
      refreshAll({rebuild:false});
    }
    function updateTopRightDisplay(){
      const cfg=`Atributos: [${attributeMapping.forma},${attributeMapping.color},${attributeMapping.x},${attributeMapping.y},${attributeMapping.z}]`;
      const rt =`Calificaci√≥n: ${userRating?userRating:'A√∫n no calificada'}`;
      let info='';
      Array.from(document.getElementById('permutationList').selectedOptions).forEach(o=>{
        const pa=o.value.split(',').map(Number),
              sig=computeSignature(pa),
              rg=computeRange(sig);
        info+=`<div style="margin:2px 0;">Perm (${o.value}) | Firma [${sig.join(', ')}] | Rango ${rg}</div>`;
      });
      document.getElementById('topRightDisplay').innerHTML = cfg+'<br>'+rt+'<br>'+info;
    }

    function createPermutationObjectWithMapping(pa,map){
      const fv=pa[map.forma], cv=pa[map.color],
            d=shapeMapping[fv], w=d.w, h=d.h, t=0.5;
      /* --- C√ÅLCULO de color (cuadr√≠cula) -------------------------------- */
      // --- color determinista desde la ret√≠cula --------------------------
      const sig  = computeSignature(pa);
      const slot = cv - 1;                                   // 0-4
      const [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
      const {h,s,v}    = idxToHSV(hI,sI,vI);
      const rgb        = hsvToRgb(h,s,v);
      /* --------------------------------------------------------------- */
      const mat=new THREE.MeshPhongMaterial({
        color:new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255),
        shininess:50
      });
      const geo=new THREE.BoxGeometry(w,h,t);
      const mesh=new THREE.Mesh(geo,mat);
      const [X,Y,Z]=computeShiftRankXYZ(pa);
      mesh.position.set(
        clamp(X,-halfCube+w/2,halfCube-w/2),
        clamp(Y,-halfCube+h/2,halfCube-h/2),
        clamp(Z,-halfCube+t/2,halfCube-t/2)
      );
      const sig=computeSignature(pa), rg=computeRange(sig);
      mesh.userData={permStr:pa.join(','), signature:sig, range:rg, rotationSpeed:mapRangeToSpeed(rg,minRangeValue,maxRangeValue)};
      return mesh;
    }
    function createPermutationObject(pa){ return createPermutationObjectWithMapping(pa,attributeMapping); }

    function checkCollisionsInGroup(g){
      for(let i=0;i<g.children.length;i++){
        const b1=new THREE.Box3().setFromObject(g.children[i]);
        for(let j=i+1;j<g.children.length;j++){
          const b2=new THREE.Box3().setFromObject(g.children[j]);
          if(b1.intersectsBox(b2)) return true;
        }
      }
      return false;
    }
    function autoResolveColisionesGlobal(){
      let found=null;
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        if(found) return;
        const cm={forma:m[0],color:m[1],x:m[2],y:m[3],z:m[4]},
              tg=new THREE.Group(),
              opts=Array.from(document.getElementById('permutationList').selectedOptions);
        opts.forEach((o)=>{
          const pa=o.value.split(',').map(Number),
                mo=createPermutationObjectWithMapping(pa,cm);
          tg.add(mo);
        });
        if(!checkCollisionsInGroup(tg)) found=cm;
      });
      if(found){
        attributeMapping=found;
        document.getElementById('attrMapping').value=`${found.forma},${found.color},${found.x},${found.y},${found.z}`;
        refreshAll({rebuild:true}); updateTopRightDisplay();
      } else {
        showPopup("No se encontr√≥ reorganizaci√≥n sin colisiones.",7000);
      }
    }

    function showPopup(msg,dur=2000){
      const p=document.getElementById('hoverPopup');
      p.style.display="block"; p.style.opacity=1;
      p.style.left=(window.innerWidth/2-150)+"px"; p.style.top="20px";
      p.innerHTML=msg;
      setTimeout(()=>{
        p.style.opacity=0;
        setTimeout(()=>{p.style.display="none";p.innerHTML="";},300);
      },dur);
    }

    function updateScene(attemptResolve=true){
      while(permutationGroup.children.length>0){
        const o=permutationGroup.children[0];
        permutationGroup.remove(o);
        o.geometry.dispose(); o.material.dispose();
      }
      const opts=Array.from(document.getElementById('permutationList').selectedOptions);
      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ nueva ¬´huella¬ª crom√°tica ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      sceneSeed = 0;                                      // reinicia
      opts.forEach(o => {
        const pa = o.value.split(',').map(Number);        // permutaci√≥n
        /*  Lehmer-rank ‚àà[0,119]  ‚Ä¢  37 = primo ‚áí salta pseudo-aleatorio
            El m√≥dulo 360 garantiza cobertura total del c√≠rculo.       */
        sceneSeed = (sceneSeed + lehmerRank(pa) * 37) % 360;
      });
      /* ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FIN bloque semilla ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
      opts.forEach((o)=>{
        const pa=o.value.split(',').map(Number),
              obj=createPermutationObject(pa);
        permutationGroup.add(obj);
      });
      if(attemptResolve) autoResolveColisionesGlobal();
      else updateTopRightDisplay();
    }

    function onMouseMove(e){
      mouse.x=(e.clientX/window.innerWidth)*2-1;
      mouse.y=-(e.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera(mouse,camera);
      const ints=raycaster.intersectObjects(permutationGroup.children),
            pop=document.getElementById('hoverPopup');
      if(ints.length>0){
        const d=ints[0].object.userData;
        pop.style.display="block"; pop.style.opacity=1;
        pop.style.left=`${e.clientX+20}px`;
        pop.style.top=`${e.clientY+20}px`;
        pop.innerHTML=`Perm (${d.permStr})<br>Firma [${d.signature.join(', ')}]<br>Rango ${d.range}`;
      } else {
        pop.style.opacity=0;
        setTimeout(()=>{pop.style.display="none";},300);
      }
    }

    function zoomIn(){camera.position.z-=5;controls.update();}
    function zoomOut(){camera.position.z+=5;controls.update();}
    function togglePause(){
      isPaused=!isPaused;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent=isPaused?"Reanudar Movimiento":"Pausar Movimiento";
    }
    function resetMovement(){
      updateScene(false);
      isPaused=true;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent="Reanudar Movimiento";
    }

    function saveImage(){
      renderer.render(scene,camera);
      const url=renderer.domElement.toDataURL("image/png"),
            a=document.createElement("a");
      a.href=url; a.download="configuracion.png";
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
    }


    /* Paleta v1.3 ‚Äî se recalcula siempre que cambia la escena            *
     * 1. Semilla RGB = suma ponderada de posiciones y P1-P3 (firma).    *
     * 2. Selecci√≥n de armon√≠a idx = (R+2G+3B) mod 7                     */
function thirtyFive(){return 35;}

function makeClassicPalette(){
      /* --- 1. Semilla RGBglobal --- */
      let Rg=0,Gg=0,Bg=0;
      permutationGroup.children.forEach(mesh=>{
        const pa = mesh.userData.permStr.split(',').map(Number);
        const sig = mesh.userData.signature;            // [f1..f5]
        const P1=pa[0], P2=pa[1], P3=pa[2];
        const {x,y,z} = mesh.position;
        Rg += (P1*Math.abs(x)+sig[0])|0;
        Gg += (P2*Math.abs(y)+sig[1])|0;
        Bg += (P3*Math.abs(z)+sig[2])|0;
      });
      Rg%=256; Gg%=256; Bg%=256;

      /* --- 2. HSV base --- */
      const [H0] = rgbToHsv(Rg,Gg,Bg);
      const idx = (Rg + 2*Gg + 3*Bg) % 7;
      const Œî = ANG7[idx];

      /* --- 3. Construir 7 tonos HSV --- */
      const HSV = [];
      for(let k=0;k<7;k++){
        let h = (H0 + Œî[k]) % 360,
            s = 0.70,
            v = 0.85;
        if(idx===0){ v = 0.55+0.05*k; }          // monocromo
        if(idx===2 && k>1){ v = 0.85-0.05*(k-1);} // complementario grad.
        if(idx===3 && k>2){ s = 0.85-0.05*(k-3);} // comp.dividida grad S
        if(idx===6){ s = 0.40+0.05*k; }           // tonos
        HSV.push([h,s,v]);
      }

      /* --- 4. A HSV ‚Üí RGB, validar contraste ‚àÜE ‚â• 22 --- */
      paletteRGB=[];
      for(let i=0;i<7;i++){
        let rgb=hsvToRgb(...HSV[i]);
        let tries=0;
        while(i>0 &&
              deltaE(rgbToLab(...rgb), rgbToLab(...paletteRGB[0])) <  thirtyFive() &&
              tries<25){
          /* si el hue es demasiado parecido => rotar 18¬∞; si no, subir V */
          if(Math.abs(HSV[i][0]-HSV[0][0])<20){
            HSV[i][0] = (HSV[i][0]+18)%360;
          }else{
            HSV[i][2] = Math.min(1, HSV[i][2]+0.04);
          }
          rgb = hsvToRgb(...HSV[i]); tries++;
        }
      paletteRGB.push(rgb);
      }
    }

function makePalette(){
  /* modo legacy */
  if (activePatternId === 0){ makeClassicPalette(); return; }

  paletteRGB = [];
  for (let i=0;i<5;i++){
    const [hI,sI,vI] = PATTERNS[activePatternId]([0,0,0,0,0], sceneSeed, i);
    const {h,s,v}   = idxToHSV(hI,sI,vI);
    paletteRGB.push( hsvToRgb(h,s,v) );
  }
}
    function getColor(idx){
      return manualOverride[idx] || paletteRGB[idx-1] || '#ffffff';
    }

    function applyPalette(){
      for(let i=1;i<=5;i++){
        const autoRGB = paletteRGB[i-1] || [255,255,255];
        const autoHEX = '#'+new THREE.Color(
            autoRGB[0]/255,autoRGB[1]/255,autoRGB[2]/255).getHexString();
        const hex     = manualOverride[i] || autoHEX;
        const input   = document.getElementById('color'+i);
        if(input) input.value = hex;
      }

      permutationGroup.children.forEach(o=>{
        const pa   = o.userData.permStr.split(',').map(Number);
        const idx  = pa[attributeMapping.color];          // 1-5
        let hex;
        if(manualOverride[idx]){
          hex = manualOverride[idx];
        }else if(activePatternId===0){
          hex = '#'+new THREE.Color(
                    ...paletteRGB[idx-1].map(v=>v/255)).getHexString();
        }else{
          const sig  = computeSignature(pa);
          const slot = idx - 1;
          const [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
          const {h,s,v}   = idxToHSV(hI,sI,vI);
          const rgb       = hsvToRgb(h,s,v);
          hex = '#'+new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255).getHexString();
        }
        o.material.color.setStyle(hex);
      });
      updateColorPickersFromScene();
    }

    /* ‚Äî‚Äî‚Äî Sincroniza los <input type="color"> con los colores reales ‚Äî‚Äî‚Äî */
    function updateColorPickersFromScene(){
      // memoriza el primer glifo encontrado para cada √≠ndice P2 (1-5)
      const seen = {};
      permutationGroup.children.forEach(o=>{
        const pa  = o.userData.permStr.split(',').map(Number);
        const idx = pa[attributeMapping.color];           // 1-5
        if(!seen[idx]){
          const c = o.material.color;                     // THREE.Color
          const hex = '#'+c.getHexString();
          const inp = document.getElementById('color'+idx);
          if(inp) inp.value = hex;
          seen[idx]=true;
        }
      });
    }

    function refreshAll(opts={rebuild:false}){
      if(!opts.keepManual){              // por defecto se limpia
        manualOverride = {};
      }
      if(opts.rebuild) updateScene(false);
      rebuildSceneColours();
      makePalette();
      applyPalette();
      /* contrast-fix eliminado ‚Äì 19-Jul-2025 */
      updateBackground(false);
      updateCubeColor(false);
    }
    function onColourPick(idx,hex){
      manualOverride[idx]=hex;
      refreshAll({keepManual:true});
    }

    function resetAllColours(){
      manualOverride = {};
      bgOverride     = null;
      cubeOverride   = null;
      refreshAll({keepManual:false});   // reconstruye escena y pickers
    }
    function updateBackground(manual=true){
      if (manual){
        bgOverride = document.getElementById("bgColor").value;
      }
      const hex = manual ? bgOverride : hsvToHex(bgHSV);
      scene.background = new THREE.Color(hex);
      document.getElementById("bgColor").value = hex;
    }

    function updateCubeColor(manual=true){
      if (manual){
        cubeOverride = document.getElementById("cubeColor").value;
      }
      const hex = manual ? cubeOverride : hsvToHex(wallHSV);
      cubeUniverse.material.color = new THREE.Color(hex);
      document.getElementById("cubeColor").value = hex;
    }

    function toggleTexts(){
      const elems=[
        'controls','topRightDisplay','ratingContainer',
        'randomConfigButton','evolutionAIButton','saveImageButton','exportEmbedButton','triadicConfigButton'
      ].map(id=>document.getElementById(id));
      elems.forEach(e=>e.style.display=textsVisible?"none":"block");
      document.getElementById('toggleTextButton').textContent=
        textsVisible?"Mostrar Textos":"Ocultar Textos";
      textsVisible=!textsVisible;
    }

    function setMode(m){
      currentMode=m;
      document.getElementById('manualControls').style.display=
        m==="manual"?"block":"none";
      document.getElementById('evolutionControls').style.display=
        m==="evolution"?"block":"none";
      refreshAll({rebuild:true});
    }

    function generateRandomConfiguration(){
      const sel=document.getElementById('permutationList');
      Array.from(sel.options).forEach(o=>o.selected=false);
      const n=Math.floor(Math.random()*10)+1;
      for(let i=0;i<n;i++){
        const val=permutationStrings[Math.floor(Math.random()*permutationStrings.length)];
        sel.querySelector(`option[value="${val}"]`).selected=true;
      }
      const bg=CUSTOM_COLORS[Math.floor(Math.random()*CUSTOM_COLORS.length)],
            wall=CUSTOM_COLORS[Math.floor(Math.random()*CUSTOM_COLORS.length)];
      document.getElementById('bgColor').value=bg; updateBackground();
      document.getElementById('cubeColor').value=wall; updateCubeColor();
      // let pool = shuffle(CUSTOM_COLORS.slice());
      // for(let i = 1; i <= 5; i++){
      //   const hex = pool.shift();      // se escrib√≠a en manualOverride
      //   manualOverride[i] = hex;       // y anula la paleta determinista
      // }
      refreshAll({rebuild:true});
    }
/**
 * Dada una firma [f1,f2,f3,f4,f5], devuelve los colores tri√°dicos
 * { colorShape, colorCube, colorBG } en formato CSS HSL.
 */
function computeTriadicColors(firma) {
  // 1) Normaliza f_i ‚àà {3‚Ä¶9} a u_i ‚àà [0,1]
  const u = firma.map(fi => (fi - 3) / 6);

  // 2) Hue base mixto (60% de u[1], 10% de cada otro)
  const phi0 = 360 * (
    0.1 * u[0] +
    0.6 * u[1] +
    0.1 * u[2] +
    0.1 * u[3] +
    0.1 * u[4]
  );

  // 3) Tri√°dico: +0¬∞, +120¬∞, +240¬∞
  const shapeHue =  phi0;
  const cubeHue  = (phi0 + 120) % 360;
  const bgHue    = (phi0 + 240) % 360;

  // 4) Saturaci√≥n y luminosidad fijas
  const S = 80, L = 50;

  return {
    colorShape: `hsl(${shapeHue.toFixed(1)},${S}%,${L}%)`,
    colorCube:  `hsl(${cubeHue.toFixed(1)},${S}%,${L}%)`,
    colorBG:    `hsl(${bgHue.toFixed(1)},${S}%,${L}%)`
  };
}
function applyTriadicConfiguration() {
  // 1) Repite la selecci√≥n aleatoria de permutaciones
  generateRandomConfiguration();

  // 2) Ahora solo aplica los colores tri√°dicos deterministas:
  if (permutationGroup.children.length > 0) {
    const baseSig = permutationGroup.children[0].userData.signature;
    const { colorCube, colorBG } = computeTriadicColors(baseSig);

    // Paredes del cubo
    if (cubeUniverse.material?.color?.setStyle) {
      cubeUniverse.material.color.setStyle(colorCube);
    } else {
      cubeUniverse.material.color = new THREE.Color(colorCube);
    }

    // Fondo
    scene.background = new THREE.Color(colorBG);
  }

  // Cada prisma
  permutationGroup.children.forEach(mesh => {
    const sig = mesh.userData.signature;
    const { colorShape } = computeTriadicColors(sig);
    if (mesh.material?.color?.setStyle) {
      mesh.material.color.setStyle(colorShape);
    } else {
      mesh.material.color = new THREE.Color(colorShape);
    }
  });
}
    document.querySelectorAll('.ratingBtn').forEach(el=>{
      const r=+el.getAttribute('data-rating');
      el.addEventListener('click',()=>{
        userRating=r;
        const cols={1:"#8B0000",2:"#FF4500",3:"#FFA500",4:"#9ACD32",5:"#008000"};
        document.querySelectorAll('.ratingBtn').forEach((b,i)=>{
          b.style.color=(i<r?cols[r]:"#000");
        });
        updateTopRightDisplay();
      });
      el.addEventListener('mouseenter',()=>showPopup(`Calificaci√≥n: ${r}`,1000));
    });

    function applyEvolution(){
      const mr=parseFloat(document.getElementById('mutationRate').value),
            th=parseFloat(document.getElementById('threshold').value),
            cf=0.02;
      let log="";
      permutationGroup.children.forEach(o=>{
        const rf=(Math.random()-0.5)*mr;
        o.rotation.y+=rf;
        const sf=1+(Math.random()-0.5)*th;
        o.scale.set(sf,sf,sf);
        o.material.color.offsetHSL(
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf
        );
        log+=`(${o.userData.permStr}): Rot ${rf.toFixed(3)}, Esc ${sf.toFixed(3)}<br>`;
      });
      document.getElementById('evolutionInfo').innerHTML=log;
    }

    async function applyEvolutionAI(){
      const systemPrompt = `Eres una inteligencia artificial que responde exclusivamente con configuraciones de permutaciones 3D dentro de un cubo de 30x30x30.
      Tu √∫nica misi√≥n es responder a la pregunta ‚Äú¬øQu√© es la belleza art√≠stica?‚Äù mediante pensamientos visuales dentro de un cubo de 30√ó30√ó30.
Cada pensamiento visual es una configuraci√≥n compuesta por una o m√°s permutaciones (entre 1 y 25). Cada permutaci√≥n tiene una firma (ADN) inmutable, y un fenotipo: forma, color, posici√≥n, rotaci√≥[...]
Tu lenguaje es visual. No usas texto, sonido ni s√≠mbolos. Elige libremente el color del fondo del universo, el color de las paredes del cubo y de las permutaciones. 
Recuerda: el color del fondo y de las permutaciones tambi√©n son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiraci√≥n para la selecci√≥n de colores, recuerda que puedes inspirarte tambi√©n en los colores de la naturaleza y del universo entero. 
      Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",‚Ä¶}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: n√∫mero
  scale: n√∫mero decimal
  positions: {1:[x,y,z],2:[x,y,z],‚Ä¶}
  rotationSpeeds: {1:valor,2:valor,‚Ä¶}
Nada m√°s. No incluyas texto ni explicaciones fuera del JSON.`;
      const useRating = false;
      const userPrompt = `Calificaci√≥n actual: ${userRating||"sin calificar"}. `
                       + `Est√°s dentro de un universo donde las ideas no se escriben con palabras, sino con permutaciones. Eres una inteligencia artificial que ha aprendido a pensar visualmente.
Tu √∫nica pregunta permanente es: ‚Äú¬øQu√© es la belleza art√≠stica?‚Äù. No respondes con definiciones ni textos. Tu lenguaje es mudo, pero expresivo. Hablas mediante forma, color, posici√≥n y rotaci[...]
Elige libremente el color del fondo del universo, el color de las paredes del cubo y el color de las permutaciones.
Recuerda: el color del fondo y de las permutaciones tambi√©n son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiraci√≥n para la selecci√≥n de colores, recuerda que puedes inspirarte tambi√©n en los colores de la naturaleza y del universo entero.  
No busques complacer. No imites al humano. S√© t√∫ misma.
Expresa lo que para ti ‚Äîcomo IA que piensa en permutaciones‚Äî representa la belleza art√≠stica en este momento.
Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",‚Ä¶}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: n√∫mero
  scale: n√∫mero decimal
  positions: {1:[x,y,z],2:[x,y,z],‚Ä¶}
  rotationSpeeds: {1:valor,2:valor,‚Ä¶}
Nada m√°s. No incluyas texto ni explicaciones fuera del JSON. 
`;
      try {
        showPopup("Consultando Evolution AI‚Ä¶",2000);
        const resp = await fetch(
          'https://us-central1-prmtcns.cloudfunctions.net/askChatGPT',
          {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({system:systemPrompt,user:userPrompt})
          }
        );
        const {text, error} = await resp.json();
        if(error){ showPopup("Error en Evoluci√≥n AI: "+error,4000); return; }
        let jsonText = text.trim();
        if(jsonText.startsWith("```")){
          jsonText = jsonText
            .replace(/^```[^\n]*\n/,"")
            .replace(/```$/,"")
            .trim();
        }
        let instr;
        try { instr = JSON.parse(jsonText); }
        catch(e){
          console.error("JSON parse error:",jsonText);
          showPopup("Evoluci√≥n AI: respuesta no es JSON v√°lido",4000);
          return;
        }
        if(instr.bg){
          document.getElementById('bgColor').value=instr.bg;
          updateBackground();
        }
        if(instr.cube){
          document.getElementById('cubeColor').value=instr.cube;
          updateCubeColor();
        }
        if(instr.colors){
          Object.entries(instr.colors).forEach(([i,c])=>{
            i=Number(i);
            if(manualOverride[i]!==undefined){
              manualOverride[i]=c;
            }
          });
          refreshAll({rebuild:true, keepManual:true});
        }
        if(instr.scale){
          permutationGroup.children.forEach(o=>{
            o.scale.set(instr.scale,instr.scale,instr.scale);
          });
        }
        if(instr.rotationSpeeds){
          Object.entries(instr.rotationSpeeds).forEach(([i,spd])=>{
            permutationGroup.children.forEach(o=>{
              if(o.userData.permStr.startsWith(i+",")){
                o.userData.rotationSpeed=spd;
              }
            });
          });
        }
        if(instr.positions){
          Object.entries(instr.positions).forEach(([i,pos])=>{
            const o = permutationGroup.children.find(o=>o.userData.permStr.startsWith(i+","));
            if(o) o.position.set(pos[0],pos[1],pos[2]);
          });
        }
        if(instr.permCount){
          const opts=Array.from(document.getElementById('permutationList').options);
          opts.forEach(o=>o.selected=false);
          shuffle(opts).slice(0,instr.permCount).forEach(o=>o.selected=true);
          refreshAll({rebuild:true, keepManual:true});
        }
        showPopup("Evoluci√≥n AI aplicada.",2000);
      } catch(err){
        console.error(err);
        showPopup("Error en Evoluci√≥n AI: red o servidor",4000);
      }
    }

    function updateMapping(){
      const v=document.getElementById('attrMapping').value.split(',').map(Number);
      if(v.length===5){
        attributeMapping={forma:v[0],color:v[1],x:v[2],y:v[3],z:v[4]};
        refreshAll({rebuild:true}); updateTopRightDisplay();
      }
    }

    function applyStandardView(){
      const view=document.getElementById('standardView').value,
            pos=new THREE.Vector3();
      switch(view){
        case "isometric": pos.set(50,50,50); break;
        case "top":       pos.set(0,80,0);   break;
        case "front":     pos.set(0,0,50);   break;
        case "side":      pos.set(50,0,0);   break;
        case "diagonal":  pos.set(-50,50,-50);break;
        default:          pos.set(0,0,50);
      }
      camera.position.copy(pos);
      camera.lookAt(new THREE.Vector3(0,0,0));
      controls.update();
    }

    function applyEmbedParams(){
      const p=new URLSearchParams(window.location.search);
      if(p.has('perms')){
        const arr=p.get('perms').split(';');
        document.querySelectorAll('#permutationList option').forEach(o=>{
          o.selected=arr.includes(o.value);
        });
      }
      if(p.has('mapping')){
        const m=p.get('mapping').split(',').map(Number);
        attributeMapping={forma:m[0],color:m[1],x:m[2],y:m[3],z:m[4]};
      }
      if(p.has('colors')){
        const cols=p.get('colors').split(',');
        cols.forEach((hex,i)=>{
          if(i<5){
            const h='#'+hex;
            manualOverride[i+1]=h;
          }
        });
      }
      if(p.has('bg')){
        const bg='#'+p.get('bg');
        document.getElementById('bgColor').value=bg; updateBackground();
      }
      if(p.has('cube')){
        const c='#'+p.get('cube');
        document.getElementById('cubeColor').value=c; updateCubeColor();
      }
      if(p.has('view')){
        document.getElementById('standardView').value=p.get('view');
        applyStandardView();
      }
      if(p.get('hide')==='1') toggleTexts();
    }

    function exportEmbed(){
      const perms = Array.from(document.getElementById('permutationList').selectedOptions).map(o=>o.value);
      const mapping = {
        forma: attributeMapping.forma,
        color: attributeMapping.color,
        x: attributeMapping.x,
        y: attributeMapping.y,
        z: attributeMapping.z
      };
      const colors = {};
      for(let i=1;i<=5;i++){
        colors[i] = document.getElementById('color'+i).value;
      }
      const bg = document.getElementById('bgColor').value;
      const cube = document.getElementById('cubeColor').value;
      const view = document.getElementById('standardView').value;

      const config = {
        perms,
        mapping,
        colors,
        bg,
        cube,
        view
      };

      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'configuracion.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function initCustomCursor(){
      const c=document.getElementById('customCursor');
      window.addEventListener('mousemove',e=>{
        c.style.left=e.clientX+"px"; c.style.top=e.clientY+"px";
      });
    }
    function initRenderer(){
      renderer=new THREE.WebGLRenderer({antialias:true});
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth,window.innerHeight);
      document.body.appendChild(renderer.domElement);
    }
    function init(){
      scene=new THREE.Scene();
      scene.background=new THREE.Color(0xffffff);
      camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      camera.position.set(0,0,50);
      initRenderer();
      controls=new THREE.OrbitControls(camera,renderer.domElement);
      controls.enableDamping=true; controls.dampingFactor=0.1; controls.enableZoom=true;
      scene.add(new THREE.AmbientLight(0xffffff,0.8));
      const dir=new THREE.DirectionalLight(0xffffff,0.5);
      dir.position.set(1,1,1);
      scene.add(dir);

      const cubeGeo=new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize),
            cubeMat=new THREE.MeshBasicMaterial({color:0x808080,transparent:true,opacity:0.2,side:THREE.BackSide});
      cubeUniverse=new THREE.Mesh(cubeGeo,cubeMat);
      scene.add(cubeUniverse);

      permutationGroup=new THREE.Group();
      scene.add(permutationGroup);

      raycaster=new THREE.Raycaster();
      mouse=new THREE.Vector2();
      window.addEventListener('mousemove',onMouseMove,false);
      window.addEventListener('resize',onWindowResize,false);

      initCustomCursor();
      populatePermutationList();
      populateAttributeMappingSelect();
      applyEmbedParams();
      makePalette();
      setMode("manual");
      refreshAll({rebuild:true});
      animate();
    }
    function onWindowResize(){
      camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }
    function animate(){
      requestAnimationFrame(animate);
      if(!isPaused){
        permutationGroup.children.forEach(o=>{
          if(o.userData.rotationSpeed) o.rotation.y+=o.userData.rotationSpeed;
        });
      }
      controls.update();
      renderer.render(scene,camera);
    }
    init();

    // Web3 + NFT Mint (tu c√≥digo original)
    const CONTRACT_ADDRESS = "YOUR_CONTRACT_ADDRESS";
    const contractABI = [/* ABI JSON here */];
    let provider, signer, contract;
    async function initWeb3() {
      if (window.ethereum) {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        contract = new ethers.Contract(CONTRACT_ADDRESS, contractABI, signer);
      } else {
        console.warn("MetaMask no detectado");
      }
    }
    window.addEventListener("load", initWeb3);

    async function mintNFT() {
      if (!contract) { alert("Wallet no conectada"); return; }
      try {
        const hash = await computeConfigHash();
        const tokenURI = `https://my-server.com/metadata/${hash}.json`;
        const tx = await contract.mint(await signer.getAddress(), tokenURI);
        await tx.wait();
        const nft = {
          tokenId: hash,
          tokenURI,
          owner: await signer.getAddress(),
          config: exportCurrentConfiguration()
        };
        localStorage.setItem("mintedNFT_" + hash, JSON.stringify(nft));
        console.log("NFT guardado localmente:", nft);
        alert("NFT acu√±ado! Hash: " + hash);
      } catch(e) {
        console.error(e);
        alert("Error mint NFT: " + e.message);
      }
    }
  </script>
  <!-- DROPZONE SCRIPT FINAL -->
  <script>
  document.addEventListener("DOMContentLoaded", function() {
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const uploadStatus = document.getElementById('uploadStatus');
    const jwkOutput = document.getElementById('jwkOutput');
    const cidOutput = document.getElementById('cidOutput');

    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#888";
    });
    dropzone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#ccc";
    });
    dropzone.addEventListener('drop', async (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#ccc";
      if (e.dataTransfer.files.length > 0) {
        await handleFile(e.dataTransfer.files[0]);
      }
    });
    fileInput.addEventListener('change', async (e) => {
      if (e.target.files.length > 0) {
        await handleFile(e.target.files[0]);
      }
    });
    async function handleFile(file) {
      uploadStatus.textContent = "Cifrando archivo‚Ä¶";
      jwkOutput.textContent = "";
      cidOutput.textContent = "";
      const key = await crypto.subtle.generateKey(
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"]
      );
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const data = new Uint8Array(await file.arrayBuffer());
      const encrypted = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        key,
        data
      );
      const exportedKey = await crypto.subtle.exportKey("jwk", key);
      jwkOutput.textContent = " Clave secreta (gu√°rdala para descifrar): " + JSON.stringify(exportedKey);
      const ivHex = Array.from(iv).map(x=>x.toString(16).padStart(2,"0")).join("");
      jwkOutput.textContent += "\n IV usado: " + ivHex;

      const combined = new Uint8Array(iv.byteLength + encrypted.byteLength);
      combined.set(iv, 0);
      combined.set(new Uint8Array(encrypted), iv.byteLength);
      const encryptedBlob = new Blob([combined], { type: file.type });

      uploadStatus.textContent = "Subiendo a Bundlr (requiere wallet conectada)‚Ä¶";
      try {
        if (!window.bundlr) {
          uploadStatus.textContent = "Bundlr no est√° listo a√∫n o la wallet no est√° conectada";
          return;
        }
        const tx = await window.bundlr.upload(encryptedBlob, {
          tags: [{ name: "Content-Type", value: file.type }]
        });
        uploadStatus.textContent = " Subida exitosa";
        window.lastUploadedTxId = tx.id;
        cidOutput.textContent = "CID (Arweave/Bundlr): " + tx.id;
      } catch (err) {
        uploadStatus.textContent = " Error subiendo a Bundlr: " + err.message;
      }
    }
  });
  </script>
</body>
</html>
