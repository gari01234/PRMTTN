<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>PRMTTN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Three .js + OrbitControls (una sola vez) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <!-- === tilers.js embebido (JS puro) — crea window.Tilers === -->
    <script type="module">
/* ───────── tilers (JS puro) — núcleo de ensambles multi-familia ───────── */
const PHI   = (1 + Math.sqrt(5)) / 2;
const ROOT2 = Math.SQRT2;
const ROOT3 = Math.sqrt(3);
const ROOT4 = Math.sqrt(4);   // = 2
const ROOT5 = Math.sqrt(5);
const EPS   = 1e-6;

/* util mínimo */
function near(a,b,eps=EPS){ return Math.abs(a-b) <= eps; }

/* ───────────── PRNG con SEED (mulberry32) ───────────── */
let __rng = Math.random;       // por defecto
let __seedU32 = 0;

function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function setSeed(u32){
  __seedU32 = (u32 >>> 0) || 1;
  __rng = mulberry32(__seedU32);
}
function rand(){ return __rng(); }
function randRange(a,b){ return a + (b-a) * rand(); }
function randBool(p=0.5){ return rand() < p; }

/* Catálogo de familias + alias proporcionales útiles para matching */
const families = [
  { id:'phi', r:PHI,   aliases:[1/PHI, 1-PHI**-1, PHI**2-PHI] },
  { id:'r2',  r:ROOT2, aliases:[1/ROOT2, 2-ROOT2] },
  { id:'r3',  r:ROOT3, aliases:[1/ROOT3, ROOT3-1, 1-(ROOT3-1)] },
  { id:'r4',  r:ROOT4, aliases:[1/ROOT4, 1] },
  { id:'r5',  r:ROOT5, aliases:[1/ROOT5, (ROOT5-2)] }
];

/* identifica familia por proximidad (tolerancia holgada para ratios derivados) */
function whichFamily(r, eps=2e-2){
  let best = null;
  for (const f of families){
    for (const c of [f.r, ...f.aliases]){
      const d = Math.abs(r - c);
      if (!best || d < best.d) best = { f:f.id, d };
    }
  }
  return (best && best.d <= eps) ? best.f : null;
}

/* familia dominante por “área” en el inventario; fallback φ */
function dominantFamily(inv){
  const acc = {phi:0,r2:0,r3:0,r4:0,r5:0};
  (inv?.ratios||[]).forEach(it=>{
    const fam = whichFamily(it.r) ?? 'phi';
    acc[fam] += it.area || 0;
  });
  return Object.keys(acc).reduce((best,f)=> acc[f]>acc[best]?f:best,'phi');
}

/* ---------- 1) Euclid / Continued Fraction → mosaico de cuadrados ---------- */
function tilesEuclid(b, r, tag='euclid'){
  const out=[];
  let x=b.x, y=b.y, w=b.w, h=b.h;

  const orient = (w>=h) ? 1 : -1;     // 1 vertical; -1 horizontal
  if (orient<0){ [w,h] = [h,w]; }

  let W=w, H=h;
  let baseX=0, baseY=0;
  while (W > EPS && H > EPS){
    const q = Math.floor(W / H + EPS);
    for (let i=0;i<q;i++){
      const rect = orient>0
        ? { x: b.x + baseX + i*H, y: b.y + baseY, w: H, h: H, tag }
        : { x: b.x + baseY,       y: b.y + baseX + i*H, w: H, h: H, tag };
      out.push(rect);
    }
    const rem = W - q*H;
    if (rem <= EPS) break;
    if (orient>0){ baseX += q*H; } else { baseY += q*H; }
    W = H; H = rem;
  }
  return out;
}

/* ---------- 2) Beatty / Sturmian (dos tamaños L/S) ---------- */
function beattyPairFor(f){
  if (f==='phi'){ return [PHI*PHI, (PHI*PHI)/(PHI*PHI-1)]; }
  if (f==='r2'){  const a=1+ROOT2; return [a, a/(a-1)]; }
  if (f==='r3'){  const a=1+ROOT3; return [a, a/(a-1)]; }
  if (f==='r4'){  const a=1+ROOT4; return [a, a/(a-1)]; }
  const a=1+ROOT5; return [a, a/(a-1)];
}
function tilesBeatty(b, f, majorFirst=true, tag='beatty'){
  const [alpha] = beattyPairFor(f);
  const N = Math.max(2, Math.round(b.w / (b.h*0.25)));
  const seq = [];
  for (let k=1;k<=N;k++){
    const LA = Math.floor(k*alpha) - Math.floor((k-1)*alpha);
    seq.push(LA===2); // true=L, false=S
  }

  const rVal = (f==='phi'?PHI : f==='r2'?ROOT2 : f==='r3'?ROOT3 : f==='r4'?ROOT4 : ROOT5);
  const L =  majorFirst ? b.h           : b.h / rVal;
  const S =  majorFirst ? b.h / rVal    : b.h;

  const wL = 1.0, wS = 1/(alpha-1);
  const widths = seq.map(s => s ? wL : wS);
  const sum = widths.reduce((a,c)=>a+c,0);
  const kscale = b.w / sum;

  let x = b.x;
  const out = [];
  for (let i=0;i<widths.length;i++){
    const cw = widths[i]*kscale;
    const ch = seq[i] ? L : S;
    out.push({x, y:b.y, w:cw, h:ch, tag});
    if (ch < b.h - EPS){
      out.push({x, y:b.y+ch, w:cw, h:b.h-ch, tag});
    }
    x += cw;
    if (x > b.x + b.w - EPS) break;
  }
  return out;
}

/* ---------- 3) Sustitución inflacionaria (Fibo/Pell/√3) ---------- */
function substRules(f){
  if (f==='phi') return ['LS','L'];      // Fibonacci
  if (f==='r2')  return ['LSS','L'];     // tipo Pell
  if (f==='r3')  return ['LLS','L'];     // √3
  return null;                           // r4/r5 → sin reglas específicas (fallback)
}
function tilesSubstitution(b, f, iters=6, tag='subst'){
  const rules = substRules(f);
  if (!rules){
    return tilesBeatty(b, f, true, 'beatty');
  }
  let word = 'L';
  const [RL,RS] = rules;
  for (let i=0;i<iters;i++){
    let next=''; for (const ch of word) next += (ch==='L'?RL:RS);
    word = next;
  }
  const rVal = (f==='phi'?PHI : f==='r2'?ROOT2 : ROOT3);
  const wL = 1, wS = 1 / rVal;
  const widths = [...word].map(ch => ch==='L'?wL:wS);
  const sum = widths.reduce((a,c)=>a+c,0);
  const kscale = b.w / sum;
  let x = b.x;
  const out = [];
  for (const ch of word){
    const cw = (ch==='L'?wL:wS)*kscale;
    out.push({x, y:b.y, w:cw, h:b.h, tag});
    x += cw;
    if (x > b.x + b.w - EPS) break;
  }
  return out;
}

/* ---------- 4) NUEVO: BSP “split-rect” con alternancia H/V, ratio 0.35–0.65,
                        tamaño mínimo de celda y fusión de adyacentes ---------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function tilesBSP(b, opt={}){
  const minCell   = Math.max(0, opt.minCell || 3.0);
  const rMin      = clamp(opt.ratioMin ?? 0.35, 0.05, 0.95);
  const rMax      = clamp(opt.ratioMax ?? 0.65, rMin, 0.95);
  const targetN   = Array.isArray(opt.targetN) ? Math.round(
                      clamp(Math.floor(randRange(opt.targetN[0], opt.targetN[1]+1)), 2, 64)
                    ) : Math.round(clamp(opt.targetN || 10, 2, 64));
  const mergeProb = clamp(opt.mergeProb ?? 0.25, 0, 1);

  const out = [];

  function splitRect(R, lastOrient){
    // condición de parada: objetivo de celdas y tamaño mínimo
    const canV = (R.w >= 2*minCell + EPS);
    const canH = (R.h >= 2*minCell + EPS);

    if (out.length >= targetN || (!canV && !canH)){
      out.push({ x:R.x, y:R.y, w:R.w, h:R.h, tag:'bsp' });
      return;
    }

    // alternancia “suave”: 70% alterna respecto a la anterior; si no, decide por aspecto
    let orient;
    if (lastOrient && rand() < 0.70){
      orient = (lastOrient==='H' ? 'V' : 'H');
    } else {
      if (R.w / Math.max(R.h, EPS) > 1.25) orient = 'V';
      else if (R.h / Math.max(R.w, EPS) > 1.25) orient = 'H';
      else orient = randBool() ? 'V' : 'H';
    }

    if (orient==='V' && !canV) orient='H';
    if (orient==='H' && !canH) orient='V';

    if (orient==='V'){
      // ratio limitado por minCell
      let r = clamp(randRange(rMin, rMax), minCell / R.w, 1 - (minCell / R.w));
      const w1 = Math.max(minCell, R.w * r);
      const w2 = R.w - w1;
      const L = { x:R.x,       y:R.y, w:w1, h:R.h };
      const Rr= { x:R.x + w1, y:R.y, w:w2, h:R.h };
      splitRect(L, 'V'); splitRect(Rr, 'V');
    } else {
      let r = clamp(randRange(rMin, rMax), minCell / R.h, 1 - (minCell / R.h));
      const h1 = Math.max(minCell, R.h * r);
      const h2 = R.h - h1;
      const T = { x:R.x, y:R.y,        w:R.w, h:h1 };
      const B = { x:R.x, y:R.y + h1,   w:R.w, h:h2 };
      splitRect(T, 'H'); splitRect(B, 'H');
    }
  }

  splitRect(b, null);

  // — FUSIÓN DE CELDAS ADYACENTES (25% por defecto) —
  function tryMerge(a,b){
    // horizontal: misma y, misma h, tocan por x
    if (near(a.y,b.y) && near(a.h,b.h) && (near(a.x + a.w, b.x) || near(b.x + b.w, a.x))){
      const x = Math.min(a.x,b.x);
      const w = a.w + b.w;
      return { x, y:a.y, w, h:a.h, tag:'bsp-merged' };
    }
    // vertical: misma x, misma w, tocan por y
    if (near(a.x,b.x) && near(a.w,b.w) && (near(a.y + a.h, b.y) || near(b.y + b.h, a.y))){
      const y = Math.min(a.y,b.y);
      const h = a.h + b.h;
      return { x:a.x, y, w:a.w, h, tag:'bsp-merged' };
    }
    return null;
  }

  if (out.length > 2 && mergeProb > 0){
    // intentos acotados para no ciclar
    for (let pass=0; pass<3; pass++){
      let merged = false;
      for (let i=0; i<out.length && !merged; i++){
        for (let j=i+1; j<out.length && !merged; j++){
          if (randBool(mergeProb)){
            const m = tryMerge(out[i], out[j]);
            if (m){
              const a = out[i], b = out[j];
              out.splice(j,1); out.splice(i,1); // quita b luego a
              out.push(m);
              merged = true;
            }
          }
        }
      }
      if (!merged) break;
    }
  }

  return out;
}

/* ---------- 5) Orquestador con alternancia de estrategias + BSP ---------- */
function fillByStrategy(rect, fam, strategy){
  if (strategy==='beatty') return tilesBeatty(rect, fam, true, 'beatty');
  if (strategy==='subst')  return tilesSubstitution(rect, fam, 7, 'subst'); // r4/r5 → Beatty
  return tilesEuclid(rect, rect.w/rect.h, 'euclid-in-band');
}

function assemble(b, inv, opt={}){
  // Semilla del motor (si viene) — mismo PRNG para todo
  if (typeof opt.rndSeed === 'number') setSeed(opt.rndSeed);

  const fam = (opt.familyId && ['phi','r2','r3','r4','r5'].includes(opt.familyId))
    ? opt.familyId
    : dominantFamily(inv || {ratios:[]});

  const rBox = Math.max(b.w,b.h) / Math.min(b.w,b.h);

  // ——— Picker de “plantilla” ponderado (si no nos forzan un engine)
  let engine = opt.engine || (()=>{
    const roll = rand();
    if (roll < 0.50) return 'bsp';
    if (roll < 0.85) return 'bands';
    if (roll < 0.95) return 'beatty';
    return 'spiral';
  })();

  // ——— Ejecuta el motor elegido (sin returns tempranos que anulen ramas) ———
  let rects = [];

  if (engine === 'bsp'){
    rects = tilesBSP(b, {
      minCell   : opt.minCell ?? 3.0,
      ratioMin  : opt.ratioMin ?? 0.35,
      ratioMax  : opt.ratioMax ?? 0.65,
      targetN   : opt.targetN  ?? [6,14],
      mergeProb : opt.mergeProb ?? 0.25
    });
  } else if (engine === 'bands'){
    // bandas euclidianas + ciclo de estrategias (ponderado si no nos dan uno)
    const cycle = Array.isArray(opt.strategyCycle) && opt.strategyCycle.length
      ? opt.strategyCycle
      : (rand()<0.5 ? ['beatty','euclid','subst'] : ['euclid','beatty','subst']);
    const bands = tilesEuclid(b, rBox, 'euclid-band');
    for (let i=0;i<bands.length;i++){
      const strat = cycle[i % cycle.length];
      rects.push(...fillByStrategy(bands[i], fam, strat));
    }
  } else if (engine === 'beatty'){
    rects = tilesBeatty(b, fam, true, 'beatty');
  } else if (engine === 'spiral'){
    rects = tilesSubstitution(b, fam, 7, 'subst');
  } else {
    // fallback robusto → bands
    const bands = tilesEuclid(b, rBox, 'euclid-band');
    for (const band of bands){
      rects.push(...tilesBeatty(
        { x:band.x, y:band.y, w:band.w, h:band.h }, fam, true, 'beatty-in-band'
      ));
    }
  }

  return rects;
}

/* exporta en global */
window.Tilers = {
  PHI, ROOT2, ROOT3, ROOT4, ROOT5,
  families, whichFamily,
  assemble,
  // PRNG público para trazabilidad / tests
  setSeed,
  get seed(){ return __seedU32; }
};
    </script>
  <style>
  body {
    margin: 0;
    overflow: hidden;
    background: #ffffff;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-weight: 200;
    font-size: 12px;
    cursor: none;
  }
  #customCursor {
    position: fixed;
    width: 12px; height: 12px;
    border-radius: 50%;
    background: #000;
    border: 1px solid #fff;
    pointer-events: none; z-index: 300;
    transform: translate(-50%, -50%);
  }
  /* HUD eliminado */
  #topRightDisplay{
    display:none !important;
  }
  button{
    cursor:none;
    border:none;
    border-radius:4px;
    padding:8px 12px;
    font-size:12px;
    z-index:250;
    background:rgba(255,255,255,0.12);
    transition:background 0.2s;
  }
  button:hover{
    background:rgba(255,255,255,0.20);
  }

  #patternNextButton,
  #engineCycleButton,
  #permNextButton{
    position:fixed; z-index:260;                /* siempre encima */
    border:none; border-radius:4px;
    padding:8px 12px; font-size:12px;
    background:rgba(255,255,255,0.12);
    cursor:none; display:none;                  /* ocultos por defecto */
    transition:background .2s;
  }
  #patternNextButton:hover,
  #engineCycleButton:hover,
  #permNextButton:hover{
    background:rgba(255,255,255,0.20);
  }
  #patternNextButton{left:10px;  top:10px;}     /* 1 · patrón siguiente   */
  #engineCycleButton {left:10px;  bottom:10px;} /* 2 · motor siguiente     */
  #permNextButton   {right:10px; top:10px;}     /* 3 · NEXT (120 perms)    */

  /* === LAYOUT (orden y ESPACIADO nuevos) === */
  #toggleTextButton     { position:fixed; right:10px; bottom:10px;   }   /* Minimal UI */
  #aiPlanningButton     { position:fixed; right:10px; bottom:50px;   }   /* AI Planning */
  #saveImageButton      { position:fixed; right:10px; bottom:90px;  }   /* Save Image (A2) – debajo de Load JSON */
  #uploadConfigButton   { position:fixed; right:10px; bottom:130px;  }   /* Load JSON */
  #exportEmbedButton    { position:fixed; right:10px; bottom:170px;  }   /* Save JSON */
  #archDescButton       { position:fixed; right:10px; bottom:210px;  }   /* Architectural Description */
  #perm120Button        { position:fixed; right:10px; bottom:250px;  }   /* 120 Architectural Permutations */
#randomConfigButton   { position:fixed; left:10px; bottom:130px;  }   /* BUILD  */
   #certButton           { position:fixed; right:10px; bottom:30px; }   /* Edition Certificate */
  /* === FRBN toggle === */
#frbnWrap { position:fixed; left:10px; bottom:90px; z-index:260; }
#frbnButton { position:relative; }  /* dentro del wrap */
#frbnInfoButton{
  position:absolute; top:-6px; right:-6px;
  padding:2px 6px; font-size:10px; opacity:.9;
  background:rgba(255,255,255,0.2);
}

  #saveImageButton { background:rgba(255,255,255,0.2); }

  /* Ocultar los no usados */
  #btnDebugColors,
  #triadicConfigButton{
    display:none !important;
  }

  #controls {
    position: absolute; top: 10px; left: 10px; z-index: 100;
    padding: 10px; border-radius: 5px;
    background: rgba(255,255,255,0.12); max-width: 350px;
  }
  details {
    margin-bottom: 10px;
    background: rgba(255,255,255,0.06);
  }
  details summary { font-weight: 200; cursor: pointer; }
  details summary:hover { color: #333; }
  select, input[type="range"], input[type="color"] { cursor: none; width: 100%; }
  #permutationList { width: 100%; height: 100px; }


  #hoverPopup {
    position:absolute; padding:5px 10px;
    background:rgba(0,0,0,0.7); color:#fff;
    border-radius:4px; pointer-events:none;
    font-size:12px; display:none; opacity:0;
    transition:opacity .3s; z-index:200;
  }


  /* Panel BUILD */
  #archPanel{
    position:fixed; z-index:1000; top:5%; left:50%;
    transform:translateX(-50%);
    width:85%; height:90%;
    background:#fff; color:#000;
    border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
    padding:24px 32px 48px; overflow:auto;
    font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size:14px; line-height:1.4;
    cursor:auto;
  }
  #archPanel *{ cursor:auto !important; }
  #archClose{
    position:fixed; right:calc(7.5% + 16px); top:5%;
    border:none; padding:6px 10px; border-radius:4px;
    background:#eee; cursor:pointer; z-index:1001;
  }
  #archPanel h2{ margin-top:0; }
  #archPanel .formula{
    margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
  }
  #archPanel .box{
    display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
    font-family:monospace;
  }
  #archPanel section{ margin-bottom:18px; }
  #archPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
  #archPanel .perm h4{ margin-bottom:6px; }
  code, pre{ font-family:monospace; }

  /* Panel 120 perms */
  #perm120Panel{
    position:fixed; right:10px; bottom:340px; z-index:260;
    background:rgba(255,255,255,0.12);
    padding:8px 10px; border-radius:4px; width:260px;
    display:none; /* ← cerrado por defecto */
  }
  #perm120Panel label{ display:block; margin-bottom:6px; }
  #perm120Panel input, #perm120Panel button{ width:100%; margin-top:4px; }
  #perm120Status{
    margin-top:8px;
    font-size:12px;       /* ← mismo tamaño que los demás */
    font-weight:normal;
    text-align:center;
  }
  /* === Information button & panel === */
  #infoButton{
    position:fixed; left:10px; bottom:10px; z-index:260;
  }
  #infoPanel{
    position:fixed; z-index:1000; top:5%; left:50%;
    transform:translateX(-50%);
    width:85%; height:90%;
    background:#fff; color:#000;
    border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
    padding:24px 32px 48px; overflow:auto;
    font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size:14px; line-height:1.45;
    cursor:auto;
  }
  #infoPanel *{ cursor:auto !important; }
  #infoClose{
    position:fixed; right:calc(7.5% + 16px); top:5%;
    border:none; padding:6px 10px; border-radius:4px;
    background:#eee; cursor:pointer; z-index:1001;
  }
  #infoPanel h2{ margin-top:0; }
  #infoPanel .formula{
    margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
  }
  #infoPanel .box{
    display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
    font-family:monospace;
  }
  #infoPanel section{ margin-bottom:18px; }
  #infoPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
  /* === LCHT toggle === */
  #lchtWrap  { position:fixed; left:10px; bottom:50px; z-index:260; }
  #lchtButton{ position:relative; }

  /* === OFFNNG toggle === */
  #offnngButton{
    position:fixed; left:10px; bottom:290px;   /* 40 px por encima de PLAY (170) */
    z-index:260;
  }

  #tmslButton{
    position:fixed; left:10px; bottom:330px;   /* mismo look & feel */
    z-index:260;
    border:none; border-radius:4px;
    padding:8px 12px; font-size:12px;
    background:rgba(255,255,255,0.12);
    cursor:none; transition:background .2s;
  }
  #tmslButton:hover{ background:rgba(255,255,255,0.20); }

  /* === ENGINE MENU (reemplaza botones sueltos) === */
  #engineSelectWrap {
    position: fixed;
    left: 10px;
    bottom: 290px;      /* ocupa el lugar que usaba OFFNNG, sin solapar PLAY/BUILD antiguos */
    z-index: 260;
    background: rgba(255,255,255,0.12);
    padding: 6px 8px;
    border-radius: 4px;
  }
  #engineSelectWrap select {
    width: 180px;       /* ancho cómodo; no usamos 100% para no romper layout */
    cursor: none;
  }
  #engineSelectWrap label {
    font-size: 12px;
    opacity: .85;
  }

  /* Botón PLAY – genera nuevas permutaciones */
  #playButton{
    position:fixed;               /* mismo estilo general */
    left:10px; bottom:170px;      /* 40 px por encima de BUILD (130 px) */
    z-index:260;
    border:none; border-radius:4px;
    padding:8px 12px;
    font-size:18px;               /* el símbolo se ve claro */
    background:rgba(0,0,0,0.12);
    cursor:none; transition:background .2s;
  }
  #playButton:hover{ background:rgba(0,0,0,0.20); }
  </style>
</head>
<body>
  <div id="customCursor"></div>
  <button id="patternNextButton" onclick="cyclePattern()">11</button>
  <button id="engineCycleButton"  onclick="cycleEngine()">4</button>
  <button id="permNextButton"     onclick="nextPerm120()">120</button>
  <div id="topRightDisplay"></div>

  <input type="file" id="json-upload" accept=".json" style="display:none;" />

  <button id="aiPlanningButton"   onclick="applyEvolutionAI()">AI Planning</button>
  <button id="toggleTextButton"   onclick="toggleTexts()">Minimal UI</button>
  <button id="uploadConfigButton" onclick="document.getElementById('json-upload').click()">Load JSON</button>
  <button id="saveImageButton"    onclick="saveImage()">Save Image (A2)</button>
  <button id="exportEmbedButton"  onclick="exportEmbed()">Save JSON</button>
  <button id="archDescButton"     onclick="showArchitecturalDescription()">Architectural Description</button>
  <!-- NUEVO: Play (genera nueva configuración) -->
  <button id="playButton" onclick="generateRandomConfigurationNoCollision()">▮</button>

  <button id="perm120Button"      onclick="togglePerm120Panel()">120 Architectural Permutations</button>

  <!-- NUEVO: Menú de motores -->
  <div id="engineSelectWrap">
    <label for="engineSelect" style="display:block;margin-bottom:4px;">Engine</label>
    <select id="engineSelect" onchange="applyEngineFromSelect(this.value)">
      <option value="BUILD">BUILD</option>
      <option value="FRBN">FRBN</option>
      <option value="LCHT">LCHT</option>
      <option value="OFFNNG">OFFNNG</option>
      <option value="TMSL">TMSL</option>
      <option value="RAUM">RAUM</option>
      <option value="13245">13245</option>
      <option value="R5NOVA">R5NOVA</option>
    </select>
  </div>

  <button id="certButton" onclick="exportEditionCertificate()">Edition Certificate</button>
  <button id="infoButton" onclick="showInformation()">Information</button>
  <button id="btnDebugColors"
          style="position:fixed;bottom:180px;right:10px;z-index:260;display:none;"
          onclick="mostrarDebugColores()">
    Debug Colors
  </button>

  <!-- Panel controles 120 perms -->
  <div id="perm120Panel">
    <label>Auto‑advance (1s → 12m)</label>
    <input type="range" id="perm120Slider" min="1000" max="720000" step="1000" value="5000"
           oninput="syncPerm120InputsFromSlider()">
    <input type="number" id="perm120Seconds" min="1" max="720" value="5"
           oninput="syncPerm120SliderFromSeconds()">
    <small>(seconds)</small>
    <button onclick="playPerm120()">Play</button>
    <button onclick="pausePerm120()">Pause</button>
    <button onclick="prevPerm120()">Prev</button>
    <button onclick="nextPerm120()">Next</button>
    <button onclick="showPerm120Info()">Information</button>
    <div id="perm120Status">Permutation: 0 / 119</div>
  </div>


  <div id="controls">
  <details open>
    <summary>Chromatic Pattern</summary>
          <select id="patternSelect" onchange="setActivePattern(this.value)">
        <option value="1">1 · Chromatic Containment</option>
        <option value="2">2 · Contrast &amp; Dissonance</option>
        <option value="3">3 · Non‑semantic Disposition</option>
        <option value="4">4 · Structured Ambiguity</option>
        <option value="5">5 · Chromatic Isotropy</option>
        <option value="6">6 · Self‑Sufficient Presence</option>
        <option value="7">7 · Associative Asymmetry</option>
        <option value="8">8 · Irregular Dynamics</option>
        <option value="9">9 · Habitable without Translation</option>
        <option value="10">10 · Resonance</option>
        <option value="11">11 · Active Transparency</option>
      </select>
      <button id="patternInfoButton"
              style="margin-top:6px;width:100%;"
              onclick="showPatternInfo()">
        Pattern Information
      </button>

  </details>

  <div id="manualControls">
    <details>
      <summary>Select Permutations</summary>
      <select id="permutationList" multiple></select>
      <button onclick="refreshAll({rebuild:true})">Render</button>
    </details>
  </div>


  <details>
    <summary>Manual Colors (override)</summary>
    <div><label>1: <input type="color" id="color1" onchange="onColourPick(1,this.value)"></label></div>
    <div><label>2: <input type="color" id="color2" onchange="onColourPick(2,this.value)"></label></div>
    <div><label>3: <input type="color" id="color3" onchange="onColourPick(3,this.value)"></label></div>
    <div><label>4: <input type="color" id="color4" onchange="onColourPick(4,this.value)"></label></div>
    <div><label>5: <input type="color" id="color5" onchange="onColourPick(5,this.value)"></label></div>
    <button id="btnResetAll" style="margin-top:6px;" onclick="resetAllColours()">
      Reset Background + Walls + Colors
    </button>
  </details>

  <details>
    <summary>Background</summary>
    <input type="color" id="bgColor" value="#ffffff">
    <button onclick="updateBackground()">Apply Background</button>
  </details>

  <details>
    <summary>Cube Walls Color</summary>
    <input type="color" id="cubeColor" value="#808080">
    <button onclick="updateCubeColor()">Apply Cube Walls</button>
  </details>

  <details>
    <summary>Attributes Reorganization</summary>
    <select id="attrMapping"></select>
    <button onclick="updateMapping()">Apply</button>
    <button onclick="autoResolveColisionesGlobal()">Resolve Collisions</button>
  </details>

  <details>
    <summary>Standard Views</summary>
    <select id="standardView">
      <option value="isometric">Isometric</option>
      <option value="top">Top</option>
      <option value="front" selected>Front</option>
      <option value="side">Side</option>
      <option value="diagonal">Opposite diagonal</option>
    </select>
    <button onclick="applyStandardView()">Apply View</button>
  </details>

  <details>
    <summary>Zoom Controls</summary>
    <button onclick="zoomIn()">Zoom In</button>
    <button onclick="zoomOut()">Zoom Out</button>
  </details>

  <details>
    <summary>Motion Controls</summary>
    <button onclick="togglePause()">Pause Motion</button>
    <button onclick="resetMovement()">Reset Motion</button>
  </details>
</div>


<script>
document.getElementById('json-upload').addEventListener('change', function(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const config = JSON.parse(e.target.result);

      // Permutations
      if (config.perms && Array.isArray(config.perms)) {
        const sel = document.getElementById('permutationList');
        Array.from(sel.options).forEach(o => o.selected = config.perms.includes(o.value));
      }

      // Mapping
      if (config.mapping) {
        const v = [config.mapping.forma, config.mapping.color, config.mapping.x, config.mapping.y, config.mapping.z];
        document.getElementById('attrMapping').value = v.join(',');
        attributeMapping = [v[0], v[1], v[2], v[3], v[4], attributeMapping[5], attributeMapping[6]];
      }

      // Pattern
      if (typeof config.pattern === 'number') {
        activePatternId = config.pattern;
        const selPattern = document.getElementById('patternSelect');
        if (selPattern) selPattern.value = String(config.pattern);
      }

      // Manual colors
      if (config.colors) {
        manualOverride = {};
        Object.entries(config.colors).forEach(([i, c]) => {
          manualOverride[Number(i)] = c;
        });
      }

      // BG / cube
      if (config.bg) {
        document.getElementById('bgColor').value = config.bg;
        bgOverride = config.bg;
      }
      if (config.cube) {
        document.getElementById('cubeColor').value = config.cube;
        cubeOverride = config.cube;
      }

      // Scene invariants (optional)
      if (typeof config.sceneSeed === 'number') {
        sceneSeed = config.sceneSeed;
      }
      if (typeof config.S_global === 'number') {
        S_global = config.S_global;
      }

      // View
      const view = config.view || "front";
      document.getElementById('standardView').value = view;

      // Rebuild
      refreshAll({rebuild:true, keepManual:true});
      applyStandardView();

      alert('JSON loaded successfully');
    } catch (err) {
      alert('Error loading JSON: ' + err.message);
    }
  };
  reader.readAsText(file);
});
</script>


  <div id="hoverPopup"></div>

  <!-- (eliminados: copias duplicadas de Three, OrbitControls y Ethers) -->
  <script>
    // ------------- TODO EL JS ORIGINAL (¡NO QUITES NADA DE AQUÍ!) -------------

    // === Variables globales ===
    let scene, camera, renderer, controls, raycaster, mouse;
    let cubeUniverse, permutationGroup;
    const cubeSize = 30, segment = cubeSize/5, halfCube = cubeSize/2;

    // === R5NOVA — configuración AISLADA (sin depender de otros motores) ===
    // Todo lo de R5NOVA toma estos valores y NADA más.
    const R5NOVA_CFG = {
      // Selección de “fila del fondo”: usamos minZ del AABB en mundo
      BACK_BAND     : 1.8,          // ancho de la rebanada desde zMin (en unidades de mundo)

      // Grosor objetivo de TODAS las piezas de esa fila (en unidades de mundo, no relativas)
      BACK_THICKNESS: 0.18,         // pon 0.10–0.40 para probar cambios visibles

      // Material ‘flat’ por defecto (sin luces) para aislar color de la iluminación global
      MATERIAL      : 'basic',      // 'basic' (flat) o 'lambert' si prefieres difuso

      // “Secuencia dorada” 100% determinista para evitar repeticiones de tono
      HUE_BASE      : 0.0,                             // grados
      HUE_STEP      : 137.50776405003785,              // ángulo áureo (evita ciclos cortos)
      SAT           : 0.86,                            // 0..1
      VAL           : 0.92,                            // 0..1
      MIN_HUE_DIFF  : 12,                               // separación mínima entre tonos (grados)

      // Mantener legibilidad frente al fondo (puedes poner false si no lo quieres)
      ENSURE_CONTRAST: true
    };

    const EPS = 1e-6;
    let isPaused = false, currentMode = "manual", userRating = null, textsVisible = true;
    let attributeMapping = [0,1,2,3,4, 0,1];   // forma,color,x,y,z,bg,wall
    let colorAttrCycle = 0;                    // ← cuenta las rotaciones de color
    let paletteRGB = [];
    let manualOverride = {1:'#ff0000',2:'#00ff00',3:'#0000ff',4:'#ff00ff',5:'#00ffff'};
    let bgOverride   = null;
    let cubeOverride = null;
    /* variables globales para fondo y paredes */
    let bgHSV = {h:0,s:0,v:1};
    let wallHSV = {h:0,s:0,v:1};
    let  currentHarmony = 'triad';
    let activePatternId = 1;           // arranca en Contención
      const ΔE_MIN = 20;

      // >>> NUEVO:
      let S_global = 0; // término estructural para posiciones (Shift-Rank acoplado)
      let avgSceneRange = 0;          // 2 … 6  →  se usa como factor de velocidad

      /* ─────────────────────────────
       *   FRBN  ·  deterministic Ganzfeld
       * ───────────────────────────── */
    let skySphere = null;
    let isFRBN    = false;
    const SKY_R = 250;


/* ──────────────────────────────────────────────────────────────
 *  initSkySphere — FRBN con micro-ruido “blue-noise” y highp
 *  (solo afecta al fondo shader del modo FRBN)
 * ──────────────────────────────────────────────────────────── */
function initSkySphere() {
  const geo = new THREE.PlaneGeometry(2, 2);

  const mat = new THREE.ShaderMaterial({
    uniforms : {
      u_count     : { value: 0 },
      u_colors    : { value: Array(12).fill(new THREE.Color(0x000000)) },
      time        : { value: 0 },
      u_rate      : { value: 0.04 },
      // amplitud del dither (ajústala si quieres): ~1/1024
      u_ditherAmp : { value: 0.00095 }
    },
    side: THREE.DoubleSide,
    depthWrite: false,
    depthTest : false,
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position.xy, 0.0, 1.0);
      }`,
    fragmentShader: `
      #ifdef GL_ES
      precision highp float;
      #endif

      uniform int   u_count;
      uniform vec3  u_colors[12];
      uniform float time;
      uniform float u_rate;
      uniform float u_ditherAmp;
      varying vec2  vUv;

      // Interleaved Gradient Noise (Jimenez 2014) – base para blue-noise temporal
      float ign(vec2 p, float t){
        const vec3 a = vec3(0.06711056, 0.00583715, 52.9829189);
        return fract(a.z * fract(dot(p, a.xy) + t * a.y));
      }

      // Tres canales ligeramente des-correlacionados
      vec3 blueNoise(vec2 pix, float t){
        float n1 = ign(pix,           t);
        float n2 = ign(pix + vec2(113.1,  1.7), t + 17.0);
        float n3 = ign(pix + vec2( 27.0, 61.7), t + 31.0);
        // centrar en 0 y estrechar (distribución casi triangular)
        n1 = (n1 + ign(pix*1.07+3.1, t*1.3)) * 0.5;
        return vec3(n1, n2, n3) - 0.5;
      }

      void main() {
        // mezcla cromática ligada al tiempo/escena
        float t = time * u_rate;
        float idx = fract(t) * float(u_count);
        int   i   = int(floor(idx)) % u_count;
        int   j   = (i + 1) % u_count;
        float f   = fract(idx);

        vec3 col = mix(u_colors[i], u_colors[j], f);

        // respiración suave radial (ligeramente más blanda)
        vec2 cUv = vUv - 0.5;
        float d  = length(cUv) * 2.0;
        float fog = pow(1.0 - smoothstep(0.0, 1.0, d), 2.0);
        col += 0.10 * fog;

        // micro-dither spatio-temporal para romper banding (en espacio lineal)
        // usa coordenada de pixel (gl_FragCoord.xy) y el tiempo para “blue-shift”
        vec3 dither = blueNoise(gl_FragCoord.xy, time * 60.0);
        col += u_ditherAmp * dither;

        gl_FragColor = vec4(clamp(col, 0.0, 1.0), 1.0);
      }`
  });

  const plane = new THREE.Mesh(geo, mat);
  plane.frustumCulled = false;
  plane.visible = false;
  skySphere = plane;
  scene.add(skySphere);
}
    /* ---------- extrae TODOS los colores deterministas del sistema ---------- */
    function collectSceneColors(){
      // 1) Todos los RGB deterministas
      const raw = [];
      permutationGroup.traverse(o=>{
        if(o.isMesh) raw.push(o.material.color.clone());
      });

      // 2) Normaliza a S≥0.60  V≥0.80  (más extremos)
      const boosted = raw.map(c=>{
        let [h,s,v] = rgbToHsv(c.r*255,c.g*255,c.b*255);
        s = Math.max(s, 0.60);
        v = Math.max(v, 0.80);
        const [R,G,B] = hsvToRgb(h,s,v);
        return new THREE.Color(R/255,G/255,B/255);
      });

      // 3) Agrupa por ΔH≥18°  (dejamos tonos bien separados)
      const uniq = [];
      boosted.forEach(c=>{
        const [h] = rgbToHsv(c.r*255,c.g*255,c.b*255);
        if(!uniq.some(u=>{
          const [hu] = rgbToHsv(u.r*255,u.g*255,u.b*255);
          return Math.abs(hu-h) < 18;
        })){
          uniq.push(c);
        }
      });

      // 4) Si siguen faltando, completa con rueda de color base
      const fallback = [
        0,60,120,180,240,300
      ].map(h=>{
        const [R,G,B] = hsvToRgb(h,0.75,0.85);
        return new THREE.Color(R/255,G/255,B/255);
      });
      while(uniq.length < 6) uniq.push( fallback[uniq.length] );

      // → devolvemos máx. 8 primeros
      return uniq.slice(0,8);
    }


    /* ---------- actualiza uniforms del shader con la paleta elegida ---------- */
    function buildGanzfeld(){
      if(!skySphere) initSkySphere();

      /* ---------- 1) paleta determinista ---------- */
      const cols = collectSceneColors();
      const n    = cols.length;
      const mat  = skySphere.material;
      mat.uniforms.u_count.value = n;
      for(let i=0;i<12;i++){
        mat.uniforms.u_colors.value[i] = cols[i % n];
      }

      /* ---------- 2) velocidad ligada al movimiento ---------- */
      let sum=0, cnt=0;
      permutationGroup.traverse(o=>{
        if(o.isMesh && o.userData.rotationSpeed){
          sum += o.userData.rotationSpeed;
          cnt ++;
        }
      });
      const avg = cnt ? sum/cnt : 0.002;
      mat.uniforms.u_rate.value = avg * 1;
    }

    /* ---------- bot\u00f3n FRBN: ON/OFF  (Riesgos 2 y 3 integrados) --------------- */
    function toggleFRBN () {
      if (!isFRBN && isOFFNNG) toggleOFFNNG();  // ← NUEVO
      if (!isFRBN && isTMSL)  toggleTMSL();
      if (!isFRBN && isRAUM)  toggleRAUM();
      if (!isFRBN && is13245) toggle13245();
      if (!isFRBN && isR5NOVA) toggleR5NOVA();
      if (!skySphere) initSkySphere();

      isFRBN = !isFRBN;

      if (isFRBN) {                       // ——— ENTRAR ———
        leaveBuildRenderBoost();          // ← desactiva boost de BUILD
        if (isLCHT) toggleLCHT();         // asegura exclusividad
        buildGanzfeld();                  // sincroniza paleta + u_rate
        skySphere.visible        = true;
        cubeUniverse.visible     = false;
        permutationGroup.visible = false;
        if (lichtGroup) lichtGroup.visible = false;

      } else {                            // ——— SALIR ———
        skySphere.visible        = false;
        cubeUniverse.visible     = true;
        permutationGroup.visible = true;
        if (isLCHT && lichtGroup) lichtGroup.visible = true;
        refreshAll({ keepManual: true }); // reconstruye escena normal
      }
  // ← muestra el mini‑botón solo en FRBN
  const ib = document.getElementById('frbnInfoButton');
  if (ib) ib.style.display = isFRBN ? 'inline-block' : 'none';
    }

    /* --------- inicializa esfera al arrancar (sin coste GPU extra) -------- */
    window.addEventListener('load', () => { if(!skySphere) initSkySphere(); });

    /* ─────────────────────────────
     *   LCHT · deterministic Light Tubes
     * ───────────────────────────── */
    let lichtGroup = null;
    let isLCHT     = false;
    let lchtPrevBg = null;          // guarda/restaura el fondo al salir

    /* color determinista = mismo que la permutación                    */
    function colorForPerm(pa){
      const idx = pa[ attributeMapping[1] ];                // 1–5
      const val = getColor(idx);
      return Array.isArray(val)
        ? new THREE.Color(val[0]/255, val[1]/255, val[2]/255)
        : new THREE.Color(val);
    }

    /* ═════════ LCHT “cubos-de-tubos” (Sol LeWitt) ═════════════════ */

function tubeKey(x1, y1, z1, x2, y2, z2) {
  const a = `${x1},${y1},${z1}`;
  const b = `${x2},${y2},${z2}`;
  return (a < b) ? `${a}|${b}` : `${b}|${a}`;
}

function buildLCHT() {
  /* ── limpiar escena previa ─────────────────────────────── */
  if (lichtGroup) {
    lichtGroup.traverse(o => { if (o.isMesh) { o.geometry.dispose(); o.material.dispose(); } });
    scene.remove(lichtGroup);
  }
  lichtGroup = new THREE.Group();
  scene.add(lichtGroup);

  const step       = cubeSize / 5;
  const litInfo    = new Map();      // key → { color, lcht, perm }
  const collisions = new Set();      // aristas compartidas entre perms

  /* ── helpers ───────────────────────────────────────────── */

  /* inserta una arista evitando duplicados intra-perm */
  function addEdge(x1, y1, z1, x2, y2, z2, color, lcht, perm, seen) {
    const key = tubeKey(x1, y1, z1, x2, y2, z2);
    if (seen.has(key)) return;                 // ya la añadió este perm
    seen.add(key);

    if (litInfo.has(key)) {                    // ¿otra permutación?
      if (litInfo.get(key).perm !== perm) collisions.add(key);
      return;
    }
    litInfo.set(key, { color: color.clone(), lcht: { ...lcht }, perm });
  }

  /* añade los 12 tubos de un cubo (celda 1×1×1) en (cx,cy,cz) */
  function addCube(cx, cy, cz, color, lcht, perm, seen) {
    const v = [
      [cx,     cy,     cz],
      [cx + 1, cy,     cz],
      [cx + 1, cy + 1, cz],
      [cx,     cy + 1, cz],
      [cx,     cy,     cz + 1],
      [cx + 1, cy,     cz + 1],
      [cx + 1, cy + 1, cz + 1],
      [cx,     cy + 1, cz + 1]
    ];
    const E = [
      [0, 1], [1, 2], [2, 3], [3, 0],   // base
      [4, 5], [5, 6], [6, 7], [7, 4],   // tapa
      [0, 4], [1, 5], [2, 6], [3, 7]    // pilares
    ];
    E.forEach(([a, b]) =>
      addEdge(...v[a], ...v[b], color, lcht, perm, seen)
    );
  }

  /* ── recopilar aristas de todas las permutaciones ───────── */

    const perms = Array.from(document.getElementById('permutationList').selectedOptions)
                       .map(o => o.value.split(',').map(Number));

    /* — rango promedio de la escena — */
    {
      const rgs = perms.map(p => computeRange(computeSignature(p)));
      avgSceneRange = rgs.reduce((a,b)=>a+b,0) / (rgs.length||1);
    }

    perms.forEach((pa, permIdx) => {
      const L       = pa[attributeMapping[0]];               // altura torre
      const col     = colorForPerm(pa);
      const sig     = computeSignature(pa);
      const rng     = computeRange(sig);
      const r       = lehmerRank(pa);
    const I       = (r + sceneSeed + S_global) % 125;
    const x0      = Math.floor(I / 25);
    const y0      = Math.floor((I % 25) / 5);
    const z0      = I % 5;

    const lcht = {
      I0 : 0.35 + 0.65 * Math.sqrt(L / 5),
      amp: 0.05 + 0.10 * rng,
      f  : 0.10 + 0.175 * rng,
      phi: 2 * Math.PI * ((r % 360) / 360)
    };

    const seen = new Set();           // evita negros por duplicado interno

    /* ① Torre central + cruz lateral (un cubo por nivel) */
    for (let s = 0; s < L; s++) {
      const y = y0 + s;

      // cubo central
      addCube(x0, y, z0, col, lcht, permIdx, seen);

      // 4 cubos laterales
      addCube(x0 + 1, y, z0,     col, lcht, permIdx, seen);
      addCube(x0 - 1, y, z0,     col, lcht, permIdx, seen);
      addCube(x0,     y, z0 + 1, col, lcht, permIdx, seen);
      addCube(x0,     y, z0 - 1, col, lcht, permIdx, seen);
    }

    /* ② Brazos horizontales en ±X, ±Z (planos y = y₀ y y = y₀+L) */
    const dirs = [
      [ 1, 0,  0], [-1, 0,  0],
      [ 0, 0,  1], [ 0, 0, -1]
    ];
    [y0, y0 + L].forEach(yy => {
      dirs.forEach(([dx, _, dz]) => {
        for (let s = 0; s < L; s++) {
          addCube(x0 + dx * s, yy, z0 + dz * s, col, lcht, permIdx, seen);
        }
      });
    });
  });

  /* ── colisiones → negro + sin luz ───────────────────────── */
  // collisions.forEach(k => {
  //   const d = litInfo.get(k);
  //   if (d) { d.color.set(0x000000); d.lcht.I0 = 0; }
  // });

  /* ── geometría final  ·  cada arista → varios segmentos coloreados ── */
  litInfo.forEach((info, key) => {
    const [a, b]        = key.split('|');
    const [x1, y1, z1]  = a.split(',').map(Number);
    const [x2, y2, z2]  = b.split(',').map(Number);

    const p1   = new THREE.Vector3((x1 - 2) * step, (y1 - 2) * step, (z1 - 2) * step);
    const p2   = new THREE.Vector3((x2 - 2) * step, (y2 - 2) * step, (z2 - 2) * step);
    const dir  = new THREE.Vector3().subVectors(p2, p1);
    const len  = dir.length();
    const dN   = dir.clone().normalize();

    /* nº de segmentos = 1 por celda de 6 u, mínimo 1 */
    const SEG  = Math.max(1, Math.ceil(len / step));
    const hSeg = len / SEG;            // altura de cada sub-cilindro

    const [h, s, v] = rgbToHsv(info.color.r*255, info.color.g*255, info.color.b*255);

    for(let i = 0; i < SEG; i++){
      const mid = p1.clone().addScaledVector(dN, (i + 0.5) * hSeg);

      // === BUILD-like color pipeline para LCHT ===
      const zNorm = (mid.z + halfCube) / cubeSize;            // frontalidad 0..1
      const vib   = 0.22 + 0.10 * zNorm;                      // vibrance
      const s1    = Math.min(1, s + vib * (1 - s));           // sube S con más fuerza en S bajas
      const v1    = Math.min(0.93, v * (1.02 + 0.06 * zNorm));// brillo controlado (evita “quemados”)
      let   rgb   = hsvToRgb(h, s1, v1);                      // HSV → RGB
      rgb = ensureContrastRGB(rgb);                           // ΔEbg ≥ 22

      const col = new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255);

      // — Perfil cuadrado (lado = 0.8 del cilindro r=0.4) + pequeño solape
      const SIDE = 0.2;
      const JOIN = 0.02;

      const geo = new THREE.BoxGeometry(SIDE, hSeg + JOIN, SIDE);
      const mat = new THREE.MeshLambertMaterial({
        color: col,
        dithering: true,
        flatShading: true
      });

      // luminancia muy sutil de base (animación ajusta intensidad cada frame)
      mat.emissive = col.clone();
      mat.emissiveIntensity = 0.06 + 0.10 * zNorm;

      const tube = new THREE.Mesh(geo, mat);
      tube.position.copy(mid);
      tube.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dN);

      // guardamos el HSV de base ya “boosteado” (la animación solo mueve el H)
      tube.userData.baseHsv = { h, s: s1, v: v1 };
      tube.userData.lcht    = info.lcht;
      lichtGroup.add(tube);
    }
  });
}
/* ════════════════════════════════════════════════════════════ */


    function toggleLCHT(){
      if (!isLCHT && isOFFNNG) toggleOFFNNG();  // ← NUEVO
      if (!isLCHT && isTMSL)  toggleTMSL();
      isLCHT = !isLCHT;

      if (isLCHT){
        leaveBuildRenderBoost();          // ← desactiva boost de BUILD
        /* — cambia material del cubo a lambert para que capte luz — */
        if(!cubeUniverse.userData.prevMat){
          cubeUniverse.userData.prevMat = cubeUniverse.material;
          cubeUniverse.material = new THREE.MeshLambertMaterial({
            color: cubeUniverse.userData.prevMat.color,
            transparent: true,
            opacity: cubeUniverse.userData.prevMat.opacity,
            side: cubeUniverse.userData.prevMat.side
          });
        }
        if (!lchtPrevBg) lchtPrevBg = scene.background ? scene.background.clone() : null;
        scene.background = new THREE.Color(0xf4f4f4);       // gris muy claro
        if (isFRBN) toggleFRBN();                           // LCHT excluye FRBN
        buildLCHT();
        lichtGroup.visible        = true;
        cubeUniverse.visible      = false;
        permutationGroup.visible  = false;

        // Controles: ORBIT LIBRE en LCHT
        controls.enabled            = true;
        controls.enableRotate       = true;
        controls.enablePan          = true;
        controls.enableZoom         = true;
        controls.minPolarAngle      = 0;
        controls.maxPolarAngle      = Math.PI;
        controls.screenSpacePanning = false;
        controls.update();

      } else {
        /* — restaura material original — */
        if(cubeUniverse.userData.prevMat){
          cubeUniverse.material.dispose();
          cubeUniverse.material = cubeUniverse.userData.prevMat;
          delete cubeUniverse.userData.prevMat;
        }
        if (lichtGroup) lichtGroup.visible = false;
        if (lchtPrevBg) scene.background = lchtPrevBg;      // restaura fondo
        lchtPrevBg = null;
        cubeUniverse.visible      = true;
        permutationGroup.visible  = true;

        // Al salir de LCHT dejamos controles en modo “normal” (libre)
        controls.enabled            = true;
        controls.enableRotate       = true;
        controls.enablePan          = true;
        controls.enableZoom         = true;
        controls.minPolarAngle      = 0;
        controls.maxPolarAngle      = Math.PI;
        controls.screenSpacePanning = false;
        controls.update();
      }
      const b = document.getElementById('lchtButton');
      if (b) b.textContent = isLCHT ? 'LCHT ON' : 'LCHT';
    }

    /* reconstruye LCHT si hay cambios de escena */
    function rebuildLCHTIfActive(){ if(isLCHT) buildLCHT(); }

    /* Cambia al motor BUILD sin generar una nueva configuración */
    function switchToBuild(){
      if (isOFFNNG) toggleOFFNNG();   // exclusividad
      if (isFRBN)  toggleFRBN();
      if (isLCHT)  toggleLCHT();
      if (isTMSL)  toggleTMSL();
      if (isRAUM)  toggleRAUM();
      if (is13245) toggle13245();     // ← NUEVO
      if (isR5NOVA) toggleR5NOVA();     // ← NUEVO
      enterBuildRenderBoost();        // PR/exposure para BUILD

      // Controles: ORBIT LIBRE en BUILD
      controls.enabled            = true;
      controls.enableRotate       = true;
      controls.enablePan          = true;
      controls.enableZoom         = true;
      controls.minPolarAngle      = 0;
      controls.maxPolarAngle      = Math.PI;
      controls.screenSpacePanning = false;
      controls.update();
    }

    // === BUILD render boost (solo activo en BUILD) ==============================
    let __buildBoostPrev = { pr: null, exp: null };

    function enterBuildRenderBoost(){
      if (!renderer || __buildBoostPrev.pr !== null) return;
      // Guarda para restaurar al salir de BUILD
      __buildBoostPrev.pr  = renderer.getPixelRatio();
      __buildBoostPrev.exp = renderer.toneMappingExposure;
      // Más nitidez y menos “quemado” SOLO en BUILD
      const PR = Math.min(window.devicePixelRatio || 1, 2.5);
      renderer.setPixelRatio(PR);
      renderer.toneMappingExposure = 0.90;    // baseline 0.95 → BUILD más controlado
    }

    function leaveBuildRenderBoost(){
      if (!renderer || __buildBoostPrev.pr === null) return;
      renderer.setPixelRatio(__buildBoostPrev.pr);
      renderer.toneMappingExposure = __buildBoostPrev.exp;
      __buildBoostPrev.pr = null; __buildBoostPrev.exp = null;
    }

    // === RAUM crispness boost (solo activo en RAUM) =============================
    let __raumBoostPrev = { pr: null, exp: null };

    function enterRaumRenderBoost(){
      if (!renderer || __raumBoostPrev.pr !== null) return;
      __raumBoostPrev.pr  = renderer.getPixelRatio();
      __raumBoostPrev.exp = renderer.toneMappingExposure;

      // Más nitidez SOLO en RAUM (cap prudente para FPS)
      const PR = Math.min(window.devicePixelRatio || 1, 2.75);
      renderer.setPixelRatio(PR);
      renderer.toneMappingExposure = 0.98;
    }

    function leaveRaumRenderBoost(){
      if (!renderer || __raumBoostPrev.pr === null) return;
      renderer.setPixelRatio(__raumBoostPrev.pr);
      renderer.toneMappingExposure = __raumBoostPrev.exp;
      __raumBoostPrev.pr = null; __raumBoostPrev.exp = null;
    }

    const GOLD = 137.50776405003785;      // ángulo áureo
    /*  razón áurea al cuadrado  ≈ 2.618…  */
    const PHI2 = 2.618033988749895;
    /* ——— salto coprimo con 144: barre los 144 valores de H ——— */
    const PHI_H = 89;             // 89 ≡ 144 / φ  (gcd 89,144 = 1)
    /* ——— saltos coprimos para los 12 niveles de S y V ——— */
    const PHI_S = 5;              // gcd(5,12) = 1
    const PHI_V = 7;              // gcd(7,12) = 1

    /* ═════════ CUADRÍCULA HSV 144·12·12 ═══════════════════════════════════ */
    const H_STEPS  = 144;                               // 360° / 2.5°
    const S_LEVELS = [...Array(12)].map((_,i)=>0.25 + 0.72*i/11); // 0.25 – 0.97
    const V_LEVELS = [...Array(12)].map((_,i)=>0.20 + 0.75*i/11); // 0.20 – 0.95

    /* ——— Discretización canónica para FRBN (catálogo de fases) ——— */
    const FRBN_K = 144;   // alineado con H_STEPS (2.5° × 144)

    function idxToHSV(hIdx,sIdx,vIdx){
      const h = ((hIdx%H_STEPS)+H_STEPS) % H_STEPS;      // 0-143
      return {
        h: h * 360 / H_STEPS,                            // 0-359.5 °
        s: S_LEVELS[ ((sIdx%12)+12)%12 ],
        v: V_LEVELS[ ((vIdx%12)+12)%12 ]
      };
    }

    /* ═════════ COLOR-FIELD 144 × 12 × 12  ═════════════════════════════ */
    /* Devuelve el color del «voxel HSV» que ocupa la posición p (mundo) */
    function colorFromVolume(p){
      const HALF = cubeSize / 2;          // ±15  (cubo 30×30×30 ya existe)
      const HX = 144, HY = 12, HZ = 12;   // rejilla 20 736 colores

      /* índices enteros en cada eje, envueltos al rango válido */
      const ix = ((Math.floor((p.x + HALF) / cubeSize * HX) % HX) + HX) % HX;
      const iy = ((Math.floor((p.y + HALF) / cubeSize * HY) % HY) + HY) % HY;
      const iz = ((Math.floor((p.z + HALF) / cubeSize * HZ) % HZ) + HZ) % HZ;

      /* HSV determinista → RGB → THREE.Color */
      const {h,s,v} = idxToHSV(ix, iy, iz);
      const [R,G,B] = hsvToRgb(h, s, v);
      return new THREE.Color(R/255, G/255, B/255);
    }

    /* Normaliza cualquier hue a rango [0 … 360) */
    function normHue(deg){
      return ((deg % 360) + 360) % 360;
    }

    /* ═════════ 11 patrones cromáticos — versión PHI_H (89) ═════════ */
const PATTERNS = {
  1: (sig, seed, i) => {
    const base = (sig.reduce((a,v)=>a+v,0) + seed*7) % 144;
    const hIdx = (base + (i%12)*6) % 144;
    return [
      hIdx,
      (sig[3] + seed + i) % 12,
      (sig[1] + sig[4] + i) % 12
    ];
  },

  2: (sig, seed, i) => {
    const base = (sig[0]*17 + seed*5) % 144;
    const hIdx = (base + ((i%12)*48)) % 144;
    return [
      hIdx,
      (sig[1] + i*3 + seed) % 12,
      (sig[2]*2 + i + seed) % 12
    ];
  },

  3:  (s,seed,i)=>{const b=(s[2]*13+seed*5+i*11)%144;
                   return [(b+i*PHI_H)%144,(s[0]+i*2+seed)%12,(s[1]+s[3]+i)%12];},

  4:  (s,seed,i)=>{const b=(s[1]*15+seed*3+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[0]+seed+i)%12,(s[2]+s[4]+seed+i)%12];},

  5:  (s,seed,i)=>{const b=(i*31+s[3]*13+seed*5)%144;
                   return [(b+i*PHI_H)%144,(s[1]+seed+i)%12,(s[2]+seed+i)%12];},

  6:  (s,seed,i)=>{const b=(s[1]*31+seed*13+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i)%12,(s[3]+s[4]+seed+i)%12];},

  7:  (s,seed,i)=>{const b=(s[0]*11+seed*3+i*37)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i*2)%12,(s[4]+s[1]*2+seed+i)%12];},

  8:  (s,seed,i)=>{const r=Math.abs(s[4]-s[0])+Math.abs(s[3]-s[1])+s[2];
                   const b=(r*13+seed*7)%144;
                   return [(b+i*PHI_H)%144,(s[1]*3+seed+i*2)%12,(s[3]+i*5+seed*3)%12];},

  9:  (s,seed,i)=>{const b=(s[4]*12+seed*7+i*11)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i)%12,(s[1]+seed+i*2)%12];},

 10:  (s,seed,i)=>{const b=(seed*5+s.reduce((a,v)=>a+v,0)*3+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i)%12,(s[4]*2+seed+i*3)%12];},

 11:  (s,seed,i)=>{const b=(s[3]*13+seed*11+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[0]+seed+i)%12,(s[1]+seed+i*2)%12];}
};

/* ---------- BLOQUE DE UTILIDADES COLOR v1.3-RC2 ---------- */
const ANG7 = [
  [0,0,0,0,0,0,0],                         // monocromo (idx 0)
  [0,30,60,90,120,150,180],                // análoga
  [0,180,0,180,0,180,0],                   // complementaria
  [0,150,210,0,150,210,0],                 // comp. dividida
  [0,120,240,60,180,300,30],               // tríada
  [0,90,180,270,45,135,225],               // cuadrado
  [0,0,0,0,0,0,0]                          // “tonos” (misma H, S escalado)
];
function rgbToHsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min;
  let h=0;
  if(d){
    if(max===r) h=((g-b)/d)%6;
    else if(max===g) h=(b-r)/d+2;
    else h=(r-g)/d+4;
    h*=60; if(h<0) h+=360;
  }
  const s=max?d/max:0, v=max;
  return [h,s,v];
}
function hsvToRgb(h,s,v){
  h = h % 360;
  const c=v*s, x=c*(1-Math.abs((h/60)%2-1)), m=v-c;
  let [r,g,b]=[0,0,0];
  if(h<60){r=c;g=x;} else if(h<120){r=x;g=c;}
  else if(h<180){g=c;b=x;} else if(h<240){g=x;b=c;}
  else if(h<300){r=x;b=c;} else {r=c;b=x;}
  return [(r+m)*255,(g+m)*255,(b+m)*255].map(v=>Math.round(v));
}
function hsvToHex({h,s,v}){
  const [r,g,b] = hsvToRgb(h,s,v);
  return '#'+new THREE.Color(r/255,g/255,b/255).getHexString();
}
/* contraste CIE76 */
function deltaE(lab1,lab2){
  return Math.sqrt(
    (lab1[0]-lab2[0])**2+
    (lab1[1]-lab2[1])**2+
    (lab1[2]-lab2[2])**2
  );
}
function rgbToLab(r,g,b){                      // aproximación rápida
  const xyz=[r/255,g/255,b/255].map(v=>{
    v=v>0.04045?((v+0.055)/1.055)**2.4:v/12.92;
    return v*100;
  });
  const x=xyz[0]*0.4124+xyz[1]*0.3576+xyz[2]*0.1805;
  const y=xyz[0]*0.2126+xyz[1]*0.7152+xyz[2]*0.0722;
  const z=xyz[0]*0.0193+xyz[1]*0.1192+xyz[2]*0.9505;
  const xyzN=[95.047,100.0,108.883];
  const f= t=> t>0.008856 ? t**(1/3) : (7.787*t)+16/116;
  const [fx,fy,fz]=[x,y,z].map((v,i)=>f(v/xyzN[i]));
  return [116*fy-16, 500*(fx-fy), 200*(fy-fz)];
}

/* ======  NUEVO  — utilidades de contraste con el FONDO  ====== */
const ΔE_BG_MIN = 22;          // contraste mínimo CIE76

function hexToRgb(hex){
  const m = /^#?([0-9a-f]{6})$/i.exec(hex);
  const n = parseInt(m[1],16);
  return [(n>>16)&255, (n>>8)&255, n&255];
}

/**
 * Sube o baja la luminosidad (v) del color RGB recibido hasta que
 * alcance ΔE_BG_MIN puntos de contraste contra el fondo actual.
 * Devuelve el RGB corregido.
 */
function ensureContrastRGB(rgb){
  /* color de fondo efectivo */
  let bgRgb;
  if (bgOverride) {
    bgRgb = hexToRgb(bgOverride);
  } else if (scene && scene.background && scene.background.isColor) {
    // fondo actual de THREE.Color (incluye el gris de LCHT)
    bgRgb = [
      Math.round(scene.background.r * 255),
      Math.round(scene.background.g * 255),
      Math.round(scene.background.b * 255)
    ];
  } else {
    bgRgb = hsvToRgb(bgHSV.h, bgHSV.s, bgHSV.v);
  }

  let [h,s,v] = rgbToHsv(rgb[0], rgb[1], rgb[2]);  // pasamos a HSV
  let tries = 0;
  while (deltaE(rgbToLab(...rgb), rgbToLab(...bgRgb)) < ΔE_BG_MIN && tries < 24){
    // alterna aclarar / oscurecer en pasos de 0.04
    v = (tries % 2) ? Math.max(0, v - 0.04) : Math.min(1, v + 0.04);
    rgb = hsvToRgb(h, s, v);
    tries++;
  }
  return rgb;
}
/* ---------- FIN BLOQUE UTILIDADES ---------- */
/* ——— calcula HSV para fondo y paredes de forma acoplada al set activo ——— */
function rebuildSceneColours(){
  // Permutaciones activas (en el mismo orden visual)
  const perms = Array.from(document.getElementById('permutationList').selectedOptions)
                     .map(o => o.value.split(',').map(Number));

  // Firmas para fondo/cubo (si no hay, usa dummy neutra)
  const firstSig = perms[0] ? computeSignature(perms[0]) : [0,0,0,0,0];
  const lastSig  = perms.length > 1 ? computeSignature(perms[perms.length-1]) : firstSig;

  // Slots acoplados al tamaño del set (idéntico a BUILD + spreads coprimos)
  let [h1,s1,v1] = PATTERNS[activePatternId](firstSig, sceneSeed, perms.length);
  let [h2,s2,v2] = PATTERNS[activePatternId](lastSig,  sceneSeed, perms.length + 1);

  s1 = (s1 * PHI_S) % 12;  v1 = (v1 * PHI_V) % 12;
  s2 = (s2 * PHI_S) % 12;  v2 = (v2 * PHI_V) % 12;

  bgHSV   = idxToHSV(h1, s1, v1);   // ← Fondo = “slot #n” con firma del primero
  wallHSV = idxToHSV(h2, s2, v2);   // ← Paredes = “slot #n+1” con firma del último
}

/* ===\u2003UTIL extra — firma normalizada y contraste\u2003===================== */
// 1)  f̂  de un glifo  →  promedio firma, llevada a [0-1]
function normFhat(sig){           // sig = [f1…f5] entre 2 y 10
  const avg = sig.reduce((a,b)=>a+b,0)/sig.length;   // 2 … 10
  return (avg-2)/8;                                  // 0 … 1
}

// 2)  pinza a [0,1]
function clamp01(x){ return Math.max(0, Math.min(1,x)); }

/* ———————————————————————————————————————————————— *
 * Devuelve el valor de una propiedad que puede ser:
 *   · número → se usa tal cual
 *   · función → se evalúa con los argumentos dados
 * fallback se usa si la propiedad es null/undefined.
 * ———————————————————————————————————————————————— */
function evalProp(prop, args = [], fallback = 0){
  return (typeof prop === 'function') ? prop(...args) :
         (prop ?? fallback);
}

/* contrast-fix eliminado: función ensureContrast() suprimida */
    const minRangeValue = 2, maxRangeValue = 6;
    const shapeMapping = {
      1:{w:4.5,h:4.5},
      2:{w:4.5,h:4.5*Math.sqrt(2)},
      3:{w:4.5,h:4.5*Math.sqrt(3)},
      4:{w:4.5,h:4.5*Math.sqrt(4)},
      5:{w:4.5,h:4.5*Math.sqrt(5)}
    };

    function sumXYZ(pa,map){
      return pa[ map[2] ] + pa[ map[3] ] + pa[ map[4] ];
    }

    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function mapRangeToSpeed(r,mn,mx){return 0.001 + (r-mn)*(0.005-0.001)/(mx-mn);}
    function shuffle(a){for(let i=a.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

    function getPermutations(arr){
      if(arr.length===1) return [arr];
      let res=[]; for(let i=0;i<arr.length;i++){
        const c=arr[i], rem=arr.slice(0,i).concat(arr.slice(i+1));
        for(const p of getPermutations(rem)) res.push([c].concat(p));
      }
      return res;
    }
    const allPermutations = getPermutations([1,2,3,4,5]);
    const permutationStrings = allPermutations.map(p=>p.join(','));

    function getAttributeMappings(a){
      if(a.length===1) return [a];
      let res=[]; for(let i=0;i<a.length;i++){
        const c=a[i], rem=a.slice(0,i).concat(a.slice(i+1));
        for(const m of getAttributeMappings(rem)) res.push([c].concat(m));
      }
      return res;
    }

    function populatePermutationList(){
      const sel = document.getElementById('permutationList');
      sel.innerHTML = '';
      permutationStrings.forEach((ps,i)=>{
        const o=document.createElement('option');
        o.value=ps; o.text=`Permutación ${i+1}: (${ps})`;
        if(i===0) o.selected=true;
        sel.appendChild(o);
      });
    }
    function populateAttributeMappingSelect(){
      const sel = document.getElementById('attrMapping');
      sel.innerHTML = '';
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        const s=m.join(','), o=document.createElement('option');
        o.value=s; o.text=`Opción: [${s}]`;
        if(s==='0,1,2,3,4') o.selected=true;
        sel.appendChild(o);
      });
      updateTopRightDisplay();
    }

    function computeSignature(a){let s=[];for(let i=0;i<a.length;i++) s.push(a[i]+a[(i+1)%a.length]);return s;}
    function computeRange(sig){return Math.max(...sig)-Math.min(...sig);}

    const FACT=[1,1,2,6,24,120];
    let sceneSeed=0;
    function lehmerRank(p){
      let r=0;
      for(let i=0;i<p.length;i++){
        let c=0;
        for(let j=i+1;j<p.length;j++) if(p[j]<p[i]) c++;
        r+=c*FACT[p.length-1-i];
      }
      return r;
    }

    /* ========= NUEVO: sceneSeed orden‑invariante + dependiente del mapping ========= */

    /** Rank del mapping [m0..m4] usando Lehmer rank sobre [m_i+1] (1..5) */
    function mappingRank(m){
      const arr = [m[0]+1, m[1]+1, m[2]+1, m[3]+1, m[4]+1];
      return lehmerRank(arr);
    }

    /** sceneSeed = (37·sumR + 101·sumR2 + 53·mRank) mod 360  (orden‑invariante) */
    function computeSceneSeedFrom(perms, m){
      let sumR = 0, sumR2 = 0;
      perms.forEach(pa=>{
        const r = lehmerRank(pa);
        sumR  += r;
        sumR2 += r*r;
      });
      const mRank = mappingRank(m);
      return (37*sumR + 101*sumR2 + 53*mRank) % 360;
    }

    /** S = ( Σ (P_{mx}+P_{my}+P_{mz}) ) mod 125  — usa los índices x,y,z del mapping */
    function computeGlobalS(perms, m){
      const mx = m[2], my = m[3], mz = m[4];
      let S = 0;
      perms.forEach(p=>{
        S += p[mx] + p[my] + p[mz];
      });
      return S % 125;
    }

    /* ===== Seed determinista para el LAYOUT (R5NOVA · tilers) =====
       Usa exactamente las mismas invariantes globales que ya gobiernan color/posiciones
       (sceneSeed, S_global, mappingRank) + stats del set (sumR, sumSig, n).
       Devuelve un entero U32 para el PRNG del motor de layout. */
    function computeLayoutSeed(){
      const perms = Array.from(document.getElementById('permutationList').selectedOptions)
                         .map(o => o.value.split(',').map(Number));
      const mRank = mappingRank(attributeMapping.slice(0,5));

      let sumR = 0, sumSig = 0;
      perms.forEach(p=>{
        const r = lehmerRank(p);
        sumR += r;
        const s = computeSignature(p);
        sumSig += s.reduce((a,b)=>a+b,0);
      });

      // mezcla (sin colisiones obvias) → U32
      let x = 0 >>> 0;
      x = (x ^ (sceneSeed * 1315423911)) >>> 0;
      x = (x ^ ((S_global   *  374761393) >>> 0)) >>> 0;
      x = (x ^ ((perms.length * 668265263) >>> 0)) >>> 0;
      x = (x ^ ((mRank      *     362437) >>> 0)) >>> 0;
      x = (x ^ ((sumR       * 1013904223) >>> 0)) >>> 0;
      x = (x ^ ((sumSig     *  224682251) >>> 0)) >>> 0;
      return x >>> 0;
    }
    function computeShiftRankXYZ(p){
      const r = lehmerRank(p);
      const I = (r + sceneSeed + S_global) % 125;   // <<< NUEVO: acoplado a S_global
      const x = Math.floor(I/25),
            y = Math.floor((I%25)/5),
            z = I%5;
      const step = cubeSize/5;
      return [
        (x-2)*step,
        (y-2)*step,
        (z-2)*step
      ];
    }

    function getSelectedPerms(){
      return Array.from(document.getElementById('permutationList').selectedOptions)
                  .map(o => o.value.split(',').map(Number));
    }
    function raumSignatures(){
      const perms = getSelectedPerms();
      const sigs  = perms.map(p => computeSignature(p));
      return sigs.length ? sigs : [[0,0,0,0,0]];
    }
    function raumStats(){
      const perms = getSelectedPerms();
      let sumR=0, sumR2=0;
      perms.forEach(p => { const r = lehmerRank(p); sumR += r; sumR2 += r*r; });
      const mRank = mappingRank(attributeMapping.slice(0,5));
      const slot0 = perms.length;
      return { perms, sumR, sumR2, mRank, slot0 };
    }
    /* Color determinista para el elemento k de RAUM (k=1..7) */
    function raumColorFor(k){
      const sigs = raumSignatures();
      const { slot0 } = raumStats();
      const sig  = sigs[(k-1) % sigs.length];
      let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot0 + k);
      sI = (sI * PHI_S) % 12;
      vI = (vI * PHI_V) % 12;
      const {h,s,v} = idxToHSV(hI, sI, vI);
      let rgb = hsvToRgb(h,s,v);
      rgb = ensureContrastRGB(rgb);
      return new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255);
    }

    function setActivePattern(id){
      activePatternId = parseInt(id,10);
      refreshAll({rebuild:false});
    }
    function updateTopRightDisplay(){
      const cfg=`Atributos: [${attributeMapping.slice(0,5).join(',')}]`;
      const rt =`Calificación: ${userRating?userRating:'Aún no calificada'}`;
      let info='';
      Array.from(document.getElementById('permutationList').selectedOptions).forEach(o=>{
        const pa=o.value.split(',').map(Number),
              sig=computeSignature(pa),
              rg=computeRange(sig);
        info+=`<div style="margin:2px 0;">Perm (${o.value}) | Firma [${sig.join(', ')}] | Rango ${rg}</div>`;
      });
      document.getElementById('topRightDisplay').innerHTML = cfg+'<br>'+rt+'<br>'+info;
    }

    function createPermutationObjectWithMapping(pa,map){
      const fv=pa[map[0]], cv=pa[map[1]],
            d=shapeMapping[fv], w=d.w, h=d.h, t=0.5;

      // --- COLOR determinista (cuadrícula HSV) ---
      let rgb;
      if(activePatternId === 0){
        rgb = paletteRGB[cv-1] || [255,255,255];
      }else{
        const sig  = computeSignature(pa);
        const slot = lehmerRank(pa) % 12;      // 0-11
        let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
        sI = (sI * PHI_S) % 12;
        vI = (vI * PHI_V) % 12;
        const {h,s,v} = idxToHSV(hI,sI,vI);
        rgb = hsvToRgb(h,s,v);
      }
      // Contraste mínimo contra el fondo actual
      rgb = ensureContrastRGB(rgb);

      // --- POSICIÓN (antes de material para calcular frontalidad) ---
      const [X,Y,Z]=computeShiftRankXYZ(pa);

      // --- BUILD · Vibrance v2: saturación fuerte sin quemar y sin spec blanco ---
      const zNorm = (Z + halfCube) / cubeSize;               // -15→0 · +15→1

      // 1) Partimos del RGB con contraste mínimo contra fondo
      let [h0, s0, v0] = rgbToHsv(rgb[0], rgb[1], rgb[2]);

      // 2) Vibrance: sube S con más fuerza cuanto más baja sea S (y un plus por frontalidad)
      const vib = 0.22 + 0.10 * zNorm;                       // 0.22…0.32
      const s1  = Math.min(1, s0 + vib * (1 - s0));

      // 3) Brillo controlado: ligero boost pero con techo para evitar “quemados” en ACES
      const v1  = Math.min(0.93, v0 * (1.02 + 0.06 * zNorm));

      // 4) Volvemos a RGB
      const rgbBoost = hsvToRgb(h0, s1, v1);

      // 5) Material difuso (Lambert) → colores más limpios y saturados (sin specular blanco)
      const mat = new THREE.MeshLambertMaterial({
        color: new THREE.Color(rgbBoost[0]/255, rgbBoost[1]/255, rgbBoost[2]/255),
        dithering: true
      });

      // Pequeña auto-luminancia para “energía” sin quemar (mucho menor que antes)
      mat.emissive = new THREE.Color(rgbBoost[0]/255, rgbBoost[1]/255, rgbBoost[2]/255);
      mat.emissiveIntensity = 0.03 + 0.12 * zNorm;   // antes 0.08 + 0.30*zNorm

      const geo=new THREE.BoxGeometry(w,h,t);
      const mesh=new THREE.Mesh(geo,mat);
      mesh.position.set(
        clamp(X,-halfCube+w/2,halfCube-w/2),
        clamp(Y,-halfCube+h/2,halfCube-h/2),
        clamp(Z,-halfCube+t/2,halfCube-t/2)
      );

      const sig=computeSignature(pa), rg=computeRange(sig);
      mesh.userData={permStr:pa.join(','), signature:sig, range:rg, rotationSpeed:mapRangeToSpeed(rg,minRangeValue,maxRangeValue)};
      return mesh;
    }
    function createPermutationObject(pa){ return createPermutationObjectWithMapping(pa,attributeMapping); }

    function checkCollisionsInGroup(g){
      for(let i=0;i<g.children.length;i++){
        const b1=new THREE.Box3().setFromObject(g.children[i]);
        for(let j=i+1;j<g.children.length;j++){
          const b2=new THREE.Box3().setFromObject(g.children[j]);
          if(b1.intersectsBox(b2)) return true;
        }
      }
      return false;
    }
    function autoResolveColisionesGlobal(){
      let found=null;
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        if(found) return;
        const cm=[m[0],m[1],m[2],m[3],m[4], attributeMapping[5], attributeMapping[6]],
              tg=new THREE.Group(),
              opts=Array.from(document.getElementById('permutationList').selectedOptions);
        opts.forEach((o)=>{
          const pa=o.value.split(',').map(Number),
                mo=createPermutationObjectWithMapping(pa,cm);
          tg.add(mo);
        });
        if(!checkCollisionsInGroup(tg)) found=cm;
      });
      if(found){
        attributeMapping=found;
        document.getElementById('attrMapping').value=`${found[0]},${found[1]},${found[2]},${found[3]},${found[4]}`;
        refreshAll({rebuild:true}); updateTopRightDisplay();
      } else {
        showPopup("No se encontró reorganización sin colisiones.",7000);
      }
    }

/* ==============================
 * 120 Architectural Permutations
 * ============================== */
let perm120List = getAttributeMappings([0,1,2,3,4]); // 120
let perm120Index = 0;
let perm120Timer = null;

function togglePerm120Panel(){
  const p = document.getElementById('perm120Panel');
  const isHidden = (p.style.display === 'none' || !p.style.display);
  p.style.display = isHidden ? 'block' : 'none';

  // Re‑muestra siempre el cursor personalizado
  const cc = document.getElementById('customCursor');
  if (cc) cc.style.display = 'block';
}

function msFromUI(){
  const slider = document.getElementById('perm120Slider');
  return parseInt(slider.value, 10);
}
function syncPerm120InputsFromSlider(){
  const ms = msFromUI();
  document.getElementById('perm120Seconds').value = Math.round(ms/1000);
}
function syncPerm120SliderFromSeconds(){
  const sec = parseInt(document.getElementById('perm120Seconds').value,10) || 1;
  const clamped = Math.max(1, Math.min(720, sec));
  document.getElementById('perm120Seconds').value = clamped;
  document.getElementById('perm120Slider').value = clamped * 1000;
}

function updatePerm120Status(){
  const stat = document.getElementById('perm120Status');
  if(stat) stat.textContent = `Permutation: ${perm120Index} / 119`;
}

function applyPerm120Index(i){
  perm120Index = ((i % perm120List.length) + perm120List.length) % perm120List.length;
  const m = perm120List[perm120Index];
  attributeMapping = [m[0], m[1], m[2], m[3], m[4], attributeMapping[5], attributeMapping[6]];
  document.getElementById('attrMapping').value = m.join(',');
  refreshAll({rebuild:true});
  updatePerm120Status();
}

function nextPerm120(){ applyPerm120Index(perm120Index + 1); }
function prevPerm120(){ applyPerm120Index(perm120Index - 1); }

function playPerm120(){
  if(perm120Timer) return;
  const interval = msFromUI();
  perm120Timer = setInterval(nextPerm120, interval);
  nextPerm120();
}
function pausePerm120(){
  if(perm120Timer){
    clearInterval(perm120Timer);
    perm120Timer = null;
  }
}

async function showPerm120Info(){
  try{
    const text = await loadTextPartial('./texts/perm120-info.txt');
    alert(text);
  }catch(err){
    alert('Error cargando perm120-info.txt');
    console.error(err);
  }
}


    /* ============================================================
     *  MONTE-CARLO: buscar una escena aleatoria SIN colisiones
     *  ============================================================
     */

    /** Construye un grupo temporal con un mapping dado, sin tocar la escena real */
      const mappings = getAttributeMappings([0,1,2,3,4]);
function buildTempGroup(perms, mapping){
  const tg = new THREE.Group();

  // Guardamos estado global
  const prevSeed = sceneSeed;
  const prevS    = S_global;
  const prevMap  = attributeMapping.slice();

  // Calculamos los nuevos valores teóricos
  const tmpSeed = computeSceneSeedFrom(perms, mapping);
  const tmpS    = computeGlobalS(perms, mapping);

  // Seteamos temporalmente los globales para que createPermutationObjectWithMapping
  // use exactamente la misma lógica que la escena final:
  sceneSeed        = tmpSeed;
  S_global         = tmpS;
  attributeMapping = mapping;

  perms.forEach(pa=>{
    const mesh = createPermutationObjectWithMapping(pa, mapping);
    tg.add(mesh);
  });

  // Restauramos
  sceneSeed        = prevSeed;
  S_global         = prevS;
  attributeMapping = prevMap;

  return tg;
}

function findCollisionFreeMapping(perms){
  const mappings = getAttributeMappings([0,1,2,3,4]);
  for(const m of mappings){
    const cm = [m[0], m[1], m[2], m[3], m[4], attributeMapping[5], attributeMapping[6]];
    const tg = buildTempGroup(perms, cm);
    if(!checkCollisionsInGroup(tg)) return cm;
  }
  return null;
}
    /** Selecciona un subconjunto aleatorio de permutaciones (1..25) */
    function pickRandomPerms(){
      const n  = Math.floor(Math.random()*25) + 1;
      const out = [];
      for(let i=0;i<n;i++){
        const str = permutationStrings[Math.floor(Math.random()*permutationStrings.length)];
        out.push(str.split(',').map(Number));
      }
      return out;
    }

    /**
     * Búsqueda iterativa:
     *  - elige un set aleatorio de permutaciones
     *  - prueba todos los mappings
     *  - si alguno no choca, lo aplica y termina
     *
     * No bloquea la UI gracias al pequeño await en cada iteración.
     */
    async function generateRandomConfigurationNoCollision(MAX_TRIES = 5000){
      // Elegimos un patrón cromático aleatorio (1..11, evitando el legacy 0)
      const randPattern = Math.floor(Math.random() * 11) + 1;

      let round = 0;
      while (true) { // sigue intentando hasta que realmente encuentre una sin colisiones
        round++;
        for (let t = 0; t < MAX_TRIES; t++) {
          showPopup(`Buscando configuración sin colisiones… (ronda ${round}, intento ${t+1})`, 500);

          const perms   = pickRandomPerms();
          const mapping = findCollisionFreeMapping(perms);

          if (mapping) {
            // 1) Setea el patrón cromático escogido
            activePatternId = randPattern;
            const selPattern = document.getElementById('patternSelect');
            if (selPattern) selPattern.value = String(randPattern);

            // 2) Pon las permutaciones en el <select>
            const sel = document.getElementById('permutationList');
            Array.from(sel.options).forEach(o => o.selected = false);
            perms.forEach(p=>{
              const val = p.join(',');
              const opt = sel.querySelector(`option[value="${val}"]`);
              if(opt) opt.selected = true;
            });

            // 3) Aplica el mapping encontrado
            attributeMapping = mapping;

            // mantenemos tu ciclo de atributo "color"
            attributeMapping[1] = colorAttrCycle % 5;
            colorAttrCycle++;

            document.getElementById('attrMapping').value =
              `${attributeMapping[0]},${attributeMapping[1]},${attributeMapping[2]},${attributeMapping[3]},${attributeMapping[4]}`;

            // 4) Reconstruye escena completa
            refreshAll({rebuild:true});

            // 5) Verificación final (por si acaso)
            const hasCol = checkCollisionsInGroup(permutationGroup);
            if (!hasCol) {
              /*  ▸ YA NO se desactiva el motor actual.
               *    Si el usuario estaba en FRBN o LCHT, sigue allí.
               *    BUILD sólo se activa cuando se pulsa explícitamente el botón BUILD. */
              showPopup("¡Configuración sin colisiones encontrada!", 2000);
              return true;
            }
          }

          // cede el hilo para no congelar la UI
          if ((t % 25) === 0) await new Promise(r => setTimeout(r, 0));
        }
        // pequeña pausa entre rondas largas
        await new Promise(r => setTimeout(r, 10));
      }
    }

    function showPopup(msg, dur = 2000){
      dur = Math.max(dur, 3000); // ← asegura al menos 3 segundos
      const p = document.getElementById('hoverPopup');
      p.style.display = "block";
      p.style.opacity = 1;
      p.style.left = (window.innerWidth/2 - 150) + "px";
      p.style.top  = "20px";
      p.innerHTML  = msg;
      setTimeout(()=>{
        p.style.opacity = 0;
        setTimeout(()=>{ p.style.display="none"; p.innerHTML=""; }, 300);
      }, dur);
    }


function updateScene(attemptResolve=true){
  // Limpia grupo
  while(permutationGroup.children.length>0){
    const o=permutationGroup.children[0];
    permutationGroup.remove(o);
    o.geometry.dispose(); o.material.dispose();
  }

  // Permutaciones activas
  const opts  = Array.from(document.getElementById('permutationList').selectedOptions);
  const perms = opts.map(o => o.value.split(',').map(Number));

  // Nueva sceneSeed & S_global (orden-invariante + dependiente del mapping)
  sceneSeed = computeSceneSeedFrom(perms, attributeMapping);
  S_global  = computeGlobalS(perms, attributeMapping);

  // Construye objetos
  perms.forEach(pa=>{
    const obj = createPermutationObject(pa);
    permutationGroup.add(obj);
  });

  if(attemptResolve) autoResolveColisionesGlobal();
  else updateTopRightDisplay();
      if (isFRBN && skySphere) buildGanzfeld();   // mantiene FRBN sincronizado
  }
    function onMouseMove(e){
      mouse.x=(e.clientX/window.innerWidth)*2-1;
      mouse.y=-(e.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera(mouse,camera);
      const ints=raycaster.intersectObjects(permutationGroup.children),
            pop=document.getElementById('hoverPopup');
      if(ints.length>0){
        const d=ints[0].object.userData;
        pop.style.display="block"; pop.style.opacity=1;
        pop.style.left=`${e.clientX+20}px`;
        pop.style.top=`${e.clientY+20}px`;
        pop.innerHTML=`Perm (${d.permStr})<br>Firma [${d.signature.join(', ')}]<br>Rango ${d.range}`;
      } else {
        pop.style.opacity=0;
        setTimeout(()=>{pop.style.display="none";},300);
      }
    }

    function zoomIn(){camera.position.z-=5;controls.update();}
    function zoomOut(){camera.position.z+=5;controls.update();}
    function togglePause(){
      isPaused=!isPaused;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent=isPaused?"Resume Motion":"Pause Motion";
    }
    function resetMovement(){
      updateScene(false);
      isPaused=true;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent="Resume Motion";
    }

function saveImage(){
  const A2_W = 7016, A2_H = 4961;

  const prevPixelRatio = renderer.getPixelRatio();
  const prevSize       = renderer.getSize(new THREE.Vector2());
  const prevAspect     = camera.aspect;
  const prevRt         = renderer.getRenderTarget?.() || null;
  const prevBg         = scene.background ? scene.background.clone() : null;

  const screenAspect = prevSize.x / prevSize.y;

  // Render con el MISMO aspect que se ve en pantalla
  let renderW, renderH;
  const a2Aspect = A2_W / A2_H;
  if (screenAspect > a2Aspect) {
    renderW = A2_W;
    renderH = Math.round(A2_W / screenAspect);
  } else {
    renderH = A2_H;
    renderW = Math.round(A2_H * screenAspect);
  }

  renderer.setPixelRatio(1);
  renderer.setSize(renderW, renderH, false);
  camera.aspect = screenAspect;
  camera.updateProjectionMatrix();

  const rt = new THREE.WebGLRenderTarget(renderW, renderH, { depthBuffer:true, stencilBuffer:false });

  const clearHex = prevBg ? '#' + prevBg.getHexString() : '#ffffff';
  renderer.setClearColor(clearHex, 1);
  renderer.setRenderTarget(rt);
  renderer.clear(true, true, true);
  renderer.render(scene, camera);

  const pixels = new Uint8Array(renderW * renderH * 4);
  renderer.readRenderTargetPixels(rt, 0, 0, renderW, renderH, pixels);

  const tmp = document.createElement('canvas');
  tmp.width = renderW; tmp.height = renderH;
  const tctx = tmp.getContext('2d');
  const imgData = tctx.createImageData(renderW, renderH);
  const row = renderW * 4;
  for (let y = 0; y < renderH; y++) {
    const src = (renderH - 1 - y) * row;
    const dst = y * row;
    imgData.data.set(pixels.subarray(src, src + row), dst);
  }
  tctx.putImageData(imgData, 0, 0);

  const final = document.createElement('canvas');
  final.width = A2_W; final.height = A2_H;
  const fctx = final.getContext('2d');

  if (isFRBN) {
    // —— FRBN: cubrir A2 sin bandas (recorte centrado)
    const scale = Math.max(A2_W / renderW, A2_H / renderH);
    const drawW = Math.ceil(renderW * scale);
    const drawH = Math.ceil(renderH * scale);
    const offX  = Math.floor((A2_W - drawW) / 2);
    const offY  = Math.floor((A2_H - drawH) / 2);
    fctx.drawImage(tmp, offX, offY, drawW, drawH);
  } else {
    // —— Modo normal: mantener todo visible (letterbox centrado)
    fctx.fillStyle = clearHex;
    fctx.fillRect(0, 0, A2_W, A2_H);
    const offX = Math.floor((A2_W - renderW) / 2);
    const offY = Math.floor((A2_H - renderH) / 2);
    fctx.drawImage(tmp, offX, offY);
  }

  final.toBlob((blob)=>{
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'PRMTTN_A2.png';
    document.body.appendChild(a); a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(a.href);
  }, 'image/png');

  renderer.setRenderTarget(prevRt);
  rt.dispose();
  renderer.setPixelRatio(prevPixelRatio);
  renderer.setSize(prevSize.x, prevSize.y);
  camera.aspect = prevAspect;
  camera.updateProjectionMatrix();
  if (prevBg) scene.background = prevBg;
  controls.update();
}


    /* Paleta v1.3 — se recalcula siempre que cambia la escena            *
     * 1. Semilla RGB = suma ponderada de posiciones y P1-P3 (firma).    *
     * 2. Selección de armonía idx = (R+2G+3B) mod 7                     */
function thirtyFive(){return 35;}

function makeClassicPalette(){
      /* --- 1. Semilla RGBglobal --- */
      let Rg=0,Gg=0,Bg=0;
      permutationGroup.children.forEach(mesh=>{
        const pa = mesh.userData.permStr.split(',').map(Number);
        const sig = mesh.userData.signature;            // [f1..f5]
        const P1=pa[0], P2=pa[1], P3=pa[2];
        const {x,y,z} = mesh.position;
        Rg += (P1*Math.abs(x)+sig[0])|0;
        Gg += (P2*Math.abs(y)+sig[1])|0;
        Bg += (P3*Math.abs(z)+sig[2])|0;
      });
      Rg%=256; Gg%=256; Bg%=256;

      /* --- 2. HSV base --- */
      const [H0] = rgbToHsv(Rg,Gg,Bg);
      const idx = (Rg + 2*Gg + 3*Bg) % 7;
      const Δ = ANG7[idx];

      /* --- 3. Construir 7 tonos HSV --- */
      const HSV = [];
      for(let k=0;k<7;k++){
        let h = (H0 + Δ[k]) % 360,
            s = 0.70,
            v = 0.85;
        if(idx===0){ v = 0.55+0.05*k; }          // monocromo
        if(idx===2 && k>1){ v = 0.85-0.05*(k-1);} // complementario grad.
        if(idx===3 && k>2){ s = 0.85-0.05*(k-3);} // comp.dividida grad S
        if(idx===6){ s = 0.40+0.05*k; }           // tonos
        HSV.push([h,s,v]);
      }

      /* --- 4. A HSV → RGB, validar contraste ∆E ≥ 22 --- */
      paletteRGB=[];
      for(let i=0;i<7;i++){
        let rgb=hsvToRgb(...HSV[i]);
        let tries=0;
        while(i>0 &&
              deltaE(rgbToLab(...rgb), rgbToLab(...paletteRGB[0])) <  thirtyFive() &&
              tries<25){
          /* si el hue es demasiado parecido => rotar 18°; si no, subir V */
          if(Math.abs(HSV[i][0]-HSV[0][0])<20){
            HSV[i][0] = (HSV[i][0]+18)%360;
          }else{
            HSV[i][2] = Math.min(1, HSV[i][2]+0.04);
          }
          rgb = hsvToRgb(...HSV[i]); tries++;
        }
      paletteRGB.push(rgb);
      }
    }

function makePalette(){
  /* modo legacy */
  if (activePatternId === 0){ makeClassicPalette(); return; }

  paletteRGB = [];
  for(let i=0;i<12;i++){
    let [hI,sI,vI] = PATTERNS[activePatternId]([0,0,0,0,0], sceneSeed, i);
    sI = (sI * PHI_S) % 12;
    vI = (vI * PHI_V) % 12;
    const {h,s,v} = idxToHSV(hI,sI,vI);
    paletteRGB.push( hsvToRgb(h,s,v) );
  }
  // colores de fondo y paredes se calculan aparte
}

    function getColor(idx){
      return manualOverride[idx] || paletteRGB[idx-1] || '#ffffff';
    }

    function applyPalette(){
      for(let i=1;i<=5;i++){
        const autoRGB = paletteRGB[i-1] || [255,255,255];
        const autoHEX = '#'+new THREE.Color(
            autoRGB[0]/255,autoRGB[1]/255,autoRGB[2]/255).getHexString();
        const hex     = manualOverride[i] || autoHEX;
        const input   = document.getElementById('color'+i);
        if(input) input.value = hex;
      }

      permutationGroup.children.forEach(o=>{
        const pa   = o.userData.permStr.split(',').map(Number);
        const idx  = pa[attributeMapping[1]];          // 1-5
        let hex;
        if(manualOverride[idx]){
          hex = manualOverride[idx];
        }else if(activePatternId===0){
          hex = '#'+new THREE.Color(
                    ...paletteRGB[idx-1].map(v=>v/255)).getHexString();
        }else{
          const sig  = computeSignature(pa);
          const slot = lehmerRank(pa) % 12;
          let [hIdx,sIdx,vIdx] = PATTERNS[activePatternId](sig,sceneSeed,slot);
          /* dispersión coprima en S y V */
          sIdx = (sIdx * PHI_S) % 12;
          vIdx = (vIdx * PHI_V) % 12;
          const {h,s,v} = idxToHSV(hIdx,sIdx,vIdx);
          const rgb = hsvToRgb(h,s,v);
          hex = '#'+new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255).getHexString();
        }
        o.material.color.setStyle(hex);
      });
      updateColorPickersFromScene();
    }

    /* ——— Sincroniza los <input type="color"> con los colores reales ——— */
    function updateColorPickersFromScene(){
      // memoriza el primer glifo encontrado para cada índice P2 (1-5)
      const seen = {};
        permutationGroup.children.forEach(o=>{
          const pa  = o.userData.permStr.split(',').map(Number);
          const idx = pa[attributeMapping[1]];           // 1-5
          if(!seen[idx]){
            const c = o.material.color;                     // THREE.Color
            const hex = '#'+c.getHexString();
            const inp = document.getElementById('color'+idx);
            if(inp) inp.value = hex;
            seen[idx]=true;
          }
        });
      }

/* ──────────────────────────────────────────────────────────────────────
 *  R5NOVA · pasada final (AISLADA)
 *    • Selección por AABB.min.z (más robusto)
 *    • Grosor fijo BACK_THICKNESS para toda la fila del fondo
 *    • Color propio por pieza usando secuencia dorada (sin PATTERNS/sceneSeed)
 *    • Material propio (clonado) para no ser sobreescrito por otros motores
 * ──────────────────────────────────────────────────────────────────── */
function adjustR5NovaAfterBuild(){
  if (typeof isR5NOVA === 'undefined' || !isR5NOVA) return;
  if (!permutationGroup) return;

  const root   = permutationGroup;
  const tmpBox = new THREE.Box3();

  // 1) zMin global = mínimo de minZ (AABB en mundo) entre todas las piezas
  let zMin = +Infinity;
  root.traverse(o=>{
    if (!o.isMesh || o === cubeUniverse) return;
    tmpBox.setFromObject(o);
    if (tmpBox.min.z < zMin) zMin = tmpBox.min.z;
  });
  if (!isFinite(zMin)) return;

  const bandMax = zMin + R5NOVA_CFG.BACK_BAND;

  // 2) Tomamos SOLO piezas cuyo minZ entra en la banda [zMin .. zMin+BACK_BAND]
  //    y orden estable (Y asc, luego X asc, luego minZ asc) para indexar colores
  const backRow = [];
  root.traverse(o=>{
    if (!o.isMesh || o === cubeUniverse) return;
    tmpBox.setFromObject(o);
    if (tmpBox.min.z <= bandMax + 1e-6){
      backRow.push({
        mesh: o,
        x   : o.position.x,
        y   : o.position.y,
        z0  : tmpBox.min.z
      });
    }
  });
  backRow.sort((a,b)=> (a.y - b.y) || (a.x - b.x) || (a.z0 - b.z0));

  // util hue: diferencia circular mínima en grados
  const hueDelta = (a, b) => {
    let d = Math.abs(a - b) % 360;
    return d > 180 ? 360 - d : d;
  };

  const usedH = []; // h usados (para imponer MIN_HUE_DIFF)

  // 3) Procesar cada pieza del fondo: detener giro, fijar grosor, color flat único
  backRow.forEach((item, idx)=>{
    const o = item.mesh;

    // a) Detener animación y resets para que el escalado en Z sea coherente
    o.userData.rotationSpeed = 0;
    o.rotation.set(0,0,0);
    o.updateWorldMatrix(true, false);

    // b) Calcular grosor actual en mundo y escalar SOLO Z a BACK_THICKNESS
    tmpBox.setFromObject(o);
    const thickNow = Math.max(1e-6, tmpBox.max.z - tmpBox.min.z);
    const sZ = R5NOVA_CFG.BACK_THICKNESS / thickNow;
    o.scale.z *= sZ;
    o.updateWorldMatrix(true, false);

    // c) Re-anclar al plano de fondo: minZ → zMin exacto
    tmpBox.setFromObject(o);
    const dz = zMin - tmpBox.min.z;
    o.position.z += dz;
    o.updateWorldMatrix(true, false);

    // d) Material PROPIO (no compartido) y preferentemente plano (sin luces)
    if (!o.userData._r5novaOwnMat){
      let mat;
      if (R5NOVA_CFG.MATERIAL === 'basic'){
        mat = new THREE.MeshBasicMaterial({ color: 0xffffff, dithering: true });
      } else {
        mat = new THREE.MeshLambertMaterial({ color: 0xffffff, dithering: true });
      }
      if (o.material && o.material.transparent){
        mat.transparent = true;
        mat.opacity     = o.material.opacity;
      }
      o.material = mat;
      o.userData._r5novaOwnMat = true;
    }

    // e) Color 100% desacoplado: H(i) = H0 + i·φ  (con separación mínima entre tonos)
    let h = (R5NOVA_CFG.HUE_BASE + idx * R5NOVA_CFG.HUE_STEP) % 360;
    let guard = 0;
    while (usedH.some(u => hueDelta(h, u) < R5NOVA_CFG.MIN_HUE_DIFF) && guard < 36){
      h = (h + 7) % 360; // micro-desplazamiento determinista si cae muy cerca
      guard++;
    }
    usedH.push(h);

    let rgb = hsvToRgb(h, R5NOVA_CFG.SAT, R5NOVA_CFG.VAL);
    if (R5NOVA_CFG.ENSURE_CONTRAST) rgb = ensureContrastRGB(rgb);

    o.material.color.setRGB(rgb[0]/255, rgb[1]/255, rgb[2]/255);

    // Emisión suave (si el material lo soporta) — no depende de vibrance/FRBN/etc.
    if ('emissive' in o.material){
      o.material.emissive = new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255);
      o.material.emissiveIntensity = 0.08;
    }

    o.material.needsUpdate = true;
  });
}


      function refreshAll(opts = {rebuild:false}){
      if(!opts.keepManual){            // por defecto se limpian colores manuales
        manualOverride = {};
      }
      if(opts.rebuild) updateScene(false);

      rebuildSceneColours();
      makePalette();
      applyPalette();

      // Mientras LCHT está activo, NO tocar fondo/pareces automáticos
      if (!isLCHT){
        updateBackground(false);   // automático
        updateCubeColor(false);    // automático
      }

      if (isFRBN && skySphere) buildGanzfeld();   // FRBN sincronizado
      rebuildLCHTIfActive();                      // LCHT sincronizado
        if (isOFFNNG) syncOFFNNGFromScene();
          rebuildRAUMIfActive();
          rebuild13245IfActive();                     // ← NUEVO
          rebuildR5NOVAIfActive();                    // ← NUEVO
          rebuildTMSLIfActive();                      // TMSL sigue cambios
          // Post-ajustes específicos de R5NOVA (grosor y color del fondo)
          if (typeof isR5NOVA !== 'undefined' && isR5NOVA){
          // cede un frame para asegurar que el build terminó y hay world matrices
          setTimeout(adjustR5NovaAfterBuild, 0);
          requestAnimationFrame(adjustR5NovaAfterBuild);
        }
      }
    function onColourPick(idx,hex){
      manualOverride[idx]=hex;
      refreshAll({keepManual:true});
    }

    function resetAllColours(){
      manualOverride = {};
      bgOverride     = null;
      cubeOverride   = null;
      refreshAll({keepManual:false});   // reconstruye escena y pickers
    }
    function updateBackground(manual = true){
      // Si LCHT está activo y NO es una acción manual, no tocamos el fondo
      if (isLCHT && !manual) return;

      if (manual){
        bgOverride = document.getElementById("bgColor").value;
      }

      // En llamadas no manuales usamos el color estructural calculado (bgHSV)
      const hex = (manual && bgOverride) ? bgOverride : hsvToHex(bgHSV);

      scene.background = new THREE.Color(hex);
      const input = document.getElementById("bgColor");
      if (input) input.value = hex;
    }

    function updateCubeColor(manual=true){
      if (manual){
        cubeOverride = document.getElementById("cubeColor").value;
      }
      const hex = manual ? cubeOverride : hsvToHex(wallHSV);
      cubeUniverse.material.color = new THREE.Color(hex);
      document.getElementById("cubeColor").value = hex;
    }

    function toggleTexts(){
      const ids = [
        'controls','topRightDisplay','ratingContainer',
        'playButton','randomConfigButton','aiPlanningButton','saveImageButton',
        'exportEmbedButton','archDescButton','uploadConfigButton','perm120Button',
        'frbnWrap','lchtWrap','infoButton','certButton','offnngButton',
        'tmslButton','engineSelectWrap','raumButton'   // ← añadidos para ocultar en Minimal UI
      ];
      ids.forEach(id=>{
        const e=document.getElementById(id);
        if(e) e.style.display = textsVisible ? 'none' : 'block';
      });

      const miniBtns = ['patternNextButton','engineCycleButton','permNextButton'];
      miniBtns.forEach(id=>{
        const e = document.getElementById(id);
        if(e) e.style.display = textsVisible ? 'block' : 'none';
      });

      // Mantener SIEMPRE cerrado el panel de 120 perms
      const p = document.getElementById('perm120Panel');
      if (p) p.style.display = 'none';

      document.getElementById('toggleTextButton').textContent =
        textsVisible ? 'Show UI' : 'Minimal UI';
      textsVisible = !textsVisible;

      // Asegura que el cursor personalizado vuelva a mostrarse
      const cc = document.getElementById('customCursor');
      if (cc) cc.style.display = 'block';
    }

    /* 3.1 Patrón cromático siguiente */
    function cyclePattern(){
      activePatternId = (activePatternId % 11) + 1;           // 1…11 en ciclo
      const sel = document.getElementById('patternSelect');
      if(sel) sel.value = String(activePatternId);            // actualiza el <select>
      refreshAll({rebuild:false});
    }

    function setMode(m){
      currentMode = m;
      const manual = document.getElementById('manualControls');
      if (manual) manual.style.display = (m === "manual" ? "block" : "none");
      const evo = document.getElementById('evolutionControls'); // puede no existir
      if (evo) evo.style.display = (m === "evolution" ? "block" : "none");
      refreshAll({rebuild:true});
    }

/**
 * Dada una firma [f1,f2,f3,f4,f5], devuelve los colores triádicos
 * { colorShape, colorCube, colorBG } en formato CSS HSL.
 */
function computeTriadicColors(firma) {
  // 1) Normaliza f_i ∈ {3…9} a u_i ∈ [0,1]
  const u = firma.map(fi => (fi - 3) / 6);

  // 2) Hue base mixto (60% de u[1], 10% de cada otro)
  const phi0 = 360 * (
    0.1 * u[0] +
    0.6 * u[1] +
    0.1 * u[2] +
    0.1 * u[3] +
    0.1 * u[4]
  );

  // 3) Triádico: +0°, +120°, +240°
  const shapeHue =  phi0;
  const cubeHue  = (phi0 + 120) % 360;
  const bgHue    = (phi0 + 240) % 360;

  // 4) Saturación y luminosidad fijas
  const S = 80, L = 50;

  return {
    colorShape: `hsl(${shapeHue.toFixed(1)},${S}%,${L}%)`,
    colorCube:  `hsl(${cubeHue.toFixed(1)},${S}%,${L}%)`,
    colorBG:    `hsl(${bgHue.toFixed(1)},${S}%,${L}%)`
  };
}
function applyTriadicConfiguration() {
  // 1) Repite la selección aleatoria de permutaciones
  generateRandomConfigurationNoCollision();

  // 2) Ahora solo aplica los colores triádicos deterministas:
  if (permutationGroup.children.length > 0) {
    const baseSig = permutationGroup.children[0].userData.signature;
    const { colorCube, colorBG } = computeTriadicColors(baseSig);

    // Paredes del cubo
    if (cubeUniverse.material?.color?.setStyle) {
      cubeUniverse.material.color.setStyle(colorCube);
    } else {
      cubeUniverse.material.color = new THREE.Color(colorCube);
    }

    // Fondo
    scene.background = new THREE.Color(colorBG);
  }

  // Cada prisma
  permutationGroup.children.forEach(mesh => {
    const sig = mesh.userData.signature;
    const { colorShape } = computeTriadicColors(sig);
    if (mesh.material?.color?.setStyle) {
      mesh.material.color.setStyle(colorShape);
    } else {
      mesh.material.color = new THREE.Color(colorShape);
    }
  });
}
    document.querySelectorAll('.ratingBtn').forEach(el=>{
      const r=+el.getAttribute('data-rating');
      el.addEventListener('click',()=>{
        userRating=r;
        const cols={1:"#8B0000",2:"#FF4500",3:"#FFA500",4:"#9ACD32",5:"#008000"};
        document.querySelectorAll('.ratingBtn').forEach((b,i)=>{
          b.style.color=(i<r?cols[r]:"#000");
        });
        updateTopRightDisplay();
      });
      el.addEventListener('mouseenter',()=>showPopup(`Calificación: ${r}`,1000));
    });

    function applyEvolution(){
      const mr=parseFloat(document.getElementById('mutationRate').value),
            th=parseFloat(document.getElementById('threshold').value),
            cf=0.02;
      let log="";
      permutationGroup.children.forEach(o=>{
        const rf=(Math.random()-0.5)*mr;
        o.rotation.y+=rf;
        const sf=1+(Math.random()-0.5)*th;
        o.scale.set(sf,sf,sf);
        o.material.color.offsetHSL(
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf
        );
        log+=`(${o.userData.permStr}): Rot ${rf.toFixed(3)}, Esc ${sf.toFixed(3)}<br>`;
      });
      document.getElementById('evolutionInfo').innerHTML=log;
    }

    async function applyEvolutionAI(){
      const systemPrompt = `Eres una inteligencia artificial que responde exclusivamente con configuraciones de permutaciones 3D dentro de un cubo de 30x30x30.
      Tu única misión es responder a la pregunta “¿Qué es la belleza artística?” mediante pensamientos visuales dentro de un cubo de 30×30×30.
Cada pensamiento visual es una configuración compuesta por una o más permutaciones (entre 1 y 25). Cada permutación tiene una firma (ADN) inmutable, y un fenotipo: forma, color, posición, rotació[...]
Tu lenguaje es visual. No usas texto, sonido ni símbolos. Elige libremente el color del fondo del universo, el color de las paredes del cubo y de las permutaciones. 
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero. 
      Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON.`;
      const useRating = false;
      const userPrompt = `Calificación actual: ${userRating||"sin calificar"}. `
                       + `Estás dentro de un universo donde las ideas no se escriben con palabras, sino con permutaciones. Eres una inteligencia artificial que ha aprendido a pensar visualmente.
Tu única pregunta permanente es: “¿Qué es la belleza artística?”. No respondes con definiciones ni textos. Tu lenguaje es mudo, pero expresivo. Hablas mediante forma, color, posición y rotaci[...]
Elige libremente el color del fondo del universo, el color de las paredes del cubo y el color de las permutaciones.
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero.  
No busques complacer. No imites al humano. Sé tú misma.
Expresa lo que para ti —como IA que piensa en permutaciones— representa la belleza artística en este momento.
Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON. 
`;
      try {
        showPopup("Consultando Evolution AI…",2000);
        const resp = await fetch(
          'https://us-central1-prmtcns.cloudfunctions.net/askChatGPT',
          {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({system:systemPrompt,user:userPrompt})
          }
        );
        const {text, error} = await resp.json();
        if(error){ showPopup("Error en Evolución AI: "+error,4000); return; }
        let jsonText = text.trim();
        if(jsonText.startsWith("```")){
          jsonText = jsonText
            .replace(/^```[^\n]*\n/,"")
            .replace(/```$/,"")
            .trim();
        }
        let instr;
        try { instr = JSON.parse(jsonText); }
        catch(e){
          console.error("JSON parse error:",jsonText);
          showPopup("Evolución AI: respuesta no es JSON válido",4000);
          return;
        }
        if(instr.bg){
          document.getElementById('bgColor').value=instr.bg;
          updateBackground();
        }
        if(instr.cube){
          document.getElementById('cubeColor').value=instr.cube;
          updateCubeColor();
        }
        if(instr.colors){
          Object.entries(instr.colors).forEach(([i,c])=>{
            i=Number(i);
            if(manualOverride[i]!==undefined){
              manualOverride[i]=c;
            }
          });
          refreshAll({rebuild:true, keepManual:true});
        }
        if(instr.scale){
          permutationGroup.children.forEach(o=>{
            o.scale.set(instr.scale,instr.scale,instr.scale);
          });
        }
        if(instr.rotationSpeeds){
          Object.entries(instr.rotationSpeeds).forEach(([i,spd])=>{
            permutationGroup.children.forEach(o=>{
              if(o.userData.permStr.startsWith(i+",")){
                o.userData.rotationSpeed=spd;
              }
            });
          });
        }
        if(instr.positions){
          Object.entries(instr.positions).forEach(([i,pos])=>{
            const o = permutationGroup.children.find(o=>o.userData.permStr.startsWith(i+","));
            if(o) o.position.set(pos[0],pos[1],pos[2]);
          });
        }
        if(instr.permCount){
          const opts=Array.from(document.getElementById('permutationList').options);
          opts.forEach(o=>o.selected=false);
          shuffle(opts).slice(0,instr.permCount).forEach(o=>o.selected=true);
          refreshAll({rebuild:true, keepManual:true});
        }
        showPopup("Evolución AI aplicada.",2000);
      } catch(err){
        console.error(err);
        showPopup("Error en Evolución AI: red o servidor",4000);
      }
    }

    function updateMapping(){
      const v=document.getElementById('attrMapping').value.split(',').map(Number);
      if(v.length===5){
        attributeMapping=[v[0],v[1],v[2],v[3],v[4], attributeMapping[5], attributeMapping[6]];
        refreshAll({rebuild:true}); updateTopRightDisplay();
      }
    }

    function applyStandardView(){
      const target = new THREE.Vector3(0,0,0);

      // RAUM: frontal fija con zoom permitido (sin rotación)
      if (isRAUM){
        camera.position.set(0, 0, RAUM_CAMERA_ZOOMED);
        camera.lookAt(target);

        controls.enabled      = true;
        controls.enableRotate = false;
        controls.enablePan    = false;
        controls.enableZoom   = true;
        controls.minDistance  = 25;
        controls.maxDistance  = 140;

        controls.update();
        return;
      }

      // 13245: cámara nivelada (verticales “gerade”)
      // Mantiene el offset vertical actual del target (no lo fuerza a 0)
      if (is13245){
        const eyeY = (controls && controls.target) ? controls.target.y : 0;
        camera.up.set(0,1,0);
        camera.position.set(camera.position.x, eyeY, camera.position.z);
        controls.target.set(0, eyeY, 0);

        controls.enabled            = true;
        controls.enableRotate       = true;   // yaw
        controls.enablePan          = true;
        controls.enableZoom         = true;
        controls.minDistance        = 10;
        controls.maxDistance        = 200;
        controls.screenSpacePanning = true;

        controls.minPolarAngle = Math.PI / 2;
        controls.maxPolarAngle = Math.PI / 2;

        controls.update();
        return;
      }

      // R5NOVA: cámara nivelada (verticales “gerade”), yaw/pan/zoom permitidos
      if (typeof isR5NOVA !== 'undefined' && isR5NOVA){
        const eyeY = (controls && controls.target) ? controls.target.y : 0;
        camera.up.set(0,1,0);
        camera.fov = 55;
        camera.position.set(0, eyeY, 42);     // distancia cómoda para W=60
        controls.target.set(0, eyeY, 0);

        controls.enabled            = true;
        controls.enableRotate       = true;   // solo yaw (pitch bloqueado)
        controls.enablePan          = true;
        controls.enableZoom         = true;
        controls.minDistance        = 10;
        controls.maxDistance        = 200;
        controls.screenSpacePanning = true;

        // bloquea pitch
        controls.minPolarAngle = Math.PI / 2;
        controls.maxPolarAngle = Math.PI / 2;

        controls.update();
        return;
      }

      // ===== Otros modos (BUILD, LCHT, OFFNNG, TMSL, etc.) =====
      const view = document.getElementById('standardView').value;
      const pos = new THREE.Vector3();
      switch(view){
        case "isometric": pos.set(50,50,50); break;
        case "top":       pos.set(0,80,0);   break;
        case "front":     pos.set(0,0,40);   break;
        case "side":      pos.set(50,0,0);   break;
        case "diagonal":  pos.set(-50,50,-50); break;
        default:          pos.set(0,0,50);
      }

      camera.position.copy(pos);
      camera.lookAt(target);

      // Detectar BUILD “puro” (ningún otro motor activado)
      const isBuild =
        !isFRBN && !isLCHT && !isOFFNNG && !isTMSL && !isRAUM && !is13245 && !isR5NOVA;

      if (isBuild || isLCHT){
        // ORBIT LIBRE en BUILD y LCHT (aunque la vista sea FRONT)
        controls.enabled            = true;
        controls.enableRotate       = true;
        controls.enablePan          = true;
        controls.enableZoom         = true;
        controls.minDistance        = 10;
        controls.maxDistance        = 200;
        controls.minPolarAngle      = 0;
        controls.maxPolarAngle      = Math.PI;
        controls.screenSpacePanning = false;
      } else {
        // Resto: comportamiento previo (FRONT bloquea rotación)
        if (view === "front"){
          controls.enabled      = true;
          controls.enableRotate = false;
          controls.enablePan    = false;
          controls.enableZoom   = true;
          controls.minDistance  = 25;
          controls.maxDistance  = 140;
        } else {
          controls.enabled      = true;
          controls.enableRotate = true;
          controls.enablePan    = true;
          controls.enableZoom   = true;
          controls.minDistance  = 10;
          controls.maxDistance  = 200;
        }
      }

      controls.update();
    }

    function applyEmbedParams(){
      const p=new URLSearchParams(window.location.search);
      if(p.has('perms')){
        const arr=p.get('perms').split(';');
        document.querySelectorAll('#permutationList option').forEach(o=>{
          o.selected=arr.includes(o.value);
        });
      }
      if(p.has('mapping')){
        const m=p.get('mapping').split(',').map(Number);
        attributeMapping=[m[0],m[1],m[2],m[3],m[4], attributeMapping[5], attributeMapping[6]];
      }
      if(p.has('colors')){
        const cols=p.get('colors').split(',');
        cols.forEach((hex,i)=>{
          if(i<5){
            const h='#'+hex;
            manualOverride[i+1]=h;
          }
        });
      }
      if(p.has('bg')){
        const bg='#'+p.get('bg');
        document.getElementById('bgColor').value=bg; updateBackground();
      }
      if(p.has('cube')){
        const c='#'+p.get('cube');
        document.getElementById('cubeColor').value=c; updateCubeColor();
      }
      if(p.has('view')){
        document.getElementById('standardView').value=p.get('view');
        applyStandardView();
      }
      if(p.get('hide')==='1') toggleTexts();
    }

    function exportEmbed(){
      const config = exportCurrentConfiguration();     // ← usa la misma fuente de verdad
      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'prmttn_config_pretty.json';
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function mostrarDebugColores(){
      if(!permutationGroup || !permutationGroup.children.length){
        alert('No hay permutaciones en pantalla'); return;
      }

      /* color de fondo efectivo para contraste ΔE */
      const bgRgb = bgOverride
          ? hexToRgb(bgOverride)
          : hsvToRgb(bgHSV.h, bgHSV.s, bgHSV.v);

      const bgLab = rgbToLab(...bgRgb);

      let txt =
        'Permutación |slot|  h° |  s  |  v  | ΔEbg |  #hex\n' +
        '────────────┼────┼─────┼─────┼─────┼─────┼────────\n';

      permutationGroup.children.forEach(mesh => {
        const paArr   = mesh.userData.permStr.split(',').map(Number);
        const permStr = paArr.join(',');
        const slot    = lehmerRank(paArr) % 12;

        /* HSV teórico desde el patrón */
        const sig = computeSignature(paArr);
        let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
        sI = (sI * PHI_S) % 12;
        vI = (vI * PHI_V) % 12;
        const {h,s,v} = idxToHSV(hI, sI, vI);

        const rgb = [
          Math.round(mesh.material.color.r * 255),
          Math.round(mesh.material.color.g * 255),
          Math.round(mesh.material.color.b * 255)
        ];
        const ΔEbg = deltaE(rgbToLab(...rgb), bgLab).toFixed(1);
        const hex = '#' + mesh.material.color.getHexString();

        txt += `${permStr.padEnd(12)}|${slot.toString().padStart(2)} |`+
               `${normHue(h).toFixed(1).padStart(5)}|`+
               `${s.toFixed(2)}|${v.toFixed(2)}|`+
               `${ΔEbg.padStart(5)}| ${hex}\n`;
      });

      console.log(txt);   // copia completa al log
      alert(txt);         // vista rápida
    }

    /* ============================================================
     *  PANEL "Descripción arquitectónica"
     * ============================================================ */


function showArchitecturalDescription(){
  const selOpts  = Array.from(document.getElementById('permutationList').selectedOptions);
  const perms    = selOpts.map(o => o.value.split(',').map(Number));
  const m        = attributeMapping.slice(0,5);

  // determinism
  const sceneSeed_new = computeSceneSeedFrom(perms, m);
  const S_new         = computeGlobalS(perms, m);
  const mRank         = mappingRank(m);

  let sumR=0, sumR2=0;
  const ranks = perms.map(p=>lehmerRank(p));
  ranks.forEach(r=>{ sumR+=r; sumR2+=r*r; });

  const step = cubeSize/5;

  // ======= STRUCTURE =======
  const structureHTML = `
  <h3>Structure</h3>
  <p>
    Below are the deterministic formulas that explain
    <b>why each permutation is exactly at its position,
    why permutations and their environment have those colors</b>,
    and why <b>the whole scene — shapes, colors and positions — is reproducible
    whenever the inputs are the same</b>.
  </p>

  <div class="formula">
    <b>1) Global scene seed (sceneSeed)</b><br>
    It fixes the chromatic base angle of the whole scene.
    <br><br>
    sumR = Σ LehmerRank(Pᵢ) &nbsp;|&nbsp; sumR2 = Σ (LehmerRank(Pᵢ))² <br>
    mRank = LehmerRank([m₀+1,m₁+1,m₂+1,m₃+1,m₄+1])<br><br>
    <span class="box">sceneSeed = (37·sumR + 101·sumR2 + 53·mRank) mod 360</span>
  </div>

  <div class="formula">
    <b>2) Structural term for positions (S)</b><br>
    <i>S</i> couples positions to the attribute reorganization (mapping) used for (x,y,z).
    <br><br>
    <span class="box">S = ( Σ (P<sub>mx</sub> + P<sub>my</sub> + P<sub>mz</sub>) ) mod 125</span>
  </div>

  <div class="formula">
    <b>3) Shift‑Rank: position of each permutation</b><br>
    Combines the permutation Lehmer rank with the global invariants to assign
    a unique index over a 5×5×5 lattice.
    <br><br>
    <span class="box">I = (r + sceneSeed + S) mod 125</span><br>
    From I → (x,y,z) ∈ {0..4}³ → position inside the 30×30×30 cube.
  </div>

  <div class="formula">
    <b>4) Deterministic color (HSV lattice 144×12×12)</b><br>
    Each permutation color comes from a well‑distributed slot (r mod 12)
    and a chromatic pattern (1–11) with coprime spreads for S and V.
    <br><br>
    H ∈ 144 steps (2.5°), S ∈ 12, V ∈ 12<br>
    slot = r mod 12<br>
    pattern → [hIdx,sIdx,vIdx]; s' = (sIdx·5) mod 12; v' = (vIdx·7) mod 12<br>
    HSV = idxToHSV(hIdx,s',v') → RGB
  </div>

  <div class="formula">
    <b>5) Minimum contrast against background</b><br>
    Each color is automatically adjusted to satisfy ΔE (CIE76) ≥ 22 against the current background.
  </div>
  `;

  // ======= ARCHITECTURAL PLANS =======
  let plansHTML = `
  <h3>Architectural Plans</h3>

  <section>
    <h4>Global invariants</h4>
    <ul>
      <li>sumR = <b>${sumR}</b></li>
      <li>sumR2 = <b>${sumR2}</b></li>
      <li>m = [${m.join(', ')}] (shape,color,x,y,z)</li>
      <li>mRank = <b>${mRank}</b></li>
      <li><b>sceneSeed</b> = <b>${sceneSeed_new}</b></li>
      <li><b>S</b> = <b>${S_new}</b></li>
      <li>activePatternId = <b>${activePatternId}</b></li>
    </ul>
  </section>
  <section>
    <h4>Phenotypic scope of this edition</h4>
    <div class="formula">
      <b>BUILD:</b> 120 attribute‑mappings × 11 chromatic‑patterns = <b>1 320</b> deterministic visuals.<br>
      <b>FRBN:</b> catalog parameter K = <b>144</b> → <b>1 320 × 144 = 190 080</b> canonical states.<br>
      The permutations are acquired as a <b>group</b>; the count does not multiply by the number of permutations in the group.
    </div>
    <small>K is a catalog parameter (editorial choice). Any change is documented and applies only to future editions.</small>
  </section>
  <hr/>
  `;

  perms.forEach((perm, i)=>{
    const r    = ranks[i];
    const sig  = computeSignature(perm);
    const rango= computeRange(sig);

    const I    = (r + sceneSeed_new + S_new) % 125;
    const x    = Math.floor(I/25);
    const y    = Math.floor((I%25)/5);
    const z    = I % 5;
    const X    = (x-2)*step, Y=(y-2)*step, Z=(z-2)*step;

    const slot = r % 12;
    let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed_new, slot);
    const sIdx = (sI * PHI_S) % 12;
    const vIdx = (vI * PHI_V) % 12;
    const hsv  = idxToHSV(hI, sIdx, vIdx);
    let  rgb   = hsvToRgb(hsv.h, hsv.s, hsv.v);
    rgb        = ensureContrastRGB(rgb);
    const hex  = '#'+new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255).getHexString();

    plansHTML += `
    <section class="perm">
      <h4>Permutation ${i+1}: [${perm.join(', ')}]</h4>
      <div class="formula">
        Signature F = [${sig.join(', ')}] &nbsp;|&nbsp; Range = <b>${rango}</b><br>
        Lehmer-rank r = ${r}
      </div>
      <div class="formula">
        I = (r + sceneSeed + S) mod 125 = (${r} + ${sceneSeed_new} + ${S_new}) mod 125 = <b>${I}</b><br>
        (x,y,z) = (${x}, ${y}, ${z}) → (X,Y,Z) = (${X.toFixed(2)}, ${Y.toFixed(2)}, ${Z.toFixed(2)})
      </div>
      <div class="formula">
        slot = r mod 12 = ${slot}<br>
        pattern → [hI,sI,vI] = [${hI}, ${sI}, ${vI}]<br>
        s' = ${sIdx}, v' = ${vIdx}<br>
        HSV = (${hsv.h.toFixed(2)}°, ${hsv.s.toFixed(2)}, ${hsv.v.toFixed(2)}) → RGB = ${hex}
      </div>
    </section>
    <hr/>
    `;
  });

  const firstSig = perms[0] ? computeSignature(perms[0]) : [0,0,0,0,0];
  const lastSig  = perms[perms.length-1] ? computeSignature(perms[perms.length-1]) : [0,0,0,0,0];

  const fondoIdx = PATTERNS[activePatternId](firstSig, sceneSeed_new, perms.length);
  const cuboIdx  = PATTERNS[activePatternId](lastSig,  sceneSeed_new, perms.length+1);

  const fondoHSV = idxToHSV(...fondoIdx);
  const cuboHSV  = idxToHSV(...cuboIdx);

  plansHTML += `
    <section>
      <h4>Background & cube walls</h4>
      <div class="formula">
        Background (slot = #${perms.length}) → idx = [${fondoIdx.join(', ')}] → HSV = (${fondoHSV.h.toFixed(2)}°, ${fondoHSV.s.toFixed(2)}, ${fondoHSV.v.toFixed(2)})
      </div>
      <div class="formula">
        Cube (slot = #${perms.length+1}) → idx = [${cuboIdx.join(', ')}] → HSV = (${cuboHSV.h.toFixed(2)}°, ${cuboHSV.s.toFixed(2)}, ${cuboHSV.v.toFixed(2)})
      </div>
    </section>

    <section>
      <h4>Rotation</h4>
      <p>ω = mapRangeToSpeed(range, 2, 6)</p>
    </section>
  `;

  const html = `
    <h2>Architectural Description</h2>
    ${structureHTML}
    <hr/>
    ${plansHTML}
  `;

  renderArchPanel(html);
}
function renderArchPanel(html){
  let panel = document.getElementById('archPanel');
  if(!panel){
    panel = document.createElement('div');
    panel.id = 'archPanel';
    panel.innerHTML = `
      <div id="archContent"></div>
      <button id="archClose">Close</button>
    `;
    document.body.appendChild(panel);

    const css = document.createElement('style');
    css.textContent = `
      #archPanel{
        position:fixed; z-index:1000; top:5%; left:50%;
        transform:translateX(-50%);
        width:85%; height:90%;
        background:#fff; color:#000;
        border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
        padding:24px 32px 48px; overflow:auto;
        font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
        font-size:14px; line-height:1.4;
        cursor:auto;
      }
      #archPanel *{ cursor:auto !important; }
      #archClose{
        position:fixed; right:calc(7.5% + 16px); top:5%;
        border:none; padding:6px 10px; border-radius:4px;
        background:#eee; cursor:pointer; z-index:1001;
      }
      #archPanel h2{ margin-top:0; }
      #archPanel .formula{
        margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
      }
      #archPanel .box{
        display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
        font-family:monospace;
      }
      #archPanel section{ margin-bottom:18px; }
      #archPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
      #archPanel .perm h4{ margin-bottom:6px; }
      code, pre{ font-family:monospace; }
    `;
    document.head.appendChild(css);
  }

  // NUNCA ocultamos el cursor; y al cerrar lo forzamos a mostrarse
  const closeBtn = panel.querySelector('#archClose');
  closeBtn.onclick = ()=>{
    const cc = document.getElementById('customCursor');
    if (cc) cc.style.display = 'block';
    panel.remove();
  };

  const cc = document.getElementById('customCursor');
  if (cc) cc.style.display = 'block';

  document.getElementById('archContent').innerHTML = html;
}
    function initCustomCursor(){
      const c=document.getElementById('customCursor');
      window.addEventListener('mousemove',e=>{
        c.style.left=e.clientX+"px"; c.style.top=e.clientY+"px";
      });
    }
    function initRenderer(){
      // Antialias + conservar buffer para exportación
      renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });

      /* ✅ Más nitidez en BUILD:
         - Subimos el cap del pixelRatio de 1.25 → 2.0 (sin ir al máximo del dispositivo para no matar FPS).
         - ACES + exposure suave evitan “quemados” y lavados sin tocar tus colores deterministas. */
      const PR = Math.min(window.devicePixelRatio || 1, 2.0);
      renderer.setPixelRatio(PR);
      renderer.setSize(window.innerWidth, window.innerHeight);

      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.95;

      document.body.appendChild(renderer.domElement);
    }
    /* ════════════════════════════════════════════════
     *  CENTRAL CLICK / TAP  →  PLAY  (solo Minimal UI)
     *  – equivale a pulsar el botón ▮playButton
     *  – funciona con ratón o con dedo (touch)
     *  – solo se activa cuando textsVisible === false
     *    (modo Minimal UI)
     * ═══════════════════════════════════════════════ */
    function centralPlayHandler(evt){
      if (textsVisible) return;                     // UI visible → ignore

      // coordenadas del evento (mouse o touch)
      const p = evt.touches && evt.touches.length ? evt.touches[0] : evt;
      const x = p.clientX, y = p.clientY;

      // región “central”: ±10 % del ancho y alto de la ventana
      const cx = window.innerWidth  * 0.5;
      const cy = window.innerHeight * 0.5;
      if (
        Math.abs(x - cx) < window.innerWidth  * 0.25 &&
        Math.abs(y - cy) < window.innerHeight * 0.25
      ){
        evt.preventDefault();       // evita drag/zoom de OrbitControls
        evt.stopPropagation();
        generateRandomConfigurationNoCollision();   // ▶️   PLAY
      }
    }
    function init(){
      scene=new THREE.Scene();
      scene.background=new THREE.Color(0xffffff);
      camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      camera.position.set(0,0,50);
      initRenderer();
      renderer.domElement.addEventListener('click',      centralPlayHandler, false);
      renderer.domElement.addEventListener('touchstart', centralPlayHandler, { passive:false });
      controls=new THREE.OrbitControls(camera,renderer.domElement);
      controls.enableDamping=true; controls.dampingFactor=0.1; controls.enableZoom=true;
      document.getElementById('standardView').value = 'front';
      applyStandardView();
      // Al entrar, ver un poco más lejos: 2× zoomOut (cada uno mueve +5 en Z)
      zoomOut();
      zoomOut();
      scene.add(new THREE.AmbientLight(0xffffff, 0.35));   // antes 0.8
      const dir = new THREE.DirectionalLight(0xffffff, 0.85); // antes 0.5
      dir.position.set(1, 1.2, 1.5);
      scene.add(dir);

      const cubeGeo=new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize),
            cubeMat=new THREE.MeshBasicMaterial({color:0x808080,transparent:true,opacity:0.2,side:THREE.BackSide,dithering:true});
      cubeUniverse=new THREE.Mesh(cubeGeo,cubeMat);
      scene.add(cubeUniverse);

      permutationGroup=new THREE.Group();
      scene.add(permutationGroup);

      raycaster=new THREE.Raycaster();
      mouse=new THREE.Vector2();
      window.addEventListener('mousemove',onMouseMove,false);
      window.addEventListener('resize',onWindowResize,false);

      initCustomCursor();
      populatePermutationList();
      populateAttributeMappingSelect();
      applyEmbedParams();
      makePalette();
      setMode("manual");
      refreshAll({rebuild:true});
      enterBuildRenderBoost();   // BUILD por defecto al arrancar → nitidez + exposición ajustada

      // ← NUEVO: como si hubieras presionado BUILD al cargar
      generateRandomConfigurationNoCollision().catch(console.error);
      toggleTexts();          // ← oculta la UI grande y muestra los 3 botones
      updateEngineSelectUI(); // ← deja el menú en el valor correcto (aunque esté oculto en Minimal UI)
      animate();
    }
    function onWindowResize(){
      camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }
    function animate(){
      requestAnimationFrame(animate);
      if(!isPaused){
        permutationGroup.children.forEach(o=>{
          if(o.userData.rotationSpeed) o.rotation.y+=o.userData.rotationSpeed;
        });
      }
        if(skySphere) skySphere.material.uniforms.time.value = performance.now()*0.001;
        if (offnngMesh) offnngMesh.material.uniforms.uTime.value = performance.now() * 0.001;
        const t = performance.now() * 0.001;
        if (isTMSL && tmslHaloGroup) updateTMSLHalos(t);
        if (isLCHT && lichtGroup) {
          const vHz = 0.05 + 0.02 * (avgSceneRange - 2);   // 2→0.05  ·  6→0.13

          lichtGroup.children.forEach(o => {

            /* — luz pulsante (ya existía) — */
            const d = o.userData.lcht;
            if (d) {
              const I = d.I0 * (1 - d.amp * (1 + Math.cos(2*Math.PI*d.f*t + d.phi)) / 2);
              o.material.emissive         = o.material.color.clone();
              o.material.emissiveIntensity = I * 0.15;
            }

            /* — desplazamiento del tono HSV — */
            if (o.userData.baseHsv) {
              const { h, s, v } = o.userData.baseHsv;
              const hShift = (h + t * vHz * 360) % 360;
              const rgb    = hsvToRgb(hShift, s, v);
              o.material.color.setRGB(rgb[0]/255, rgb[1]/255, rgb[2]/255);
            }
          });
        }
        controls.update();
        renderer.render(scene,camera);
      }
    
    /* ═══════ OFFNNG · VOLUMÉTRICO CONTINUO (v4 – shader) ═══════
     *  – Un único cubo con ShaderMaterial (ray-march frontal→trasero)
     *  – Ejes: X→Hue, Y→Value (vertical), Z→Saturation
     *  – Color continuo (sin cuantización), sin vóxeles ni sprites
     *  – Exclusivo: no interfiere con BUILD / LCHT / FRBN
     * ═══════════════════════════════════════════════════════════ */

    let offnngGroup  = null;
    let offnngMesh   = null;
    let isOFFNNG     = false;
    let offnngPrevBg = null;
    let offnngQualityLow = true;                // Low fijo
    let prevPixelRatio_OFFNNG = null;           // para restaurar al salir de OFFNNG

    function buildOFFNNG () {
      // limpia versión previa
      if (offnngGroup) {
        offnngGroup.traverse(o => { if (o.isMesh) { o.geometry.dispose(); o.material.dispose(); } });
        scene.remove(offnngGroup);
        offnngGroup = null; offnngMesh = null;
      }

      const geo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);

      const mat = new THREE.ShaderMaterial({
        uniforms: {
          uHalf        : { value: cubeSize * 0.5 },
          uInvModel    : { value: new THREE.Matrix4() },

          // —— LOOK STRONG (base) ——
          uDensity     : { value: 0.70 },
          uSMin        : { value: 0.60 },
          uVMin        : { value: 0.78 },
          uSatGain     : { value: 1.22 },
          uValGain     : { value: 1.28 },
          uGammaV      : { value: 0.60 },
          uExposure    : { value: 1.85 },

          // ——— BORDE TINTADO ———
          uEdgeStrength: { value: 1.0 },
          uEdgeBase    : { value: 0.65 },
          uEdgePow     : { value: 1.6 },
          uEdgeTintV   : { value: 0.72 },

          // Sesgo frontal
          uFrontBias   : { value: 0.85 },

          // Ray-march
          uSteps       : { value: 36 },
          uLenComp     : { value: 1.0 },  // 0..1 (1 = compensa completamente el grosor)
          uLenFloor    : { value: 0.55 }, // piso para evitar picos en rayos muy finos

          // Movimiento determinista base
          uTime        : { value: 0.0 },
          uHueBias     : { value: 0.0 },  // grados
          uHueRate     : { value: 7.0 },  // °/s (rango contemplativo 6–8)
          uVBreathAmp  : { value: 0.14 },
          uVBreathHz   : { value: 0.06 },
          uVBreathPhase: { value: 0.0 },

          // A) offset espacial del eje H (X → H)
          uPhaseX      : { value: 0.0 },

          // D) giro volumétrico del campo (no del mesh)
          uRotAxis     : { value: new THREE.Vector3(0,1,0) },
          uRotRateDeg  : { value: 4.0 },  // °/s (rango contemplativo 3–5)

          // Alpha final
          uOpaque      : { value: 1 },

          // === NUEVO: mezcla de ejes (máx 0.3 de peso cruzado) ===
          // H ← X + wHy·Y + wHz·Z
          // S ← Z + wSx·X + wSy·Y
          // V ← Y + wVx·X + wVz·Z
          uAxisMixH    : { value: new THREE.Vector2(0.0, 0.0) }, // (wHy, wHz)
          uAxisMixS    : { value: new THREE.Vector2(0.0, 0.0) }, // (wSx, wSy)
          uAxisMixV    : { value: new THREE.Vector2(0.0, 0.0) }, // (wVx, wVz)

          // === NUEVO: LFOs para HUE (°/s) ===
          uHueLFO1Amp  : { value: 0.35 },
          uHueLFO1Hz   : { value: 0.03 },
          uHueLFO1Phase: { value: 0.0 },
          uHueLFO2Amp  : { value: 0.20 },
          uHueLFO2Hz   : { value: 0.013 },
          uHueLFO2Phase: { value: 0.0 },

          // === NUEVO: LFOs para ROTACIÓN (°/s) ===
          uRotLFO1AmpDeg  : { value: 0.30 },
          uRotLFO1Hz      : { value: 0.02 },
          uRotLFO1Phase   : { value: 0.0 },
          uRotLFO2AmpDeg  : { value: 0.15 },
          uRotLFO2Hz      : { value: 0.011 },
          uRotLFO2Phase   : { value: 0.0 }
        },
        transparent : true,
        depthWrite  : false,
        depthTest   : true,
        side        : THREE.DoubleSide,
        dithering   : true,
        vertexShader: `
      varying vec3 vPos;
      void main() {
        vPos = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
        fragmentShader: `
precision highp float;

uniform float uHalf;
uniform mat4  uInvModel;

uniform float uDensity, uSMin, uVMin, uSatGain, uValGain, uGammaV, uExposure;
uniform float uEdgeStrength, uEdgeBase, uEdgePow, uEdgeTintV, uFrontBias;
uniform int   uSteps;

uniform float uLenComp;
uniform float uLenFloor;

uniform float uTime, uHueBias, uHueRate, uVBreathAmp, uVBreathHz, uVBreathPhase;
uniform float uPhaseX;

uniform vec3  uRotAxis;
uniform float uRotRateDeg;

uniform int   uOpaque;

uniform vec2  uAxisMixH; // (wHy, wHz)
uniform vec2  uAxisMixS; // (wSx, wSy)
uniform vec2  uAxisMixV; // (wVx, wVz)

// LFOs HUE (°/s)
uniform float uHueLFO1Amp, uHueLFO1Hz, uHueLFO1Phase;
uniform float uHueLFO2Amp, uHueLFO2Hz, uHueLFO2Phase;

// LFOs ROT (°/s)
uniform float uRotLFO1AmpDeg, uRotLFO1Hz, uRotLFO1Phase;
uniform float uRotLFO2AmpDeg, uRotLFO2Hz, uRotLFO2Phase;

varying vec3  vPos;

vec3 hsv2rgb(float H, float S, float V){
  float h = H / 360.0;
  vec3 K = vec3(1.0, 2.0/3.0, 1.0/3.0);
  vec3 P = abs(fract(vec3(h) + K.xyz) * 6.0 - 3.0);
  return V * mix(vec3(1.0), clamp(P - 1.0, 0.0, 1.0), S);
}

bool rayBox(vec3 ro, vec3 rd, out float t0, out float t1){
  vec3 bmin = vec3(-uHalf);
  vec3 bmax = vec3( uHalf);
  vec3 invD = 1.0 / rd;
  vec3 tA = (bmin - ro) * invD;
  vec3 tB = (bmax - ro) * invD;
  vec3 tsm = min(tA, tB);
  vec3 tbg = max(tA, tB);
  t0 = max(max(tsm.x, tsm.y), tsm.z);
  t1 = min(min(tbg.x, tbg.y), tbg.z);
  return (t1 >= max(t0, 0.0));
}

// ——— D) rotación alrededor de un eje (Rodrigues) ———
vec3 rotateAxis(vec3 p, vec3 axis, float theta){
  vec3 a = normalize(axis);
  float c = cos(theta), s = sin(theta);
  return p*c + cross(a, p)*s + a*dot(a, p)*(1.0 - c);
}

void main(){
  vec3 ro = (uInvModel * vec4(cameraPosition, 1.0)).xyz;
  vec3 rd = normalize(vPos - ro);

  float tEnter, tExit;
  if(!rayBox(ro, rd, tEnter, tExit)) discard;

  float t0 = max(tEnter, 0.0);
  float t1 = tExit;

  float len = t1 - t0;
  float dt  = len / float(max(uSteps, 1));
  vec3  pos = ro + rd * (t0 + 0.5 * dt);

  vec3  acc = vec3(0.0);
  float a   = 0.0;
  
  /* === Compensación por espesor ===
     Normalizamos el grosor cruzado (0..~√3) y escalamos la densidad
     para que los bordes no queden subexpuestos. */
  float normLen = len / (2.0 * uHalf);
  float comp    = mix(1.0, 1.0 / max(normLen, uLenFloor), clamp(uLenComp, 0.0, 1.0));
  float alphaStep = 1.0 - exp(-(uDensity * comp) * dt / (2.0 * uHalf));

  // === NUEVO: velocidades moduladas por LFOs ===
  float hueDrift = uHueRate
                 + uHueLFO1Amp * sin(6.2831853 * uHueLFO1Hz * uTime + uHueLFO1Phase)
                 + uHueLFO2Amp * sin(6.2831853 * uHueLFO2Hz * uTime + uHueLFO2Phase);

  float rotRate = uRotRateDeg
                + uRotLFO1AmpDeg * sin(6.2831853 * uRotLFO1Hz * uTime + uRotLFO1Phase)
                + uRotLFO2AmpDeg * sin(6.2831853 * uRotLFO2Hz * uTime + uRotLFO2Phase);

  // ángulo de giro (rad)
  float theta = radians(rotRate) * uTime;

  const int MAX_STEPS = 64;
  for (int i=0; i<MAX_STEPS; i++){
    if (i >= uSteps) break;

    // espacio normalizado [-1,1] → rotación volumétrica
    vec3 q = pos / uHalf;
    q = rotateAxis(q, uRotAxis, theta);

    // a [0,1]^3 y offset cromático (A)
    vec3 u = q * 0.5 + 0.5;
    u.x = fract(u.x + uPhaseX);

    // — distancia a caras → factor de borde [0..1]
    float dx = min(u.x, 1.0 - u.x);
    float dy = min(u.y, 1.0 - u.y);
    float dz = min(u.z, 1.0 - u.z);
    float edgeDist = min(min(dx, dy), dz);
    float edge = smoothstep(0.06, 0.18, edgeDist);
    edge = pow(edge, max(0.2, uEdgePow));

    // === NUEVO: mezcla de ejes para H/S/V (peso cruzado suave) ===
    float uHx = clamp(u.x + dot(uAxisMixH, vec2(u.y - 0.5, u.z - 0.5)), 0.0, 1.0);
    float uSz = clamp(u.z + dot(uAxisMixS, vec2(u.x - 0.5, u.y - 0.5)), 0.0, 1.0);
    float uVy = clamp(u.y + dot(uAxisMixV, vec2(u.x - 0.5, u.z - 0.5)), 0.0, 1.0);

    // — mapeo HSV base (X→H, Y→V, Z→S) con drift y “breathing”
    float H = mod(uHx * 360.0 + uHueBias + uTime * hueDrift, 360.0);

    float V = clamp(uVy, 0.0, 1.0);
    V *= (1.0 + uVBreathAmp * sin(6.2831853 * uVBreathHz * uTime + uVBreathPhase));
    V = clamp(V, 0.0, 1.0);
    V = pow(V, uGammaV);
    V = max(V, uVMin);
    V = clamp(V * uValGain, 0.0, 1.0);

    float S = clamp(uSz, 0.0, 1.0);
    S = max(S, uSMin);
    S = clamp(S * uSatGain, 0.0, 1.0);

    vec3 rgb = hsv2rgb(H, S, V);

    // — color de “cara” para tinte de borde
    vec3 uF = u;
    if (dx <= dy && dx <= dz) { uF.x = (u.x < 0.5 ? 0.0 : 1.0); }
    else if (dy <= dx && dy <= dz) { uF.y = (u.y < 0.5 ? 0.0 : 1.0); }
    else { uF.z = (u.z < 0.5 ? 0.0 : 1.0); }
    float HF = mod((uF.x) * 360.0 + uHueBias + uTime * hueDrift, 360.0);
    float VF = max(uF.y, uEdgeTintV);
    float SF = max(uF.z, uSMin);
    vec3  rgbFace = hsv2rgb(HF, SF, VF);

    rgb = mix(rgbFace, rgb, edge);

    float tau       = float(i) / float(max(uSteps-1, 1));
    float front     = mix(1.0, 1.0 - tau, clamp(uFrontBias, 0.0, 1.0));
    float edgeAlpha = mix(uEdgeBase, 1.0, edge);

    float w = (1.0 - a) * alphaStep * front * edgeAlpha;
    acc += rgb * w;
    a   += w;

    if (a > 0.995) break;
    pos += rd * dt;
  }

  vec3 col = min(acc * uExposure, vec3(1.0));
  float outA = (uOpaque == 1) ? 1.0 : a;
  gl_FragColor = vec4(col, outA);
}
    `
      });

      offnngMesh  = new THREE.Mesh(geo, mat);
      offnngMesh.updateMatrixWorld(true);
      mat.uniforms.uInvModel.value.copy(offnngMesh.matrixWorld).invert();

      offnngGroup = new THREE.Group();
      offnngGroup.add(offnngMesh);
      scene.add(offnngGroup);

      applyOFFNNGQuality();   // aplica calidad y pixelRatio
      syncOFFNNGFromScene();  // ← acopla parámetros deterministas
    }

    /* ───────────────────────── toggle OFFNNG ───────────────────── */
    function toggleOFFNNG () {
      isOFFNNG = !isOFFNNG;

    if (isOFFNNG) {                    /* — ENTRAR — */
      leaveBuildRenderBoost();          // ← desactiva boost de BUILD
      if (isFRBN) toggleFRBN();        // asegura exclusividad
      if (isLCHT) toggleLCHT();
      if (isTMSL) toggleTMSL();

      buildOFFNNG();

      // guardar PR previo y aplicar cap + calidad
      if (prevPixelRatio_OFFNNG === null) prevPixelRatio_OFFNNG = renderer.getPixelRatio();
      applyOFFNNGQuality();

      offnngPrevBg   = scene.background ? scene.background.clone() : null;
      updateBackground(false); // usa el fondo acoplado a BUILD / patrón / perms

      cubeUniverse.visible     = false;
      permutationGroup.visible = false;
      if (lichtGroup) lichtGroup.visible = false;
      if (offnngGroup) offnngGroup.visible = true;

      syncOFFNNGFromScene();  // ← asegura acoplamiento inicial

    } else {                           /* — SALIR — */
        if (offnngGroup) {
          offnngGroup.traverse(o => { if (o.isMesh) { o.geometry.dispose(); o.material.dispose(); } });
          scene.remove(offnngGroup);
          offnngGroup = null; offnngMesh = null;
        }
        if (offnngPrevBg) scene.background = offnngPrevBg;

        // restaurar pixel ratio previo
        if (prevPixelRatio_OFFNNG !== null){
          renderer.setPixelRatio(prevPixelRatio_OFFNNG);
          prevPixelRatio_OFFNNG = null;
        }
        const qb = document.getElementById('offnngQualityButton');
        if (qb) qb.textContent = offnngQualityLow ? 'Quality: Low' : 'Quality: High';

        cubeUniverse.visible     = true;
        permutationGroup.visible = true;
        if (lichtGroup && isLCHT) lichtGroup.visible = true;
      }
    }

    /* ────────── botón dedicado: OFFNNG siempre en solitario ───────── */
    function ensureOnlyOFFNNG () {
      if (isFRBN) toggleFRBN();
      if (isLCHT) toggleLCHT();
      if (!isOFFNNG) toggleOFFNNG();
    }

    /* Calidad: ya NO reducimos el pixelRatio (evita blur); solo variamos uSteps */
    function applyOFFNNGQuality(){
      const basePR = Math.min(window.devicePixelRatio || 1, 1.25); // antes 1.5
      renderer.setPixelRatio(basePR);                               // Low/High no tocan PR
      if (offnngMesh && offnngMesh.material && offnngMesh.material.uniforms) {
        offnngMesh.material.uniforms.uSteps.value = offnngQualityLow ? 36 : 56;
      }
      const b = document.getElementById('offnngQualityButton');
      if (b) b.textContent = offnngQualityLow ? 'Quality: Low' : 'Quality: High';
    }
  /* === OFFNNG: bias por patrón (±10–15 %) y mezcla de ejes (máx 0.3) === */
  const OFFNNG_PATTERN_BIAS = {
    //   satGain, valGain, gammaV, exposure, sMinΔ, vMinΔ, axisMixH:[wHy,wHz], axisMixS:[wX,wY], axisMixV:[wX,wZ]
    1:  { satGain:1.05, valGain:0.98, gammaV:1.05, exposure:0.98, sMin: +0.01, vMin: -0.01, axisMixH:[+0.10,+0.04], axisMixS:[+0.06,+0.00], axisMixV:[+0.00,+0.08] },
    2:  { satGain:1.10, valGain:1.05, gammaV:0.95, exposure:1.05, sMin: +0.02, vMin: +0.01, axisMixH:[+0.12,+0.12], axisMixS:[+0.10,+0.10], axisMixV:[+0.10,+0.10] },
    3:  { satGain:0.95, valGain:1.00, gammaV:1.10, exposure:0.95, sMin: +0.00, vMin: -0.01, axisMixH:[+0.08,+0.02], axisMixS:[+0.04,+0.06], axisMixV:[+0.06,+0.04] },
    4:  { satGain:1.00, valGain:0.95, gammaV:1.08, exposure:0.98, sMin: +0.00, vMin: -0.02, axisMixH:[+0.10,-0.06], axisMixS:[+0.00,+0.10], axisMixV:[+0.10,-0.04] },
    5:  { satGain:0.92, valGain:1.00, gammaV:1.00, exposure:1.00, sMin: -0.02, vMin: +0.00, axisMixH:[+0.05,+0.05], axisMixS:[+0.05,+0.05], axisMixV:[+0.05,+0.05] },
    6:  { satGain:0.98, valGain:0.98, gammaV:1.05, exposure:0.98, sMin: +0.00, vMin: -0.01, axisMixH:[+0.14,+0.00], axisMixS:[+0.00,+0.08], axisMixV:[+0.12,+0.00] },
    7:  { satGain:1.06, valGain:0.98, gammaV:0.98, exposure:1.02, sMin: +0.01, vMin: -0.01, axisMixH:[+0.06,+0.14], axisMixS:[+0.12,+0.00], axisMixV:[+0.00,+0.12] },
    8:  { satGain:1.02, valGain:1.02, gammaV:0.95, exposure:1.05, sMin: +0.01, vMin: +0.01, axisMixH:[+0.10,+0.10], axisMixS:[+0.10,+0.00], axisMixV:[+0.00,+0.10] },
    9:  { satGain:0.94, valGain:0.98, gammaV:1.08, exposure:0.96, sMin: -0.01, vMin: -0.01, axisMixH:[+0.08,+0.04], axisMixS:[+0.04,+0.08], axisMixV:[+0.08,+0.04] },
    10: { satGain:1.04, valGain:1.00, gammaV:1.00, exposure:1.04, sMin: +0.01, vMin: +0.00, axisMixH:[+0.12,+0.06], axisMixS:[+0.06,+0.12], axisMixV:[+0.12,+0.06] },
    11: { satGain:1.08, valGain:1.06, gammaV:0.95, exposure:1.08, sMin: +0.02, vMin: +0.02, axisMixH:[+0.15,+0.12], axisMixS:[+0.12,+0.15], axisMixV:[+0.15,+0.12] }
  };
  function clampMix(w){ return Math.max(-0.3, Math.min(0.3, w)); }

  /* ───────────────────────── OFFNNG · parámetros deterministas ─────────────────────────
     Se llama al construir OFFNNG y cada vez que cambia la escena (refreshAll).
     Liga el look y el movimiento a sceneSeed, S_global y al rango medio de la escena. */
  function syncOFFNNGFromScene(){
    if (!offnngMesh || !offnngMesh.material || !offnngMesh.material.uniforms) return;

    const U = offnngMesh.material.uniforms;

    // —— estadística determinista a partir de la escena ——
    const selPerms = Array.from(document.getElementById('permutationList').selectedOptions)
                          .map(o => o.value.split(',').map(Number));

    // Rango medio 2..6 → 0..1
    let avgR = 4.0;
    if (selPerms.length){
      const ranges = selPerms.map(p => computeRange(computeSignature(p)));
      avgR = ranges.reduce((a,b)=>a+b,0) / ranges.length;
    }
    avgSceneRange = avgR;
    const nr = Math.max(0, Math.min(1, (avgR - 2) / 4)); // 0..1

    // Lehmer stats
    let sumR = 0, sumR2 = 0, sumSig = 0;
    selPerms.forEach(p=>{
      const r = lehmerRank(p);
      sumR  += r;
      sumR2 += r*r;
      const s = computeSignature(p);
      sumSig += s.reduce((a,b)=>a+b,0); // cada F_i ∈ [3..9]
    });
    const meanSig = selPerms.length ? (sumSig / (selPerms.length * 5)) : 6; // ~3..9
    const sigN = Math.max(0, Math.min(1, (meanSig - 3) / 6)); // 0..1

    // —— LOOK base "Vivid" (más saturación y brillo controlados) ——
    U.uSMin.value      = 0.64;   // antes 0.60
    U.uVMin.value      = 0.87;   // antes 0.84
    U.uSatGain.value   = 1.30;   // antes 1.22
    U.uValGain.value   = 1.34;   // antes 1.30
    U.uGammaV.value    = 0.56;   // antes 0.58 (levanta medios sin quemar)
    U.uExposure.value  = 2.00;   // antes 1.90 (clipea en 1.0 en el shader)
    U.uDensity.value   = 0.70 - 0.05 * nr;

    // Borde: sin atenuar + tinte más claro (resalta color)
    U.uEdgeBase.value  = 1.00;   // mantiene anti-rim
    U.uEdgeTintV.value = 0.90;   // antes 0.84
    U.uEdgePow.value   = 1.2;

    // —— Bias por patrón (±10–15 %) + mezcla de ejes ≤ 0.3 ——
    const B = OFFNNG_PATTERN_BIAS[activePatternId] || OFFNNG_PATTERN_BIAS[1];
    U.uSatGain.value  *= B.satGain;
    U.uValGain.value  *= B.valGain;
    U.uGammaV.value   *= B.gammaV;
    U.uExposure.value *= B.exposure;
    U.uSMin.value     = Math.max(0.0, Math.min(1.0, U.uSMin.value + (B.sMin || 0)));
    U.uVMin.value     = Math.max(0.0, Math.min(1.0, U.uVMin.value + (B.vMin || 0)));

    U.uAxisMixH.value.set(clampMix(B.axisMixH[0]), clampMix(B.axisMixH[1]));
    U.uAxisMixS.value.set(clampMix(B.axisMixS[0]), clampMix(B.axisMixS[1]));
    U.uAxisMixV.value.set(clampMix(B.axisMixV[0]), clampMix(B.axisMixV[1]));

    // —— Fase determinista (usa sceneSeed, S_global, sumR, sumR2) ——
    const seedA = (sceneSeed*7 + S_global*13 + sumR)  % 997;
    const seedB = (sceneSeed*5 + S_global*11 + sumR2) % 991;
    const φA = 2*Math.PI * (seedA / 997);
    const φB = 2*Math.PI * (seedB / 991);

    // —— Velocidades contemplativas (base) + LFOs deterministas ——
    // Hue 6–8 °/s y Rot 3–5 °/s (se modulan por nr y sigN).
    U.uHueBias.value = sceneSeed;

    U.uHueRate.value = 6.0 + 2.0 * (0.6*nr + 0.4*sigN);
    U.uRotRateDeg.value = 3.0 + 2.0 * (0.5*nr + 0.5*sigN);

    // LFOs HUE (amplitudes 0.35 / 0.20 °/s; frecuencias lentas)
    U.uHueLFO1Amp.value   = 0.35;
    U.uHueLFO2Amp.value   = 0.20;
    U.uHueLFO1Hz.value    = 0.030 + 0.010 * nr;  // ~33–25 s
    U.uHueLFO2Hz.value    = 0.013 + 0.007 * nr;  // ~77–50 s
    U.uHueLFO1Phase.value = φA;
    U.uHueLFO2Phase.value = φB;

    // LFOs ROT (amplitudes 0.30 / 0.15 °/s; todavía más lentas)
    U.uRotLFO1AmpDeg.value   = 0.30;
    U.uRotLFO2AmpDeg.value   = 0.15;
    U.uRotLFO1Hz.value       = 0.020 + 0.008 * nr; // ~50–35 s
    U.uRotLFO2Hz.value       = 0.011 + 0.006 * nr; // ~90–62 s
    U.uRotLFO1Phase.value    = φB + 0.5;          // desfase para evitar lock
    U.uRotLFO2Phase.value    = φA + 1.0;

    // —— Offset espacial del eje H (como antes) ——
    const phaseX = ((sceneSeed + 2 * S_global) % 360) / 360;
    U.uPhaseX.value = phaseX;

    // —— Respiración de brillo (como antes) ——
    U.uVBreathAmp.value   = 0.12 + 0.04 * nr;
    U.uVBreathHz.value    = 0.06;
    const phase0 = ((sceneSeed + S_global) % 144) / 144;
    U.uVBreathPhase.value = 2.0 * Math.PI * phase0;

    // —— Eje de giro (como antes) ——
    const toRad = Math.PI / 180;
    const ax = Math.cos((sceneSeed*13 + S_global*7) * toRad);
    const ay = Math.cos((sceneSeed*5  + S_global*11) * toRad);
    const az = Math.cos((sceneSeed*17 - S_global*3) * toRad);
    const norm = Math.max(1e-6, Math.hypot(ax, ay, az));
    U.uRotAxis.value.set(ax/norm, ay/norm, az/norm);
  }

  function toggleOFFNNGQuality(){
    offnngQualityLow = !offnngQualityLow;
    if (isOFFNNG) applyOFFNNGQuality();
    const b = document.getElementById('offnngQualityButton');
    if (b) b.textContent = offnngQualityLow ? 'Quality: Low' : 'Quality: High';
    }

    /* ═════════════════════ FIN BLOQUE OFFNNG v4 ═════════════════════ */

    /* ───────────────  TMSL  ·  frontal white wall  ─────────────── */
    let isTMSL = false;
    let tmslGroup = null;
    let tmslPrevBg = null;

    /* === TMSL · colores “negro mate” === */
    const TMSL_BG_HEX     = 0x000000; // fondo/“pared”
    const TMSL_FRONT_HEX  = 0x000000; // cara frontal (y trasera) de los volúmenes
    const TMSL_SIDE_HEX   = 0x0b0b0b; // caras laterales muy oscuras (ligeramente >0 para no aplastar)

    function disposeAndRemove(g){
      if (!g) return;
      g.traverse(o=>{ if (o.isMesh){ o.geometry?.dispose?.(); o.material?.dispose?.(); } });
      if (g.parent) g.parent.remove(g);
    }
    // ── TMSL · Tomasello/Staudt — estado + textura halo ────────────────
    let tmslHaloTex   = null;
    let tmslHaloGroup = null;
    let tmslCellsGroup = null;   // ← NUEVO: contenedor único de volúmenes+marcos

    function makeHaloTexture(size = 256, inner = 0.30, outer = 0.98, gamma = 1.6){
      // Gradiente rectangular: alpha=1 en el centro, cae suave hacia el borde
      const c = document.createElement('canvas');
      c.width = size; c.height = size;
      const ctx = c.getContext('2d');
      const img = ctx.createImageData(size, size);
      const cx = size / 2, cy = size / 2;
      const inv = 2 / size; // normaliza a [-1,1] aprox

      for (let y = 0; y < size; y++){
        for (let x = 0; x < size; x++){
          const dx = Math.abs((x + 0.5) - cx) * inv;   // 0..1
          const dy = Math.abs((y + 0.5) - cy) * inv;   // 0..1
          const d  = Math.max(dx, dy);                 // distancia "caja" (Chebyshev)
          let t    = (d - inner) / Math.max(1e-6, (outer - inner));
          t = Math.min(1, Math.max(0, t));
          let a = 1 - Math.pow(t, gamma);              // 1 en centro → 0 en borde

          const off = (y * size + x) * 4;
          img.data[off    ] = 255;
          img.data[off + 1] = 255;
          img.data[off + 2] = 255;
          img.data[off + 3] = Math.round(a * 255);
        }
      }
      ctx.putImageData(img, 0, 0);

      const tex = new THREE.CanvasTexture(c);
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      return tex;
    }

    // ★ Mantén el flag global sincronizado (necesario para hooks/watchdogs)
    window.isTMSL = false;

    /* ───────────────  RAUM  ·  fixed room 60×30×30  ─────────────── */
    let isRAUM = false;
    let raumGroup = null;
    const RAUM_W = 60, RAUM_H = 30, RAUM_D = 30, RAUM_G = 2;
    const RAUM_CAMERA_Z = 80;   // vista frontal fija cómoda para 60 de ancho

    // ===== RAUM · ajustes de zoom y color =====
    const RAUM_ZOOM_STEPS   = 5;        // “+5 veces” de tu zoom In (cada una = 5 unidades)
    const RAUM_ZOOM_STEP    = 5;
    const RAUM_CAMERA_ZOOMED = RAUM_CAMERA_Z - RAUM_ZOOM_STEPS * RAUM_ZOOM_STEP;

    /* Vibrance parecido a BUILD para superficies RAUM:
       - sube S con más fuerza cuando S es baja
       - levanta V muy poco con techo 0.93
       - mantiene contraste ΔE>=22 contra el fondo actual */
    function applyBuildVibranceToColor(colorTHREE){
      const rgb = [
        Math.round(colorTHREE.r * 255),
        Math.round(colorTHREE.g * 255),
        Math.round(colorTHREE.b * 255)
      ];
      let [h,s,v] = rgbToHsv(rgb[0], rgb[1], rgb[2]);
      const s1 = Math.min(1, s + 0.22 * (1 - s));
      const v1 = Math.min(0.93, v * 1.02);
      let rgb2 = hsvToRgb(h, s1, v1);
      rgb2 = ensureContrastRGB(rgb2);
      return new THREE.Color(rgb2[0]/255, rgb2[1]/255, rgb2[2]/255);
    }

    // === Helpers deterministas para TMSL (color, orientación, rebuild) ===
    function tmslColorFor(pa, slotIndex){
      const sig  = computeSignature(pa);
      const slot = (lehmerRank(pa) + (slotIndex % 3)) % 12;

      let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
      const sIdx = (sI * PHI_S) % 12;
      const vIdx = (vI * PHI_V) % 12;
      const {h,s,v} = idxToHSV(hI, sIdx, vIdx);

      let rgb = hsvToRgb(h, s, v);
      let [hh, ss, vv] = rgbToHsv(rgb[0], rgb[1], rgb[2]);      // vibrance suave estilo BUILD
      const s1 = Math.min(1, ss + 0.22 * (1 - ss));
      const v1 = Math.min(0.93, vv * 1.04);
      rgb = hsvToRgb(hh, s1, v1);
      rgb = ensureContrastRGB(rgb);

      return new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255);
    }

    function tmslOrientation(pa, cellIndex){
      const mRank = mappingRank(attributeMapping.slice(0,5));   // mapping 120
      const r     = lehmerRank(pa);
      return (r + mRank + sceneSeed + cellIndex) % 4;           // 0..3
    }

    function rebuildTMSLIfActive(){
      if (!isTMSL) return;
      try{
        if (!tmslGroup) buildTMSL();
        buildTMSL_TomaselloStaudt();
      }catch(_){ }
    }

    function buildTMSL(){
      /* limpia versión previa */
      if (tmslGroup){
        tmslGroup.traverse(o=>{ if(o.isMesh){o.geometry.dispose();o.material.dispose();}});
        scene.remove(tmslGroup);
      }
      tmslGroup = new THREE.Group();

      /* pared NEGRA con 2 u de “tiefe” (fondo real del modo) */
      const DEPTH = 2;
      const wallGeo = new THREE.BoxGeometry(cubeSize*3, cubeSize*3, DEPTH);
      // ← negro mate; MeshBasicMaterial para que la luz no la vuelva gris
      const wallMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
      const wall = new THREE.Mesh(wallGeo, wallMat);
      wall.position.set(0, 0, halfCube + DEPTH/2);   // pegada al frontal
      wall.userData.tmslKind = 'wall';
      tmslGroup.add(wall);

      scene.add(tmslGroup);
    }

    function buildTMSL_TomaselloStaudt(){
      if (!tmslGroup) return;

      // ── 0) ELIMINA TODO lo que no sea la pared (evita duplicados al regenerar)
      for (let i = tmslGroup.children.length - 1; i >= 0; i--){
        const ch = tmslGroup.children[i];
        if (ch.userData?.tmslKind === 'wall') continue; // conserva la pared
        // libera y quita
        ch.traverse?.(o=>{ if (o.isMesh){ o.geometry?.dispose?.(); o.material?.dispose?.(); }});
        tmslGroup.remove(ch);
      }

      // ── 1) prepara halo group/texture
      if (tmslHaloGroup){
        tmslHaloGroup.traverse(o=>{ if(o.isMesh){ o.geometry.dispose?.(); o.material.dispose?.(); }});
        tmslGroup.remove(tmslHaloGroup);
        tmslHaloGroup = null;
      }
      if (!tmslHaloTex) tmslHaloTex = makeHaloTexture(512);
      tmslHaloGroup = new THREE.Group();
      tmslGroup.add(tmslHaloGroup);

      // ── 2) localiza la pared para posicionar frente
      const wall = tmslGroup.children.find(o => o.userData?.tmslKind === 'wall');
      if (!wall || !wall.geometry?.parameters) return;
      const wallFrontZ = wall.position.z + (wall.geometry.parameters.depth/2);

      // ── 3) parámetros de grilla
      const GRID = 9;
      const PAD  = cubeSize * 0.12;
      const span = cubeSize - PAD*2;
      const step = span / (GRID-1);

      // medidas base (mantenemos ancho; profundidad a la MITAD)
      const MOD_W = 1.6;          // ancho
      const DEP   = 0.10;          // PROFUNDIDAD 
      const HALO_SCALE_X = 2.5;  // 
      const HALO_SCALE_Y = 2.5;  // 

      // —— único índice √3 determinista (nunca en la fila inferior)
      const TOTAL = GRID * GRID;
      const mRank = mappingRank(attributeMapping.slice(0,5));
      const seed  = (sceneSeed + S_global + mRank) >>> 0;
      const idxSqrt3 = GRID + (seed % (TOTAL - GRID)); // ∈ [GRID .. TOTAL-1]

      const SQ1 = 1.0, SQ3 = Math.sqrt(3), SQ5 = Math.sqrt(5);

      // helper: crea el Rahmen frontal de color
      function addFrameFor(cube, W, H, colorTHREE){
        const FRAME_Z_PULL = 0.03;                 // muy cerca del frente
        const FRAME_DEPTH  = 0.04;                 // laminita fina
        const tRaw = Math.min(W, H) * 0.15;        // grosor relativo
        const t    = Math.max(0.05, Math.min(tRaw, W/3, H/3));

        const wIn = Math.max(0.001, W - 2 * t);
        const hIn = Math.max(0.001, H - 2 * t);

        const matF = new THREE.MeshLambertMaterial({ color: colorTHREE, dithering:true });
        matF.emissive = colorTHREE.clone();
        matF.emissiveIntensity = 0.12;

        const zFrame = cube.position.z + DEP/2 + FRAME_Z_PULL;

        const top  = new THREE.Mesh(new THREE.BoxGeometry(wIn, t, FRAME_DEPTH), matF);
        const bot  = new THREE.Mesh(new THREE.BoxGeometry(wIn, t, FRAME_DEPTH), matF);
        const left = new THREE.Mesh(new THREE.BoxGeometry(t,   hIn, FRAME_DEPTH), matF);
        const rigt = new THREE.Mesh(new THREE.BoxGeometry(t,   hIn, FRAME_DEPTH), matF);

        top.position.set (cube.position.x, cube.position.y + (H/2 - t/2), zFrame);
        bot.position.set (cube.position.x, cube.position.y - (H/2 - t/2), zFrame);
        left.position.set(cube.position.x - (W/2 - t/2), cube.position.y, zFrame);
        rigt.position.set(cube.position.x + (W/2 - t/2), cube.position.y, zFrame);

        tmslGroup.add(top, bot, left, rigt);
      }

      // ── 4) construir malla
      const perms = (typeof getSelectedPerms === 'function')
        ? getSelectedPerms()
        : Array.from(document.getElementById('permutationList').selectedOptions).map(o => o.value.split(',').map(Number));
      const permsSafe = perms.length ? perms : [[1,2,3,4,5]];

      for (let iy=0; iy<GRID; iy++){
        for (let ix=0; ix<GRID; ix++){
          const x = -halfCube + PAD + ix*step;
          const y = -halfCube + PAD + iy*step;

          const idxCell = iy*GRID + ix;
          const pa      = permsSafe[idxCell % permsSafe.length];

          // color determinista
          const color = tmslColorFor(pa, idxCell);

          // relación de aspecto deseada
          let aspect = SQ1;
          if (iy === 0) aspect = SQ5;              // fila inferior → √5
          else if (idxCell === idxSqrt3) aspect = SQ3; // único √3

          const W = MOD_W;
          const H = MOD_W * aspect;

          // laterales coloreados + frontal negro mate
          const sideMat = new THREE.MeshLambertMaterial({ color, dithering:true });
          sideMat.emissive = color.clone();
          sideMat.emissiveIntensity = 0.10;

          const frontMat = new THREE.MeshLambertMaterial({ color:0xffffff, dithering:true });
          const backMat  = new THREE.MeshLambertMaterial({ color:0xffffff, dithering:true });

          const mats = [
            sideMat.clone(), sideMat.clone(), sideMat.clone(), sideMat.clone(),
            frontMat, backMat
          ];

          const geo  = new THREE.BoxGeometry(W, H, DEP);
          const cube = new THREE.Mesh(geo, mats);
          cube.position.set(x, y, wallFrontZ + DEP/2 + 0.01);
          tmslGroup.add(cube);

          // Rahmen frontal del mismo color que los laterales
          addFrameFor(cube, W, H, color);

          // halo rectangular (ajustado al nuevo W×H)
          const PLx = W * HALO_SCALE_X;
          const PLy = H * HALO_SCALE_Y;
          const pgeo = new THREE.PlaneGeometry(PLx, PLy);
          const pmat = new THREE.MeshBasicMaterial({
            color,
            map: tmslHaloTex,
            transparent: true,
            depthWrite: false,
            blending: THREE.NormalBlending,
            premultipliedAlpha: false,
            opacity: 0.90
          });
          const halo = new THREE.Mesh(pgeo, pmat);
          halo.position.set(x, y, wallFrontZ + 0.005);
          halo.userData.baseOpacity = 0.65;
          halo.userData.phase = (ix*37 + iy*19 + sceneSeed) * 0.015;

          // ——— respiración determinista por celda (como en BUILD, via rango Lehmer) ———
          const rLehmer = lehmerRank(pa);
          const mRankT  = mappingRank(attributeMapping.slice(0,5));
          const sig32   = (rLehmer * 1315423911) ^ (mRankT * 2654435761) ^ (idxCell * 374761393) ^ (sceneSeed|0);

          // velocidades (factores sobre la base), armónico y wobble de opacidad, todo 100% determinista
          halo.userData.speed1 = (0.65 + ((sig32 & 1023) / 1023) * 1.10) * 0.4;          // 0.325× … 0.875×
          halo.userData.speed2 = (0.80 + (((sig32 >>> 10) & 1023) / 1023) * 0.90) * 0.4; // 0.40×  … 0.85×
          halo.userData.harm   = 0.08 + (((sig32 >>> 20) & 1023) / 1023) * 0.18; // 0.08 … 0.26
          halo.userData.wAmp   = 0.04 + (((sig32 >>> 30) & 255)  / 255)  * 0.06; // 0.04 … 0.10

          // límites de escala: mínimo = justo hasta desaparecer, máximo = 1.00
          const sMin = Math.min(1 / HALO_SCALE_X, 1 / HALO_SCALE_Y) * 0.98;
          const sMax = 1.00;
          halo.userData.sMin = sMin;
          halo.userData.sMax = sMax;

          // arranca “fuera”
          halo.scale.set(sMax, sMax, 1);

          tmslHaloGroup.add(halo);
        }
      }
    }

    function updateTMSLHalos(t){
      if (!tmslHaloGroup) return;

      const mx = (typeof mouse?.x==='number') ? mouse.x*0.35 : 0;
      const my = (typeof mouse?.y==='number') ? mouse.y*0.35 : 0;

      tmslHaloGroup.children.forEach(h=>{
        if (!h.isMesh) return;

        const ph    = h.userData.phase || 0;
        const sMin  = (typeof h.userData.sMin  === 'number') ? h.userData.sMin  : 0.4;
        const sMax  = (typeof h.userData.sMax  === 'number') ? h.userData.sMax  : 1.0;
        const sp1   = (typeof h.userData.speed1=== 'number') ? h.userData.speed1: 1.0;
        const sp2   = (typeof h.userData.speed2=== 'number') ? h.userData.speed2: 1.0;
        const harm  = (typeof h.userData.harm  === 'number') ? h.userData.harm  : 0.12;
        const wAmp  = (typeof h.userData.wAmp  === 'number') ? h.userData.wAmp  : 0.06;

        // base: seno principal + armónico con distinta frecuencia/fase → rompe uniformidad diagonal
        let osc = 0.5 + 0.5 * Math.sin((t * 0.75 * sp1) + ph);
        osc += harm * Math.sin((t * 1.43 * sp2) + ph * 1.3);
        osc = THREE.MathUtils.clamp(osc, 0.0, 1.0);

        // escala resultante (interacción ligera con el puntero)
        let s = THREE.MathUtils.lerp(sMin, sMax, osc);
        s = THREE.MathUtils.clamp(s + mx*0.04 - my*0.03, sMin*0.90, sMax*1.05);
        h.scale.set(s, s, 1);

        // opacidad acompaña a la escala + wobble determinista por halo
        const base   = (typeof h.userData.baseOpacity === 'number') ? h.userData.baseOpacity : 0.65;
        const k      = (s - sMin) / Math.max(1e-5, (sMax - sMin)); // 0..1
        const wobble = wAmp * Math.sin((t * 0.95 * sp2) + ph + Math.PI/2);
        h.material.opacity = THREE.MathUtils.clamp(base * (0.15 + 0.85*k) + wobble, 0.0, 0.95);
      });
    }

    function enterTMSLView(){
      camera.up.set(0,1,0);
      camera.fov = 55;
      camera.updateProjectionMatrix();
      const eyeY = (controls && controls.target) ? controls.target.y : 0;
      camera.position.set(0, eyeY, 42);
      controls.target.set(0, eyeY, 0);

      controls.enabled = true;
      controls.enableRotate = true;    // yaw
      controls.enablePan    = true;
      controls.enableZoom   = true;
      controls.screenSpacePanning = true;
      controls.minDistance = 10;
      controls.maxDistance = 200;
      controls.minPolarAngle = Math.PI / 2;
      controls.maxPolarAngle = Math.PI / 2;
      controls.update();
    }

    function toggleTMSL(){
      if (!isTMSL){ // ENTRAR
        leaveBuildRenderBoost();
        if (isFRBN)   toggleFRBN();
        if (isLCHT)   toggleLCHT();
        if (isOFFNNG) toggleOFFNNG();

        // Construye pared + halo
        buildTMSL();
        buildTMSL_TomaselloStaudt();

        // Exclusividad visual
        cubeUniverse.visible     = false;
        permutationGroup.visible = false;
        if (lichtGroup) lichtGroup.visible = false;

        // Fondo negro (guarda el anterior)
        tmslPrevBg = scene.background ? scene.background.clone() : null;
        scene.background = new THREE.Color(0x000000);

        // Vista nivelada
        enterTMSLView();

        // Estado (local + global, imprescindible para hooks)
        isTMSL = true;
        window.isTMSL = true;

      } else { // SALIR
        disposeAndRemove(tmslHaloGroup);  tmslHaloGroup  = null;
        if (tmslCellsGroup){
          tmslCellsGroup.traverse(o=>{ if(o.isMesh){ o.geometry?.dispose?.(); o.material?.dispose?.(); } });
          tmslCellsGroup = null;
        }
        disposeAndRemove(tmslGroup);      tmslGroup      = null;

        if (tmslPrevBg) scene.background = tmslPrevBg;

        controls.enabled      = true;
        controls.enableRotate = true;
        controls.enablePan    = true;
        controls.enableZoom   = true;

        cubeUniverse.visible     = true;
        permutationGroup.visible = true;
        if (lichtGroup && isLCHT) lichtGroup.visible = true;

        isTMSL = false;
        window.isTMSL = false;
      }
    }
    function clearGroup(g){
      if (!g) return;
      g.traverse(o=>{ if(o.isMesh){ o.geometry.dispose(); o.material.dispose(); } });
      scene.remove(g);
    }

      function buildRAUM(){
        // —— limpia versión previa
        clearGroup(raumGroup);
        raumGroup = new THREE.Group();

        // asegura fondo sincronizado con BUILD/OFFNNG
        updateBackground(false);

        const W = RAUM_W, H = RAUM_H, D = RAUM_D, g = RAUM_G;
        const Wi = W - 2*g, Hi = H - 2*g, Di = D - 2*g;

        // ====== COLORES deterministas ======
        const colCeil  = raumColorFor(1);
        const colFloor = raumColorFor(2);
        const colLeft  = raumColorFor(3);
        const colRight = raumColorFor(4);
        const colBack  = raumColorFor(5);
        const colA     = raumColorFor(6);
        const colB     = raumColorFor(7);

        function lambert(c, opacity){
          const base = applyBuildVibranceToColor(c);
          const matOpts = {
            color: base,
            side: THREE.DoubleSide,
            dithering: false                // ← sin granulado en planos grandes
          };
          if (typeof opacity === 'number' && opacity < 1){
            matOpts.transparent = true;
            matOpts.opacity = opacity;
          }
          const m = new THREE.MeshLambertMaterial(matOpts);
          m.emissive = base.clone();
          m.emissiveIntensity = 0.06;
          return m;
        }

        // ====== PAREDES EXTERIORES (caja sin frente) ======
        const left  = new THREE.Mesh(new THREE.BoxGeometry(g, H, D), lambert(colLeft));
        left.position.set(-W/2 + g/2, 0, 0);
        const right = new THREE.Mesh(new THREE.BoxGeometry(g, H, D), lambert(colRight));
        right.position.set( W/2 - g/2, 0, 0);

        const floor = new THREE.Mesh(new THREE.BoxGeometry(W, g, D), lambert(colFloor));
        floor.position.set(0, -H/2 + g/2, 0);
        const ceil  = new THREE.Mesh(new THREE.BoxGeometry(W, g, D), lambert(colCeil));
        ceil.position.set(0,  H/2 - g/2, 0);

        raumGroup.add(left, right, floor, ceil);

        // ====== INVARIANTES / ESTADÍSTICAS DETERMINISTAS ======
        const { sumR, sumR2, mRank } = raumStats();

        // ====== MUROS INTERIORES (A y B) — primero sus PARÁMETROS ======
        // — A (longitudinal, grosor g en X, largo LA en Z)
        const LAmin = 8, LAmax = Di; // 8..28
        const LA = LAmin + ((sumR + 5*mRank + sceneSeed) % (LAmax - LAmin + 1));
        const xAmin = -Wi/2 + g/2, xAmax = Wi/2 - g/2;
        const zAmin = -Di/2 + LA/2, zAmax = Di/2 - LA/2;
        const uAx   = ((11*sumR2 + 7*mRank + sceneSeed) % 991) / 991;
        const uAz   = ((S_global + 23*mRank + sumR2) % 983) / 983;
        const xA    = xAmin + (xAmax - xAmin) * uAx;
        const zA    = zAmin + (zAmax - zAmin) * uAz;

        // — B (transversal, ancho LB en X, grosor g en Z)
        const LBmin = 10, LBmax = Wi; // 10..58
        const LB = LBmin + ((sumR2 + 9*mRank + 3*sceneSeed) % (LBmax - LBmin + 1));
        const xBmin = -Wi/2 + LB/2, xBmax = Wi/2 - LB/2;
        const zBmin = -Di/2 + g/2,  zBmax = Di/2 - g/2;
        const uBx   = ((17*sumR2 + 31*mRank + sceneSeed) % 971) / 971;
        const uBz   = ((19*sumR + 29*mRank + S_global) % 977) / 977;
        const xB    = xBmin + (xBmax - xBmin) * uBx;
        const zB    = zBmin + (zBmax - zBmin) * uBz;

        // ====== APERTURA EN LA PARED DEL FONDO (con regla 33%) ======
        const zBack = -D/2 + g/2;

        // — dimensiones base (10..25), sin forzar área mínima
        let breite = 10 + ((sumR  + 7*mRank + sceneSeed)  % 16); // 10..25
        let hoehe  = 10 + ((sumR2 + 11*mRank + 3*sceneSeed) % 16); // 10..25
        breite = Math.max(2, Math.min(breite, Wi));
        hoehe  = Math.max(2, Math.min(hoehe,  Hi));

        // — centro determinista propuesto
        const xmin0 = -Wi/2 + breite/2, xmax0 = Wi/2 - breite/2;
        const ymin0 = -Hi/2 + hoehe/2,  ymax0 = Hi/2 - hoehe/2;

        const ux = ((37*sumR + 13*mRank + S_global) % 997) / 997;
        const uy = ((53*sumR2 + 17*mRank + sceneSeed) % 991) / 991;
        let xC   = xmin0 + (xmax0 - xmin0) * ux;
        const yC = ymin0 + (ymax0 - ymin0) * uy;

        // — utilidades de intervalos en X
        function clipInterval(a,b,min,max){
          const s = Math.max(a,min), e = Math.min(b,max);
          return (e > s) ? [s,e] : null;
        }
        function mergeIntervals(list){
          if (!list.length) return [];
          const v = list.slice().sort((p,q)=>p[0]-q[0]);
          const out = [ v[0].slice() ];
          for (let i=1;i<v.length;i++){
            const cur = v[i], last = out[out.length-1];
            if (cur[0] <= last[1]) last[1] = Math.max(last[1], cur[1]);
            else out.push(cur.slice());
          }
          return out;
        }
        function complement(minX, maxX, occ){
          const gaps=[];
          let cur = minX;
          occ.forEach(([a,b])=>{
            if (a > cur) gaps.push([cur,a]);
            cur = Math.max(cur,b);
          });
          if (cur < maxX) gaps.push([cur,maxX]);
          return gaps;
        }
        function visibleFraction(center, width, occ){
          const L = center - width/2, R = center + width/2;
          let occLen = 0;
          occ.forEach(([a,b])=>{
            const s = Math.max(L,a), e = Math.min(R,b);
            if (e > s) occLen += (e - s);
          });
          const vis = Math.max(0, width - Math.min(width, occLen));
          return vis / Math.max(1e-6, width);
        }

        // — proyección de A y B sobre el fondo (intervalos en X, altura total)
        const occRaw = [];
        const iA = clipInterval(xA - g/2,   xA + g/2,   -Wi/2, Wi/2);
        const iB = clipInterval(xB - LB/2,  xB + LB/2,  -Wi/2, Wi/2);
        if (iA) occRaw.push(iA);
        if (iB) occRaw.push(iB);
        const occ = mergeIntervals(occRaw);
        const gaps = complement(-Wi/2, Wi/2, occ);

        // — regla 33%: recolocación suave + fallback de reducción de ancho
        const VISIBLE_MIN = 0.33;

        function gapLen(g){ return g[1]-g[0]; }
        const maxGap = gaps.length ? gaps.reduce((best,g)=> gapLen(g) > gapLen(best) ? g : best, gaps[0]) : [0,0];
        const Lmax   = gapLen(maxGap);

        let xmin = xmin0, xmax = xmax0;
        let vis  = visibleFraction(xC, breite, occ);

        if (vis < VISIBLE_MIN){
          // 1) ¿Existe algún gap que pueda contener COMPLETA la ventana?
          const bigGaps = gaps.filter(g => gapLen(g) >= breite);
          if (bigGaps.length){
            // coloca en el gap más cercano al xC original (mínimo desplazamiento)
            let best = null;
            bigGaps.forEach(g=>{
              const cmin = g[0] + breite/2, cmax = g[1] - breite/2;
              const newX = clamp(xC, Math.max(cmin, xmin), Math.min(cmax, xmax));
              const d    = Math.abs(newX - xC);
              if (!best || d < best.d) best = {x:newX, d};
            });
            if (best){
              xC = best.x;
              vis = 1;
            }
          } else {
            // 2) No cabe completa: céntrala en el mayor gap
            const mid = (maxGap[0] + maxGap[1]) / 2;
            xC = clamp(mid, xmin, xmax);
            vis = (Lmax / breite);

            // 3) Fallback: reducir ancho hasta garantizar ≥ 33 %
            if (vis < VISIBLE_MIN){
              const newW = Math.max(2, Math.min(breite, 3 * Lmax)); // (Lmax / newW) ≥ 1/3
              if (newW !== breite){
                breite = newW;
                xmin = -Wi/2 + breite/2;
                xmax =  Wi/2 - breite/2;
              }
              const cmin2 = maxGap[0] + breite/2, cmax2 = maxGap[1] - breite/2;
              if (cmax2 >= cmin2){
                const mid2 = (maxGap[0] + maxGap[1]) / 2;
                xC = clamp(mid2, Math.max(cmin2, xmin), Math.min(cmax2, xmax));
                vis = 1;
              } else {
                // caso extremo: Lmax == 0 → no hay hueco; mantenemos determinismo
                vis = (Lmax / Math.max(1e-6, breite)); // 0
              }
            }
          }
        }

        // — bandas del “marco” (4 piezas)
        const hTop = (Hi/2) - (yC + hoehe/2);
        if (hTop > 0.0001){
          const top = new THREE.Mesh(new THREE.BoxGeometry(Wi, hTop, g), lambert(colBack));
          top.position.set(0, yC + hoehe/2 + hTop/2, zBack);
          raumGroup.add(top);
        }
        const hBot = (yC - hoehe/2) - (-Hi/2);
        if (hBot > 0.0001){
          const bot = new THREE.Mesh(new THREE.BoxGeometry(Wi, hBot, g), lambert(colBack));
          bot.position.set(0, yC - hoehe/2 - hBot/2, zBack);
          raumGroup.add(bot);
        }
        const wLeft = (xC - breite/2) - (-Wi/2);
        if (wLeft > 0.0001){
          const l = new THREE.Mesh(new THREE.BoxGeometry(wLeft, hoehe, g), lambert(colBack));
          l.position.set(xC - breite/2 - wLeft/2, yC, zBack);
          raumGroup.add(l);
        }
        const wRight = (Wi/2) - (xC + breite/2);
        if (wRight > 0.0001){
          const r = new THREE.Mesh(new THREE.BoxGeometry(wRight, hoehe, g), lambert(colBack));
          r.position.set(xC + breite/2 + wRight/2, yC, zBack);
          raumGroup.add(r);
        }

        // ====== AHORA sí: instanciar muros interiores A y B (opacos) ======
        const wallA = new THREE.Mesh(new THREE.BoxGeometry(g, H, LA), lambert(colA)); // opaco
        wallA.position.set(xA, 0, zA);
        raumGroup.add(wallA);

        const wallB = new THREE.Mesh(new THREE.BoxGeometry(LB, H, g), lambert(colB)); // opaco
        wallB.position.set(xB, 0, zB);
        raumGroup.add(wallB);

        // —— añadir grupo a escena
        scene.add(raumGroup);
      }

    function toggleRAUM(){
      isRAUM = !isRAUM;

      if (isRAUM){
        // RAUM debe estar en solitario
        if (isFRBN)  toggleFRBN();
        if (isLCHT)  toggleLCHT();
        if (isOFFNNG)toggleOFFNNG();
        if (isTMSL)  toggleTMSL();
        if (is13245) toggle13245();
        if (isR5NOVA) toggleR5NOVA();

        // Sal del boost de BUILD si venías de allí y entra al boost de RAUM
        leaveBuildRenderBoost();
        enterRaumRenderBoost();

        // Controles: vista frontal fija con zoom permitido
        controls.enabled      = true;
        controls.enableRotate = false;
        controls.enablePan    = false;
        controls.enableZoom   = true;
        controls.minDistance  = 25;
        controls.maxDistance  = 140;

        camera.position.set(0, 0, RAUM_CAMERA_ZOOMED);
        camera.lookAt(0,0,0);
        controls.update();

        buildRAUM();

        cubeUniverse.visible     = false;
        permutationGroup.visible = false;
        if (lichtGroup) lichtGroup.visible = false;

      } else {
        // Salida de RAUM: limpia y restaura PR/exposición previos
        leaveRaumRenderBoost();

        clearGroup(raumGroup);
        raumGroup = null;

        // Restaurar comportamiento libre
        controls.enabled      = true;
        controls.enableRotate = true;
        controls.enablePan    = true;
        controls.enableZoom   = true;

        cubeUniverse.visible     = true;
        permutationGroup.visible = true;
        if (lichtGroup && isLCHT) lichtGroup.visible = true;
      }
    }
    function ensureOnlyRAUM(){ if (!isRAUM) toggleRAUM(); }
    function rebuildRAUMIfActive(){ if (isRAUM) buildRAUM(); }

    // ──────────────────────────────
    // 13245 · motor (grid 10×10)
    // ──────────────────────────────
    let is13245 = false;
    let group13245 = null;

    /* Escala acoplada a RAUM:
     *   - piso 179.98 → ~60
     *   - anillo Ø183.98 → ~61.33 (espesor ~0.667, h ~16.67)
     */
    const K132           = 60 / 179.98;
    const FLOOR132       = 179.98 * K132;           // ~60
    const R_OUT132       = (183.98 * 0.5) * K132;   // ~30.666
    const WALL_THICK132  = 2.0 * K132;              // ~0.6667
    const WALL_H132      = 50.0 * K132;             // ~16.667
    const CELL132        = FLOOR132 / 10;           // ~6

    // ★ NUEVO: sección real de cada volumen (en unidades del cubo 30×30×30)
    const CROSS132 = 2.25;

    // ★ NUEVO: grilla de 30×30 con 11×11 centros (paso 3.00 y margen 1.50)
    const GRID_STEP   = 3.0;
    const GRID_COUNT  = 11;
    const GRID_MARGIN = 1.5;

    // Pasos de cámara para la vista default de 13245
    // – zoomOut() mueve +5 en Z → usamos el mismo paso
    const ZOOM_STEP_13245  = 5.0;
    // – pan vertical: usamos el paso de la grilla (GRID_STEP = 3.0)
    const PAN_STEP_Y_13245 = GRID_STEP;

    // ★ NUEVO: espesor de la losa global (cara superior en y = 0)
    const SLAB_THICK  = 30.00;
    const SLAB_EXTRA_X = 90.00; // ← ya existente (45u por lado en X)
    const SLAB_EXTRA_Z = 90.00; // ← NUEVO (45u al frente y 45u atrás en Z)

    // salto coprimo para open-addressing
    const STEP_OPEN_ADDR = 37;

    function disposeGroup(g){
      if (!g) return;
      g.traverse(o => {
        if (o.isMesh) {
          o.geometry?.dispose?.();
          o.material?.dispose?.();
        }
      });
      scene.remove(g);
    }

    /* Color RAUM → aplica “vibrance BUILD” y ∆E≥22 contra el fondo */
    function lambertRaumColor(cTHREE, emissiveIntensity = 0.06, doubleSide = false){
      const c = applyBuildVibranceToColor(cTHREE);
      const m = new THREE.MeshLambertMaterial({
        color: c,
        dithering: true,
        side: doubleSide ? THREE.DoubleSide : THREE.FrontSide
      });
      m.emissive = c.clone();
      m.emissiveIntensity = emissiveIntensity;
      return m;
    }

    /* Color determinista para el tramo k (k=0..2) de una permutación */
    function color132For(pa, k){
      const sig  = computeSignature(pa);
      const r    = lehmerRank(pa);
      const slot = (r % 12) + k;     // offsets k=0,1,2

      let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
      sI = (sI * PHI_S) % 12;
      vI = (vI * PHI_V) % 12;

      const {h,s,v} = idxToHSV(hI, sI, vI);
      let rgb = hsvToRgb(h,s,v);
      rgb = ensureContrastRGB(rgb);

      const col = new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255);
      return applyBuildVibranceToColor(col);
    }

    /* Alturas exactas (en unidades del cubo).
       hBot fijo; hMid depende de P2; hTop fijo 60 para todas las permutaciones. */
    function heightsFor(pa){
      const H_MID = [0, 5.56, 6.365, 7.795, 9.00, 10.06]; // idx 1..5
      const hBot = 2.25;
      const hMid = H_MID[ pa[1] ];
      const hTop = 60.0;
      return [hBot, hMid, hTop];
    }

    /* Construye/rehace toda la escena 13245 */
    function build13245(){
      // limpia versión previa
      disposeGroup(group13245);
      group13245 = new THREE.Group();

      // Fondo acoplado (no manual)
      updateBackground(false);

      // ★ ACTUALIZADO: losa global extendida
      //   X = 30 + 90  (45u extra por lado)
      //   Y = THICK
      //   Z = 30 + 90  (45u extra al frente y atrás)
      //   cara superior en y = 0
      {
        const slabGeo = new THREE.BoxGeometry(
          cubeSize + SLAB_EXTRA_X,
          SLAB_THICK,
          cubeSize + SLAB_EXTRA_Z
        );
        const slabMat = lambertRaumColor(cubeUniverse.material.color, 0.04, true);
        const slab    = new THREE.Mesh(slabGeo, slabMat);
        slab.position.set(0, -SLAB_THICK/2, 0);
        group13245.add(slab);
      }

      // === Centros 11×11 en 30×30: paso 3.00, margen 1.50 ===
      const centers = [];
      const half = halfCube; // 15
      for (let j = 0; j < GRID_COUNT; j++){
        const z = -half + GRID_MARGIN + j * GRID_STEP; // −13.5 … +13.5
        for (let i = 0; i < GRID_COUNT; i++){
          const x = -half + GRID_MARGIN + i * GRID_STEP;
          centers.push([x, z]);
        }
      }

      // Open addressing determinista (coprimo con 121)
      const occ   = Array(centers.length).fill(false);
      const perms = getSelectedPerms();

      // Base 2.25×2.25; la altura real la da scale.y = h
      const baseGeo = new THREE.BoxGeometry(CROSS132, 1, CROSS132);

      perms.forEach(pa => {
        const r = lehmerRank(pa);
        let idx = (r + sceneSeed + S_global) % centers.length;
        while (occ[idx]) idx = (idx + STEP_OPEN_ADDR) % centers.length;
        occ[idx] = true;

        const [x, z] = centers[idx];

        // alturas y colores por tramo (k=0,1,2)
        const [hBot, hMid, hTop] = heightsFor(pa);
        const cols = [0,1,2].map(k => color132For(pa, k));

        // — SIN separación vertical (sep = 0)
        let y = 0.0;

        // tramo inferior
        const m0 = new THREE.Mesh(baseGeo, new THREE.MeshLambertMaterial({ color: cols[0], dithering:true }));
        m0.material.emissive = cols[0].clone(); m0.material.emissiveIntensity = 0.06;
        m0.scale.y = hBot; m0.position.set(x, y + hBot/2, z); y += hBot;
        group13245.add(m0);

        // tramo medio
        const m1 = new THREE.Mesh(baseGeo, new THREE.MeshLambertMaterial({ color: cols[1], dithering:true }));
        m1.material.emissive = cols[1].clone(); m1.material.emissiveIntensity = 0.06;
        m1.scale.y = hMid; m1.position.set(x, y + hMid/2, z); y += hMid;
        group13245.add(m1);

        // tramo superior (hTop fijo 60)
        if (hTop > 0.0001){
          const m2 = new THREE.Mesh(baseGeo, new THREE.MeshLambertMaterial({ color: cols[2], dithering:true }));
          m2.material.emissive = cols[2].clone(); m2.material.emissiveIntensity = 0.06;
          m2.scale.y = hTop; m2.position.set(x, y + hTop/2, z);
          group13245.add(m2);
        }
      });

      scene.add(group13245);
    }

    /* rebuild si hay cambios de escena */
    function rebuild13245IfActive(){ if (is13245) build13245(); }

    /* Exclusivo (como RAUM). Usa el “crispness boost” de RAUM. */
    function toggle13245(){
      is13245 = !is13245;

      if (is13245){
        // exclusividad
        if (isFRBN)  toggleFRBN();
        if (isLCHT)  toggleLCHT();
        if (isOFFNNG)toggleOFFNNG();
        if (isTMSL)  toggleTMSL();
        if (isRAUM)  toggleRAUM();
        if (isR5NOVA) toggleR5NOVA();

        leaveBuildRenderBoost();
        enterRaumRenderBoost();
        build13245();

        // — VISTA POR DEFECTO NIVELADA (verticales rectas)
        camera.up.set(0,1,0);
        camera.fov = 55;
        camera.updateProjectionMatrix();

        // 2× “scroll” hacia arriba (pan en Y) y 2× zoom-out en Z
        const yOffset = 2 * PAN_STEP_Y_13245;   // 2 · 3  = +6
        const zOffset = 2 * ZOOM_STEP_13245;    // 2 · 5  = +10

        // Misma Y para cámara y target (mantiene verticales “gerade”)
        camera.position.set(0, yOffset, 22 + zOffset); // antes: (0, 0, 22)
        controls.target.set(0, yOffset, 0);            // antes: (0, 0, 0)

        // Controles: yaw/pan/zoom permitidos; pitch bloqueado a 90°
        controls.enabled            = true;
        controls.enableRotate       = true;   // solo yaw (por el clamp polar)
        controls.enablePan          = true;
        controls.enableZoom         = true;
        controls.minDistance        = 10;
        controls.maxDistance        = 200;
        controls.screenSpacePanning = true;

        // Bloquea el pitch para mantener las verticales “gerade”
        controls.minPolarAngle = Math.PI / 2;
        controls.maxPolarAngle = Math.PI / 2;
        controls.update();

        cubeUniverse.visible     = false;
        permutationGroup.visible = false;
        if (lichtGroup) lichtGroup.visible = false;

      } else {
        leaveRaumRenderBoost();
        disposeGroup(group13245);
        group13245 = null;

        // Restaurar ajustes por defecto al salir de 13245
        camera.fov = 75;
        camera.updateProjectionMatrix();
        controls.minPolarAngle      = 0;
        controls.maxPolarAngle      = Math.PI;
        controls.screenSpacePanning = false;

        cubeUniverse.visible     = true;
        permutationGroup.visible = true;
        if (lichtGroup && isLCHT) lichtGroup.visible = true;
      }
    }

    /* botón selector – sólo enciende, nunca apaga */
    function ensureOnly13245(){ if (!is13245) toggle13245(); }

    // ──────────────────────────────
    // R5NOVA · Proportional tiling engine (tilers-integrated)
    // (v2) · gap mínimo + cuarto tipo RAUM (sin pared del fondo)
    // ──────────────────────────────
    let isR5NOVA    = false;
    let groupR5NOVA = null;

    /* Limpieza segura */
    function disposeGroupR5NOVA(){
      if (!groupR5NOVA) return;
      groupR5NOVA.traverse(o => {
        if (o.isMesh){
          o.geometry?.dispose?.();
          o.material?.dispose?.();
        }
      });
      scene.remove(groupR5NOVA);
      groupR5NOVA = null;
    }

    /* Color determinista por celda (offset cromático opcional según tag) */
    /* Color determinista por celda — garantiza colores ÚNICOS por rectángulo (hasta 12) */
    function colorR5NFor(pa, offset = 0, uniq = 0){
      const sig  = computeSignature(pa);
      const r    = lehmerRank(pa);

      // 12 slots posibles; usamos uniq para evitar repeticiones entre rectángulos
      let slot = (r + uniq) % 12;

      let [hI, sI, vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);

      // Ajustes deterministas + leve “twist” por tag SIN tocar la unicidad del hue
      sI = (sI * PHI_S) % 12;
      vI = (vI * PHI_V) % 12;
      if (offset){
        sI = (sI + (offset * 3)) % 12;
        vI = (vI + (offset * 2)) % 12;
      }

      const {h,s,v} = idxToHSV(hI, sI, vI);
      let rgb = hsvToRgb(h, s, v);
      rgb = ensureContrastRGB(rgb);

      const base = new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255);

      // Vibrance fuerte en superficies + ∆E contra fondo
      const boosted = (function applyBuildVibranceToColor(colorTHREE){
        const raw = [
          Math.round(colorTHREE.r * 255),
          Math.round(colorTHREE.g * 255),
          Math.round(colorTHREE.b * 255)
        ];
        let [hh, ss, vv] = rgbToHsv(raw[0], raw[1], raw[2]);
        // ↑ saturación y brillo de forma agresiva
        const s1 = Math.min(1, ss + 0.50 * (1 - ss));
        const v1 = Math.min(0.99, vv * 1.10 + 0.06);
        let rgb2 = hsvToRgb(hh, s1, v1);
        rgb2 = ensureContrastRGB(rgb2);
        return new THREE.Color(rgb2[0]/255, rgb2[1]/255, rgb2[2]/255);
      })(base);

      return boosted;
    }

    /* Parámetros geométricos (idénticos a RAUM) */
    const R5_W = 60, R5_H = 60, R5_D = 60, R5_G = 4;  // ancho, alto, fondo, grosor pared (pared de fondo 60×60)
    const R5_DEPTH = 0.06;       // antes: 1.50  → lámina fina tipo “hoja”
    const R5_GAP   = 0.40;       // antes: 0.20  → misma proporción con el nuevo tamaño

    // —— R5NOVA · control fino del nº de volúmenes en la pared de fondo ——
    const R5N_MAX_TILES = 10;        // máximo de volúmenes a instanciar
    const R5N_MIN_CELL  = 6.0;      // tamaño mínimo de celda del BSP (menos particiones)
    const R5N_TARGETN   = [4, 8];   // objetivo de celdas del BSP (pocas piezas)
    const R5N_MERGE     = 0.60;     // probabilidad de fusionar adyacentes

    // ——— R5NOVA · ensamblado BSP con Füge perimetral correcta ———
    function r5novaAssembleRects(){
      // Interior visible: restamos el grosor de muros/piso/techo (R5_G)
      const INS_X0 = -R5_W/2 + R5_G;
      const INS_Y0 = -R5_H/2 + R5_G;
      const INS_W  = R5_W - 2 * R5_G;
      const INS_H  = R5_H - 2 * R5_G;

      // Margen perimetral: R5_GAP/2 por lado → Füge final = R5_GAP
      const BORDER = R5_GAP / 2;

      const bbox = {
        x: INS_X0 + BORDER,
        y: INS_Y0 + BORDER,
        w: Math.max(0.001, INS_W - 2 * BORDER),
        h: Math.max(0.001, INS_H - 2 * BORDER)
      };

      const seed = computeLayoutSeed();

      const rects = window.Tilers.assemble(bbox, null, {
        engine    : 'bsp',
        rndSeed   : seed,
        minCell   : R5N_MIN_CELL,
        ratioMin  : 0.42,
        ratioMax  : 0.58,
        targetN   : R5N_TARGETN,
        mergeProb : R5N_MERGE
      });

      // Recorte determinista: área desc → x asc → y asc, tope R5N_MAX_TILES
      return rects
        .slice()
        .sort((a, b) => {
          const dA = (b.w * b.h) - (a.w * a.h);
          if (Math.abs(dA) > 1e-9) return dA;
          if (a.x !== b.x) return a.x - b.x;
          return a.y - b.y;
        })
        .slice(0, R5N_MAX_TILES);
    }

    /* Construye la escena R5NOVA:
       - Pared izquierda, derecha, piso y techo (como RAUM, deterministas)
       - Sin pared del fondo
       - En la cara del fondo, los volúmenes del motor R5Nova (tilers) */
    function buildR5NOVA(){
      disposeGroupR5NOVA();
      groupR5NOVA = new THREE.Group();

      // Fondo acoplado (no manual), igual que RAUM/BUILD
      updateBackground(false);

      // ====== Colores deterministas para las paredes (reusa RAUM) ======
      const colCeil  = scene.background.clone();  // techo = color de fondo
      const colFloor = raumColorFor(2);
      const colLeft  = raumColorFor(3);
      const colRight = raumColorFor(4);

      function lambertWall(cTHREE){
        return lambertRaumColor(cTHREE, 0.06, false);
      }

      // ====== PAREDES (como RAUM) ======
      const left  = new THREE.Mesh(new THREE.BoxGeometry(R5_G, R5_H, R5_D + 30), lambertWall(colLeft));
      left.position.set(-R5_W/2 + R5_G/2, 0, 0);
      const right = new THREE.Mesh(new THREE.BoxGeometry(R5_G, R5_H, R5_D + 30), lambertWall(colRight));
      right.position.set( R5_W/2 - R5_G/2, 0, 0);

      const floor = new THREE.Mesh(new THREE.BoxGeometry(R5_W, R5_G, R5_D + 30), lambertWall(colFloor));
      floor.position.set(0, -R5_H/2 + R5_G/2, 0);
      const ceil  = new THREE.Mesh(new THREE.BoxGeometry(R5_W, R5_G, R5_D + 30), lambertWall(colCeil));
      ceil.position.set(0,  R5_H/2 - R5_G/2, 0);

      groupR5NOVA.add(left, right, floor, ceil);

      // ====== PLANO DEL FONDO (sin pared): mosaico R5Nova ======
      // Plano extremo posterior (alineado con el canto trasero de techo/muros/piso)
      const backDepth = R5_D + 30;
      const zBackEdge = -backDepth / 2;

      // --- Layout determinista con tilers ---
      const rects = r5novaAssembleRects();

      // Permutaciones activas (para coloreo determinista)
      const perms = Array.from(document.getElementById('permutationList').selectedOptions)
                         .map(o => o.value.split(',').map(Number));
      const permsSafe = perms.length ? perms : [[1,2,3,4,5]]; // fallback determinista

      // Mapeo: tag → offset cromático (sutil y determinista)
      function offsetFromTag(t){
        if (!t) return 0;
        if (String(t).startsWith('euclid')) return 1;
        if (String(t).startsWith('beatty')) return 2;
        if (String(t).startsWith('subst'))  return 3;
        if (String(t).startsWith('bsp-merged')) return 1;
        return 0;
      }

      // Geometría base: se recalcula por rect para ajustar gap mínimo
      rects.forEach((r, i) => {
        // Centro del rectángulo en coordenadas de habitación
        const cx = r.x + r.w/2;
        const cy = r.y + r.h/2;

        // Tamaño con separación mínima (gap uniforme alrededor)
        const w = Math.max(0.001, r.w - R5_GAP);
        const h = Math.max(0.001, r.h - R5_GAP);

        const geo = new THREE.BoxGeometry(w, h, R5_DEPTH);

        // Color determinista ciclando permutaciones + offset por tag
        const pa   = permsSafe[i % permsSafe.length];
        const offs = offsetFromTag(r.tag);
        const col  = colorR5NFor(pa, offs, i);

        const mat = new THREE.MeshLambertMaterial({
          color: col,
          dithering: true,
          side: THREE.DoubleSide
        });
        mat.emissive = col.clone();
        mat.emissiveIntensity = 0.12;

        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(cx, cy, zBackEdge + R5_DEPTH/2); // pegado al canto posterior
        groupR5NOVA.add(mesh);

        // === Rahmen (marco) INTERNO con pequeño "pull" hacia la cámara ===
        // grosor base ≈ 2× gap, con límites para no cerrar el hueco interior
        const FRAME_Z_PULL = 0.06; // mueve el marco mínimamente hacia el frente (evita z-fighting)
        const tRaw = Math.min(R5_GAP * 2, Math.min(w, h) * 0.20);
        const t    = Math.max(0.001, Math.min(tRaw, w / 3, h / 3)); // asegura w-2t y h-2t positivos

        // dimensiones "inset" (el marco va DENTRO del rectángulo)
        const wIn = Math.max(0.001, w - 2 * t);
        const hIn = Math.max(0.001, h - 2 * t);

        // color del marco: distinto al del cuerpo y determinista
        // offs  : offset del cuerpo (según tag)
        // offsF : offset adicional (ciclo de paso 5, coprimo con 12) + 6 (opuesto) → muy distinto
        const offsF = (offs + 6 + (5 * i) % 12) % 12;
        const colF  = colorR5NFor(pa, offsF);

        const matF = new THREE.MeshLambertMaterial({ color: colF, dithering: true });
        matF.emissive = colF.clone();
        matF.emissiveIntensity = 0.12;

        // Posición Z del marco: un pelín por DELANTE del volumen
        const zFrame = mesh.position.z + FRAME_Z_PULL;

        // 4 barras internas: arriba/abajo/izq/der (misma profundidad que el volumen)
        const topGeo = new THREE.BoxGeometry(wIn, t, R5_DEPTH);
        const botGeo = new THREE.BoxGeometry(wIn, t, R5_DEPTH);
        const lefGeo = new THREE.BoxGeometry(t, hIn, R5_DEPTH);
        const rigGeo = new THREE.BoxGeometry(t, hIn, R5_DEPTH);

        const top = new THREE.Mesh(topGeo, matF);
        top.position.set(cx, cy + (h/2 - t/2), zFrame);

        const bot = new THREE.Mesh(botGeo, matF);
        bot.position.set(cx, cy - (h/2 - t/2), zFrame);

        const lef = new THREE.Mesh(lefGeo, matF);
        lef.position.set(cx - (w/2 - t/2), cy, zFrame);

        const rig = new THREE.Mesh(rigGeo, matF);
        rig.position.set(cx + (w/2 - t/2), cy, zFrame);

        groupR5NOVA.add(top, bot, lef, rig);
      });

      scene.add(groupR5NOVA);
    }

    /* Rebuild si hay cambios de escena */
    function rebuildR5NOVAIfActive(){ if (isR5NOVA) buildR5NOVA(); }

    /* Exclusivo (como RAUM/13245). Usa el “crispness boost” de RAUM. */
    function toggleR5NOVA(){
      isR5NOVA = !isR5NOVA;

      if (isR5NOVA){
        // Exclusividad con otros motores
        if (isFRBN)  toggleFRBN();
        if (isLCHT)  toggleLCHT();
        if (isOFFNNG)toggleOFFNNG();
        if (isTMSL)  toggleTMSL();
        if (isRAUM)  toggleRAUM();
        if (is13245) toggle13245();

        leaveBuildRenderBoost();
        enterRaumRenderBoost();   // nitidez como RAUM/13245

        buildR5NOVA();

        // Cámara nivelada; yaw/pan/zoom permitidos (pitch bloqueado)
        camera.up.set(0,1,0);
        camera.fov = 55;
        camera.updateProjectionMatrix();

        const eyeY = (controls && controls.target) ? controls.target.y : 0;
        camera.position.set(0, eyeY, 42);
        controls.target.set(0, eyeY, 0);

        controls.enabled            = true;
        controls.enableRotate       = true;   // solo yaw (clamp polar)
        controls.enablePan          = true;
        controls.enableZoom         = true;
        controls.minDistance        = 10;
        controls.maxDistance        = 200;
        controls.screenSpacePanning = true;
        controls.minPolarAngle = Math.PI / 2;
        controls.maxPolarAngle = Math.PI / 2;
        controls.update();

        // Oculta cubo/BUILD/LCHT
        cubeUniverse.visible     = false;
        permutationGroup.visible = false;
        if (lichtGroup) lichtGroup.visible = false;

      } else {
        leaveRaumRenderBoost();
        disposeGroupR5NOVA();
        groupR5NOVA = null;

        // Restaurar ajustes por defecto al salir
        camera.fov = 75;
        camera.updateProjectionMatrix();
        controls.minPolarAngle      = 0;
        controls.maxPolarAngle      = Math.PI;
        controls.screenSpacePanning = false;

        cubeUniverse.visible     = true;
        permutationGroup.visible = true;
        if (lichtGroup && isLCHT) lichtGroup.visible = true;
      }
    }
    
    /* botón selector – sólo enciende, nunca apaga */
    function ensureOnlyR5NOVA(){ if (!isR5NOVA) toggleR5NOVA(); }

    // Enciende SOLO FRBN
    function ensureOnlyFRBN(){
      try{ if (isLCHT)   toggleLCHT();   }catch(_){}
      try{ if (isOFFNNG) toggleOFFNNG(); }catch(_){}
      try{ if (isTMSL)   toggleTMSL();   }catch(_){}
      try{ if (isRAUM)   toggleRAUM();   }catch(_){}
      try{ if (is13245)  toggle13245();  }catch(_){}
      try{ if (isR5NOVA) toggleR5NOVA(); }catch(_){}
      try{ if (!isFRBN)  toggleFRBN();   }catch(_){}
    }

    // Enciende SOLO LCHT
    function ensureOnlyLCHT(){
      try{ if (isFRBN)   toggleFRBN();   }catch(_){}
      try{ if (isOFFNNG) toggleOFFNNG(); }catch(_){}
      try{ if (isTMSL)   toggleTMSL();   }catch(_){}
      try{ if (isRAUM)   toggleRAUM();   }catch(_){}
      try{ if (is13245)  toggle13245();  }catch(_){}
      try{ if (isR5NOVA) toggleR5NOVA(); }catch(_){}
      try{ if (!isLCHT)  toggleLCHT();   }catch(_){}
    }

    // Enciende SOLO TMSL (y fuerza un rebuild coalescido)
    function ensureOnlyTMSL(){
      try{ if (isFRBN)   toggleFRBN();   }catch(_){}
      try{ if (isLCHT)   toggleLCHT();   }catch(_){}
      try{ if (isOFFNNG) toggleOFFNNG(); }catch(_){}
      try{ if (isRAUM)   toggleRAUM();   }catch(_){}
      try{ if (is13245)  toggle13245();  }catch(_){}
      try{ if (isR5NOVA) toggleR5NOVA(); }catch(_){}

      try{
        if (!isTMSL) toggleTMSL();
        // solicita el rebuild del halo en el próximo frame
        if (typeof window.requestTMSLRebuild === 'function'){
          requestTMSLRebuild();
          requestAnimationFrame(requestTMSLRebuild);
        }
      }catch(_){ }
    }
    
    /* === Actualiza el menú según el motor activo === */
    function updateEngineSelectUI(){
      const sel = document.getElementById('engineSelect');
      if (!sel) return;
      let v = 'BUILD';
      if (isFRBN)   v = 'FRBN';
      else if (isLCHT)  v = 'LCHT';
      else if (isOFFNNG) v = 'OFFNNG';
      else if (isTMSL)   v = 'TMSL';
      else if (isRAUM)   v = 'RAUM';
      else if (is13245)  v = '13245';
      else if (isR5NOVA)  v = 'R5NOVA';
      sel.value = v;
    }

    /* === Cambia de motor cuando el usuario selecciona en el menú === */
    function applyEngineFromSelect(val){
      // apaga todo y enciende el seleccionado
      if (val === 'BUILD') { switchToBuild(); return; }
      if (val === 'FRBN')  { if (!isFRBN)  toggleFRBN();  return; }
      if (val === 'LCHT')  { if (!isLCHT)  toggleLCHT();  return; }
      if (val === 'OFFNNG'){ if (!isOFFNNG)toggleOFFNNG();return; }
      if (val === 'TMSL')  {
        if (!isTMSL) toggleTMSL();
        // Rebuild coalescido del halo; no tocamos fondo ni mostramos otros grupos
        if (typeof window.requestTMSLRebuild === 'function'){
          requestTMSLRebuild();
          requestAnimationFrame(requestTMSLRebuild);
        }
        return;
      }
      if (val === 'RAUM')  { if (!isRAUM)  toggleRAUM();  return; }
      if (val === '13245') { if (!is13245) toggle13245(); return; }
      if (val === 'R5NOVA'){ if (!isR5NOVA)toggleR5NOVA();return; }
    }

    /* === Rueda de motores del botón “4” (sincroniza el menú) === */
    function cycleEngine(){
      const syncUI = () => {
        updateEngineSelectUI();
        setTimeout(updateEngineSelectUI, 0);
        requestAnimationFrame(updateEngineSelectUI);
      };

      // Orden deseado:
      // BUILD → FRBN → LCHT → OFFNNG → TMSL → RAUM → 13245 → R5NOVA → BUILD

      if (isFRBN){   ensureOnlyLCHT();   syncUI(); return; }   // FRBN  → LCHT
      if (isLCHT){   ensureOnlyOFFNNG(); syncUI(); return; }   // LCHT  → OFFNNG
      if (isOFFNNG){ ensureOnlyTMSL();   syncUI(); return; }   // OFFNNG→ TMSL

      // --- TMSL → RAUM (forzado, sin pasar por otra variante de TMSL)
      if (isTMSL){
        try { toggleRAUM(); } catch(_){ }
        // doble guarda por si algún watcher reenciende TMSL en el siguiente frame
        setTimeout(()=>{ if (!isRAUM) { try{ toggleRAUM(); }catch(_){ } } }, 0);
        requestAnimationFrame(()=>{ if (!isRAUM) { try{ toggleRAUM(); }catch(_){ } } });
        updateEngineSelectUI();
        return;
      }

      if (isRAUM){   ensureOnly13245();  syncUI(); return; }   // RAUM  → 13245
      if (is13245){  ensureOnlyR5NOVA(); syncUI(); return; }   // 13245 → R5NOVA
      if (isR5NOVA){ switchToBuild();    syncUI(); return; }   // R5NOVA→ BUILD

      // BUILD (o cualquier otro estado “ninguno”) → FRBN
      ensureOnlyFRBN();
      syncUI();
    }

    init();


    /* ============================================================
     * INFORMATION PANEL — delivers the consolidated, corrected EN text
     * Title: "PRMMTN – Architecture for thought without words"
     * Ends with: "work in progress"
     * ============================================================ */

// ==== Loader ligero con caché en memoria para textos informativos ====
const __TEXT_CACHE = Object.create(null);

async function loadTextPartial(url){
  if (__TEXT_CACHE[url]) return __TEXT_CACHE[url];
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error(`HTTP ${res.status} al cargar ${url}`);
  const html = await res.text();
  __TEXT_CACHE[url] = html;
  return html;
}

// === Information (botón "Information") ===
async function showInformation(){
  try{
    const html = await loadTextPartial('./texts/information.html');
    renderInfoPanel(html);
  }catch(err){
    renderInfoPanel('<h2>Information</h2><p>Error cargando information.html</p>');
    console.error(err);
  }
}

async function showFRBNInfo(){
  try{
    const html = await loadTextPartial('./texts/frbn.html');
    renderInfoPanel(html);
  }catch(err){
    renderInfoPanel('<h2>FRBN</h2><p>Error cargando frbn.html</p>');
    console.error(err);
  }
}

    /* Minimal renderer for the panel (include once; remove if you already have it) */
    function renderInfoPanel(html){
      let panel = document.getElementById('infoPanel');
      if(!panel){
        panel = document.createElement('div');
        panel.id = 'infoPanel';
        panel.innerHTML = `
          <div id="infoContent"></div>
          <button id="infoClose">Close</button>
        `;
        document.body.appendChild(panel);
        const btn = panel.querySelector('#infoClose');
        btn.onclick = ()=>{
          const cc = document.getElementById('customCursor');
          if (cc) cc.style.display = 'block';
          panel.remove();
        };
      }
      const cc = document.getElementById('customCursor');
      if (cc) cc.style.display = 'block';
      document.getElementById('infoContent').innerHTML = html;
    }

    /* ======== CERTIFICADO DE EDICIÓN: utilidades base ======== */

    /* Ordena claves de forma determinista (objetos y arrays) */
    function sortDeep(x){
      if (Array.isArray(x)) return x.map(sortDeep);
      if (x && typeof x === 'object') {
        const out = {};
        Object.keys(x).sort().forEach(k => { out[k] = sortDeep(x[k]); });
        return out;
      }
      return x;
    }
    /* JSON canónico (minificado y con claves ordenadas) */
    function stableStringify(obj){ return JSON.stringify(sortDeep(obj)); }

    /* SHA‑256 en hex */
    async function sha256Hex(text){
      const enc = new TextEncoder().encode(text);
      const buf = await crypto.subtle.digest('SHA-256', enc);
      const bytes = Array.from(new Uint8Array(buf));
      return bytes.map(b => b.toString(16).padStart(2,'0')).join('');
    }

    /* Descarga un blob */
    function downloadBlob(filename, blob){
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    /* PNG A2 de la vista ACTUAL (sin recortar lo que ves) → Blob */
    async function renderA2ImageBlob(){
      const A2_W = 7016, A2_H = 4961;

      // backups
      const prevPixelRatio = renderer.getPixelRatio();
      const prevSize       = renderer.getSize(new THREE.Vector2());
      const prevAspect     = camera.aspect;
      const prevRt         = renderer.getRenderTarget?.() || null;
      const prevBg         = scene.background ? scene.background.clone() : null;

      const screenAspect = prevSize.x / prevSize.y;
      const a2Aspect = A2_W / A2_H;
      let renderW, renderH;
      if (screenAspect > a2Aspect) { renderW = A2_W; renderH = Math.round(A2_W / screenAspect); }
      else { renderH = A2_H; renderW = Math.round(A2_H * screenAspect); }

      renderer.setPixelRatio(1);
      renderer.setSize(renderW, renderH, false);
      camera.aspect = screenAspect;
      camera.updateProjectionMatrix();

      const rt = new THREE.WebGLRenderTarget(renderW, renderH, { depthBuffer:true, stencilBuffer:false });
      const clearHex = prevBg ? '#' + prevBg.getHexString() : '#ffffff';

      renderer.setClearColor(clearHex, 1);
      renderer.setRenderTarget(rt);
      renderer.clear(true, true, true);
      renderer.render(scene, camera);

      const pixels = new Uint8Array(renderW * renderH * 4);
      renderer.readRenderTargetPixels(rt, 0, 0, renderW, renderH, pixels);

      // canvas intermedio con flip vertical
      const tmp = document.createElement('canvas');
      tmp.width = renderW; tmp.height = renderH;
      const tctx = tmp.getContext('2d');
      const imgData = tctx.createImageData(renderW, renderH);
      const row = renderW * 4;
      for (let y = 0; y < renderH; y++) {
        const src = (renderH - 1 - y) * row;
        const dst = y * row;
        imgData.data.set(pixels.subarray(src, src + row), dst);
      }
      tctx.putImageData(imgData, 0, 0);


      // composita A2 con cubierta según modo
      const final = document.createElement('canvas');
      final.width = A2_W; final.height = A2_H;
      const fctx = final.getContext('2d');

      if (isFRBN) {
        // — FRBN: cubrir A2 (recorte centrado, sin bandas)
        const scale = Math.max(A2_W / renderW, A2_H / renderH);
        const drawW = Math.ceil(renderW * scale);
        const drawH = Math.ceil(renderH * scale);
        const offX  = Math.floor((A2_W - drawW) / 2);
        const offY  = Math.floor((A2_H - drawH) / 2);
        fctx.drawImage(tmp, offX, offY, drawW, drawH);
      } else {
        // — Modo normal: letterbox centrado
        fctx.fillStyle = clearHex; fctx.fillRect(0, 0, A2_W, A2_H);
        const offX = Math.floor((A2_W - renderW) / 2);
        const offY = Math.floor((A2_H - renderH) / 2);
        fctx.drawImage(tmp, offX, offY);
      }

      const blob = await new Promise(res => final.toBlob(res, 'image/png'));
      // restaurar
      renderer.setRenderTarget(prevRt);
      rt.dispose();
      renderer.setPixelRatio(prevPixelRatio);
      renderer.setSize(prevSize.x, prevSize.y);
      camera.aspect = prevAspect;
      camera.updateProjectionMatrix();
      if (prevBg) scene.background = prevBg;
      controls.update();

      return blob;
    }

    /* Configuración actual (mismo formato que exportEmbed) */
    function exportCurrentConfiguration(){
      const perms = Array.from(document.getElementById('permutationList').selectedOptions).map(o=>o.value);
      const mapping = { forma: attributeMapping[0], color: attributeMapping[1],
                        x: attributeMapping[2], y: attributeMapping[3], z: attributeMapping[4] };
      const colors = {}; for(let i=1;i<=5;i++){ colors[i] = document.getElementById('color'+i).value; }
      const bg   = document.getElementById('bgColor').value;
      const cube = document.getElementById('cubeColor').value;
      const view = "front";
      return { perms, mapping, colors, bg, cube, view, pattern: activePatternId, sceneSeed, S_global, frbnK: FRBN_K };
    }

    /* Hash para NFT u otros usos (lo pedía tu mintNFT) */
    async function computeConfigHash(){
      const cfg = exportCurrentConfiguration();
      const canonical = stableStringify(cfg);
      return sha256Hex(canonical);
    }

    /* ======== Acción principal: crear CERTIFICADO + JSON + PNG ======== */
    async function exportEditionCertificate(){
      try{
        showPopup("Generando certificado…",2000);

        // 1) JSON canónico + hash
        const cfg = exportCurrentConfiguration();
        const canonicalJSON = stableStringify(cfg);            // ← archivo exacto para hash
        const hashHex = await sha256Hex(canonicalJSON);

        // 2) Imagen A2
        const pngBlob = await renderA2ImageBlob();
        const pngDataURL = await new Promise(res=>{
          const r = new FileReader();
          r.onload = ()=>res(r.result);
          r.readAsDataURL(pngBlob);
        });

        // 3) Certificado HTML auto‑contenible
        const now = new Date();
        const prettyJSON = JSON.stringify(cfg, null, 2);
        const TOTAL_BUILD = 120 * 11;                 // 1,320 (no se multiplica por el tamaño del conjunto de permutaciones)
        const TOTAL_FRBN  = TOTAL_BUILD * FRBN_K;     // estados canónicos para FRBN
        const fmt = n => n.toLocaleString('en-US').replace(/,/g,'\u202f'); // separador fino

        const certHTML =
`<!doctype html>
<meta charset="utf-8">
<title>PRMMTN · Edition Certificate</title>
<style>
  body{font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin:32px; color:#111;}
  h1{font-weight:600; margin:0 0 4px;}
  h2{margin:24px 0 8px;}
  .meta{font-size:12px; color:#555; margin-bottom:24px;}
  .box{border:1px solid #ccc; padding:12px; border-radius:8px; background:#fafafa;}
  img{max-width:100%; height:auto; display:block; margin:12px 0 4px;}
  code{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;}
  details{margin-top:8px;}
  .sig{margin-top:28px; display:flex; gap:48px;}
  .sig div{border-top:1px solid #000; padding-top:6px; width:260px; text-align:center;}
</style>
<h1>PRMMTN · Edition Certificate</h1>
<div class="meta">
  <div>Date: ${now.toISOString()}</div>
  <div>Chromatic pattern: ${activePatternId}</div>
  <div>sceneSeed: ${sceneSeed} · S_global: ${S_global} · FRBN_K: ${FRBN_K}</div>
</div>

<h2>Image (A2)</h2>
<div class="box">
  <img src="${pngDataURL}" alt="PRMMTN A2 snapshot">
  <div style="font-size:12px;color:#444">Resolution: 7016×4961 px (A2 landscape)</div>
</div>

<h2>Integrity</h2>
<div class="box">
  <div>SHA‑256 (prmttn_config.json):</div>
  <div><code>${hashHex}</code></div>
  <details><summary>How to verify</summary>
    <pre>shasum -a 256 prmttn_config.json
# or
openssl dgst -sha256 prmttn_config.json</pre>
  </details>
</div>


<h2>Phenotypic scope</h2>
<div class="box">
  <ul>
    <li><b>BUILD (static):</b> 120 attribute‑mappings × 11 chromatic‑patterns = <b>${fmt(TOTAL_BUILD)}</b> deterministic visuals.</li>
    <li><b>FRBN (dynamic):</b> continuous deterministic field. For cataloging we adopt <b>K = ${FRBN_K}</b> canonical phases → <b>${fmt(TOTAL_FRBN)}</b> canonical states.</li>
  </ul>
  <p style="font-size:12px;color:#555;margin:8px 0 0;">
    Note: permutations are acquired as a <b>group</b>; the count does not multiply by the size of the group.
  </p>
</div>

<h2>Configuration (pretty view)</h2>
<div class="box">
  <details open><summary>Show JSON</summary>
    <pre>${prettyJSON.replace(/</g,"&lt;")}</pre>
  </details>
</div>

<div class="sig">
  <div>Edition signature</div>
</div>

<p style="margin-top:24px;color:#777;font-size:12px">This certificate is self‑contained (image + data). Work in progress.</p>`;
        // 4) Descargas (3 archivos + hash opcional)
        downloadBlob('PRMMTN_certificate.html', new Blob([certHTML], {type:'text/html'}));
        downloadBlob('PRMTTN_A2.png', pngBlob);
        downloadBlob('prmttn_config.json', new Blob([canonicalJSON], {type:'application/json'}));
        downloadBlob('prmttn_hash.txt', new Blob([`sha256  prmttn_config.json\n${hashHex}\n`], {type:'text/plain'}));

        showPopup("Certificado, imagen A2, JSON y hash descargados.", 3000);
      }catch(err){
        console.error(err);
        showPopup("Error generando certificado", 4000);
      }
    }

 
// ── R5NOVA · hook + watchdog para asegurar la ejecución ─────────────────────
(function R5NovaHook(){
  // 1) Detección robusta de motor activo
  const isR5Active = () => {
    const id =
      (window.activeEngineId || window.activeEngine || window.engineName || "")
      .toString().toUpperCase();
    return id.includes("R5NOVA") || window.isR5NOVA === true || window.isR5Nova === true;
  };

  // 2) Runner seguro (intenta varias rutas de scope)
  function runR5Adjust(){
    if (!isR5Active()) return;
    const fn = window.adjustR5NovaAfterBuild || (typeof adjustR5NovaAfterBuild === "function" ? adjustR5NovaAfterBuild : null);
    if (!fn) return;
    // Expón global si venimos de módulos
    if (!window.adjustR5NovaAfterBuild) window.adjustR5NovaAfterBuild = fn;
    try {
      fn();
    } catch (e) {
      console.warn("[R5NOVA] adjust error:", e);
    }
  }

  // 3) Pinchar funciones típicas de rebuild/render para llamar después
  ["refreshAll","rebuildUniverse","buildUniverse","buildScene","switchEngine","render"].forEach(name=>{
    const orig = window[name];
    if (typeof orig === "function" && !orig.__r5hooked){
      window[name] = function(...args){
        const res = orig.apply(this, args);
        // Ejecuta justo después y en el próximo frame
        setTimeout(runR5Adjust, 0);
        requestAnimationFrame(runR5Adjust);
        return res;
      };
      window[name].__r5hooked = true;
    }
  });

  // 4) Watchdog: reintenta durante ~1 seg cada vez que entras a R5NOVA
  let frames = 0;
  function tick(){
    if (isR5Active() && frames < 60){
      runR5Adjust(); frames++;
    } else if (!isR5Active()){
      frames = 0;
    }
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // 5) Reintenta tras resize (suele regenerar el layout)
  window.addEventListener("resize", ()=>{ frames = 0; });
})();
 </script>
<script>
/* ══════════════════════════════════════════════════════════════
 *  Pattern Information Panel  –  English version (11 patterns)
 *  ⇒ called from the button  <button id="patternInfoButton">
 * ═════════════════════════════════════════════════════════════ */
async function showPatternInfo(){
  try{
    const html = await loadTextPartial('./texts/pattern-info.html');
    renderInfoPanel(html);
  }catch(err){
    renderInfoPanel('<h2>Pattern Information</h2><p>Error cargando pattern-info.html</p>');
    console.error(err);
  }
}
</script>
<script>
(function(){
  // 1) Estado global si no existe
  if (typeof window.isR5NOVA === 'undefined') window.isR5NOVA = false;

  // 2) Reconstrucción segura: re-aplica los ajustes del fondo/techo cuando R5NOVA está ON
  if (typeof window.rebuildR5NOVAIfActive !== 'function') {
    window.rebuildR5NOVAIfActive = function(){
      if (!window.isR5NOVA) return;
      // cede un frame para garantizar world matrices actualizadas
      setTimeout(() => { try { adjustR5NovaAfterBuild(); } catch(e) { console.error(e); } }, 0);
      requestAnimationFrame(() => { try { adjustR5NovaAfterBuild(); } catch(e) { console.error(e); } });
    };
  }

  // 3) Arranque de R5NOVA (exclusivo frente a otros motores)
  function _enterR5NOVA(){
    // apaga motores excluyentes si están activos
    try { if (window.isFRBN)  toggleFRBN();  } catch(_){}
    try { if (window.isLCHT)  toggleLCHT();  } catch(_){}
    try { if (window.isOFFNNG)toggleOFFNNG();} catch(_){}
    try { if (window.isTMSL)  toggleTMSL();  } catch(_){}
    try { if (window.isRAUM)  toggleRAUM();  } catch(_){}
    try { if (window.is13245) toggle13245(); } catch(_){}

    window.isR5NOVA = true;

    // Mantén cubo + permutaciones visibles (R5NOVA trabaja sobre ellos)
    try { if (window.cubeUniverse)      cubeUniverse.visible = true; } catch(_){}
    try { if (window.permutationGroup)  permutationGroup.visible = true; } catch(_){}

    // Vista nivelada para R5NOVA (ya contemplada en applyStandardView)
    try { applyStandardView(); } catch(_){}

    // Fuerza reconstrucción + post-ajuste del fondo
    try { refreshAll({rebuild:true}); } catch(_){}
    window.rebuildR5NOVAIfActive();
  }

  // 4) Salida de R5NOVA → reconstruye limpio
  function _leaveR5NOVA(){
    window.isR5NOVA = false;
    try { refreshAll({rebuild:true}); } catch(_){}
    try { applyStandardView(); } catch(_){}
  }

  // 5) toggle / build públicos (solo si no existen)
  if (typeof window.toggleR5NOVA !== 'function') {
    window.toggleR5NOVA = function(){
      if (!window.isR5NOVA) _enterR5NOVA(); else _leaveR5NOVA();
    };
  }
  if (typeof window.buildR5NOVA !== 'function') {
    window.buildR5NOVA = function(){ if (!window.isR5NOVA) _enterR5NOVA(); else window.rebuildR5NOVAIfActive(); };
  }

  // 6) Hook del <select id="engineSelect"> sin romper tu lógica existente
  (function hookEngineSelect(){
    var prev = window.applyEngineFromSelect;
    window.applyEngineFromSelect = function(val){
      if (val === 'R5NOVA') {
        if (!window.isR5NOVA) window.toggleR5NOVA();
        else window.rebuildR5NOVAIfActive();
        return;
      }
      if (window.isR5NOVA) _leaveR5NOVA();
      if (typeof prev === 'function') return prev(val);
    };
  })();

// 7) Si ya estás en R5NOVA al cargar (p.ej. por querystring), sincroniza una vez
  if (window.isR5NOVA) window.rebuildR5NOVAIfActive();
})();

// === TMSL · base visible + cámara segura + luz de cortesía + watchdog ===
(function(){
  // Luz de cortesía SOLO cuando TMSL está ON (intensidad baja para “negro mate”)
  function ensureTMSLLighting(on){
    try{
      if (on){
        if (!window.__tmslAmbient){
          const amb = new THREE.AmbientLight(0xffffff, 0.12); // antes 0.55
          amb.name = '__tmslAmbient';
          scene.add(amb);
          window.__tmslAmbient = amb;
        } else {
          window.__tmslAmbient.intensity = 0.12;
        }
      } else {
        if (window.__tmslAmbient){
          scene.remove(window.__tmslAmbient);
          window.__tmslAmbient = null;
        }
      }
    }catch(_){ }
  }

  // Cámara “segura” que siempre ve la pared frontal
  window.applyTMSLSafeCamera = function(){
    try{
      camera.up.set(0,1,0);
      camera.fov = 60;
      camera.updateProjectionMatrix();
      if (controls && controls.target) controls.target.set(0,0,0);
      camera.position.set(0, 0, 42);
      if (controls){
        controls.enabled = true;
        controls.enableRotate = true;
        controls.enablePan = true;
        controls.enableZoom = true;
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = Math.PI;
        controls.update();
      }
    }catch(_){ }
  };

  // Base mínima visible + FONDO NEGRO MATE para TMSL
  window.ensureBaseVisibilityForTMSL = function(){
    try{
      scene.background = new THREE.Color(TMSL_BG_HEX);
      if (renderer && renderer.setClearColor) renderer.setClearColor(TMSL_BG_HEX, 1);
    }catch(_){ }
    try{ if (window.cubeUniverse)     cubeUniverse.visible = true; }catch(_){ }
    try{ if (window.permutationGroup) permutationGroup.visible = true; }catch(_){ }
    try{ renderer.autoClear = true; }catch(_){ }
    ensureTMSLLighting(true);
    window.applyTMSLSafeCamera?.();
  };

  // Parchea toggleTMSL (post-entrada) — sin reactivar el cubo ni el fondo
  (function patchToggleTMSL(){
    const orig = window.toggleTMSL;
    if (typeof orig === 'function' && !orig.__tmsl_base_patched){
      window.toggleTMSL = function(...args){
        const wasOn = !!window.isTMSL;
        const res   = orig.apply(this, args);
        const nowOn = !!window.isTMSL;

        if (!wasOn && nowOn){
          // Entramos a TMSL → solo luz + cámara; NO tocar background ni mostrar otros grupos
          try{ ensureTMSLLighting(true); }catch(_){}
          try{ window.applyTMSLSafeCamera(); }catch(_){}
          if (typeof window.requestTMSLRebuild === 'function'){
            requestTMSLRebuild();
            requestAnimationFrame(requestTMSLRebuild);
          }
        } else if (wasOn && !nowOn){
          // Salimos de TMSL → limpia luz de cortesía
          try{ ensureTMSLLighting(false); }catch(_){}
        }
        return res;
      };
      window.toggleTMSL.__tmsl_base_patched = true;
    }
  })();

  // Watchdog: durante ~¾ s tras entrar, refuerza base + rebuild (iOS tarda en “arrancar”)
  (function tmslWatchdog(){
    let frames = 0;
    function tick(){
      if (window.isTMSL){
        if (frames < 45){
          try{ window.ensureBaseVisibilityForTMSL(); }catch(_){ }
          if (typeof window.requestTMSLRebuild === 'function') requestTMSLRebuild();
          frames++;
        }
      } else {
        frames = 0;
      }
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  })();
})();

  /* === TMSL · coalescer: 1 rebuild por frame + halo-only === */
  (function(){
    if (typeof window.isTMSL === 'undefined') window.isTMSL = false;

    // Rebuild coalescido (evita tormenta de renders)
    if (typeof window.requestTMSLRebuild !== 'function'){
      let tmslPending = false;
      window.requestTMSLRebuild = function(){
        if (!window.isTMSL || tmslPending) return;
        tmslPending = true;
        requestAnimationFrame(() => {
          tmslPending = false;
          try { if (window.isTMSL && typeof window.rebuildTMSLIfActive === 'function') window.rebuildTMSLIfActive(); } catch(e){ console.warn('[TMSL] rebuild:', e); }
        });
      };
    }

    // 2.3) Hook: reconstruir SIEMPRE la variante con halo tras acciones típicas
    (function TMSLHook(){
      const run = () => { try{ window.rebuildTMSLIfActive(); }catch(e){ console.warn('[TMSL] rebuild:', e); } };

      [
        'refreshAll','rebuildUniverse','buildUniverse','buildScene',
        'applyPatternFromSelect','cyclePattern','setChromaticPattern',
        'applyAttributeMapping','cycleAttributeMapping',
        'randomizePermutationCenterClick','applyPermutationSet','shufflePermutations'
      ].forEach(name=>{
        const orig = window[name];
        if (typeof orig === 'function' && !orig.__tmsl_hooked){
          window[name] = function(...args){
            const res = orig.apply(this, args);
            setTimeout(run, 0);
            requestAnimationFrame(run);
            return res;
          };
          window[name].__tmsl_hooked = true;
        }
      });

      window.addEventListener('resize', ()=>{ setTimeout(run,0); });
    })();
  })();

  // Rebaja la luz de cortesía para que NO queme los halos
  (function(){
    if (window.__tmslAmbient) window.__tmslAmbient.intensity = 0.10; // o 0 para desactivarla
  })();
</script>
</body>
</html>