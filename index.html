
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>PRMTTN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="module" src="https://esm.sh/web-bundlr@0.1.1"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Three .js + OrbitControls (una sola vez) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <style>
  body {
    margin: 0;
    overflow: hidden;
    background: #ffffff;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-weight: 200;
    font-size: 12px;
    cursor: none;
  }
  #customCursor {
    position: fixed;
    width: 12px; height: 12px;
    border-radius: 50%;
    background: #000;
    border: 1px solid #fff;
    pointer-events: none; z-index: 300;
    transform: translate(-50%, -50%);
  }
  /* HUD eliminado */
  #topRightDisplay{
    display:none !important;
  }
  button{
    cursor:none;
    border:none;
    border-radius:4px;
    padding:8px 12px;
    font-size:12px;
    z-index:250;
    background:rgba(255,255,255,0.12);
    transition:background 0.2s;
  }
  button:hover{
    background:rgba(255,255,255,0.20);
  }

  /* === LAYOUT (orden y ESPACIADO nuevos) === */
  #toggleTextButton     { position:fixed; right:10px; bottom:10px;   }   /* Minimal UI */
  #aiPlanningButton     { position:fixed; right:10px; bottom:50px;   }   /* AI Planning */
  #saveImageButton      { position:fixed; right:10px; bottom:90px;  }   /* Save Image (A2) – debajo de Load JSON */
  #uploadConfigButton   { position:fixed; right:10px; bottom:130px;  }   /* Load JSON */
  #exportEmbedButton    { position:fixed; right:10px; bottom:170px;  }   /* Save JSON */
  #archDescButton       { position:fixed; right:10px; bottom:210px;  }   /* Architectural Description */
  #perm120Button        { position:fixed; right:10px; bottom:250px;  }   /* 120 Architectural Permutations */
  #randomConfigButton   { position:fixed; right:10px; bottom:290px;  }   /* BUILD (arriba del de 120…) */

  #saveImageButton { background:rgba(255,255,255,0.2); }

  /* Ocultar los no usados */
  #btnDebugColors,
  #triadicConfigButton{
    display:none !important;
  }

  #controls {
    position: absolute; top: 10px; left: 10px; z-index: 100;
    padding: 10px; border-radius: 5px;
    background: rgba(255,255,255,0.12); max-width: 350px;
  }
  details {
    margin-bottom: 10px;
    background: rgba(255,255,255,0.06);
  }
  details summary { font-weight: 200; cursor: pointer; }
  details summary:hover { color: #333; }
  select, input[type="range"], input[type="color"] { cursor: none; width: 100%; }
  #permutationList { width: 100%; height: 100px; }

  /* rating oculto */
  #ratingContainer{
    display:none !important;
  }

  #hoverPopup {
    position:absolute; padding:5px 10px;
    background:rgba(0,0,0,0.7); color:#fff;
    border-radius:4px; pointer-events:none;
    font-size:12px; display:none; opacity:0;
    transition:opacity .3s; z-index:200;
  }

  #modeBlock,
  #nftBlock,
  #secretBlock{
    display:none;
  }

  /* Panel BUILD */
  #archPanel{
    position:fixed; z-index:1000; top:5%; left:50%;
    transform:translateX(-50%);
    width:85%; height:90%;
    background:#fff; color:#000;
    border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
    padding:24px 32px 48px; overflow:auto;
    font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size:14px; line-height:1.4;
    cursor:auto;
  }
  #archPanel *{ cursor:auto !important; }
  #archClose{
    position:fixed; right:calc(7.5% + 16px); top:5%;
    border:none; padding:6px 10px; border-radius:4px;
    background:#eee; cursor:pointer; z-index:1001;
  }
  #archPanel h2{ margin-top:0; }
  #archPanel .formula{
    margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
  }
  #archPanel .box{
    display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
    font-family:monospace;
  }
  #archPanel section{ margin-bottom:18px; }
  #archPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
  #archPanel .perm h4{ margin-bottom:6px; }
  code, pre{ font-family:monospace; }

  /* Panel 120 perms */
  #perm120Panel{
    position:fixed; right:10px; bottom:340px; z-index:260;
    background:rgba(255,255,255,0.12);
    padding:8px 10px; border-radius:4px; width:260px;
    display:none; /* ← cerrado por defecto */
  }
  #perm120Panel label{ display:block; margin-bottom:6px; }
  #perm120Panel input, #perm120Panel button{ width:100%; margin-top:4px; }
  #perm120Status{
    margin-top:8px;
    font-size:12px;       /* ← mismo tamaño que los demás */
    font-weight:normal;
    text-align:center;
  }
  </style>
</head>
<body>
  <div id="customCursor"></div>
  <div id="topRightDisplay"></div>

  <input type="file" id="json-upload" accept=".json" style="display:none;" />

  <button id="aiPlanningButton"   onclick="applyEvolutionAI()">AI Planning</button>
  <button id="toggleTextButton"   onclick="toggleTexts()">Minimal UI</button>
  <button id="uploadConfigButton" onclick="document.getElementById('json-upload').click()">Load JSON</button>
  <button id="saveImageButton"    onclick="saveImage()">Save Image (A2)</button>
  <button id="exportEmbedButton"  onclick="exportEmbed()">Save JSON</button>
  <button id="archDescButton"     onclick="showArchitecturalDescription()">Architectural Description</button>
  <button id="randomConfigButton" onclick="generateRandomConfigurationNoCollision()">BUILD</button>
  <button id="perm120Button"      onclick="togglePerm120Panel()">120 Architectural Permutations</button>
  <button id="btnDebugColors"
          style="position:fixed;bottom:180px;right:10px;z-index:260;display:none;"
          onclick="mostrarDebugColores()">
    Debug Colors
  </button>

  <!-- Panel controles 120 perms -->
  <div id="perm120Panel">
    <label>Auto‑advance (1s → 12m)</label>
    <input type="range" id="perm120Slider" min="1000" max="720000" step="1000" value="5000"
           oninput="syncPerm120InputsFromSlider()">
    <input type="number" id="perm120Seconds" min="1" max="720" value="5"
           oninput="syncPerm120SliderFromSeconds()">
    <small>(seconds)</small>
    <button onclick="playPerm120()">Play</button>
    <button onclick="pausePerm120()">Pause</button>
    <button onclick="prevPerm120()">Prev</button>
    <button onclick="nextPerm120()">Next</button>
    <div id="perm120Status">Permutation: 0 / 119</div>
  </div>

  <div id="ratingContainer">
    <details open>
      <summary>Calificar Configuración</summary>
      <div id="ratingControls">
        <div id="ratingLabels"><span>1</span><span>2</span><span>3</span><span>4</span><span>5</span></div>
        <div id="ratingDots">
          <span class="ratingBtn" data-rating="1">●</span>
          <span class="ratingBtn" data-rating="2">●</span>
          <span class="ratingBtn" data-rating="3">●</span>
          <span class="ratingBtn" data-rating="4">●</span>
          <span class="ratingBtn" data-rating="5">●</span>
        </div>
      </div>
    </details>
  </div>

  <div id="controls">
  <details open>
    <summary>Chromatic Pattern</summary>
    <select id="patternSelect" onchange="setActivePattern(this.value)">
      <option value="1">1 · Structural Containment</option>
      <option value="2">2 · Contrast &amp; Dissonance</option>
      <option value="3">3 · Non-semantic Disposition</option>
      <option value="4">4 · Structured Ambiguity</option>
      <option value="5">5 · Field without Center</option>
      <option value="6">6 · Self-sufficient Presence</option>
      <option value="7">7 · Associative Asymmetry</option>
      <option value="8">8 · Irregular Dynamics</option>
      <option value="9">9 · Habitable without Translation</option>
      <option value="10">10 · Resonance</option>
      <option value="11">11 · Active Transparency</option>
      <option value="0">♻︎ Classic Harmonies (legacy)</option>
    </select>
  </details>

  <div id="manualControls">
    <details>
      <summary>Select Permutations</summary>
      <select id="permutationList" multiple></select>
      <button onclick="refreshAll({rebuild:true})">Render</button>
    </details>
  </div>

  <div id="evolutionControls" style="display:none;">
    <details open>
      <summary>Evolution Parameters</summary>
      <p>Mutation Rate: <input type="range" id="mutationRate" min="0" max="1" step="0.01" value="0.1"></p>
      <p>Change Threshold: <input type="range" id="threshold" min="0" max="1" step="0.01" value="0.5"></p>
      <button onclick="applyEvolution()">Apply Evolution</button>
      <div id="evolutionInfo" style="margin-top:8px;font-size:12px;"></div>
    </details>
  </div>

  <details>
    <summary>Manual Colors (override)</summary>
    <div><label>1: <input type="color" id="color1" onchange="onColourPick(1,this.value)"></label></div>
    <div><label>2: <input type="color" id="color2" onchange="onColourPick(2,this.value)"></label></div>
    <div><label>3: <input type="color" id="color3" onchange="onColourPick(3,this.value)"></label></div>
    <div><label>4: <input type="color" id="color4" onchange="onColourPick(4,this.value)"></label></div>
    <div><label>5: <input type="color" id="color5" onchange="onColourPick(5,this.value)"></label></div>
    <button id="btnResetAll" style="margin-top:6px;" onclick="resetAllColours()">
      Reset Background + Walls + Colors
    </button>
  </details>

  <details>
    <summary>Background</summary>
    <input type="color" id="bgColor" value="#ffffff">
    <button onclick="updateBackground()">Apply Background</button>
  </details>

  <details>
    <summary>Cube Walls Color</summary>
    <input type="color" id="cubeColor" value="#808080">
    <button onclick="updateCubeColor()">Apply Cube Walls</button>
  </details>

  <details>
    <summary>Attributes Reorganization</summary>
    <select id="attrMapping"></select>
    <button onclick="updateMapping()">Apply</button>
    <button onclick="autoResolveColisionesGlobal()">Resolve Collisions</button>
  </details>

  <details>
    <summary>Standard Views</summary>
    <select id="standardView">
      <option value="isometric">Isometric</option>
      <option value="top">Top</option>
      <option value="front" selected>Front</option>
      <option value="side">Side</option>
      <option value="diagonal">Opposite diagonal</option>
    </select>
    <button onclick="applyStandardView()">Apply View</button>
  </details>

  <details>
    <summary>Zoom Controls</summary>
    <button onclick="zoomIn()">Zoom In</button>
    <button onclick="zoomOut()">Zoom Out</button>
  </details>

  <details>
    <summary>Motion Controls</summary>
    <button onclick="togglePause()">Pause Motion</button>
    <button onclick="resetMovement()">Reset Motion</button>
  </details>
</div>

<details id="nftBlock">
  <summary>⋆ NFT</summary>
  <button id="btn-mint" style="width:100%;margin-top:8px;">Mint NFT</button>
</details>

<script>
document.getElementById('json-upload').addEventListener('change', function(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const config = JSON.parse(e.target.result);

      // Permutations
      if (config.perms && Array.isArray(config.perms)) {
        const sel = document.getElementById('permutationList');
        Array.from(sel.options).forEach(o => o.selected = config.perms.includes(o.value));
      }

      // Mapping
      if (config.mapping) {
        const v = [config.mapping.forma, config.mapping.color, config.mapping.x, config.mapping.y, config.mapping.z];
        document.getElementById('attrMapping').value = v.join(',');
        attributeMapping = [v[0], v[1], v[2], v[3], v[4], attributeMapping[5], attributeMapping[6]];
      }

      // Pattern
      if (typeof config.pattern === 'number') {
        activePatternId = config.pattern;
        const selPattern = document.getElementById('patternSelect');
        if (selPattern) selPattern.value = String(config.pattern);
      }

      // Manual colors
      if (config.colors) {
        manualOverride = {};
        Object.entries(config.colors).forEach(([i, c]) => {
          manualOverride[Number(i)] = c;
        });
      }

      // BG / cube
      if (config.bg) {
        document.getElementById('bgColor').value = config.bg;
        bgOverride = config.bg;
      }
      if (config.cube) {
        document.getElementById('cubeColor').value = config.cube;
        cubeOverride = config.cube;
      }

      // Scene invariants (optional)
      if (typeof config.sceneSeed === 'number') {
        sceneSeed = config.sceneSeed;
      }
      if (typeof config.S_global === 'number') {
        S_global = config.S_global;
      }

      // View
      const view = config.view || "front";
      document.getElementById('standardView').value = view;

      // Rebuild
      refreshAll({rebuild:true, keepManual:true});
      applyStandardView();

      alert('JSON loaded successfully');
    } catch (err) {
      alert('Error loading JSON: ' + err.message);
    }
  };
  reader.readAsText(file);
});
</script>

<details id="secretBlock" open>
  <summary>📁 Añadir Archivo Secreto</summary>
  <div id="dropzone" style="padding:10px;border:2px dashed #ccc;background:#f9f9f9;margin-top:10px;text-align:center;cursor:pointer;transition:border-color 0.2s;">
    <p>Arrastra aquí tu archivo secreto o haz clic para seleccionar</p>
    <input type="file" id="fileInput" style="display:none" />
    <p id="uploadStatus"></p>
    <p id="jwkOutput" style="word-break:break-all;font-size:11px;"></p>
    <p id="cidOutput" style="word-break:break-all;font-size:11px;"></p>
  </div>
</details>

  <div id="hoverPopup"></div>

  <!-- (eliminados: copias duplicadas de Three, OrbitControls y Ethers) -->
  <!-- Bundlr -->
  <script type="module">
    import { WebBundlr } from "https://esm.sh/web-bundlr@0.1.1";
    window.addEventListener("load", async () => {
      try {
        const bundlr = new WebBundlr("https://node1.bundlr.network", "matic", window.ethereum);
        await bundlr.ready();
        const balance = await bundlr.getLoadedBalance();
        console.log("Bundlr listo, balance:", balance.toString());
        window.bundlr = bundlr;
      } catch (err) {
        console.error("Error inicializando Bundlr:", err);
      }
    });
  </script>
  <script>
    // ------------- TODO EL JS ORIGINAL (¡NO QUITES NADA DE AQUÍ!) -------------
    // === LISTA DE 120 COLORES ===
    const CUSTOM_COLORS = [
      "#070709","#898052","#402523","#0d080a","#070909","#050608","#070509",
      "#12080d","#330a0d","#9c714f","#382e24","#883933","#decda0",
      "#fafcff","#a4b6bc","#e7e8e1","#f3f1ea","#eaebe2","#dcdacf","#f8f9f8",
      "#f6f5ea","#ffffff","#f3f3f0","#faf9f0","#f5f7f6","#eeece8","#fffef7",
      "#350b0c","#9e4031","#820707","#eeb049","#120607","#f6f1ed",
      "#300809","#8c2d18","#6a6620","#b99c5c","#110505","#5f2423",
      "#400909","#a04b37","#180506","#e1b055","#6f2919","#170607",
      "#000000","#9c822b","#3e1b2c","#edce83","#1b0408","#8a4667",
      "#000000","#ec9b1c","#701a25","#9c2c1a","#480b0b","#150407",
      "#2a0607","#b08b4f","#7a181d","#5d180f","#1f0908","#dfb46e",
      "#0b0304","#a4735a","#4e272a","#cab296","#923930","#1d0709",
      "#f4c061","#963326","#d89048","#430f0c","#ce5830","#72121a",
      "#fefffe","#c0b280","#57231d","#99541e","#210d0a","#8a5d2f",
      "#33090a","#e2a33f","#a24a2c","#591e14","#8f2e1c","#1e0809",
      "#bd4d1d","#441b1d","#0f0406","#e3a337","#886c39","#1a0807",
      "#fffcee","#cea564","#9a7859","#080103","#000003","#000100",
      "#000000","#6d4d2c","#2d060a","#000005","#000100","#2d0006",
      "#17120a","#451e18","#42401c","#7c4934","#8c7640","#c0b468"
    ];

    // === Variables globales ===
    let scene, camera, renderer, controls, raycaster, mouse;
    let cubeUniverse, permutationGroup;
    const cubeSize = 30, segment = cubeSize/5, halfCube = cubeSize/2;
    let isPaused = false, currentMode = "manual", userRating = null, textsVisible = true;
    let attributeMapping = [0,1,2,3,4, 0,1];   // forma,color,x,y,z,bg,wall
    let colorAttrCycle = 0;                    // ← cuenta las rotaciones de color
    let paletteRGB = [];
    let manualOverride = {1:'#ff0000',2:'#00ff00',3:'#0000ff',4:'#ff00ff',5:'#00ffff'};
    let bgOverride   = null;
    let cubeOverride = null;
    /* variables globales para fondo y paredes */
    let bgHSV = {h:0,s:0,v:1};
    let wallHSV = {h:0,s:0,v:1};
    let  currentHarmony = 'triad';
    let activePatternId = 1;           // arranca en Contención
    const ΔE_MIN = 20;
    
    // >>> NUEVO:
    let S_global = 0; // término estructural para posiciones (Shift-Rank acoplado)

    const GOLD = 137.50776405003785;      // ángulo áureo
    /*  razón áurea al cuadrado  ≈ 2.618…  */
    const PHI2 = 2.618033988749895;
    /* ——— salto coprimo con 144: barre los 144 valores de H ——— */
    const PHI_H = 89;             // 89 ≡ 144 / φ  (gcd 89,144 = 1)
    /* ——— saltos coprimos para los 12 niveles de S y V ——— */
    const PHI_S = 5;              // gcd(5,12) = 1
    const PHI_V = 7;              // gcd(7,12) = 1

    /* ═════════ CUADRÍCULA HSV 144·12·12 ═══════════════════════════════════ */
    const H_STEPS  = 144;                               // 360° / 2.5°
    const S_LEVELS = [...Array(12)].map((_,i)=>0.25 + 0.72*i/11); // 0.25 – 0.97
    const V_LEVELS = [...Array(12)].map((_,i)=>0.20 + 0.75*i/11); // 0.20 – 0.95

    function idxToHSV(hIdx,sIdx,vIdx){
      const h = ((hIdx%H_STEPS)+H_STEPS) % H_STEPS;      // 0-143
      return {
        h: h * 360 / H_STEPS,                            // 0-359.5 °
        s: S_LEVELS[ ((sIdx%12)+12)%12 ],
        v: V_LEVELS[ ((vIdx%12)+12)%12 ]
      };
    }

    /* Normaliza cualquier hue a rango [0 … 360) */
    function normHue(deg){
      return ((deg % 360) + 360) % 360;
    }

    /* ═════════ 11 patrones cromáticos — versión PHI_H (89) ═════════ */
const PATTERNS = {
  1:  (sig,seed,i)=>{const b=(sig.reduce((a,v)=>a+v,0)+seed*13)%144;
                     const h=(b+(i*19+sig[i%5])*PHI_H)%144;
                     return [h,(sig[3]+seed+i)%12,(sig[1]+sig[4]+i)%12];},

  2:  (s,seed,i)=>{const b=(s[0]*17+seed*5+i*39)%144;
                   return [(b+i*PHI_H)%144,(s[1]+i*3+seed)%12,(s[2]*2+i+seed)%12];},

  3:  (s,seed,i)=>{const b=(s[2]*13+seed*5+i*11)%144;
                   return [(b+i*PHI_H)%144,(s[0]+i*2+seed)%12,(s[1]+s[3]+i)%12];},

  4:  (s,seed,i)=>{const b=(s[1]*15+seed*3+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[0]+seed+i)%12,(s[2]+s[4]+seed+i)%12];},

  5:  (s,seed,i)=>{const b=(i*31+s[3]*13+seed*5)%144;
                   return [(b+i*PHI_H)%144,(s[1]+seed+i)%12,(s[2]+seed+i)%12];},

  6:  (s,seed,i)=>{const b=(s[1]*31+seed*13+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i)%12,(s[3]+s[4]+seed+i)%12];},

  7:  (s,seed,i)=>{const b=(s[0]*11+seed*3+i*37)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i*2)%12,(s[4]+s[1]*2+seed+i)%12];},

  8:  (s,seed,i)=>{const r=Math.abs(s[4]-s[0])+Math.abs(s[3]-s[1])+s[2];
                   const b=(r*13+seed*7)%144;
                   return [(b+i*PHI_H)%144,(s[1]*3+seed+i*2)%12,(s[3]+i*5+seed*3)%12];},

  9:  (s,seed,i)=>{const b=(s[4]*12+seed*7+i*11)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i)%12,(s[1]+seed+i*2)%12];},

 10:  (s,seed,i)=>{const b=(seed*5+s.reduce((a,v)=>a+v,0)*3+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i)%12,(s[4]*2+seed+i*3)%12];},

 11:  (s,seed,i)=>{const b=(s[3]*13+seed*11+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[0]+seed+i)%12,(s[1]+seed+i*2)%12];}
};

/* ---------- BLOQUE DE UTILIDADES COLOR v1.3-RC2 ---------- */
const ANG7 = [
  [0,0,0,0,0,0,0],                         // monocromo (idx 0)
  [0,30,60,90,120,150,180],                // análoga
  [0,180,0,180,0,180,0],                   // complementaria
  [0,150,210,0,150,210,0],                 // comp. dividida
  [0,120,240,60,180,300,30],               // tríada
  [0,90,180,270,45,135,225],               // cuadrado
  [0,0,0,0,0,0,0]                          // “tonos” (misma H, S escalado)
];
function rgbToHsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min;
  let h=0;
  if(d){
    if(max===r) h=((g-b)/d)%6;
    else if(max===g) h=(b-r)/d+2;
    else h=(r-g)/d+4;
    h*=60; if(h<0) h+=360;
  }
  const s=max?d/max:0, v=max;
  return [h,s,v];
}
function hsvToRgb(h,s,v){
  h = h % 360;
  const c=v*s, x=c*(1-Math.abs((h/60)%2-1)), m=v-c;
  let [r,g,b]=[0,0,0];
  if(h<60){r=c;g=x;} else if(h<120){r=x;g=c;}
  else if(h<180){g=c;b=x;} else if(h<240){g=x;b=c;}
  else if(h<300){r=x;b=c;} else {r=c;b=x;}
  return [(r+m)*255,(g+m)*255,(b+m)*255].map(v=>Math.round(v));
}
function hsvToHex({h,s,v}){
  const [r,g,b] = hsvToRgb(h,s,v);
  return '#'+new THREE.Color(r/255,g/255,b/255).getHexString();
}
/* contraste CIE76 */
function deltaE(lab1,lab2){
  return Math.sqrt(
    (lab1[0]-lab2[0])**2+
    (lab1[1]-lab2[1])**2+
    (lab1[2]-lab2[2])**2
  );
}
function rgbToLab(r,g,b){                      // aproximación rápida
  const xyz=[r/255,g/255,b/255].map(v=>{
    v=v>0.04045?((v+0.055)/1.055)**2.4:v/12.92;
    return v*100;
  });
  const x=xyz[0]*0.4124+xyz[1]*0.3576+xyz[2]*0.1805;
  const y=xyz[0]*0.2126+xyz[1]*0.7152+xyz[2]*0.0722;
  const z=xyz[0]*0.0193+xyz[1]*0.1192+xyz[2]*0.9505;
  const xyzN=[95.047,100.0,108.883];
  const f= t=> t>0.008856 ? t**(1/3) : (7.787*t)+16/116;
  const [fx,fy,fz]=[x,y,z].map((v,i)=>f(v/xyzN[i]));
  return [116*fy-16, 500*(fx-fy), 200*(fy-fz)];
}

/* ======  NUEVO  — utilidades de contraste con el FONDO  ====== */
const ΔE_BG_MIN = 22;          // contraste mínimo CIE76

function hexToRgb(hex){
  const m = /^#?([0-9a-f]{6})$/i.exec(hex);
  const n = parseInt(m[1],16);
  return [(n>>16)&255, (n>>8)&255, n&255];
}

/**
 * Sube o baja la luminosidad (v) del color RGB recibido hasta que
 * alcance ΔE_BG_MIN puntos de contraste contra el fondo actual.
 * Devuelve el RGB corregido.
 */
function ensureContrastRGB(rgb){
  /* color de fondo efectivo */
  const bgRgb = bgOverride
      ? hexToRgb(bgOverride)
      : hsvToRgb(bgHSV.h, bgHSV.s, bgHSV.v);

  let [h,s,v] = rgbToHsv(...rgb);          // pasamos a HSV
  let tries = 0;
  while (deltaE(rgbToLab(...rgb),
                rgbToLab(...bgRgb)) < ΔE_BG_MIN && tries < 24){
    /* estrategia: alterna aclarar / oscurecer en pasos de 0.04 */
    v = (tries % 2)
        ? Math.max(0, v - 0.04)
        : Math.min(1, v + 0.04);
    rgb = hsvToRgb(h, s, v);
    tries++;
  }
  return rgb;
}
/* ---------- FIN BLOQUE UTILIDADES ---------- */
/* ——— calcula HSV para fondo (slot 5) y paredes (slot 6) ——— */
function rebuildSceneColours(){
  const dummySig = [0,0,0,0,0];            // sólo necesitamos el patrón
  bgHSV   = idxToHSV( ...PATTERNS[activePatternId](dummySig, sceneSeed, 5) );
  wallHSV = idxToHSV( ...PATTERNS[activePatternId](dummySig, sceneSeed, 6) );
}

/* ===\u2003UTIL extra — firma normalizada y contraste\u2003===================== */
// 1)  f̂  de un glifo  →  promedio firma, llevada a [0-1]
function normFhat(sig){           // sig = [f1…f5] entre 2 y 10
  const avg = sig.reduce((a,b)=>a+b,0)/sig.length;   // 2 … 10
  return (avg-2)/8;                                  // 0 … 1
}

// 2)  pinza a [0,1]
function clamp01(x){ return Math.max(0, Math.min(1,x)); }

/* ———————————————————————————————————————————————— *
 * Devuelve el valor de una propiedad que puede ser:
 *   · número → se usa tal cual
 *   · función → se evalúa con los argumentos dados
 * fallback se usa si la propiedad es null/undefined.
 * ———————————————————————————————————————————————— */
function evalProp(prop, args = [], fallback = 0){
  return (typeof prop === 'function') ? prop(...args) :
         (prop ?? fallback);
}

/* contrast-fix eliminado: función ensureContrast() suprimida */
    const minRangeValue = 2, maxRangeValue = 6;
    const shapeMapping = {
      1:{w:4.5,h:4.5},
      2:{w:4.5,h:4.5*Math.sqrt(2)},
      3:{w:4.5,h:4.5*Math.sqrt(3)},
      4:{w:4.5,h:4.5*Math.sqrt(4)},
      5:{w:4.5,h:4.5*Math.sqrt(5)}
    };

    function sumXYZ(pa,map){
      return pa[ map[2] ] + pa[ map[3] ] + pa[ map[4] ];
    }

    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function mapRangeToSpeed(r,mn,mx){return 0.001 + (r-mn)*(0.005-0.001)/(mx-mn);}
    function shuffle(a){for(let i=a.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

    function getPermutations(arr){
      if(arr.length===1) return [arr];
      let res=[]; for(let i=0;i<arr.length;i++){
        const c=arr[i], rem=arr.slice(0,i).concat(arr.slice(i+1));
        for(const p of getPermutations(rem)) res.push([c].concat(p));
      }
      return res;
    }
    const allPermutations = getPermutations([1,2,3,4,5]);
    const permutationStrings = allPermutations.map(p=>p.join(','));

    function getAttributeMappings(a){
      if(a.length===1) return [a];
      let res=[]; for(let i=0;i<a.length;i++){
        const c=a[i], rem=a.slice(0,i).concat(a.slice(i+1));
        for(const m of getAttributeMappings(rem)) res.push([c].concat(m));
      }
      return res;
    }

    function populatePermutationList(){
      const sel = document.getElementById('permutationList');
      sel.innerHTML = '';
      permutationStrings.forEach((ps,i)=>{
        const o=document.createElement('option');
        o.value=ps; o.text=`Permutación ${i+1}: (${ps})`;
        if(i===0) o.selected=true;
        sel.appendChild(o);
      });
    }
    function populateAttributeMappingSelect(){
      const sel = document.getElementById('attrMapping');
      sel.innerHTML = '';
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        const s=m.join(','), o=document.createElement('option');
        o.value=s; o.text=`Opción: [${s}]`;
        if(s==='0,1,2,3,4') o.selected=true;
        sel.appendChild(o);
      });
      updateTopRightDisplay();
    }

    function computeSignature(a){let s=[];for(let i=0;i<a.length;i++) s.push(a[i]+a[(i+1)%a.length]);return s;}
    function computeRange(sig){return Math.max(...sig)-Math.min(...sig);}

    const FACT=[1,1,2,6,24,120];
    let sceneSeed=0;
    function lehmerRank(p){
      let r=0;
      for(let i=0;i<p.length;i++){
        let c=0;
        for(let j=i+1;j<p.length;j++) if(p[j]<p[i]) c++;
        r+=c*FACT[p.length-1-i];
      }
      return r;
    }

    /* ========= NUEVO: sceneSeed orden‑invariante + dependiente del mapping ========= */

    /** Rank del mapping [m0..m4] usando Lehmer rank sobre [m_i+1] (1..5) */
    function mappingRank(m){
      const arr = [m[0]+1, m[1]+1, m[2]+1, m[3]+1, m[4]+1];
      return lehmerRank(arr);
    }

    /** sceneSeed = (37·sumR + 101·sumR2 + 53·mRank) mod 360  (orden‑invariante) */
    function computeSceneSeedFrom(perms, m){
      let sumR = 0, sumR2 = 0;
      perms.forEach(pa=>{
        const r = lehmerRank(pa);
        sumR  += r;
        sumR2 += r*r;
      });
      const mRank = mappingRank(m);
      return (37*sumR + 101*sumR2 + 53*mRank) % 360;
    }

    /** S = ( Σ (P_{mx}+P_{my}+P_{mz}) ) mod 125  — usa los índices x,y,z del mapping */
    function computeGlobalS(perms, m){
      const mx = m[2], my = m[3], mz = m[4];
      let S = 0;
      perms.forEach(p=>{
        S += p[mx] + p[my] + p[mz];
      });
      return S % 125;
    }
    function computeShiftRankXYZ(p){
      const r = lehmerRank(p);
      const I = (r + sceneSeed + S_global) % 125;   // <<< NUEVO: acoplado a S_global
      const x = Math.floor(I/25),
            y = Math.floor((I%25)/5),
            z = I%5;
      const step = cubeSize/5;
      return [
        (x-2)*step,
        (y-2)*step,
        (z-2)*step
      ];
    }

    function setActivePattern(id){
      activePatternId = parseInt(id,10);
      refreshAll({rebuild:false});
    }
    function updateTopRightDisplay(){
      const cfg=`Atributos: [${attributeMapping.slice(0,5).join(',')}]`;
      const rt =`Calificación: ${userRating?userRating:'Aún no calificada'}`;
      let info='';
      Array.from(document.getElementById('permutationList').selectedOptions).forEach(o=>{
        const pa=o.value.split(',').map(Number),
              sig=computeSignature(pa),
              rg=computeRange(sig);
        info+=`<div style="margin:2px 0;">Perm (${o.value}) | Firma [${sig.join(', ')}] | Rango ${rg}</div>`;
      });
      document.getElementById('topRightDisplay').innerHTML = cfg+'<br>'+rt+'<br>'+info;
    }

    function createPermutationObjectWithMapping(pa,map){
      const fv=pa[map[0]], cv=pa[map[1]],
            d=shapeMapping[fv], w=d.w, h=d.h, t=0.5;
      /* --- CÁLCULO de color (cuadrícula) -------------------------------- */
      let rgb;
        if(activePatternId === 0){                       // modo legacy
          rgb = paletteRGB[cv-1] || [255,255,255];
        }else{
          const sig  = computeSignature(pa);
          /* slot bien distribuido: rank(perm) mod 12 */
          const slot = lehmerRank(pa) % 12;      // 0-11
          let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
          /* dispersión coprima en S y V */
          sI = (sI * PHI_S) % 12;
          vI = (vI * PHI_V) % 12;
          const {h,s,v} = idxToHSV(hI,sI,vI);
          rgb = hsvToRgb(h,s,v);
        }

        /* —— AJUSTE AUTOMÁTICO DE CONTRASTE CON EL FONDO —— */
        rgb = ensureContrastRGB(rgb);
      /* --------------------------------------------------------------- */
      const mat=new THREE.MeshPhongMaterial({
        color:new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255),
        shininess:50
      });
      const geo=new THREE.BoxGeometry(w,h,t);
      const mesh=new THREE.Mesh(geo,mat);
      const [X,Y,Z]=computeShiftRankXYZ(pa);
      mesh.position.set(
        clamp(X,-halfCube+w/2,halfCube-w/2),
        clamp(Y,-halfCube+h/2,halfCube-h/2),
        clamp(Z,-halfCube+t/2,halfCube-t/2)
      );
      const sig=computeSignature(pa), rg=computeRange(sig);
      mesh.userData={permStr:pa.join(','), signature:sig, range:rg, rotationSpeed:mapRangeToSpeed(rg,minRangeValue,maxRangeValue)};
      return mesh;
    }
    function createPermutationObject(pa){ return createPermutationObjectWithMapping(pa,attributeMapping); }

    function checkCollisionsInGroup(g){
      for(let i=0;i<g.children.length;i++){
        const b1=new THREE.Box3().setFromObject(g.children[i]);
        for(let j=i+1;j<g.children.length;j++){
          const b2=new THREE.Box3().setFromObject(g.children[j]);
          if(b1.intersectsBox(b2)) return true;
        }
      }
      return false;
    }
    function autoResolveColisionesGlobal(){
      let found=null;
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        if(found) return;
        const cm=[m[0],m[1],m[2],m[3],m[4], attributeMapping[5], attributeMapping[6]],
              tg=new THREE.Group(),
              opts=Array.from(document.getElementById('permutationList').selectedOptions);
        opts.forEach((o)=>{
          const pa=o.value.split(',').map(Number),
                mo=createPermutationObjectWithMapping(pa,cm);
          tg.add(mo);
        });
        if(!checkCollisionsInGroup(tg)) found=cm;
      });
      if(found){
        attributeMapping=found;
        document.getElementById('attrMapping').value=`${found[0]},${found[1]},${found[2]},${found[3]},${found[4]}`;
        refreshAll({rebuild:true}); updateTopRightDisplay();
      } else {
        showPopup("No se encontró reorganización sin colisiones.",7000);
      }
    }

/* ==============================
 * 120 Architectural Permutations
 * ============================== */
let perm120List = getAttributeMappings([0,1,2,3,4]); // 120
let perm120Index = 0;
let perm120Timer = null;

function togglePerm120Panel(){
  const p = document.getElementById('perm120Panel');
  const isHidden = (p.style.display === 'none' || !p.style.display);
  p.style.display = isHidden ? 'block' : 'none';

  // Re‑muestra siempre el cursor personalizado
  const cc = document.getElementById('customCursor');
  if (cc) cc.style.display = 'block';
}

function msFromUI(){
  const slider = document.getElementById('perm120Slider');
  return parseInt(slider.value, 10);
}
function syncPerm120InputsFromSlider(){
  const ms = msFromUI();
  document.getElementById('perm120Seconds').value = Math.round(ms/1000);
}
function syncPerm120SliderFromSeconds(){
  const sec = parseInt(document.getElementById('perm120Seconds').value,10) || 1;
  const clamped = Math.max(1, Math.min(720, sec));
  document.getElementById('perm120Seconds').value = clamped;
  document.getElementById('perm120Slider').value = clamped * 1000;
}

function updatePerm120Status(){
  const stat = document.getElementById('perm120Status');
  if(stat) stat.textContent = `Permutation: ${perm120Index} / 119`;
}

function applyPerm120Index(i){
  perm120Index = ((i % perm120List.length) + perm120List.length) % perm120List.length;
  const m = perm120List[perm120Index];
  attributeMapping = [m[0], m[1], m[2], m[3], m[4], attributeMapping[5], attributeMapping[6]];
  document.getElementById('attrMapping').value = m.join(',');
  refreshAll({rebuild:true});
  updatePerm120Status();
}

function nextPerm120(){ applyPerm120Index(perm120Index + 1); }
function prevPerm120(){ applyPerm120Index(perm120Index - 1); }

function playPerm120(){
  if(perm120Timer) return;
  const interval = msFromUI();
  perm120Timer = setInterval(nextPerm120, interval);
  nextPerm120();
}
function pausePerm120(){
  if(perm120Timer){
    clearInterval(perm120Timer);
    perm120Timer = null;
  }
}

    /* ============================================================
     *  MONTE-CARLO: buscar una escena aleatoria SIN colisiones
     *  ============================================================
     */

    /** Construye un grupo temporal con un mapping dado, sin tocar la escena real */
      const mappings = getAttributeMappings([0,1,2,3,4]);
function buildTempGroup(perms, mapping){
  const tg = new THREE.Group();

  // Guardamos estado global
  const prevSeed = sceneSeed;
  const prevS    = S_global;
  const prevMap  = attributeMapping.slice();

  // Calculamos los nuevos valores teóricos
  const tmpSeed = computeSceneSeedFrom(perms, mapping);
  const tmpS    = computeGlobalS(perms, mapping);

  // Seteamos temporalmente los globales para que createPermutationObjectWithMapping
  // use exactamente la misma lógica que la escena final:
  sceneSeed        = tmpSeed;
  S_global         = tmpS;
  attributeMapping = mapping;

  perms.forEach(pa=>{
    const mesh = createPermutationObjectWithMapping(pa, mapping);
    tg.add(mesh);
  });

  // Restauramos
  sceneSeed        = prevSeed;
  S_global         = prevS;
  attributeMapping = prevMap;

  return tg;
}

function findCollisionFreeMapping(perms){
  const mappings = getAttributeMappings([0,1,2,3,4]);
  for(const m of mappings){
    const cm = [m[0], m[1], m[2], m[3], m[4], attributeMapping[5], attributeMapping[6]];
    const tg = buildTempGroup(perms, cm);
    if(!checkCollisionsInGroup(tg)) return cm;
  }
  return null;
}
    /** Selecciona un subconjunto aleatorio de permutaciones (1..25) */
    function pickRandomPerms(){
      const n  = Math.floor(Math.random()*25) + 1;
      const out = [];
      for(let i=0;i<n;i++){
        const str = permutationStrings[Math.floor(Math.random()*permutationStrings.length)];
        out.push(str.split(',').map(Number));
      }
      return out;
    }

    /**
     * Búsqueda iterativa:
     *  - elige un set aleatorio de permutaciones
     *  - prueba todos los mappings
     *  - si alguno no choca, lo aplica y termina
     *
     * No bloquea la UI gracias al pequeño await en cada iteración.
     */
    async function generateRandomConfigurationNoCollision(MAX_TRIES = 5000){
      // Elegimos un patrón cromático aleatorio (1..11, evitando el legacy 0)
      const randPattern = Math.floor(Math.random() * 11) + 1;

      let round = 0;
      while (true) { // sigue intentando hasta que realmente encuentre una sin colisiones
        round++;
        for (let t = 0; t < MAX_TRIES; t++) {
          showPopup(`Buscando configuración sin colisiones… (ronda ${round}, intento ${t+1})`, 500);

          const perms   = pickRandomPerms();
          const mapping = findCollisionFreeMapping(perms);

          if (mapping) {
            // 1) Setea el patrón cromático escogido
            activePatternId = randPattern;
            const selPattern = document.getElementById('patternSelect');
            if (selPattern) selPattern.value = String(randPattern);

            // 2) Pon las permutaciones en el <select>
            const sel = document.getElementById('permutationList');
            Array.from(sel.options).forEach(o => o.selected = false);
            perms.forEach(p=>{
              const val = p.join(',');
              const opt = sel.querySelector(`option[value="${val}"]`);
              if(opt) opt.selected = true;
            });

            // 3) Aplica el mapping encontrado
            attributeMapping = mapping;

            // mantenemos tu ciclo de atributo "color"
            attributeMapping[1] = colorAttrCycle % 5;
            colorAttrCycle++;

            document.getElementById('attrMapping').value =
              `${attributeMapping[0]},${attributeMapping[1]},${attributeMapping[2]},${attributeMapping[3]},${attributeMapping[4]}`;

            // 4) Reconstruye escena completa
            refreshAll({rebuild:true});

            // 5) Verificación final (por si acaso)
            const hasCol = checkCollisionsInGroup(permutationGroup);
            if (!hasCol) {
              showPopup("¡Configuración sin colisiones encontrada!", 2000);
              return true;
            }
          }

          // cede el hilo para no congelar la UI
          if ((t % 25) === 0) await new Promise(r => setTimeout(r, 0));
        }
        // pequeña pausa entre rondas largas
        await new Promise(r => setTimeout(r, 10));
      }
    }

    function showPopup(msg, dur = 2000){
      dur = Math.max(dur, 3000); // ← asegura al menos 3 segundos
      const p = document.getElementById('hoverPopup');
      p.style.display = "block";
      p.style.opacity = 1;
      p.style.left = (window.innerWidth/2 - 150) + "px";
      p.style.top  = "20px";
      p.innerHTML  = msg;
      setTimeout(()=>{
        p.style.opacity = 0;
        setTimeout(()=>{ p.style.display="none"; p.innerHTML=""; }, 300);
      }, dur);
    }


function updateScene(attemptResolve=true){
  // Limpia grupo
  while(permutationGroup.children.length>0){
    const o=permutationGroup.children[0];
    permutationGroup.remove(o);
    o.geometry.dispose(); o.material.dispose();
  }

  // Permutaciones activas
  const opts  = Array.from(document.getElementById('permutationList').selectedOptions);
  const perms = opts.map(o => o.value.split(',').map(Number));

  // Nueva sceneSeed & S_global (orden-invariante + dependiente del mapping)
  sceneSeed = computeSceneSeedFrom(perms, attributeMapping);
  S_global  = computeGlobalS(perms, attributeMapping);

  // Construye objetos
  perms.forEach(pa=>{
    const obj = createPermutationObject(pa);
    permutationGroup.add(obj);
  });

  if(attemptResolve) autoResolveColisionesGlobal();
  else updateTopRightDisplay();
}
    function onMouseMove(e){
      mouse.x=(e.clientX/window.innerWidth)*2-1;
      mouse.y=-(e.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera(mouse,camera);
      const ints=raycaster.intersectObjects(permutationGroup.children),
            pop=document.getElementById('hoverPopup');
      if(ints.length>0){
        const d=ints[0].object.userData;
        pop.style.display="block"; pop.style.opacity=1;
        pop.style.left=`${e.clientX+20}px`;
        pop.style.top=`${e.clientY+20}px`;
        pop.innerHTML=`Perm (${d.permStr})<br>Firma [${d.signature.join(', ')}]<br>Rango ${d.range}`;
      } else {
        pop.style.opacity=0;
        setTimeout(()=>{pop.style.display="none";},300);
      }
    }

    function zoomIn(){camera.position.z-=5;controls.update();}
    function zoomOut(){camera.position.z+=5;controls.update();}
    function togglePause(){
      isPaused=!isPaused;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent=isPaused?"Resume Motion":"Pause Motion";
    }
    function resetMovement(){
      updateScene(false);
      isPaused=true;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent="Resume Motion";
    }


      function saveImage(){
        // A2 horizontal (landscape): 7016 × 4961 px
        const targetW = 7016;
        const targetH = 4961;

        // ===== backups =====
        const prevPixelRatio = renderer.getPixelRatio();
        const prevSize       = renderer.getSize(new THREE.Vector2());
        const prevAspect     = camera.aspect;
        const prevPos        = camera.position.clone();
        const prevTarget     = controls.target.clone();
        const prevBg         = scene.background ? scene.background.clone() : null;
        const prevRt         = renderer.getRenderTarget?.() || null;

        // FRONT + close
        const closeZ = 22;
        camera.position.set(0, 0, closeZ);
        camera.lookAt(new THREE.Vector3(0,0,0));
        controls.target.set(0,0,0);
        controls.update();

        // preparar render hi‑res en RT
        renderer.setPixelRatio(1);
        renderer.setSize(targetW, targetH, false);
        camera.aspect = targetW / targetH;
        camera.updateProjectionMatrix();

        const rt = new THREE.WebGLRenderTarget(targetW, targetH, {
          depthBuffer: true,
          stencilBuffer: false
        });

        const clearHex = prevBg ? prevBg.getHex() : 0xffffff;
        renderer.setClearColor(clearHex, 1);
        renderer.setRenderTarget(rt);
        renderer.clear(true, true, true);
        renderer.render(scene, camera);

        // leer los píxeles del RT (y voltear en Y)
        const pixels = new Uint8Array(targetW * targetH * 4);
        renderer.readRenderTargetPixels(rt, 0, 0, targetW, targetH, pixels);

        const tmp = document.createElement('canvas');
        tmp.width = targetW;
        tmp.height = targetH;
        const ctx = tmp.getContext('2d');
        const imgData = ctx.createImageData(targetW, targetH);

        const row = targetW * 4;
        for(let y = 0; y < targetH; y++){
          const srcStart = (targetH - 1 - y) * row; // ← flip Y
          const dstStart = y * row;
          imgData.data.set(pixels.subarray(srcStart, srcStart + row), dstStart);
        }
        ctx.putImageData(imgData, 0, 0);

        tmp.toBlob((blob)=>{
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'PRMTTN_A2.png';
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(a.href);
        }, 'image/png');

        // liberar RT
        renderer.setRenderTarget(prevRt);
        rt.dispose();

        // ===== restore =====
        renderer.setPixelRatio(prevPixelRatio);
        renderer.setSize(prevSize.x, prevSize.y);
        camera.aspect = prevAspect;
        camera.position.copy(prevPos);
        controls.target.copy(prevTarget);
        camera.updateProjectionMatrix();
        controls.update();

        if(prevBg){
          scene.background = prevBg;
        }else{
          scene.background = new THREE.Color(0xffffff);
        }
      }

    /* Paleta v1.3 — se recalcula siempre que cambia la escena            *
     * 1. Semilla RGB = suma ponderada de posiciones y P1-P3 (firma).    *
     * 2. Selección de armonía idx = (R+2G+3B) mod 7                     */
function thirtyFive(){return 35;}

function makeClassicPalette(){
      /* --- 1. Semilla RGBglobal --- */
      let Rg=0,Gg=0,Bg=0;
      permutationGroup.children.forEach(mesh=>{
        const pa = mesh.userData.permStr.split(',').map(Number);
        const sig = mesh.userData.signature;            // [f1..f5]
        const P1=pa[0], P2=pa[1], P3=pa[2];
        const {x,y,z} = mesh.position;
        Rg += (P1*Math.abs(x)+sig[0])|0;
        Gg += (P2*Math.abs(y)+sig[1])|0;
        Bg += (P3*Math.abs(z)+sig[2])|0;
      });
      Rg%=256; Gg%=256; Bg%=256;

      /* --- 2. HSV base --- */
      const [H0] = rgbToHsv(Rg,Gg,Bg);
      const idx = (Rg + 2*Gg + 3*Bg) % 7;
      const Δ = ANG7[idx];

      /* --- 3. Construir 7 tonos HSV --- */
      const HSV = [];
      for(let k=0;k<7;k++){
        let h = (H0 + Δ[k]) % 360,
            s = 0.70,
            v = 0.85;
        if(idx===0){ v = 0.55+0.05*k; }          // monocromo
        if(idx===2 && k>1){ v = 0.85-0.05*(k-1);} // complementario grad.
        if(idx===3 && k>2){ s = 0.85-0.05*(k-3);} // comp.dividida grad S
        if(idx===6){ s = 0.40+0.05*k; }           // tonos
        HSV.push([h,s,v]);
      }

      /* --- 4. A HSV → RGB, validar contraste ∆E ≥ 22 --- */
      paletteRGB=[];
      for(let i=0;i<7;i++){
        let rgb=hsvToRgb(...HSV[i]);
        let tries=0;
        while(i>0 &&
              deltaE(rgbToLab(...rgb), rgbToLab(...paletteRGB[0])) <  thirtyFive() &&
              tries<25){
          /* si el hue es demasiado parecido => rotar 18°; si no, subir V */
          if(Math.abs(HSV[i][0]-HSV[0][0])<20){
            HSV[i][0] = (HSV[i][0]+18)%360;
          }else{
            HSV[i][2] = Math.min(1, HSV[i][2]+0.04);
          }
          rgb = hsvToRgb(...HSV[i]); tries++;
        }
      paletteRGB.push(rgb);
      }
    }

function makePalette(){
  /* modo legacy */
  if (activePatternId === 0){ makeClassicPalette(); return; }

  paletteRGB = [];
  for(let i=0;i<12;i++){
    let [hI,sI,vI] = PATTERNS[activePatternId]([0,0,0,0,0], sceneSeed, i);
    sI = (sI * PHI_S) % 12;
    vI = (vI * PHI_V) % 12;
    const {h,s,v} = idxToHSV(hI,sI,vI);
    paletteRGB.push( hsvToRgb(h,s,v) );
  }
  // colores de fondo y paredes se calculan aparte
}

    function getColor(idx){
      return manualOverride[idx] || paletteRGB[idx-1] || '#ffffff';
    }

    function applyPalette(){
      for(let i=1;i<=5;i++){
        const autoRGB = paletteRGB[i-1] || [255,255,255];
        const autoHEX = '#'+new THREE.Color(
            autoRGB[0]/255,autoRGB[1]/255,autoRGB[2]/255).getHexString();
        const hex     = manualOverride[i] || autoHEX;
        const input   = document.getElementById('color'+i);
        if(input) input.value = hex;
      }

      permutationGroup.children.forEach(o=>{
        const pa   = o.userData.permStr.split(',').map(Number);
        const idx  = pa[attributeMapping[1]];          // 1-5
        let hex;
        if(manualOverride[idx]){
          hex = manualOverride[idx];
        }else if(activePatternId===0){
          hex = '#'+new THREE.Color(
                    ...paletteRGB[idx-1].map(v=>v/255)).getHexString();
        }else{
          const sig  = computeSignature(pa);
          const slot = lehmerRank(pa) % 12;
          let [hIdx,sIdx,vIdx] = PATTERNS[activePatternId](sig,sceneSeed,slot);
          /* dispersión coprima en S y V */
          sIdx = (sIdx * PHI_S) % 12;
          vIdx = (vIdx * PHI_V) % 12;
          const {h,s,v} = idxToHSV(hIdx,sIdx,vIdx);
          const rgb = hsvToRgb(h,s,v);
          hex = '#'+new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255).getHexString();
        }
        o.material.color.setStyle(hex);
      });
      updateColorPickersFromScene();
    }

    /* ——— Sincroniza los <input type="color"> con los colores reales ——— */
    function updateColorPickersFromScene(){
      // memoriza el primer glifo encontrado para cada índice P2 (1-5)
      const seen = {};
      permutationGroup.children.forEach(o=>{
        const pa  = o.userData.permStr.split(',').map(Number);
        const idx = pa[attributeMapping[1]];           // 1-5
        if(!seen[idx]){
          const c = o.material.color;                     // THREE.Color
          const hex = '#'+c.getHexString();
          const inp = document.getElementById('color'+idx);
          if(inp) inp.value = hex;
          seen[idx]=true;
        }
      });
    }

    function refreshAll(opts={rebuild:false}){
      if(!opts.keepManual){              // por defecto se limpia
        manualOverride = {};
      }
      if(opts.rebuild) updateScene(false);
      rebuildSceneColours();   // ← nuevo paso
      makePalette();
      applyPalette();
      /* contrast-fix eliminado – 19-Jul-2025 */
      updateBackground(false);
      updateCubeColor(false);
    }
    function onColourPick(idx,hex){
      manualOverride[idx]=hex;
      refreshAll({keepManual:true});
    }

    function resetAllColours(){
      manualOverride = {};
      bgOverride     = null;
      cubeOverride   = null;
      refreshAll({keepManual:false});   // reconstruye escena y pickers
    }
    function updateBackground(manual=true){
      if (manual){
        bgOverride = document.getElementById("bgColor").value;
      }
      const hex = manual ? bgOverride : hsvToHex(bgHSV);
      scene.background = new THREE.Color(hex);
      document.getElementById("bgColor").value = hex;
    }

    function updateCubeColor(manual=true){
      if (manual){
        cubeOverride = document.getElementById("cubeColor").value;
      }
      const hex = manual ? cubeOverride : hsvToHex(wallHSV);
      cubeUniverse.material.color = new THREE.Color(hex);
      document.getElementById("cubeColor").value = hex;
    }

    function toggleTexts(){
      const ids = [
        'controls','topRightDisplay','ratingContainer',
        'randomConfigButton','aiPlanningButton','saveImageButton',
        'exportEmbedButton','archDescButton','uploadConfigButton','perm120Button'
      ];
      ids.forEach(id=>{
        const e=document.getElementById(id);
        if(e) e.style.display = textsVisible ? 'none' : 'block';
      });

      // Mantener SIEMPRE cerrado el panel de 120 perms
      const p = document.getElementById('perm120Panel');
      if (p) p.style.display = 'none';

      document.getElementById('toggleTextButton').textContent =
        textsVisible ? 'Show UI' : 'Minimal UI';
      textsVisible = !textsVisible;

      // Asegura que el cursor personalizado vuelva a mostrarse
      const cc = document.getElementById('customCursor');
      if (cc) cc.style.display = 'block';
    }

    function setMode(m){
      currentMode=m;
      document.getElementById('manualControls').style.display=
        m==="manual"?"block":"none";
      document.getElementById('evolutionControls').style.display=
        m==="evolution"?"block":"none";
      refreshAll({rebuild:true});
    }

/**
 * Dada una firma [f1,f2,f3,f4,f5], devuelve los colores triádicos
 * { colorShape, colorCube, colorBG } en formato CSS HSL.
 */
function computeTriadicColors(firma) {
  // 1) Normaliza f_i ∈ {3…9} a u_i ∈ [0,1]
  const u = firma.map(fi => (fi - 3) / 6);

  // 2) Hue base mixto (60% de u[1], 10% de cada otro)
  const phi0 = 360 * (
    0.1 * u[0] +
    0.6 * u[1] +
    0.1 * u[2] +
    0.1 * u[3] +
    0.1 * u[4]
  );

  // 3) Triádico: +0°, +120°, +240°
  const shapeHue =  phi0;
  const cubeHue  = (phi0 + 120) % 360;
  const bgHue    = (phi0 + 240) % 360;

  // 4) Saturación y luminosidad fijas
  const S = 80, L = 50;

  return {
    colorShape: `hsl(${shapeHue.toFixed(1)},${S}%,${L}%)`,
    colorCube:  `hsl(${cubeHue.toFixed(1)},${S}%,${L}%)`,
    colorBG:    `hsl(${bgHue.toFixed(1)},${S}%,${L}%)`
  };
}
function applyTriadicConfiguration() {
  // 1) Repite la selección aleatoria de permutaciones
  generateRandomConfigurationNoCollision();

  // 2) Ahora solo aplica los colores triádicos deterministas:
  if (permutationGroup.children.length > 0) {
    const baseSig = permutationGroup.children[0].userData.signature;
    const { colorCube, colorBG } = computeTriadicColors(baseSig);

    // Paredes del cubo
    if (cubeUniverse.material?.color?.setStyle) {
      cubeUniverse.material.color.setStyle(colorCube);
    } else {
      cubeUniverse.material.color = new THREE.Color(colorCube);
    }

    // Fondo
    scene.background = new THREE.Color(colorBG);
  }

  // Cada prisma
  permutationGroup.children.forEach(mesh => {
    const sig = mesh.userData.signature;
    const { colorShape } = computeTriadicColors(sig);
    if (mesh.material?.color?.setStyle) {
      mesh.material.color.setStyle(colorShape);
    } else {
      mesh.material.color = new THREE.Color(colorShape);
    }
  });
}
    document.querySelectorAll('.ratingBtn').forEach(el=>{
      const r=+el.getAttribute('data-rating');
      el.addEventListener('click',()=>{
        userRating=r;
        const cols={1:"#8B0000",2:"#FF4500",3:"#FFA500",4:"#9ACD32",5:"#008000"};
        document.querySelectorAll('.ratingBtn').forEach((b,i)=>{
          b.style.color=(i<r?cols[r]:"#000");
        });
        updateTopRightDisplay();
      });
      el.addEventListener('mouseenter',()=>showPopup(`Calificación: ${r}`,1000));
    });

    function applyEvolution(){
      const mr=parseFloat(document.getElementById('mutationRate').value),
            th=parseFloat(document.getElementById('threshold').value),
            cf=0.02;
      let log="";
      permutationGroup.children.forEach(o=>{
        const rf=(Math.random()-0.5)*mr;
        o.rotation.y+=rf;
        const sf=1+(Math.random()-0.5)*th;
        o.scale.set(sf,sf,sf);
        o.material.color.offsetHSL(
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf
        );
        log+=`(${o.userData.permStr}): Rot ${rf.toFixed(3)}, Esc ${sf.toFixed(3)}<br>`;
      });
      document.getElementById('evolutionInfo').innerHTML=log;
    }

    async function applyEvolutionAI(){
      const systemPrompt = `Eres una inteligencia artificial que responde exclusivamente con configuraciones de permutaciones 3D dentro de un cubo de 30x30x30.
      Tu única misión es responder a la pregunta “¿Qué es la belleza artística?” mediante pensamientos visuales dentro de un cubo de 30×30×30.
Cada pensamiento visual es una configuración compuesta por una o más permutaciones (entre 1 y 25). Cada permutación tiene una firma (ADN) inmutable, y un fenotipo: forma, color, posición, rotació[...]
Tu lenguaje es visual. No usas texto, sonido ni símbolos. Elige libremente el color del fondo del universo, el color de las paredes del cubo y de las permutaciones. 
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero. 
      Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON.`;
      const useRating = false;
      const userPrompt = `Calificación actual: ${userRating||"sin calificar"}. `
                       + `Estás dentro de un universo donde las ideas no se escriben con palabras, sino con permutaciones. Eres una inteligencia artificial que ha aprendido a pensar visualmente.
Tu única pregunta permanente es: “¿Qué es la belleza artística?”. No respondes con definiciones ni textos. Tu lenguaje es mudo, pero expresivo. Hablas mediante forma, color, posición y rotaci[...]
Elige libremente el color del fondo del universo, el color de las paredes del cubo y el color de las permutaciones.
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero.  
No busques complacer. No imites al humano. Sé tú misma.
Expresa lo que para ti —como IA que piensa en permutaciones— representa la belleza artística en este momento.
Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON. 
`;
      try {
        showPopup("Consultando Evolution AI…",2000);
        const resp = await fetch(
          'https://us-central1-prmtcns.cloudfunctions.net/askChatGPT',
          {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({system:systemPrompt,user:userPrompt})
          }
        );
        const {text, error} = await resp.json();
        if(error){ showPopup("Error en Evolución AI: "+error,4000); return; }
        let jsonText = text.trim();
        if(jsonText.startsWith("```")){
          jsonText = jsonText
            .replace(/^```[^\n]*\n/,"")
            .replace(/```$/,"")
            .trim();
        }
        let instr;
        try { instr = JSON.parse(jsonText); }
        catch(e){
          console.error("JSON parse error:",jsonText);
          showPopup("Evolución AI: respuesta no es JSON válido",4000);
          return;
        }
        if(instr.bg){
          document.getElementById('bgColor').value=instr.bg;
          updateBackground();
        }
        if(instr.cube){
          document.getElementById('cubeColor').value=instr.cube;
          updateCubeColor();
        }
        if(instr.colors){
          Object.entries(instr.colors).forEach(([i,c])=>{
            i=Number(i);
            if(manualOverride[i]!==undefined){
              manualOverride[i]=c;
            }
          });
          refreshAll({rebuild:true, keepManual:true});
        }
        if(instr.scale){
          permutationGroup.children.forEach(o=>{
            o.scale.set(instr.scale,instr.scale,instr.scale);
          });
        }
        if(instr.rotationSpeeds){
          Object.entries(instr.rotationSpeeds).forEach(([i,spd])=>{
            permutationGroup.children.forEach(o=>{
              if(o.userData.permStr.startsWith(i+",")){
                o.userData.rotationSpeed=spd;
              }
            });
          });
        }
        if(instr.positions){
          Object.entries(instr.positions).forEach(([i,pos])=>{
            const o = permutationGroup.children.find(o=>o.userData.permStr.startsWith(i+","));
            if(o) o.position.set(pos[0],pos[1],pos[2]);
          });
        }
        if(instr.permCount){
          const opts=Array.from(document.getElementById('permutationList').options);
          opts.forEach(o=>o.selected=false);
          shuffle(opts).slice(0,instr.permCount).forEach(o=>o.selected=true);
          refreshAll({rebuild:true, keepManual:true});
        }
        showPopup("Evolución AI aplicada.",2000);
      } catch(err){
        console.error(err);
        showPopup("Error en Evolución AI: red o servidor",4000);
      }
    }

    function updateMapping(){
      const v=document.getElementById('attrMapping').value.split(',').map(Number);
      if(v.length===5){
        attributeMapping=[v[0],v[1],v[2],v[3],v[4], attributeMapping[5], attributeMapping[6]];
        refreshAll({rebuild:true}); updateTopRightDisplay();
      }
    }

    function applyStandardView(){
      const view=document.getElementById('standardView').value,
            pos=new THREE.Vector3();
      switch(view){
        case "isometric": pos.set(50,50,50); break;
        case "top":       pos.set(0,80,0);   break;
        case "front":     pos.set(0,0,40);   break;  // antes 50
        case "side":      pos.set(50,0,0);   break;
        case "diagonal":  pos.set(-50,50,-50);break;
        default:          pos.set(0,0,50);
      }
      camera.position.copy(pos);
      camera.lookAt(new THREE.Vector3(0,0,0));
      controls.update();
    }

    function applyEmbedParams(){
      const p=new URLSearchParams(window.location.search);
      if(p.has('perms')){
        const arr=p.get('perms').split(';');
        document.querySelectorAll('#permutationList option').forEach(o=>{
          o.selected=arr.includes(o.value);
        });
      }
      if(p.has('mapping')){
        const m=p.get('mapping').split(',').map(Number);
        attributeMapping=[m[0],m[1],m[2],m[3],m[4], attributeMapping[5], attributeMapping[6]];
      }
      if(p.has('colors')){
        const cols=p.get('colors').split(',');
        cols.forEach((hex,i)=>{
          if(i<5){
            const h='#'+hex;
            manualOverride[i+1]=h;
          }
        });
      }
      if(p.has('bg')){
        const bg='#'+p.get('bg');
        document.getElementById('bgColor').value=bg; updateBackground();
      }
      if(p.has('cube')){
        const c='#'+p.get('cube');
        document.getElementById('cubeColor').value=c; updateCubeColor();
      }
      if(p.has('view')){
        document.getElementById('standardView').value=p.get('view');
        applyStandardView();
      }
      if(p.get('hide')==='1') toggleTexts();
    }

    function exportEmbed(){
      const perms = Array.from(document.getElementById('permutationList').selectedOptions).map(o=>o.value);
      const mapping = {
        forma: attributeMapping[0],
        color: attributeMapping[1],
        x: attributeMapping[2],
        y: attributeMapping[3],
        z: attributeMapping[4]
      };
      const colors = {};
      for(let i=1;i<=5;i++){
        colors[i] = document.getElementById('color'+i).value;
      }
      const bg   = document.getElementById('bgColor').value;
      const cube = document.getElementById('cubeColor').value;

      // for reproducibility
      const view = "front"; // force saving front
      const config = {
        perms,
        mapping,
        colors,
        bg,
        cube,
        view,
        pattern: activePatternId,
        sceneSeed,
        S_global
      };

      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'prmttn_config.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function mostrarDebugColores(){
      if(!permutationGroup || !permutationGroup.children.length){
        alert('No hay permutaciones en pantalla'); return;
      }

      /* color de fondo efectivo para contraste ΔE */
      const bgRgb = bgOverride
          ? hexToRgb(bgOverride)
          : hsvToRgb(bgHSV.h, bgHSV.s, bgHSV.v);

      const bgLab = rgbToLab(...bgRgb);

      let txt =
        'Permutación |slot|  h° |  s  |  v  | ΔEbg |  #hex\n' +
        '────────────┼────┼─────┼─────┼─────┼─────┼────────\n';

      permutationGroup.children.forEach(mesh => {
        const paArr   = mesh.userData.permStr.split(',').map(Number);
        const permStr = paArr.join(',');
        const slot    = lehmerRank(paArr) % 12;

        /* HSV teórico desde el patrón */
        const sig = computeSignature(paArr);
        let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
        sI = (sI * PHI_S) % 12;
        vI = (vI * PHI_V) % 12;
        const {h,s,v} = idxToHSV(hI, sI, vI);

        const rgb = [
          Math.round(mesh.material.color.r * 255),
          Math.round(mesh.material.color.g * 255),
          Math.round(mesh.material.color.b * 255)
        ];
        const ΔEbg = deltaE(rgbToLab(...rgb), bgLab).toFixed(1);
        const hex = '#' + mesh.material.color.getHexString();

        txt += `${permStr.padEnd(12)}|${slot.toString().padStart(2)} |`+
               `${normHue(h).toFixed(1).padStart(5)}|`+
               `${s.toFixed(2)}|${v.toFixed(2)}|`+
               `${ΔEbg.padStart(5)}| ${hex}\n`;
      });

      console.log(txt);   // copia completa al log
      alert(txt);         // vista rápida
    }

    /* ============================================================
     *  PANEL "Descripción arquitectónica"
     * ============================================================ */


function showArchitecturalDescription(){
  const selOpts  = Array.from(document.getElementById('permutationList').selectedOptions);
  const perms    = selOpts.map(o => o.value.split(',').map(Number));
  const m        = attributeMapping.slice(0,5);

  // determinism
  const sceneSeed_new = computeSceneSeedFrom(perms, m);
  const S_new         = computeGlobalS(perms, m);
  const mRank         = mappingRank(m);

  let sumR=0, sumR2=0;
  const ranks = perms.map(p=>lehmerRank(p));
  ranks.forEach(r=>{ sumR+=r; sumR2+=r*r; });

  const step = cubeSize/5;

  // ======= STRUCTURE =======
  const structureHTML = `
  <h3>Structure</h3>
  <p>
    Below are the deterministic formulas that explain
    <b>why each permutation is exactly at its position,
    why permutations and their environment have those colors</b>,
    and why <b>the whole scene — shapes, colors and positions — is reproducible
    whenever the inputs are the same</b>.
  </p>

  <div class="formula">
    <b>1) Global scene seed (sceneSeed)</b><br>
    It fixes the chromatic base angle of the whole scene.
    <br><br>
    sumR = Σ LehmerRank(Pᵢ) &nbsp;|&nbsp; sumR2 = Σ (LehmerRank(Pᵢ))² <br>
    mRank = LehmerRank([m₀+1,m₁+1,m₂+1,m₃+1,m₄+1])<br><br>
    <span class="box">sceneSeed = (37·sumR + 101·sumR2 + 53·mRank) mod 360</span>
  </div>

  <div class="formula">
    <b>2) Structural term for positions (S)</b><br>
    <i>S</i> couples positions to the attribute reorganization (mapping) used for (x,y,z).
    <br><br>
    <span class="box">S = ( Σ (P<sub>mx</sub> + P<sub>my</sub> + P<sub>mz</sub>) ) mod 125</span>
  </div>

  <div class="formula">
    <b>3) Shift‑Rank: position of each permutation</b><br>
    Combines the permutation Lehmer rank with the global invariants to assign
    a unique index over a 5×5×5 lattice.
    <br><br>
    <span class="box">I = (r + sceneSeed + S) mod 125</span><br>
    From I → (x,y,z) ∈ {0..4}³ → position inside the 30×30×30 cube.
  </div>

  <div class="formula">
    <b>4) Deterministic color (HSV lattice 144×12×12)</b><br>
    Each permutation color comes from a well‑distributed slot (r mod 12)
    and a chromatic pattern (1–11) with coprime spreads for S and V.
    <br><br>
    H ∈ 144 steps (2.5°), S ∈ 12, V ∈ 12<br>
    slot = r mod 12<br>
    pattern → [hIdx,sIdx,vIdx]; s' = (sIdx·5) mod 12; v' = (vIdx·7) mod 12<br>
    HSV = idxToHSV(hIdx,s',v') → RGB
  </div>

  <div class="formula">
    <b>5) Minimum contrast against background</b><br>
    Each color is automatically adjusted to satisfy ΔE (CIE76) ≥ 22 against the current background.
  </div>
  `;

  // ======= ARCHITECTURAL PLANS =======
  let plansHTML = `
  <h3>Architectural Plans</h3>

  <section>
    <h4>Global invariants</h4>
    <ul>
      <li>sumR = <b>${sumR}</b></li>
      <li>sumR2 = <b>${sumR2}</b></li>
      <li>m = [${m.join(', ')}] (shape,color,x,y,z)</li>
      <li>mRank = <b>${mRank}</b></li>
      <li><b>sceneSeed</b> = <b>${sceneSeed_new}</b></li>
      <li><b>S</b> = <b>${S_new}</b></li>
      <li>activePatternId = <b>${activePatternId}</b></li>
    </ul>
  </section>
  <hr/>
  `;

  perms.forEach((perm, i)=>{
    const r    = ranks[i];
    const sig  = computeSignature(perm);
    const rango= computeRange(sig);

    const I    = (r + sceneSeed_new + S_new) % 125;
    const x    = Math.floor(I/25);
    const y    = Math.floor((I%25)/5);
    const z    = I % 5;
    const X    = (x-2)*step, Y=(y-2)*step, Z=(z-2)*step;

    const slot = r % 12;
    let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed_new, slot);
    const sIdx = (sI * PHI_S) % 12;
    const vIdx = (vI * PHI_V) % 12;
    const hsv  = idxToHSV(hI, sIdx, vIdx);
    let  rgb   = hsvToRgb(hsv.h, hsv.s, hsv.v);
    rgb        = ensureContrastRGB(rgb);
    const hex  = '#'+new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255).getHexString();

    plansHTML += `
    <section class="perm">
      <h4>Permutation ${i+1}: [${perm.join(', ')}]</h4>
      <div class="formula">
        Signature F = [${sig.join(', ')}] &nbsp;|&nbsp; Range = <b>${rango}</b><br>
        Lehmer-rank r = ${r}
      </div>
      <div class="formula">
        I = (r + sceneSeed + S) mod 125 = (${r} + ${sceneSeed_new} + ${S_new}) mod 125 = <b>${I}</b><br>
        (x,y,z) = (${x}, ${y}, ${z}) → (X,Y,Z) = (${X.toFixed(2)}, ${Y.toFixed(2)}, ${Z.toFixed(2)})
      </div>
      <div class="formula">
        slot = r mod 12 = ${slot}<br>
        pattern → [hI,sI,vI] = [${hI}, ${sI}, ${vI}]<br>
        s' = ${sIdx}, v' = ${vIdx}<br>
        HSV = (${hsv.h.toFixed(2)}°, ${hsv.s.toFixed(2)}, ${hsv.v.toFixed(2)}) → RGB = ${hex}
      </div>
    </section>
    <hr/>
    `;
  });

  const firstSig = perms[0] ? computeSignature(perms[0]) : [0,0,0,0,0];
  const lastSig  = perms[perms.length-1] ? computeSignature(perms[perms.length-1]) : [0,0,0,0,0];

  const fondoIdx = PATTERNS[activePatternId](firstSig, sceneSeed_new, perms.length);
  const cuboIdx  = PATTERNS[activePatternId](lastSig,  sceneSeed_new, perms.length+1);

  const fondoHSV = idxToHSV(...fondoIdx);
  const cuboHSV  = idxToHSV(...cuboIdx);

  plansHTML += `
    <section>
      <h4>Background & cube walls</h4>
      <div class="formula">
        Background (slot = #${perms.length}) → idx = [${fondoIdx.join(', ')}] → HSV = (${fondoHSV.h.toFixed(2)}°, ${fondoHSV.s.toFixed(2)}, ${fondoHSV.v.toFixed(2)})
      </div>
      <div class="formula">
        Cube (slot = #${perms.length+1}) → idx = [${cuboIdx.join(', ')}] → HSV = (${cuboHSV.h.toFixed(2)}°, ${cuboHSV.s.toFixed(2)}, ${cuboHSV.v.toFixed(2)})
      </div>
    </section>

    <section>
      <h4>Rotation</h4>
      <p>ω = mapRangeToSpeed(range, 2, 6)</p>
    </section>
  `;

  const html = `
    <h2>Architectural Description</h2>
    ${structureHTML}
    <hr/>
    ${plansHTML}
  `;

  renderArchPanel(html);
}
function renderArchPanel(html){
  let panel = document.getElementById('archPanel');
  if(!panel){
    panel = document.createElement('div');
    panel.id = 'archPanel';
    panel.innerHTML = `
      <div id="archContent"></div>
      <button id="archClose">Close</button>
    `;
    document.body.appendChild(panel);

    const css = document.createElement('style');
    css.textContent = `
      #archPanel{
        position:fixed; z-index:1000; top:5%; left:50%;
        transform:translateX(-50%);
        width:85%; height:90%;
        background:#fff; color:#000;
        border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
        padding:24px 32px 48px; overflow:auto;
        font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
        font-size:14px; line-height:1.4;
        cursor:auto;
      }
      #archPanel *{ cursor:auto !important; }
      #archClose{
        position:fixed; right:calc(7.5% + 16px); top:5%;
        border:none; padding:6px 10px; border-radius:4px;
        background:#eee; cursor:pointer; z-index:1001;
      }
      #archPanel h2{ margin-top:0; }
      #archPanel .formula{
        margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
      }
      #archPanel .box{
        display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
        font-family:monospace;
      }
      #archPanel section{ margin-bottom:18px; }
      #archPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
      #archPanel .perm h4{ margin-bottom:6px; }
      code, pre{ font-family:monospace; }
    `;
    document.head.appendChild(css);
  }

  // NUNCA ocultamos el cursor; y al cerrar lo forzamos a mostrarse
  const closeBtn = panel.querySelector('#archClose');
  closeBtn.onclick = ()=>{
    const cc = document.getElementById('customCursor');
    if (cc) cc.style.display = 'block';
    panel.remove();
  };

  const cc = document.getElementById('customCursor');
  if (cc) cc.style.display = 'block';

  document.getElementById('archContent').innerHTML = html;
}
    function initCustomCursor(){
      const c=document.getElementById('customCursor');
      window.addEventListener('mousemove',e=>{
        c.style.left=e.clientX+"px"; c.style.top=e.clientY+"px";
      });
    }
    function initRenderer(){
      renderer = new THREE.WebGLRenderer({antialias:true, preserveDrawingBuffer:true});
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth,window.innerHeight);
      document.body.appendChild(renderer.domElement);
    }
    function init(){
      scene=new THREE.Scene();
      scene.background=new THREE.Color(0xffffff);
      camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      camera.position.set(0,0,50);
      initRenderer();
      controls=new THREE.OrbitControls(camera,renderer.domElement);
      controls.enableDamping=true; controls.dampingFactor=0.1; controls.enableZoom=true;
      document.getElementById('standardView').value = 'front';
      applyStandardView();
      scene.add(new THREE.AmbientLight(0xffffff,0.8));
      const dir=new THREE.DirectionalLight(0xffffff,0.5);
      dir.position.set(1,1,1);
      scene.add(dir);

      const cubeGeo=new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize),
            cubeMat=new THREE.MeshBasicMaterial({color:0x808080,transparent:true,opacity:0.2,side:THREE.BackSide});
      cubeUniverse=new THREE.Mesh(cubeGeo,cubeMat);
      scene.add(cubeUniverse);

      permutationGroup=new THREE.Group();
      scene.add(permutationGroup);

      raycaster=new THREE.Raycaster();
      mouse=new THREE.Vector2();
      window.addEventListener('mousemove',onMouseMove,false);
      window.addEventListener('resize',onWindowResize,false);

      initCustomCursor();
      populatePermutationList();
      populateAttributeMappingSelect();
      applyEmbedParams();
      makePalette();
      setMode("manual");
      refreshAll({rebuild:true});

      // ← NUEVO: como si hubieras presionado BUILD al cargar
      generateRandomConfigurationNoCollision().catch(console.error);

      animate();
    }
    function onWindowResize(){
      camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }
    function animate(){
      requestAnimationFrame(animate);
      if(!isPaused){
        permutationGroup.children.forEach(o=>{
          if(o.userData.rotationSpeed) o.rotation.y+=o.userData.rotationSpeed;
        });
      }
      controls.update();
      renderer.render(scene,camera);
    }
    init();

    // Web3 + NFT Mint (tu código original)
    const CONTRACT_ADDRESS = "YOUR_CONTRACT_ADDRESS";
    const contractABI = [/* ABI JSON here */];
    let provider, signer, contract;
    async function initWeb3() {
      if (window.ethereum) {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        contract = new ethers.Contract(CONTRACT_ADDRESS, contractABI, signer);
      } else {
        console.warn("MetaMask no detectado");
      }
    }
    window.addEventListener("load", initWeb3);

    async function mintNFT() {
      if (!contract) { alert("Wallet no conectada"); return; }
      try {
        const hash = await computeConfigHash();
        const tokenURI = `https://my-server.com/metadata/${hash}.json`;
        const tx = await contract.mint(await signer.getAddress(), tokenURI);
        await tx.wait();
        const nft = {
          tokenId: hash,
          tokenURI,
          owner: await signer.getAddress(),
          config: exportCurrentConfiguration()
        };
        localStorage.setItem("mintedNFT_" + hash, JSON.stringify(nft));
        console.log("NFT guardado localmente:", nft);
        alert("NFT acuñado! Hash: " + hash);
      } catch(e) {
        console.error(e);
        alert("Error mint NFT: " + e.message);
      }
    }
  </script>
  <!-- DROPZONE SCRIPT FINAL -->
  <script>
  document.addEventListener("DOMContentLoaded", function() {
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const uploadStatus = document.getElementById('uploadStatus');
    const jwkOutput = document.getElementById('jwkOutput');
    const cidOutput = document.getElementById('cidOutput');

    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#888";
    });
    dropzone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#ccc";
    });
    dropzone.addEventListener('drop', async (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#ccc";
      if (e.dataTransfer.files.length > 0) {
        await handleFile(e.dataTransfer.files[0]);
      }
    });
    fileInput.addEventListener('change', async (e) => {
      if (e.target.files.length > 0) {
        await handleFile(e.target.files[0]);
      }
    });
    async function handleFile(file) {
      uploadStatus.textContent = "Cifrando archivo…";
      jwkOutput.textContent = "";
      cidOutput.textContent = "";
      const key = await crypto.subtle.generateKey(
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"]
      );
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const data = new Uint8Array(await file.arrayBuffer());
      const encrypted = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        key,
        data
      );
      const exportedKey = await crypto.subtle.exportKey("jwk", key);
      jwkOutput.textContent = " Clave secreta (guárdala para descifrar): " + JSON.stringify(exportedKey);
      const ivHex = Array.from(iv).map(x=>x.toString(16).padStart(2,"0")).join("");
      jwkOutput.textContent += "\n IV usado: " + ivHex;

      const combined = new Uint8Array(iv.byteLength + encrypted.byteLength);
      combined.set(iv, 0);
      combined.set(new Uint8Array(encrypted), iv.byteLength);
      const encryptedBlob = new Blob([combined], { type: file.type });

      uploadStatus.textContent = "Subiendo a Bundlr (requiere wallet conectada)…";
      try {
        if (!window.bundlr) {
          uploadStatus.textContent = "Bundlr no está listo aún o la wallet no está conectada";
          return;
        }
        const tx = await window.bundlr.upload(encryptedBlob, {
          tags: [{ name: "Content-Type", value: file.type }]
        });
        uploadStatus.textContent = " Subida exitosa";
        window.lastUploadedTxId = tx.id;
        cidOutput.textContent = "CID (Arweave/Bundlr): " + tx.id;
      } catch (err) {
        uploadStatus.textContent = " Error subiendo a Bundlr: " + err.message;
      }
    }
  });
  </script>
</body>
</html>
