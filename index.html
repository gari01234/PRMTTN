<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>PRMTTN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Three .js + OrbitControls (una sola vez) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
// Bootstrap GRVTY flags to avoid ReferenceError before its script loads
if (typeof window.isGRVTY === 'undefined') window.isGRVTY = false;
// Optional no-ops so calls won't crash if invoked early
if (typeof window.ensureOnlyGRVTY === 'undefined') window.ensureOnlyGRVTY = function(){
  if (!window.isGRVTY && typeof window.toggleGRVTY === 'function') window.toggleGRVTY();
};
if (typeof window.ensureOnlyGRVTYFromUI === 'undefined') window.ensureOnlyGRVTYFromUI = function(){
  window.ensureOnlyGRVTY(); if (typeof updateEngineSelectUI==='function') updateEngineSelectUI();
};
if (typeof window.rebuildGRVTYIfActive === 'undefined') window.rebuildGRVTYIfActive = function(){};
  </script>
  <!-- === tilers.js embebido (JS puro) — crea window.Tilers === -->
    <script type="module">
/* ───────── tilers (JS puro) — núcleo de ensambles multi-familia ───────── */
const PHI   = (1 + Math.sqrt(5)) / 2;
const ROOT2 = Math.SQRT2;
const ROOT3 = Math.sqrt(3);
const ROOT4 = Math.sqrt(4);   // = 2
const ROOT5 = Math.sqrt(5);
const EPS   = 1e-6;

/* util mínimo */
function near(a,b,eps=EPS){ return Math.abs(a-b) <= eps; }

/* ───────────── PRNG con SEED (mulberry32) ───────────── */
let __rng = Math.random;       // por defecto
let __seedU32 = 0;

function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function setSeed(u32){
  __seedU32 = (u32 >>> 0) || 1;
  __rng = mulberry32(__seedU32);
}
function rand(){ return __rng(); }
function randRange(a,b){ return a + (b-a) * rand(); }
function randBool(p=0.5){ return rand() < p; }

/* Catálogo de familias + alias proporcionales útiles para matching */
const families = [
  { id:'phi', r:PHI,   aliases:[1/PHI, 1-PHI**-1, PHI**2-PHI] },
  { id:'r2',  r:ROOT2, aliases:[1/ROOT2, 2-ROOT2] },
  { id:'r3',  r:ROOT3, aliases:[1/ROOT3, ROOT3-1, 1-(ROOT3-1)] },
  { id:'r4',  r:ROOT4, aliases:[1/ROOT4, 1] },
  { id:'r5',  r:ROOT5, aliases:[1/ROOT5, (ROOT5-2)] }
];

/* identifica familia por proximidad (tolerancia holgada para ratios derivados) */
function whichFamily(r, eps=2e-2){
  let best = null;
  for (const f of families){
    for (const c of [f.r, ...f.aliases]){
      const d = Math.abs(r - c);
      if (!best || d < best.d) best = { f:f.id, d };
    }
  }
  return (best && best.d <= eps) ? best.f : null;
}

/* familia dominante por “área” en el inventario; fallback φ */
function dominantFamily(inv){
  const acc = {phi:0,r2:0,r3:0,r4:0,r5:0};
  (inv?.ratios||[]).forEach(it=>{
    const fam = whichFamily(it.r) ?? 'phi';
    acc[fam] += it.area || 0;
  });
  return Object.keys(acc).reduce((best,f)=> acc[f]>acc[best]?f:best,'phi');
}

/* ---------- 1) Euclid / Continued Fraction → mosaico de cuadrados ---------- */
function tilesEuclid(b, r, tag='euclid'){
  const out=[];
  let x=b.x, y=b.y, w=b.w, h=b.h;

  const orient = (w>=h) ? 1 : -1;     // 1 vertical; -1 horizontal
  if (orient<0){ [w,h] = [h,w]; }

  let W=w, H=h;
  let baseX=0, baseY=0;
  while (W > EPS && H > EPS){
    const q = Math.floor(W / H + EPS);
    for (let i=0;i<q;i++){
      const rect = orient>0
        ? { x: b.x + baseX + i*H, y: b.y + baseY, w: H, h: H, tag }
        : { x: b.x + baseY,       y: b.y + baseX + i*H, w: H, h: H, tag };
      out.push(rect);
    }
    const rem = W - q*H;
    if (rem <= EPS) break;
    if (orient>0){ baseX += q*H; } else { baseY += q*H; }
    W = H; H = rem;
  }
  return out;
}

/* ---------- 2) Beatty / Sturmian (dos tamaños L/S) ---------- */
function beattyPairFor(f){
  if (f==='phi'){ return [PHI*PHI, (PHI*PHI)/(PHI*PHI-1)]; }
  if (f==='r2'){  const a=1+ROOT2; return [a, a/(a-1)]; }
  if (f==='r3'){  const a=1+ROOT3; return [a, a/(a-1)]; }
  if (f==='r4'){  const a=1+ROOT4; return [a, a/(a-1)]; }
  const a=1+ROOT5; return [a, a/(a-1)];
}
function tilesBeatty(b, f, majorFirst=true, tag='beatty'){
  const [alpha] = beattyPairFor(f);
  const N = Math.max(2, Math.round(b.w / (b.h*0.25)));
  const seq = [];
  for (let k=1;k<=N;k++){
    const LA = Math.floor(k*alpha) - Math.floor((k-1)*alpha);
    seq.push(LA===2); // true=L, false=S
  }

  const rVal = (f==='phi'?PHI : f==='r2'?ROOT2 : f==='r3'?ROOT3 : f==='r4'?ROOT4 : ROOT5);
  const L =  majorFirst ? b.h           : b.h / rVal;
  const S =  majorFirst ? b.h / rVal    : b.h;

  const wL = 1.0, wS = 1/(alpha-1);
  const widths = seq.map(s => s ? wL : wS);
  const sum = widths.reduce((a,c)=>a+c,0);
  const kscale = b.w / sum;

  let x = b.x;
  const out = [];
  for (let i=0;i<widths.length;i++){
    const cw = widths[i]*kscale;
    const ch = seq[i] ? L : S;
    out.push({x, y:b.y, w:cw, h:ch, tag});
    if (ch < b.h - EPS){
      out.push({x, y:b.y+ch, w:cw, h:b.h-ch, tag});
    }
    x += cw;
    if (x > b.x + b.w - EPS) break;
  }
  return out;
}

/* ---------- 3) Sustitución inflacionaria (Fibo/Pell/√3) ---------- */
function substRules(f){
  if (f==='phi') return ['LS','L'];      // Fibonacci
  if (f==='r2')  return ['LSS','L'];     // tipo Pell
  if (f==='r3')  return ['LLS','L'];     // √3
  return null;                           // r4/r5 → sin reglas específicas (fallback)
}
function tilesSubstitution(b, f, iters=6, tag='subst'){
  const rules = substRules(f);
  if (!rules){
    return tilesBeatty(b, f, true, 'beatty');
  }
  let word = 'L';
  const [RL,RS] = rules;
  for (let i=0;i<iters;i++){
    let next=''; for (const ch of word) next += (ch==='L'?RL:RS);
    word = next;
  }
  const rVal = (f==='phi'?PHI : f==='r2'?ROOT2 : ROOT3);
  const wL = 1, wS = 1 / rVal;
  const widths = [...word].map(ch => ch==='L'?wL:wS);
  const sum = widths.reduce((a,c)=>a+c,0);
  const kscale = b.w / sum;
  let x = b.x;
  const out = [];
  for (const ch of word){
    const cw = (ch==='L'?wL:wS)*kscale;
    out.push({x, y:b.y, w:cw, h:b.h, tag});
    x += cw;
    if (x > b.x + b.w - EPS) break;
  }
  return out;
}

/* ---------- 4) NUEVO: BSP “split-rect” con alternancia H/V, ratio 0.35–0.65,
                        tamaño mínimo de celda y fusión de adyacentes ---------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function tilesBSP(b, opt={}){
  const minCell   = Math.max(0, opt.minCell || 3.0);
  const rMin      = clamp(opt.ratioMin ?? 0.35, 0.05, 0.95);
  const rMax      = clamp(opt.ratioMax ?? 0.65, rMin, 0.95);
  const targetN   = Array.isArray(opt.targetN) ? Math.round(
                      clamp(Math.floor(randRange(opt.targetN[0], opt.targetN[1]+1)), 2, 64)
                    ) : Math.round(clamp(opt.targetN || 10, 2, 64));
  const mergeProb = clamp(opt.mergeProb ?? 0.25, 0, 1);

  const out = [];

  function splitRect(R, lastOrient){
    // condición de parada: objetivo de celdas y tamaño mínimo
    const canV = (R.w >= 2*minCell + EPS);
    const canH = (R.h >= 2*minCell + EPS);

    if (out.length >= targetN || (!canV && !canH)){
      out.push({ x:R.x, y:R.y, w:R.w, h:R.h, tag:'bsp' });
      return;
    }

    // alternancia “suave”: 70% alterna respecto a la anterior; si no, decide por aspecto
    let orient;
    if (lastOrient && rand() < 0.70){
      orient = (lastOrient==='H' ? 'V' : 'H');
    } else {
      if (R.w / Math.max(R.h, EPS) > 1.25) orient = 'V';
      else if (R.h / Math.max(R.w, EPS) > 1.25) orient = 'H';
      else orient = randBool() ? 'V' : 'H';
    }

    if (orient==='V' && !canV) orient='H';
    if (orient==='H' && !canH) orient='V';

    if (orient==='V'){
      // ratio limitado por minCell
      let r = clamp(randRange(rMin, rMax), minCell / R.w, 1 - (minCell / R.w));
      const w1 = Math.max(minCell, R.w * r);
      const w2 = R.w - w1;
      const L = { x:R.x,       y:R.y, w:w1, h:R.h };
      const Rr= { x:R.x + w1, y:R.y, w:w2, h:R.h };
      splitRect(L, 'V'); splitRect(Rr, 'V');
    } else {
      let r = clamp(randRange(rMin, rMax), minCell / R.h, 1 - (minCell / R.h));
      const h1 = Math.max(minCell, R.h * r);
      const h2 = R.h - h1;
      const T = { x:R.x, y:R.y,        w:R.w, h:h1 };
      const B = { x:R.x, y:R.y + h1,   w:R.w, h:h2 };
      splitRect(T, 'H'); splitRect(B, 'H');
    }
  }

  splitRect(b, null);

  // — FUSIÓN DE CELDAS ADYACENTES (25% por defecto) —
  function tryMerge(a,b){
    // horizontal: misma y, misma h, tocan por x
    if (near(a.y,b.y) && near(a.h,b.h) && (near(a.x + a.w, b.x) || near(b.x + b.w, a.x))){
      const x = Math.min(a.x,b.x);
      const w = a.w + b.w;
      return { x, y:a.y, w, h:a.h, tag:'bsp-merged' };
    }
    // vertical: misma x, misma w, tocan por y
    if (near(a.x,b.x) && near(a.w,b.w) && (near(a.y + a.h, b.y) || near(b.y + b.h, a.y))){
      const y = Math.min(a.y,b.y);
      const h = a.h + b.h;
      return { x:a.x, y, w:a.w, h, tag:'bsp-merged' };
    }
    return null;
  }

  if (out.length > 2 && mergeProb > 0){
    // intentos acotados para no ciclar
    for (let pass=0; pass<3; pass++){
      let merged = false;
      for (let i=0; i<out.length && !merged; i++){
        for (let j=i+1; j<out.length && !merged; j++){
          if (randBool(mergeProb)){
            const m = tryMerge(out[i], out[j]);
            if (m){
              const a = out[i], b = out[j];
              out.splice(j,1); out.splice(i,1); // quita b luego a
              out.push(m);
              merged = true;
            }
          }
        }
      }
      if (!merged) break;
    }
  }

  return out;
}

/* ---------- 5) Orquestador con alternancia de estrategias + BSP ---------- */
function fillByStrategy(rect, fam, strategy){
  if (strategy==='beatty') return tilesBeatty(rect, fam, true, 'beatty');
  if (strategy==='subst')  return tilesSubstitution(rect, fam, 7, 'subst'); // r4/r5 → Beatty
  return tilesEuclid(rect, rect.w/rect.h, 'euclid-in-band');
}

function assemble(b, inv, opt={}){
  // Semilla del motor (si viene) — mismo PRNG para todo
  if (typeof opt.rndSeed === 'number') setSeed(opt.rndSeed);

  const fam = (opt.familyId && ['phi','r2','r3','r4','r5'].includes(opt.familyId))
    ? opt.familyId
    : dominantFamily(inv || {ratios:[]});

  const rBox = Math.max(b.w,b.h) / Math.min(b.w,b.h);

  // ——— Picker de “plantilla” ponderado (si no nos forzan un engine)
  let engine = opt.engine || (()=>{
    const roll = rand();
    if (roll < 0.50) return 'bsp';
    if (roll < 0.85) return 'bands';
    if (roll < 0.95) return 'beatty';
    return 'spiral';
  })();

  // ——— Ejecuta el motor elegido (sin returns tempranos que anulen ramas) ———
  let rects = [];

  if (engine === 'bsp'){
    rects = tilesBSP(b, {
      minCell   : opt.minCell ?? 3.0,
      ratioMin  : opt.ratioMin ?? 0.35,
      ratioMax  : opt.ratioMax ?? 0.65,
      targetN   : opt.targetN  ?? [6,14],
      mergeProb : opt.mergeProb ?? 0.25
    });
  } else if (engine === 'bands'){
    // bandas euclidianas + ciclo de estrategias (ponderado si no nos dan uno)
    const cycle = Array.isArray(opt.strategyCycle) && opt.strategyCycle.length
      ? opt.strategyCycle
      : (rand()<0.5 ? ['beatty','euclid','subst'] : ['euclid','beatty','subst']);
    const bands = tilesEuclid(b, rBox, 'euclid-band');
    for (let i=0;i<bands.length;i++){
      const strat = cycle[i % cycle.length];
      rects.push(...fillByStrategy(bands[i], fam, strat));
    }
  } else if (engine === 'beatty'){
    rects = tilesBeatty(b, fam, true, 'beatty');
  } else if (engine === 'spiral'){
    rects = tilesSubstitution(b, fam, 7, 'subst');
  } else {
    // fallback robusto → bands
    const bands = tilesEuclid(b, rBox, 'euclid-band');
    for (const band of bands){
      rects.push(...tilesBeatty(
        { x:band.x, y:band.y, w:band.w, h:band.h }, fam, true, 'beatty-in-band'
      ));
    }
  }

  return rects;
}

/* exporta en global */
window.Tilers = {
  PHI, ROOT2, ROOT3, ROOT4, ROOT5,
  families, whichFamily,
  assemble,
  // PRNG público para trazabilidad / tests
  setSeed,
  get seed(){ return __seedU32; }
};
    </script>
  <style>
  body {
    margin: 0;
    overflow: hidden;
    background: #ffffff;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-weight: 200;
    font-size: 12px;
    cursor: none;
  }
  #customCursor {
    position: fixed;
    width: 12px; height: 12px;
    border-radius: 50%;
    background: #000;
    border: 1px solid #fff;
    pointer-events: none; z-index: 300;
    transform: translate(-50%, -50%);
  }
  /* HUD eliminado */
  #topRightDisplay{
    display:none !important;
  }
  button{
    cursor:none;
    border:none;
    border-radius:4px;
    padding:8px 12px;
    font-size:12px;
    z-index:250;
    background:rgba(255,255,255,0.12);
    transition:background 0.2s;
  }
  button:hover{
    background:rgba(255,255,255,0.20);
  }

  #patternNextButton,
  #engineCycleButton,
  #permNextButton{
    position:fixed; z-index:260;                /* siempre encima */
    border:none; border-radius:4px;
    padding:8px 12px; font-size:12px;
    background:rgba(255,255,255,0.12);
    cursor:none; display:none;                  /* ocultos por defecto */
    transition:background .2s;
  }
  #patternNextButton:hover,
  #engineCycleButton:hover,
  #permNextButton:hover{
    background:rgba(255,255,255,0.20);
  }
  #patternNextButton{left:10px;  top:10px;}     /* 1 · patrón siguiente   */
  #engineCycleButton {left:10px;  bottom:10px;} /* 2 · motor siguiente     */
  #permNextButton   {right:10px; top:10px;}     /* 3 · NEXT (120 perms)    */

  /* === LAYOUT (orden y ESPACIADO nuevos) === */
  #toggleTextButton     { position:fixed; right:10px; bottom:10px;   }   /* Minimal UI */
  #aiPlanningButton     { position:fixed; right:10px; bottom:50px;   }   /* AI Planning */
  #saveImageButton      { position:fixed; right:10px; bottom:90px;  }   /* Save Image (A2) – debajo de Load JSON */
  #uploadConfigButton   { position:fixed; right:10px; bottom:130px;  }   /* Load JSON */
  #exportEmbedButton    { position:fixed; right:10px; bottom:170px;  }   /* Save JSON */
  #archDescButton       { position:fixed; right:10px; bottom:210px;  }   /* Architectural Description */
  #perm120Button        { position:fixed; right:10px; bottom:250px;  }   /* 120 Architectural Permutations */
#randomConfigButton   { position:fixed; left:10px; bottom:130px;  }   /* BUILD  */
   #certButton           { position:fixed; right:10px; bottom:30px; }   /* Edition Certificate */
  /* === FRBN toggle === */
#frbnWrap { position:fixed; left:10px; bottom:90px; z-index:260; }
#frbnButton { position:relative; }  /* dentro del wrap */
#frbnInfoButton{
  position:absolute; top:-6px; right:-6px;
  padding:2px 6px; font-size:10px; opacity:.9;
  background:rgba(255,255,255,0.2);
}

  #saveImageButton { background:rgba(255,255,255,0.2); }

  /* Ocultar los no usados */
  #btnDebugColors,
  #triadicConfigButton{
    display:none !important;
  }

  #controls {
    position: absolute; top: 10px; left: 10px; z-index: 100;
    padding: 10px; border-radius: 5px;
    background: rgba(255,255,255,0.12); max-width: 350px;
  }
  details {
    margin-bottom: 10px;
    background: rgba(255,255,255,0.06);
  }
  details summary { font-weight: 200; cursor: pointer; }
  details summary:hover { color: #333; }
  select, input[type="range"], input[type="color"] { cursor: none; width: 100%; }
  #permutationList { width: 100%; height: 100px; }


  #hoverPopup {
    position:absolute; padding:5px 10px;
    background:rgba(0,0,0,0.7); color:#fff;
    border-radius:4px; pointer-events:none;
    font-size:12px; display:none; opacity:0;
    transition:opacity .3s; z-index:200;
  }


  /* Panel BUILD */
  #archPanel{
    position:fixed; z-index:1000; top:5%; left:50%;
    transform:translateX(-50%);
    width:85%; height:90%;
    background:#fff; color:#000;
    border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
    padding:24px 32px 48px; overflow:auto;
    font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size:14px; line-height:1.4;
    cursor:auto;
  }
  #archPanel *{ cursor:auto !important; }
  #archClose{
    position:fixed; right:calc(7.5% + 16px); top:5%;
    border:none; padding:6px 10px; border-radius:4px;
    background:#eee; cursor:pointer; z-index:1001;
  }
  #archPanel h2{ margin-top:0; }
  #archPanel .formula{
    margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
  }
  #archPanel .box{
    display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
    font-family:monospace;
  }
  #archPanel section{ margin-bottom:18px; }
  #archPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
  #archPanel .perm h4{ margin-bottom:6px; }
  code, pre{ font-family:monospace; }

  /* Panel 120 perms */
  #perm120Panel{
    position:fixed; right:10px; bottom:340px; z-index:260;
    background:rgba(255,255,255,0.12);
    padding:8px 10px; border-radius:4px; width:260px;
    display:none; /* ← cerrado por defecto */
  }
  #perm120Panel label{ display:block; margin-bottom:6px; }
  #perm120Panel input, #perm120Panel button{ width:100%; margin-top:4px; }
  #perm120Status{
    margin-top:8px;
    font-size:12px;       /* ← mismo tamaño que los demás */
    font-weight:normal;
    text-align:center;
  }
  /* === Information button & panel === */
  #infoButton{
    position:fixed; left:10px; bottom:10px; z-index:260;
  }
  #infoPanel{
    position:fixed; z-index:1000; top:5%; left:50%;
    transform:translateX(-50%);
    width:85%; height:90%;
    background:#fff; color:#000;
    border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
    padding:24px 32px 48px; overflow:auto;
    font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size:14px; line-height:1.45;
    cursor:auto;
  }
  #infoPanel *{ cursor:auto !important; }
  #infoClose{
    position:fixed; right:calc(7.5% + 16px); top:5%;
    border:none; padding:6px 10px; border-radius:4px;
    background:#eee; cursor:pointer; z-index:1001;
  }
  #infoPanel h2{ margin-top:0; }
  #infoPanel .formula{
    margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
  }
  #infoPanel .box{
    display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
    font-family:monospace;
  }
  #infoPanel section{ margin-bottom:18px; }
  #infoPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
  /* === LCHT toggle === */
  #lchtWrap  { position:fixed; left:10px; bottom:50px; z-index:260; }
  #lchtButton{ position:relative; }

  /* === OFFNNG toggle === */
  #offnngButton{
    position:fixed; left:10px; bottom:290px;   /* 40 px por encima de PLAY (170) */
    z-index:260;
  }

  #tmslButton{
    position:fixed; left:10px; bottom:330px;   /* mismo look & feel */
    z-index:260;
    border:none; border-radius:4px;
    padding:8px 12px; font-size:12px;
    background:rgba(255,255,255,0.12);
    cursor:none; transition:background .2s;
  }
  #tmslButton:hover{ background:rgba(255,255,255,0.20); }

  /* === ENGINE MENU (reemplaza botones sueltos) === */
  #engineSelectWrap {
    position: fixed;
    left: 10px;
    bottom: 290px;      /* ocupa el lugar que usaba OFFNNG, sin solapar PLAY/BUILD antiguos */
    z-index: 260;
    background: rgba(255,255,255,0.12);
    padding: 6px 8px;
    border-radius: 4px;
  }
  #engineSelectWrap select {
    width: 180px;       /* ancho cómodo; no usamos 100% para no romper layout */
    cursor: none;
  }
  #engineSelectWrap label {
    font-size: 12px;
    opacity: .85;
  }

  /* Botón PLAY – genera nuevas permutaciones */
  #playButton{
    position:fixed;               /* mismo estilo general */
    left:10px; bottom:170px;      /* 40 px por encima de BUILD (130 px) */
    z-index:260;
    border:none; border-radius:4px;
    padding:8px 12px;
    font-size:18px;               /* el símbolo se ve claro */
    background:rgba(0,0,0,0.12);
    cursor:none; transition:background .2s;
  }
  #playButton:hover{ background:rgba(0,0,0,0.20); }
  </style>
</head>
<body>
  <div id="customCursor"></div>
  <button id="patternNextButton" onclick="cyclePattern()">11</button>
  <button id="engineCycleButton"  onclick="cycleEngine()">4</button>
  <button id="permNextButton"     onclick="nextPerm120()">120</button>
  <div id="topRightDisplay"></div>

  <input type="file" id="json-upload" accept=".json" style="display:none;" />

  <button id="aiPlanningButton"   onclick="applyEvolutionAI()">AI Planning</button>
  <button id="toggleTextButton"   onclick="toggleTexts()">Minimal UI</button>
  <button id="uploadConfigButton" onclick="document.getElementById('json-upload').click()">Load JSON</button>
  <button id="saveImageButton"    onclick="saveImage()">Save Image (A2)</button>
  <button id="exportEmbedButton"  onclick="exportEmbed()">Save JSON</button>
  <button id="archDescButton"     onclick="showArchitecturalDescription()">Architectural Description</button>
  <!-- NUEVO: Play (genera nueva configuración) -->
  <button id="playButton" onclick="generateRandomConfigurationNoCollision()">▮</button>

  <button id="perm120Button"      onclick="togglePerm120Panel()">120 Architectural Permutations</button>

  <!-- NUEVO: Menú de motores -->
  <div id="engineSelectWrap">
    <label for="engineSelect" style="display:block;margin-bottom:4px;">Engine</label>
    <select id="engineSelect" onchange="applyEngineFromSelect(this.value)">
      <option value="BUILD">BUILD</option>
    </select>
  </div>

  <button id="certButton" onclick="exportEditionCertificate()">Edition Certificate</button>
  <button id="infoButton" onclick="showInformation()">Information</button>
  <button id="btnDebugColors"
          style="position:fixed;bottom:180px;right:10px;z-index:260;display:none;"
          onclick="mostrarDebugColores()">
    Debug Colors
  </button>

  <!-- Panel controles 120 perms -->
  <div id="perm120Panel">
    <label>Auto‑advance (1s → 12m)</label>
    <input type="range" id="perm120Slider" min="1000" max="720000" step="1000" value="5000"
           oninput="syncPerm120InputsFromSlider()">
    <input type="number" id="perm120Seconds" min="1" max="720" value="5"
           oninput="syncPerm120SliderFromSeconds()">
    <small>(seconds)</small>
    <button onclick="playPerm120()">Play</button>
    <button onclick="pausePerm120()">Pause</button>
    <button onclick="prevPerm120()">Prev</button>
    <button onclick="nextPerm120()">Next</button>
    <button onclick="showPerm120Info()">Information</button>
    <div id="perm120Status">Permutation: 0 / 119</div>
  </div>


  <div id="controls">
  <details open>
    <summary>Chromatic Pattern</summary>
          <select id="patternSelect" onchange="setActivePattern(this.value)">
        <option value="1">1 · Chromatic Containment</option>
        <option value="2">2 · Contrast &amp; Dissonance</option>
        <option value="3">3 · Non‑semantic Disposition</option>
        <option value="4">4 · Structured Ambiguity</option>
        <option value="5">5 · Chromatic Isotropy</option>
        <option value="6">6 · Self‑Sufficient Presence</option>
        <option value="7">7 · Associative Asymmetry</option>
        <option value="8">8 · Irregular Dynamics</option>
        <option value="9">9 · Habitable without Translation</option>
        <option value="10">10 · Resonance</option>
        <option value="11">11 · Active Transparency</option>
      </select>
      <button id="patternInfoButton"
              style="margin-top:6px;width:100%;"
              onclick="showPatternInfo()">
        Pattern Information
      </button>

  </details>

  <div id="manualControls">
    <details>
      <summary>Select Permutations</summary>
      <select id="permutationList" multiple></select>
      <button onclick="refreshAll({rebuild:true})">Render</button>
    </details>
  </div>


  <details>
    <summary>Manual Colors (override)</summary>
    <div><label>1: <input type="color" id="color1" onchange="onColourPick(1,this.value)"></label></div>
    <div><label>2: <input type="color" id="color2" onchange="onColourPick(2,this.value)"></label></div>
    <div><label>3: <input type="color" id="color3" onchange="onColourPick(3,this.value)"></label></div>
    <div><label>4: <input type="color" id="color4" onchange="onColourPick(4,this.value)"></label></div>
    <div><label>5: <input type="color" id="color5" onchange="onColourPick(5,this.value)"></label></div>
    <button id="btnResetAll" style="margin-top:6px;" onclick="resetAllColours()">
      Reset Background + Walls + Colors
    </button>
  </details>

  <details>
    <summary>Background</summary>
    <input type="color" id="bgColor" value="#ffffff">
    <button onclick="updateBackground()">Apply Background</button>
  </details>

  <details>
    <summary>Cube Walls Color</summary>
    <input type="color" id="cubeColor" value="#808080">
    <button onclick="updateCubeColor()">Apply Cube Walls</button>
  </details>

  <details>
    <summary>Attributes Reorganization</summary>
    <select id="attrMapping"></select>
    <button onclick="updateMapping()">Apply</button>
    <button onclick="autoResolveColisionesGlobal()">Resolve Collisions</button>
  </details>

  <details>
    <summary>Standard Views</summary>
    <select id="standardView">
      <option value="isometric">Isometric</option>
      <option value="top">Top</option>
      <option value="front" selected>Front</option>
      <option value="side">Side</option>
      <option value="diagonal">Opposite diagonal</option>
    </select>
    <button onclick="applyStandardView()">Apply View</button>
  </details>

  <details>
    <summary>Zoom Controls</summary>
    <button onclick="zoomIn()">Zoom In</button>
    <button onclick="zoomOut()">Zoom Out</button>
  </details>

  <details>
    <summary>Motion Controls</summary>
    <button onclick="togglePause()">Pause Motion</button>
    <button onclick="resetMovement()">Reset Motion</button>
  </details>
</div>


<script>
document.getElementById('json-upload').addEventListener('change', function(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const config = JSON.parse(e.target.result);

      // Permutations
      if (config.perms && Array.isArray(config.perms)) {
        const sel = document.getElementById('permutationList');
        Array.from(sel.options).forEach(o => o.selected = config.perms.includes(o.value));
      }

      // Mapping
      if (config.mapping) {
        const v = [config.mapping.forma, config.mapping.color, config.mapping.x, config.mapping.y, config.mapping.z];
        document.getElementById('attrMapping').value = v.join(',');
        attributeMapping = [v[0], v[1], v[2], v[3], v[4], attributeMapping[5], attributeMapping[6]];
      }

      // Pattern
      if (typeof config.pattern === 'number') {
        activePatternId = config.pattern;
        const selPattern = document.getElementById('patternSelect');
        if (selPattern) selPattern.value = String(config.pattern);
      }

      // Manual colors
      if (config.colors) {
        manualOverride = {};
        Object.entries(config.colors).forEach(([i, c]) => {
          manualOverride[Number(i)] = c;
        });
      }

      // BG / cube
      if (config.bg) {
        document.getElementById('bgColor').value = config.bg;
        bgOverride = config.bg;
      }
      if (config.cube) {
        document.getElementById('cubeColor').value = config.cube;
        cubeOverride = config.cube;
      }

      // Scene invariants (optional)
      if (typeof config.sceneSeed === 'number') {
        sceneSeed = config.sceneSeed;
      }
      if (typeof config.S_global === 'number') {
        S_global = config.S_global;
      }

      // View
      const view = config.view || "front";
      document.getElementById('standardView').value = view;

      // Rebuild
      refreshAll({rebuild:true, keepManual:true});
      applyStandardView();

      alert('JSON loaded successfully');
    } catch (err) {
      alert('Error loading JSON: ' + err.message);
    }
  };
  reader.readAsText(file);
});
</script>


  <div id="hoverPopup"></div>

  <!-- (eliminados: copias duplicadas de Three, OrbitControls y Ethers) -->
  <script>
    // ------------- TODO EL JS ORIGINAL (¡NO QUITES NADA DE AQUÍ!) -------------

    // === Variables globales ===
    let scene, camera, renderer, controls, raycaster, mouse;
    let cubeUniverse, permutationGroup;
    const cubeSize = 30, segment = cubeSize/5, halfCube = cubeSize/2;

    // === R5NOVA — configuración AISLADA (sin depender de otros motores) ===
    // Todo lo de R5NOVA toma estos valores y NADA más.
    const R5NOVA_CFG = {
      // Selección de “fila del fondo”: usamos minZ del AABB en mundo
      BACK_BAND     : 1.8,          // ancho de la rebanada desde zMin (en unidades de mundo)

      // Grosor objetivo de TODAS las piezas de esa fila (en unidades de mundo, no relativas)
      BACK_THICKNESS: 0.18,         // pon 0.10–0.40 para probar cambios visibles

      // Material ‘flat’ por defecto (sin luces) para aislar color de la iluminación global
      MATERIAL      : 'basic',      // 'basic' (flat) o 'lambert' si prefieres difuso

      // “Secuencia dorada” 100% determinista para evitar repeticiones de tono
      HUE_BASE      : 0.0,                             // grados
      HUE_STEP      : 137.50776405003785,              // ángulo áureo (evita ciclos cortos)
      SAT           : 0.86,                            // 0..1
      VAL           : 0.92,                            // 0..1
      MIN_HUE_DIFF  : 12,                               // separación mínima entre tonos (grados)

      // Mantener legibilidad frente al fondo (puedes poner false si no lo quieres)
      ENSURE_CONTRAST: true
    };

    const EPS = 1e-6;
    let isPaused = false, currentMode = "manual", userRating = null, textsVisible = true;
    let attributeMapping = [0,1,2,3,4, 0,1];   // forma,color,x,y,z,bg,wall
    let colorAttrCycle = 0;                    // ← cuenta las rotaciones de color
    let paletteRGB = [];
    let manualOverride = {1:'#ff0000',2:'#00ff00',3:'#0000ff',4:'#ff00ff',5:'#00ffff'};
    let bgOverride   = null;
    let cubeOverride = null;
    /* variables globales para fondo y paredes */
    let bgHSV = {h:0,s:0,v:1};
    let wallHSV = {h:0,s:0,v:1};
    let  currentHarmony = 'triad';
    let activePatternId = 1;           // arranca en Contención
      const ΔE_MIN = 20;

      // >>> NUEVO:
      let S_global = 0; // término estructural para posiciones (Shift-Rank acoplado)
      let avgSceneRange = 0;          // 2 … 6  →  se usa como factor de velocidad

      // BUILD-only compatibility (motores archivados físicamente)
      let skySphere = null, offnngMesh = null, lichtGroup = null;
      let isFRBN = false, isLCHT = false, isOFFNNG = false, isTMSL = false, isRAUM = false, is13245 = false, isKEPLR = false, isRAPHI = false, isR5NOVA = false;

      /* Cambia al motor BUILD sin generar una nueva configuración */
    function switchToBuild(){
  // Garantiza “modo BUILD” sin depender de flags/toggles de otros motores
  try{ enterBuildRenderBoost(); }catch(_){}

  try{ if (cubeUniverse) cubeUniverse.visible = true; }catch(_){}
  try{ if (permutationGroup) permutationGroup.visible = true; }catch(_){}

  // Restaura la vista BUILD (respeta tu selector de “standardView”)
  try{ restoreBuildView(); }catch(_){}

  // Si existe el sistema de wall manager, asegúrate de estar en BUILD
  try{
    if (typeof window.WW_applyFor === 'function') window.WW_applyFor('BUILD');
    else if (typeof window.setWall_BUILD === 'function') window.setWall_BUILD();
  }catch(_){}

  updateEngineSelectUI();
}

    // ——— Canon para motores tipo BUILD (frontal libre)
    const BUILD_FOV = 34;
    const BUILD_Z   = 84;

    /* ============================================================
       CAMERAS · definición independiente por motor (fuente única)
       ============================================================ */
    function setCamera_FRBN(){
      camera.up.set(0,1,0);
      camera.near = 0.1; camera.far = 4000;
      camera.fov = 75; camera.updateProjectionMatrix();
      if (controls && controls.target) controls.target.set(0, 0, 0);
      camera.position.set(0, 0, 55);
      if (controls){
        controls.enabled = true;
        controls.enableRotate = true;
        controls.enablePan    = true;
        controls.enableZoom   = true;
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = Math.PI;
        controls.screenSpacePanning = false;
        controls.update();
      }
    }

    function setCamera_LCHT(){
      camera.up.set(0,1,0);
      camera.near = 0.1; camera.far = 4000;
      camera.fov = 75; camera.updateProjectionMatrix();
      if (controls && controls.target) controls.target.set(0, 0, 0);
      camera.position.set(0, 0, 130);
      if (controls){
        controls.enabled = true;
        controls.enableRotate = true;
        controls.enablePan    = true;
        controls.enableZoom   = true;
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = Math.PI;
        controls.screenSpacePanning = false;
        controls.update();
      }
    }

    function setCamera_OFFNNG(){
      camera.up.set(0,1,0);
      camera.near = 0.1; camera.far = 4000;
      camera.fov = 75; camera.updateProjectionMatrix();
      if (controls && controls.target) controls.target.set(0, 0, 0);
      camera.position.set(0, 0, 47.5);
      if (controls){
        controls.enabled = true;
        controls.enableRotate = true;
        controls.enablePan    = true;
        controls.enableZoom   = true;
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = Math.PI;
        controls.screenSpacePanning = false;
        controls.update();
      }
    }

    function setCamera_KEPLR(){
      camera.up.set(0,1,0);
      camera.near = 0.1; camera.far = 4000;
      camera.fov = 75; camera.updateProjectionMatrix();
      if (controls && controls.target) controls.target.set(0, 0, 0);
      camera.position.set(0, 0, 45);
      if (controls){
        controls.enabled = true;
        controls.enableRotate = true;
        controls.enablePan    = true;
        controls.enableZoom   = true;
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = Math.PI;
        controls.screenSpacePanning = false;

        // ← IMPORTANTE: resetear límites de zoom para este motor
        controls.minDistance = 0;
        controls.maxDistance = Infinity;

        controls.update();
      }
    }

    function setCamera_RAPHI(){
      camera.up.set(0,1,0);
      camera.near = 0.1; camera.far = 4000;
      camera.fov = 75; camera.updateProjectionMatrix();
      if (controls && controls.target) controls.target.set(0, 0, 0);
      camera.position.set(0, 0, 45);
      if (controls){
        controls.enabled = true;
        controls.enableRotate = true;
        controls.enablePan    = true;
        controls.enableZoom   = true;
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = Math.PI;
        controls.screenSpacePanning = false;

        // ← IMPORTANTE: resetear límites de zoom para este motor
        controls.minDistance = 0;
        controls.maxDistance = Infinity;

        controls.update();
      }
    }

    function setCamera_R5NOVA(){
      camera.up.set(0,1,0);
      camera.near = 0.1; camera.far = 4000;
      camera.fov = 75; camera.updateProjectionMatrix();
      if (controls && controls.target) controls.target.set(0, 0, 0);
      camera.position.set(0, 0, 108);
      if (controls){
        controls.enabled = true;
        controls.enableRotate = true;
        controls.enablePan    = true;
        controls.enableZoom   = true;
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = Math.PI;
        controls.screenSpacePanning = false;
        controls.update();
      }
    }

    function setCamera_GRVTY(){
// Vista tipo “horizonte/mar”: más baja y mirando más hacia abajo.
  camera.up.set(0,1,0);
  camera.near = 0.1;
  camera.far  = 4000;
  camera.fov  = 75;                 // mantenemos tu FOV actual
  camera.updateProjectionMatrix();

  // Ojo un poco más bajo y un pelín más atrás
  const eyeX = 0.0, eyeY = 32.0, eyeZ = 275.0;
  // Apunta más abajo para que el suelo (grid) llene la parte inferior
  const tgtY = 90.0;

  if (controls && controls.target) controls.target.set(0, tgtY, 0);
  camera.position.set(eyeX, eyeY, eyeZ);
  camera.lookAt(0, tgtY, 0);

  if (controls){
    controls.enabled = true;
    controls.enableRotate = true;
    controls.enablePan    = true;
    controls.enableZoom   = true;
    controls.screenSpacePanning = false;

    // Restringimos el pitch a un rango “mirando hacia abajo”
    // (π/2 es horizontal). Permitimos ~−0.35..+0.05 rad respecto a horizontal.
    controls.minPolarAngle = Math.PI/2 - 0.35;
    controls.maxPolarAngle = Math.PI/2 + 0.05;

    // Zoom útil para este encuadre (no afecta a otros motores)
    controls.minDistance = 170;
    controls.maxDistance = 520;


        controls.update();
      }
    }

    /* 13245 · ventana nivelada (verticales rectas) con yaw + pan/zoom
       - Usa tu encuadre de referencia del WW Tuning (X/Z iguales)
       - Altura de ojo = 22.92 (de tu captura)
       - IMPORTANTE: target.y = eyeY para bloquear el pitch (sin ver “desde arriba”)
    */
    function setCamera_13245(){
      const eyeY = 52.5;                // altura de ojo (planta baja sensación nivel)
      const eyeX = 4.97, eyeZ = 164.12;  // desde tu WW Tuning
      const tgtX = 5.13, tgtZ = -0.1;   // desde tu WW Tuning (pero nivelado en Y)

      camera.up.set(0,1,0);
      camera.near = 0.1;
      camera.far  = 4000;
      camera.fov  = 75;
      camera.updateProjectionMatrix();

      // Cámara y target: MISMA Y → sin inclinación (verticales “derechas”)
      camera.position.set(eyeX, eyeY, eyeZ);
      if (controls && controls.target) controls.target.set(tgtX, eyeY, tgtZ);
      camera.lookAt(tgtX, eyeY, tgtZ);

      if (controls){
        controls.enabled = true;

        // Rotación permitida solo en yaw (sin pitch): bloqueamos el ángulo polar
        controls.enableRotate = true;
        controls.minPolarAngle = Math.PI / 2; // horizontal
        controls.maxPolarAngle = Math.PI / 2; // horizontal

        // Pan libre (incluye mover arriba/abajo) manteniendo cámara nivelada
        controls.enablePan = true;
        controls.screenSpacePanning = true;

        // Zoom útil alrededor de tu distancia (~173) sin permitir acercarse demasiado
        controls.enableZoom = true;
        controls.minDistance = 120;
        controls.maxDistance = 260;

        // (Opcional cómodo) algo de velocidad para pan/orbit
        controls.rotateSpeed = 0.9;
        controls.panSpeed    = 0.8;

        controls.update();
      }
    }

    /* RAUM: frontal fija, sin rotación/pan; zoom limitado (encuadre “DESEADO”) */
    function setCamera_RAUM(){
      const target = (controls && controls.target) ? controls.target : new THREE.Vector3(0,0,0);

      camera.up.set(0,1,0);
      camera.near = 0.1;
      camera.far  = 4000;
      camera.fov  = 75;
      camera.updateProjectionMatrix();

      // Posición exacta deseada (ver captura): z = 82.90
      camera.position.set(0, 0, 82.90);
      camera.lookAt(target);

      if (controls){
        controls.enabled = true;
        controls.enableRotate = false;  // sin rotación
        controls.enablePan    = false;  // sin pan
        controls.enableZoom   = true;   // sólo zoom (limitado)

        // Limites de zoom ajustados a este encuadre
        controls.minDistance  = 78;     // evita “acercarte de más”
        controls.maxDistance  = 140;
        controls.update();
      }
    }

    /* TMSL: nivelada (solo yaw), alejada y con límites amplios */
    function setCamera_TMSL(){
      camera.up.set(0,1,0);
      camera.fov = 75; camera.updateProjectionMatrix();
      const eyeY = (controls && controls.target) ? controls.target.y : 0;
      if (controls && controls.target) controls.target.set(0, eyeY, 0);
      camera.position.set(0, eyeY, 71);
      if (controls){
        controls.enabled = true;
        controls.enableRotate = true;
        controls.enablePan    = true;
        controls.enableZoom   = true;
        controls.screenSpacePanning = true;
        controls.minDistance = 10;
        controls.maxDistance = 300;
        controls.minPolarAngle = Math.PI / 2;
        controls.maxPolarAngle = Math.PI / 2;
        controls.update();
      }
    }

    /* BUILD: vista base (frontal libre) — aislada como los demás motores */
    function setCamera_BUILD(){
      camera.up.set(0,1,0);
      camera.near = 0.1; camera.far = 4000;
      camera.fov  = 75;  camera.updateProjectionMatrix();
      if (controls && controls.target) controls.target.set(0, 0, 0);
      camera.position.set(0, 0, 50);
      if (controls){
        controls.enabled = true;
        controls.enableRotate = true;
        controls.enablePan    = true;
        controls.enableZoom   = true;
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = Math.PI;
        controls.screenSpacePanning = false;
        controls.update();
      }
    }

    Object.assign(window, {
      setCamera_BUILD,
      setCamera_FRBN,
      setCamera_LCHT,
      setCamera_OFFNNG,
      setCamera_KEPLR,
      setCamera_RAPHI,
      setCamera_R5NOVA,
      setCamera_GRVTY,
      setCamera_13245,
      setCamera_RAUM,
      setCamera_TMSL
    });

    /* Cámara por motor: wrapper sin parpadeo ni doble carga */
    (function installCameraPerEngine(){
      const pairs = [
        ['toggleFRBN',   'isFRBN',   'setCamera_FRBN'],
        ['toggleLCHT',   'isLCHT',   'setCamera_LCHT'],
        ['toggleOFFNNG', 'isOFFNNG', 'setCamera_OFFNNG'],
        ['toggleTMSL',   'isTMSL',   'setCamera_TMSL'],
        ['toggleRAUM',   'isRAUM',   'setCamera_RAUM'],
        ['toggle13245',  'is13245',  'setCamera_13245'],
        ['toggleKEPLR',  'isKEPLR',  'setCamera_KEPLR'],
        ['toggleRAPHI',  'isRAPHI',  'setCamera_RAPHI'],
        ['toggleR5NOVA', 'isR5NOVA', 'setCamera_R5NOVA'],
        ['toggleGRVTY',  'isGRVTY',  'setCamera_GRVTY']
      ];
      pairs.forEach(([fname, flag, cset])=>{
        const fn = window[fname];
        if (typeof fn !== 'function' || fn.__camHooked) return;
        window[fname] = function(...args){
          const wasOn = !!window[flag];
          const out   = fn.apply(this, args);
          const nowOn = !!window[flag];
          if (!wasOn && nowOn && typeof window[cset] === 'function'){
            window[cset]();
          }
          return out;
        };
        window[fname].__camHooked = true;
      });

      // BUILD no tiene flag toggle: interceptamos “switchToBuild” y “applyStandardView”
      ['switchToBuild','applyStandardView'].forEach(name=>{
        const fn = window[name];
        if (typeof fn !== 'function' || fn.__camHooked) return;
        window[name] = function(...args){
          const out = fn.apply(this, args);
          try{ window.setCamera_BUILD(); }catch(_){ }
          return out;
        };
        window[name].__camHooked = true;
      });
    })();

    /* ============================================================
       WALLS · definición independiente por motor (fuente única)
       - Misma apertura por defecto en todos los motores
       - outer (ancho total) = 2 × (auto) para tapar laterales
       - KEPLR deja de “verse más chico” al tener su spec propia
       ============================================================ */

    /* Valores base (puedes cambiar aquí si quieres otro estándar):
       distance = separación del muro
       thickness = grosor del “marco”
       open = tamaño de apertura
       outer = ancho total del muro (lo forzamos a 2× más abajo)
    */
    const WALL_BASE = { distance: 110, thickness: 15, open: 100 };

    const WALL_SPECS = {
      BUILD : { ...WALL_BASE },
      FRBN  : { ...WALL_BASE },
      LCHT  : { ...WALL_BASE, distance: 110 }, // mismo look que tu cámara
      OFFNNG: { ...WALL_BASE, distance: 110 },
      TMSL  : { ...WALL_BASE, distance: 110 },
      RAUM  : { ...WALL_BASE, distance: 110 },
      '13245':{ ...WALL_BASE, distance: 110 },
      KEPLR : { ...WALL_BASE, distance: 110 }, // evita “apertura más chica”
      RAPHI : { ...WALL_BASE, distance: 110 },
      R5NOVA: { ...WALL_BASE, distance: 110 },
      GRVTY : { ...WALL_BASE, distance: 110, open: 420 } // horizonte muy lejos
    };

    /* Aplica un spec al motor indicado y fuerza outer=2× */
    function applyWallSpec(engine){
      try{
        const WW = window.WW || null;
        if (!WW) return;

        // Spec explícito para este motor
        const s = Object.assign({}, WALL_SPECS[engine] || WALL_BASE);

        // “outer” (largo lateral) 2×. Si WW.get() ya tiene uno, lo duplicamos.
        let outerAuto = null;
        try{
          const g = WW.get ? WW.get(engine) : null;
          if (g && g.params && typeof g.params.outer === 'number') outerAuto = g.params.outer;
        }catch(_){ }
        const fallbackOuter = (s.open + s.thickness * 2);   // aproximación razonable
        const outer2x = (outerAuto ? outerAuto * 2.0 : fallbackOuter * 2.0);

        // Intenta setters específicos si existen, y registra en SPECS
        if (!WW.SPECS) WW.SPECS = Object.create(null);
        WW.SPECS[engine] = { distance: s.distance, thickness: s.thickness, open: s.open, outer: outer2x };

        if (typeof WW.setDistance === 'function') WW.setDistance(engine, s.distance);
        if (typeof WW.setThickness === 'function') WW.setThickness(engine, s.thickness);
        if (typeof WW.setOpen === 'function')      WW.setOpen(engine,      s.open);
        if (typeof WW.setOuter === 'function')     WW.setOuter(engine,     outer2x);

        // Fuerza reconstrucción/aplicación si el módulo la expone
        if (typeof WW.apply === 'function')        WW.apply(engine);
        if (typeof WW.rebuild === 'function')      WW.rebuild(engine);
        if (typeof WW.update === 'function')       WW.update();
      }catch(_){ }
    }

    /* Helpers por motor – misma interfaz que las cámaras */
    function setWall_BUILD(){  applyWallSpec('BUILD'); }
    function setWall_FRBN(){   applyWallSpec('FRBN'); }
    function setWall_LCHT(){   applyWallSpec('LCHT'); }
    function setWall_OFFNNG(){ applyWallSpec('OFFNNG'); }
    function setWall_TMSL(){   applyWallSpec('TMSL'); }
    function setWall_RAUM(){   applyWallSpec('RAUM'); }
    function setWall_13245(){  applyWallSpec('13245'); }
    function setWall_KEPLR(){  applyWallSpec('KEPLR'); }
    function setWall_RAPHI(){  applyWallSpec('RAPHI'); }
    function setWall_R5NOVA(){ applyWallSpec('R5NOVA'); }
    function setWall_GRVTY(){  applyWallSpec('GRVTY'); }

    Object.assign(window, {
      setWall_BUILD, setWall_FRBN, setWall_LCHT, setWall_OFFNNG, setWall_TMSL,
      setWall_RAUM, setWall_13245, setWall_KEPLR, setWall_RAPHI, setWall_R5NOVA, setWall_GRVTY
    });

    /* Hook automático: cuando entras a un motor, aplica SU muro */
    (function installWallPerEngine(){
      const pairs = [
        ['toggleFRBN',   'isFRBN',   'setWall_FRBN'],
        ['toggleLCHT',   'isLCHT',   'setWall_LCHT'],
        ['toggleOFFNNG', 'isOFFNNG', 'setWall_OFFNNG'],
        ['toggleTMSL',   'isTMSL',   'setWall_TMSL'],
        ['toggleRAUM',   'isRAUM',   'setWall_RAUM'],
        ['toggle13245',  'is13245',  'setWall_13245'],
        ['toggleKEPLR',  'isKEPLR',  'setWall_KEPLR'],
        ['toggleRAPHI',  'isRAPHI',  'setWall_RAPHI'],
        ['toggleR5NOVA', 'isR5NOVA', 'setWall_R5NOVA'],
        ['toggleGRVTY',  'isGRVTY',  'setWall_GRVTY']
      ];
      pairs.forEach(([fname, flag, wset])=>{
        const fn = window[fname];
        if (typeof fn !== 'function' || fn.__wallHooked) return;
        window[fname] = function(...args){
          const wasOn = !!window[flag];
          const out   = fn.apply(this, args);
          const nowOn = !!window[flag];
          if (!wasOn && nowOn && typeof window[wset] === 'function'){
            window[wset]();
          }
          return out;
        };
        window[fname].__wallHooked = true;
      });

      // Para BUILD, interceptamos “switchToBuild” y “applyStandardView”
      ['switchToBuild','applyStandardView'].forEach(name=>{
        const fn = window[name];
        if (typeof fn !== 'function' || fn.__wallHooked) return;
        window[name] = function(...args){
          const out = fn.apply(this, args);
          try{ window.setWall_BUILD(); }catch(_){ }
          return out;
        };
        window[name].__wallHooked = true;
      });

      // Aplica de inicio el muro del motor activo (o BUILD si ninguno está ON)
      const applyInitial = ()=>{
        try{
          if (window.isFRBN)      return setWall_FRBN();
          if (window.isLCHT)      return setWall_LCHT();
          if (window.isOFFNNG)    return setWall_OFFNNG();
          if (window.isTMSL)      return setWall_TMSL();
          if (window.isRAUM)      return setWall_RAUM();
          if (window.is13245)     return setWall_13245();
          if (window.isKEPLR)     return setWall_KEPLR();
          if (window.isRAPHI)     return setWall_RAPHI();
          if (window.isR5NOVA)    return setWall_R5NOVA();
          if (window.isGRVTY)     return setWall_GRVTY();
          return setWall_BUILD();
        }catch(_){ }
      };
      applyInitial();
    })();

    function applyBuildCamera(eyeY = 0){
      camera.up.set(0,1,0);
      camera.near = 0.1;
      camera.far  = 4000;
      camera.fov  = BUILD_FOV;
      camera.updateProjectionMatrix();

      if (controls && controls.target) controls.target.set(0, eyeY, 0);
      camera.position.set(0, eyeY, BUILD_Z);

      if (controls){
        controls.enabled = true;
        controls.enableRotate = true;
        controls.enablePan    = true;
        controls.enableZoom   = true;
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = Math.PI;
        controls.screenSpacePanning = false;
        controls.update();
      }
    }

    // ——— Volver al BUILD “normal” (usa tu selector de vista)
    function restoreBuildView(){
      camera.up.set(0,1,0);
      camera.near = 0.1;
      camera.far  = 4000;
      camera.fov  = 75;                // tu FOV por defecto en BUILD/UI
      camera.updateProjectionMatrix();

      if (controls){
        controls.enabled = true;
        controls.enableRotate = true;
        controls.enablePan    = true;
        controls.enableZoom   = true;
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = Math.PI;
        controls.screenSpacePanning = false;
        controls.update();
      }
      // reposiciona según el dropdown (front/top/iso…)
      try { applyStandardView(); } catch(_){ }
    }

    // === BUILD render boost (solo activo en BUILD) ==============================
    let __buildBoostPrev = { pr: null, exp: null };

    function enterBuildRenderBoost(){
      if (!renderer || __buildBoostPrev.pr !== null) return;
      // Guarda para restaurar al salir de BUILD
      __buildBoostPrev.pr  = renderer.getPixelRatio();
      __buildBoostPrev.exp = renderer.toneMappingExposure;
      // Más nitidez y menos “quemado” SOLO en BUILD
      const PR = Math.min(window.devicePixelRatio || 1, 2.5);
      renderer.setPixelRatio(PR);
      renderer.toneMappingExposure = 0.90;    // baseline 0.95 → BUILD más controlado
    }

    function leaveBuildRenderBoost(){
      if (!renderer || __buildBoostPrev.pr === null) return;
      renderer.setPixelRatio(__buildBoostPrev.pr);
      renderer.toneMappingExposure = __buildBoostPrev.exp;
      __buildBoostPrev.pr = null; __buildBoostPrev.exp = null;
    }

    // === RAUM crispness boost (solo activo en RAUM) =============================
    let __raumBoostPrev = { pr: null, exp: null };

    function enterRaumRenderBoost(){
      if (!renderer || __raumBoostPrev.pr !== null) return;
      __raumBoostPrev.pr  = renderer.getPixelRatio();
      __raumBoostPrev.exp = renderer.toneMappingExposure;

      // Más nitidez SOLO en RAUM (cap prudente para FPS)
      const PR = Math.min(window.devicePixelRatio || 1, 2.75);
      renderer.setPixelRatio(PR);
      renderer.toneMappingExposure = 0.98;
    }

    function leaveRaumRenderBoost(){
      if (!renderer || __raumBoostPrev.pr === null) return;
      renderer.setPixelRatio(__raumBoostPrev.pr);
      renderer.toneMappingExposure = __raumBoostPrev.exp;
      __raumBoostPrev.pr = null; __raumBoostPrev.exp = null;
    }

    const GOLD = 137.50776405003785;      // ángulo áureo
    /*  razón áurea al cuadrado  ≈ 2.618…  */
    const PHI2 = 2.618033988749895;
    /* ——— salto coprimo con 144: barre los 144 valores de H ——— */
    const PHI_H = 89;             // 89 ≡ 144 / φ  (gcd 89,144 = 1)
    /* ——— saltos coprimos para los 12 niveles de S y V ——— */
    const PHI_S = 5;              // gcd(5,12) = 1
    const PHI_V = 7;              // gcd(7,12) = 1

    /* ═════════ CUADRÍCULA HSV 144·12·12 ═══════════════════════════════════ */
    const H_STEPS  = 144;                               // 360° / 2.5°
    const S_LEVELS = [...Array(12)].map((_,i)=>0.25 + 0.72*i/11); // 0.25 – 0.97
    const V_LEVELS = [...Array(12)].map((_,i)=>0.20 + 0.75*i/11); // 0.20 – 0.95

    /* ——— Discretización canónica para FRBN (catálogo de fases) ——— */
    const FRBN_K = 144;   // alineado con H_STEPS (2.5° × 144)

    function idxToHSV(hIdx,sIdx,vIdx){
      const h = ((hIdx%H_STEPS)+H_STEPS) % H_STEPS;      // 0-143
      return {
        h: h * 360 / H_STEPS,                            // 0-359.5 °
        s: S_LEVELS[ ((sIdx%12)+12)%12 ],
        v: V_LEVELS[ ((vIdx%12)+12)%12 ]
      };
    }

    /* ═════════ COLOR-FIELD 144 × 12 × 12  ═════════════════════════════ */
    /* Devuelve el color del «voxel HSV» que ocupa la posición p (mundo) */
    function colorFromVolume(p){
      const HALF = cubeSize / 2;          // ±15  (cubo 30×30×30 ya existe)
      const HX = 144, HY = 12, HZ = 12;   // rejilla 20 736 colores

      /* índices enteros en cada eje, envueltos al rango válido */
      const ix = ((Math.floor((p.x + HALF) / cubeSize * HX) % HX) + HX) % HX;
      const iy = ((Math.floor((p.y + HALF) / cubeSize * HY) % HY) + HY) % HY;
      const iz = ((Math.floor((p.z + HALF) / cubeSize * HZ) % HZ) + HZ) % HZ;

      /* HSV determinista → RGB → THREE.Color */
      const {h,s,v} = idxToHSV(ix, iy, iz);
      const [R,G,B] = hsvToRgb(h, s, v);
      return new THREE.Color(R/255, G/255, B/255);
    }

    /* Normaliza cualquier hue a rango [0 … 360) */
    function normHue(deg){
      return ((deg % 360) + 360) % 360;
    }

    /* ════════════════════════════════════════════════════════════════
       COLOR CONDITIONER · por patrón (local, determinista, sin hooks)
       — Trabaja en el espacio de ÍNDICES (H_idx, S_idx, V_idx)
       — Mantiene tu discretización original: H:144, S:12, V:12
       — NO altera funciones globales ni motores.
       — Determinismo: usa (patternId, slot, seed, sceneSeed, S_global).
       ════════════════════════════════════════════════════════════════ */

    const _SC_PI   = Math.PI;
    const _SC_TAU  = Math.PI * 2.0;

    /* Índices → valores de tu rejilla HSV */
    function _sc_idxToH(hIdx){ return (hIdx % 144) * 2.5; }         // grados
    function _sc_idxToS(sIdx){ return 0.25 + 0.72 * ( (sIdx%12) / 11 ); }
    function _sc_idxToV(vIdx){ return 0.20 + 0.75 * ( (vIdx%12) / 11 ); }

    /* Valores → índices de tu rejilla HSV (con clamp) */
    function _sc_HtoIdx(Hdeg){
      let h = Hdeg % 360; if (h < 0) h += 360;
      return Math.round(h / 2.5) % 144;
    }
    function _sc_StoIdx(S){
      const x = (S - 0.25) / 0.72;                // 0..1 ideal
      return Math.max(0, Math.min(11, Math.round(x * 11)));
    }
    function _sc_VtoIdx(V){
      const x = (V - 0.20) / 0.75;                // 0..1 ideal
      return Math.max(0, Math.min(11, Math.round(x * 11)));
    }

    /* HSV → RGB (para ajuste suave de luminancia) */
    function _sc_hsv2rgb(Hdeg, S, V){
      const h = ( (Hdeg % 360) + 360 ) % 360 / 60.0;
      const c = V * S;
      const x = c * (1 - Math.abs((h % 2) - 1));
      const m = V - c;
      let r=0,g=0,b=0;
      if      (h < 1){ r=c; g=x; b=0; }
      else if (h < 2){ r=x; g=c; b=0; }
      else if (h < 3){ r=0; g=c; b=x; }
      else if (h < 4){ r=0; g=x; b=c; }
      else if (h < 5){ r=x; g=0; b=c; }
      else           { r=c; g=0; b=x; }
      return [r+m, g+m, b+m];
    }

    /* Luma (Rec.709) */
    function _sc_lumaRGB(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }

    /* Envuelve diferencia angular en [-180, +180] */
    function _sc_angDiff(a, b){
      let d = (a - b) % 360; if (d < -180) d += 360; if (d > 180) d -= 360; return d;
    }

    /* Semilla determinista suave (0..1) desde escena + patrón + slot */
    function _sc_hash01(patternId, slot, seed){
      const sceneSeedVal = (typeof sceneSeed !== 'undefined') ? (sceneSeed|0) : 0;
      const SGlobalVal = (typeof S_global !== 'undefined') ? (S_global|0) : 0;
      const a = sceneSeedVal, b = SGlobalVal;
      let x = ( (a*73856093) ^ (b*19349663) ^ (patternId*83492791) ^ (slot*2971215073) ^ (seed*1664525) ) >>> 0;
      // LCG un paso
      x = (Math.imul(x, 1664525) + 1013904223) >>> 0;
      return (x & 0xFFFFFF) / 0xFFFFFF; // 0..1
    }

    /* Tabla de “intenciones” por patrón (resumen de tu teoría)
       spanH:   compresión/expansión del abanico angular (1=sin cambio)
       sMean/vMean: medias objetivo
       sTight/vTight: 0..1 (0 = no mover, 1 = llevar a la media)
       luma:   luminancia objetivo (0..1, ajuste leve)
       mode:   estrategia de separación (none | altHiLo | jitter | narrow)
    */
    const _SC_POLICY = {
      1:  { spanH:0.75, sMean:0.62, vMean:0.78, sTight:0.35, vTight:0.35, luma:0.68, mode:'narrow' },        // Contención estructural
      2:  { spanH:1.40, sMean:0.70, vMean:0.72, sTight:0.15, vTight:0.10, luma:0.64, mode:'altHiLo' },       // Contraste & Disonancia
      3:  { spanH:1.00, sMean:0.55, vMean:0.72, sTight:0.30, vTight:0.30, luma:0.66, mode:'none' },          // Disposición no semántica
      4:  { spanH:0.85, sMean:0.58, vMean:0.74, sTight:0.30, vTight:0.30, luma:0.67, mode:'jitter' },        // Ambigüedad estructurada
      5:  { spanH:0.60, sMean:0.52, vMean:0.76, sTight:0.45, vTight:0.35, luma:0.68, mode:'narrow' },        // Campo sin centro
      6:  { spanH:1.10, sMean:0.64, vMean:0.80, sTight:0.25, vTight:0.25, luma:0.70, mode:'none' },          // Presencia autosuficiente
      7:  { spanH:0.95, sMean:0.60, vMean:0.76, sTight:0.25, vTight:0.25, luma:0.68, mode:'altHiLo' },       // Asimetría asociativa
      8:  { spanH:1.20, sMean:0.66, vMean:0.78, sTight:0.20, vTight:0.25, luma:0.69, mode:'jitter' },        // Dinámica irregular
      9:  { spanH:0.80, sMean:0.56, vMean:0.74, sTight:0.35, vTight:0.30, luma:0.67, mode:'narrow' },        // Habitable sin traducción
      10: { spanH:0.90, sMean:0.60, vMean:0.78, sTight:0.25, vTight:0.30, luma:0.69, mode:'jitter' },        // Resonancia
      11: { spanH:0.95, sMean:0.48, vMean:0.86, sTight:0.40, vTight:0.30, luma:0.75, mode:'none' }           // Transparencia activa
    };

    /* Acondicionador principal: recibe índices crudos del patrón y devuelve
       NUEVOS índices (H_idx, S_idx, V_idx) ya ajustados al patrón. */
    function conditionHSV(hIdx, sIdx, vIdx, patternId, slot, seed){
      const pol = _SC_POLICY[patternId] || _SC_POLICY[1];

      // 1) Índices → valores
      let H = _sc_idxToH(hIdx);   // grados
      let S = _sc_idxToS(sIdx);
      let V = _sc_idxToV(vIdx);

      // 2) Ancla y span de H (determinista por escena / patrón / slot)
      const sceneSeedVal = (typeof sceneSeed !== 'undefined') ? (sceneSeed|0) : 0;
      const SGlobalVal = (typeof S_global !== 'undefined') ? (S_global|0) : 0;
      const baseAnchor = ((37*sceneSeedVal + 53*SGlobalVal + 11*patternId + 7*(slot|0)) % 144) * 2.5; // deg
      const d = _sc_angDiff(H, baseAnchor);            // [-180,180]
      H = baseAnchor + d * pol.spanH;

      // 3) Ajuste de S/V hacia medias (mezcla controlada)
      S = S + (pol.sMean - S) * pol.sTight;
      V = V + (pol.vMean - V) * pol.vTight;

      // 4) Separación/variación determinista por “modo”
      const r = _sc_hash01(patternId, slot, seed) - 0.5;   // [-0.5,0.5]
      if (pol.mode === 'altHiLo'){
        const sign = (slot % 2 === 0) ? +1 : -1;
        S = Math.max(0.25, Math.min(0.97, S + sign * (0.08 + 0.04*r)));
        V = Math.max(0.20, Math.min(0.98, V + sign * (0.05 + 0.03*r)));
        // empujón extra en H para ΔH grande
        H += sign * (18 + 8*r); // grados
      }else if (pol.mode === 'jitter'){
        // irregularidad leve, sin crear foco
        H += (8 * r);
        S = Math.max(0.25, Math.min(0.97, S + 0.04*r));
        V = Math.max(0.20, Math.min(0.98, V + 0.03*r));
      }else if (pol.mode === 'narrow'){
        // span ya lo hace; micro-variación para evitar coincidencias exactas
        H += (4 * r);
      }

      // 5) Luma objetivo (ajuste MUY leve sobre V manteniendo S/H)
      //    — calculamos luma actual y acercamos a pol.luma
      {
        const [rC,gC,bC] = _sc_hsv2rgb(H, Math.max(0,Math.min(1,S)), Math.max(0,Math.min(1,V)));
        const Y = _sc_lumaRGB(rC, gC, bC);
        const dY = pol.luma - Y;
        // ganancia pequeña para no “romper” la paleta (máx ±0.06 aprox)
        V = Math.max(0.20, Math.min(0.98, V + 0.20 * dY));
      }

      // 6) Volver a ÍNDICES (clamp a tu rejilla discreta)
      const Hn = _sc_HtoIdx(H);
      const Sn = _sc_StoIdx(S);
      const Vn = _sc_VtoIdx(V);
      return [Hn, Sn, Vn];
    }


    /* ═════════ 11 patrones cromáticos — versión PHI_H (89) + acondicionador local ═════════ */
const PATTERNS = {
  1: (sig, seed, i) => {
    const base = (sig.reduce((a,v)=>a+v,0) + seed*7) % 144;
    const hIdx = (base + (i%12)*6) % 144;
    const sIdx = (sig[3] + seed + i) % 12;
    const vIdx = (sig[1] + sig[4] + i) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 1, i, seed);
  },

  2: (sig, seed, i) => {
    const base = (sig[0]*17 + seed*5) % 144;
    const hIdx = (base + ((i%12)*48)) % 144;
    const sIdx = (sig[1] + i*3 + seed) % 12;
    const vIdx = (sig[2]*2 + i + seed) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 2, i, seed);
  },

  3: (s,seed,i) => {
    const b = (s[2]*13 + seed*5 + i*11) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[0] + i*2 + seed) % 12;
    const vIdx = (s[1] + s[3] + i)   % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 3, i, seed);
  },

  4: (s,seed,i) => {
    const b = (s[1]*15 + seed*3 + i*7) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[0] + seed + i) % 12;
    const vIdx = (s[2] + s[4] + seed + i) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 4, i, seed);
  },

  5: (s,seed,i) => {
    const b = (i*31 + s[3]*13 + seed*5) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[1] + seed + i) % 12;
    const vIdx = (s[2] + seed + i) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 5, i, seed);
  },

  6: (s,seed,i) => {
    const b = (s[1]*31 + seed*13 + i*7) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[2] + seed + i) % 12;
    const vIdx = (s[3] + s[4] + seed + i) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 6, i, seed);
  },

  7: (s,seed,i) => {
    const b = (s[0]*11 + seed*3 + i*37) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[2] + seed + i*2) % 12;
    const vIdx = (s[4] + s[1]*2 + seed + i) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 7, i, seed);
  },

  8: (s,seed,i) => {
    const r = Math.abs(s[4]-s[0]) + Math.abs(s[3]-s[1]) + s[2];
    const b = (r*13 + seed*7) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[1]*3 + seed + i*2) % 12;
    const vIdx = (s[3] + i*5 + seed*3) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 8, i, seed);
  },

  9: (s,seed,i) => {
    const b = (s[4]*12 + seed*7 + i*11) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[2] + seed + i) % 12;
    const vIdx = (s[1] + seed + i*2) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 9, i, seed);
  },

 10: (s,seed,i) => {
    const b = (seed*5 + s.reduce((a,v)=>a+v,0)*3 + i*7) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[2] + seed + i) % 12;
    const vIdx = (s[4]*2 + seed + i*3) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 10, i, seed);
  },

 11: (s,seed,i) => {
    const b = (s[3]*13 + seed*11 + i*7) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[0] + seed + i)   % 12;
    const vIdx = (s[1] + seed + i*2) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 11, i, seed);
  }
};

/* ---------- BLOQUE DE UTILIDADES COLOR v1.3-RC2 ---------- */
const ANG7 = [
  [0,0,0,0,0,0,0],                         // monocromo (idx 0)
  [0,30,60,90,120,150,180],                // análoga
  [0,180,0,180,0,180,0],                   // complementaria
  [0,150,210,0,150,210,0],                 // comp. dividida
  [0,120,240,60,180,300,30],               // tríada
  [0,90,180,270,45,135,225],               // cuadrado
  [0,0,0,0,0,0,0]                          // “tonos” (misma H, S escalado)
];
function rgbToHsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min;
  let h=0;
  if(d){
    if(max===r) h=((g-b)/d)%6;
    else if(max===g) h=(b-r)/d+2;
    else h=(r-g)/d+4;
    h*=60; if(h<0) h+=360;
  }
  const s=max?d/max:0, v=max;
  return [h,s,v];
}
function hsvToRgb(h,s,v){
  h = h % 360;
  const c=v*s, x=c*(1-Math.abs((h/60)%2-1)), m=v-c;
  let [r,g,b]=[0,0,0];
  if(h<60){r=c;g=x;} else if(h<120){r=x;g=c;}
  else if(h<180){g=c;b=x;} else if(h<240){g=x;b=c;}
  else if(h<300){r=x;b=c;} else {r=c;b=x;}
  return [(r+m)*255,(g+m)*255,(b+m)*255].map(v=>Math.round(v));
}
function hsvToHex({h,s,v}){
  const [r,g,b] = hsvToRgb(h,s,v);
  return '#'+new THREE.Color(r/255,g/255,b/255).getHexString();
}
/* contraste CIE76 */
function deltaE(lab1,lab2){
  return Math.sqrt(
    (lab1[0]-lab2[0])**2+
    (lab1[1]-lab2[1])**2+
    (lab1[2]-lab2[2])**2
  );
}
function rgbToLab(r,g,b){                      // aproximación rápida
  const xyz=[r/255,g/255,b/255].map(v=>{
    v=v>0.04045?((v+0.055)/1.055)**2.4:v/12.92;
    return v*100;
  });
  const x=xyz[0]*0.4124+xyz[1]*0.3576+xyz[2]*0.1805;
  const y=xyz[0]*0.2126+xyz[1]*0.7152+xyz[2]*0.0722;
  const z=xyz[0]*0.0193+xyz[1]*0.1192+xyz[2]*0.9505;
  const xyzN=[95.047,100.0,108.883];
  const f= t=> t>0.008856 ? t**(1/3) : (7.787*t)+16/116;
  const [fx,fy,fz]=[x,y,z].map((v,i)=>f(v/xyzN[i]));
  return [116*fy-16, 500*(fx-fy), 200*(fy-fz)];
}

/* ======  NUEVO  — utilidades de contraste con el FONDO  ====== */
const ΔE_BG_MIN = 22;          // contraste mínimo CIE76

function hexToRgb(hex){
  const m = /^#?([0-9a-f]{6})$/i.exec(hex);
  const n = parseInt(m[1],16);
  return [(n>>16)&255, (n>>8)&255, n&255];
}

/**
 * Sube o baja la luminosidad (v) del color RGB recibido hasta que
 * alcance ΔE_BG_MIN puntos de contraste contra el fondo actual.
 * Devuelve el RGB corregido.
 */
function ensureContrastRGB(rgb){
  /* color de fondo efectivo */
  let bgRgb;
  if (bgOverride) {
    bgRgb = hexToRgb(bgOverride);
  } else if (scene && scene.background && scene.background.isColor) {
    // fondo actual de THREE.Color (incluye el gris de LCHT)
    bgRgb = [
      Math.round(scene.background.r * 255),
      Math.round(scene.background.g * 255),
      Math.round(scene.background.b * 255)
    ];
  } else {
    bgRgb = hsvToRgb(bgHSV.h, bgHSV.s, bgHSV.v);
  }

  let [h,s,v] = rgbToHsv(rgb[0], rgb[1], rgb[2]);  // pasamos a HSV
  let tries = 0;
  while (deltaE(rgbToLab(...rgb), rgbToLab(...bgRgb)) < ΔE_BG_MIN && tries < 24){
    // alterna aclarar / oscurecer en pasos de 0.04
    v = (tries % 2) ? Math.max(0, v - 0.04) : Math.min(1, v + 0.04);
    rgb = hsvToRgb(h, s, v);
    tries++;
  }
  return rgb;
}
/* ---------- FIN BLOQUE UTILIDADES ---------- */
/* ——— calcula HSV para fondo y paredes de forma acoplada al set activo ——— */
function rebuildSceneColours(){
  // Permutaciones activas (en el mismo orden visual)
  const perms = Array.from(document.getElementById('permutationList').selectedOptions)
                     .map(o => o.value.split(',').map(Number));

  // Firmas para fondo/cubo (si no hay, usa dummy neutra)
  const firstSig = perms[0] ? computeSignature(perms[0]) : [0,0,0,0,0];
  const lastSig  = perms.length > 1 ? computeSignature(perms[perms.length-1]) : firstSig;

  // Slots acoplados al tamaño del set (idéntico a BUILD + spreads coprimos)
  let [h1,s1,v1] = PATTERNS[activePatternId](firstSig, sceneSeed, perms.length);
  let [h2,s2,v2] = PATTERNS[activePatternId](lastSig,  sceneSeed, perms.length + 1);

  s1 = (s1 * PHI_S) % 12;  v1 = (v1 * PHI_V) % 12;
  s2 = (s2 * PHI_S) % 12;  v2 = (v2 * PHI_V) % 12;

  bgHSV   = idxToHSV(h1, s1, v1);   // ← Fondo = “slot #n” con firma del primero
  wallHSV = idxToHSV(h2, s2, v2);   // ← Paredes = “slot #n+1” con firma del último
}

/* ===\u2003UTIL extra — firma normalizada y contraste\u2003===================== */
// 1)  f̂  de un glifo  →  promedio firma, llevada a [0-1]
function normFhat(sig){           // sig = [f1…f5] entre 2 y 10
  const avg = sig.reduce((a,b)=>a+b,0)/sig.length;   // 2 … 10
  return (avg-2)/8;                                  // 0 … 1
}

// 2)  pinza a [0,1]
function clamp01(x){ return Math.max(0, Math.min(1,x)); }

/* ———————————————————————————————————————————————— *
 * Devuelve el valor de una propiedad que puede ser:
 *   · número → se usa tal cual
 *   · función → se evalúa con los argumentos dados
 * fallback se usa si la propiedad es null/undefined.
 * ———————————————————————————————————————————————— */
function evalProp(prop, args = [], fallback = 0){
  return (typeof prop === 'function') ? prop(...args) :
         (prop ?? fallback);
}

/* contrast-fix eliminado: función ensureContrast() suprimida */
    const minRangeValue = 2, maxRangeValue = 6;
    const shapeMapping = {
      1:{w:4.5,h:4.5},
      2:{w:4.5,h:4.5*Math.sqrt(2)},
      3:{w:4.5,h:4.5*Math.sqrt(3)},
      4:{w:4.5,h:4.5*Math.sqrt(4)},
      5:{w:4.5,h:4.5*Math.sqrt(5)}
    };

    function sumXYZ(pa,map){
      return pa[ map[2] ] + pa[ map[3] ] + pa[ map[4] ];
    }

    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function mapRangeToSpeed(r,mn,mx){return 0.001 + (r-mn)*(0.005-0.001)/(mx-mn);}
    /* === BUILD → paso angular por frame para una permutación (permStr "1,2,3,4,5") === */
    function getBuildRotStep(permStr){
      try{
        if (!permutationGroup || !permutationGroup.children || !permStr) return 0;
        for (let i = 0; i < permutationGroup.children.length; i++){
          const m = permutationGroup.children[i];
          if (m && m.userData && m.userData.permStr === permStr){
            const s = m.userData.rotationSpeed;
            return (typeof s === 'number') ? s : 0;   // Δθ por frame (mismo que BUILD)
          }
        }
      }catch(_){ }
      return 0;
    }
    function shuffle(a){for(let i=a.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

    function getPermutations(arr){
      if(arr.length===1) return [arr];
      let res=[]; for(let i=0;i<arr.length;i++){
        const c=arr[i], rem=arr.slice(0,i).concat(arr.slice(i+1));
        for(const p of getPermutations(rem)) res.push([c].concat(p));
      }
      return res;
    }
    const allPermutations = getPermutations([1,2,3,4,5]);
    const permutationStrings = allPermutations.map(p=>p.join(','));

    function getAttributeMappings(a){
      if(a.length===1) return [a];
      let res=[]; for(let i=0;i<a.length;i++){
        const c=a[i], rem=a.slice(0,i).concat(a.slice(i+1));
        for(const m of getAttributeMappings(rem)) res.push([c].concat(m));
      }
      return res;
    }

    function populatePermutationList(){
      const sel = document.getElementById('permutationList');
      sel.innerHTML = '';
      permutationStrings.forEach((ps,i)=>{
        const o=document.createElement('option');
        o.value=ps; o.text=`Permutación ${i+1}: (${ps})`;
        if(i===0) o.selected=true;
        sel.appendChild(o);
      });
    }
    function populateAttributeMappingSelect(){
      const sel = document.getElementById('attrMapping');
      sel.innerHTML = '';
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        const s=m.join(','), o=document.createElement('option');
        o.value=s; o.text=`Opción: [${s}]`;
        if(s==='0,1,2,3,4') o.selected=true;
        sel.appendChild(o);
      });
      updateTopRightDisplay();
    }

    function computeSignature(a){let s=[];for(let i=0;i<a.length;i++) s.push(a[i]+a[(i+1)%a.length]);return s;}
    function computeRange(sig){return Math.max(...sig)-Math.min(...sig);}

    const FACT=[1,1,2,6,24,120];
    let sceneSeed=0;
    function lehmerRank(p){
      let r=0;
      for(let i=0;i<p.length;i++){
        let c=0;
        for(let j=i+1;j<p.length;j++) if(p[j]<p[i]) c++;
        r+=c*FACT[p.length-1-i];
      }
      return r;
    }

    /* ========= NUEVO: sceneSeed orden‑invariante + dependiente del mapping ========= */

    /** Rank del mapping [m0..m4] usando Lehmer rank sobre [m_i+1] (1..5) */
    function mappingRank(m){
      const arr = [m[0]+1, m[1]+1, m[2]+1, m[3]+1, m[4]+1];
      return lehmerRank(arr);
    }

    /** sceneSeed = (37·sumR + 101·sumR2 + 53·mRank) mod 360  (orden‑invariante) */
    function computeSceneSeedFrom(perms, m){
      let sumR = 0, sumR2 = 0;
      perms.forEach(pa=>{
        const r = lehmerRank(pa);
        sumR  += r;
        sumR2 += r*r;
      });
      const mRank = mappingRank(m);
      return (37*sumR + 101*sumR2 + 53*mRank) % 360;
    }

    /** S = ( Σ (P_{mx}+P_{my}+P_{mz}) ) mod 125  — usa los índices x,y,z del mapping */
    function computeGlobalS(perms, m){
      const mx = m[2], my = m[3], mz = m[4];
      let S = 0;
      perms.forEach(p=>{
        S += p[mx] + p[my] + p[mz];
      });
      return S % 125;
    }

    /* ===== Seed determinista para el LAYOUT (R5NOVA · tilers) =====
       Usa exactamente las mismas invariantes globales que ya gobiernan color/posiciones
       (sceneSeed, S_global, mappingRank) + stats del set (sumR, sumSig, n).
       Devuelve un entero U32 para el PRNG del motor de layout. */
    function computeLayoutSeed(){
      const perms = Array.from(document.getElementById('permutationList').selectedOptions)
                         .map(o => o.value.split(',').map(Number));
      const mRank = mappingRank(attributeMapping.slice(0,5));

      let sumR = 0, sumSig = 0;
      perms.forEach(p=>{
        const r = lehmerRank(p);
        sumR += r;
        const s = computeSignature(p);
        sumSig += s.reduce((a,b)=>a+b,0);
      });

      // mezcla (sin colisiones obvias) → U32
      let x = 0 >>> 0;
      x = (x ^ (sceneSeed * 1315423911)) >>> 0;
      x = (x ^ ((S_global   *  374761393) >>> 0)) >>> 0;
      x = (x ^ ((perms.length * 668265263) >>> 0)) >>> 0;
      x = (x ^ ((mRank      *     362437) >>> 0)) >>> 0;
      x = (x ^ ((sumR       * 1013904223) >>> 0)) >>> 0;
      x = (x ^ ((sumSig     *  224682251) >>> 0)) >>> 0;
      return x >>> 0;
    }
    function computeShiftRankXYZ(p){
      const r = lehmerRank(p);
      const I = (r + sceneSeed + S_global) % 125;   // <<< NUEVO: acoplado a S_global
      const x = Math.floor(I/25),
            y = Math.floor((I%25)/5),
            z = I%5;
      const step = cubeSize/5;
      return [
        (x-2)*step,
        (y-2)*step,
        (z-2)*step
      ];
    }

    function getSelectedPerms(){
      return Array.from(document.getElementById('permutationList').selectedOptions)
                  .map(o => o.value.split(',').map(Number));
    }
    function raumSignatures(){
      const perms = getSelectedPerms();
      const sigs  = perms.map(p => computeSignature(p));
      return sigs.length ? sigs : [[0,0,0,0,0]];
    }
    function raumStats(){
      const perms = getSelectedPerms();
      let sumR=0, sumR2=0;
      perms.forEach(p => { const r = lehmerRank(p); sumR += r; sumR2 += r*r; });
      const mRank = mappingRank(attributeMapping.slice(0,5));
      const slot0 = perms.length;
      return { perms, sumR, sumR2, mRank, slot0 };
    }
    /* Color determinista para el elemento k de RAUM (k=1..7) */
    function raumColorFor(k){
      const sigs = raumSignatures();
      const { slot0 } = raumStats();
      const sig  = sigs[(k-1) % sigs.length];
      let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot0 + k);
      sI = (sI * PHI_S) % 12;
      vI = (vI * PHI_V) % 12;
      const {h,s,v} = idxToHSV(hI, sI, vI);
      let rgb = hsvToRgb(h,s,v);
      rgb = ensureContrastRGB(rgb);
      return new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255);
    }

    function setActivePattern(id){
      activePatternId = parseInt(id,10);
      refreshAll({rebuild:false});
    }
    function updateTopRightDisplay(){
      const cfg=`Atributos: [${attributeMapping.slice(0,5).join(',')}]`;
      const rt =`Calificación: ${userRating?userRating:'Aún no calificada'}`;
      let info='';
      Array.from(document.getElementById('permutationList').selectedOptions).forEach(o=>{
        const pa=o.value.split(',').map(Number),
              sig=computeSignature(pa),
              rg=computeRange(sig);
        info+=`<div style="margin:2px 0;">Perm (${o.value}) | Firma [${sig.join(', ')}] | Rango ${rg}</div>`;
      });
      document.getElementById('topRightDisplay').innerHTML = cfg+'<br>'+rt+'<br>'+info;
    }

    function createPermutationObjectWithMapping(pa,map){
      const fv=pa[map[0]], cv=pa[map[1]],
            d=shapeMapping[fv], w=d.w, h=d.h, t=0.5;

      // --- COLOR determinista (cuadrícula HSV) ---
      let rgb;
      if(activePatternId === 0){
        rgb = paletteRGB[cv-1] || [255,255,255];
      }else{
        const sig  = computeSignature(pa);
        const slot = lehmerRank(pa) % 12;      // 0-11
        let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
        sI = (sI * PHI_S) % 12;
        vI = (vI * PHI_V) % 12;
        const {h,s,v} = idxToHSV(hI,sI,vI);
        rgb = hsvToRgb(h,s,v);
      }
      // Contraste mínimo contra el fondo actual
      rgb = ensureContrastRGB(rgb);

      // --- POSICIÓN (antes de material para calcular frontalidad) ---
      const [X,Y,Z]=computeShiftRankXYZ(pa);

      // --- BUILD · Vibrance v2: saturación fuerte sin quemar y sin spec blanco ---
      const zNorm = (Z + halfCube) / cubeSize;               // -15→0 · +15→1

      // 1) Partimos del RGB con contraste mínimo contra fondo
      let [h0, s0, v0] = rgbToHsv(rgb[0], rgb[1], rgb[2]);

      // 2) Vibrance: sube S con más fuerza cuanto más baja sea S (y un plus por frontalidad)
      const vib = 0.22 + 0.10 * zNorm;                       // 0.22…0.32
      const s1  = Math.min(1, s0 + vib * (1 - s0));

      // 3) Brillo controlado: ligero boost pero con techo para evitar “quemados” en ACES
      const v1  = Math.min(0.93, v0 * (1.02 + 0.06 * zNorm));

      // 4) Volvemos a RGB
      const rgbBoost = hsvToRgb(h0, s1, v1);

      // 5) Material difuso (Lambert) → colores más limpios y saturados (sin specular blanco)
      const mat = new THREE.MeshLambertMaterial({
        color: new THREE.Color(rgbBoost[0]/255, rgbBoost[1]/255, rgbBoost[2]/255),
        dithering: true
      });

      // Pequeña auto-luminancia para “energía” sin quemar (mucho menor que antes)
      mat.emissive = new THREE.Color(rgbBoost[0]/255, rgbBoost[1]/255, rgbBoost[2]/255);
      mat.emissiveIntensity = 0.03 + 0.12 * zNorm;   // antes 0.08 + 0.30*zNorm

      const geo=new THREE.BoxGeometry(w,h,t);
      const mesh=new THREE.Mesh(geo,mat);
      mesh.position.set(
        clamp(X,-halfCube+w/2,halfCube-w/2),
        clamp(Y,-halfCube+h/2,halfCube-h/2),
        clamp(Z,-halfCube+t/2,halfCube-t/2)
      );

      const sig=computeSignature(pa), rg=computeRange(sig);
      mesh.userData={permStr:pa.join(','), signature:sig, range:rg, rotationSpeed:mapRangeToSpeed(rg,minRangeValue,maxRangeValue)};
      return mesh;
    }
    function createPermutationObject(pa){ return createPermutationObjectWithMapping(pa,attributeMapping); }

    function checkCollisionsInGroup(g){
      for(let i=0;i<g.children.length;i++){
        const b1=new THREE.Box3().setFromObject(g.children[i]);
        for(let j=i+1;j<g.children.length;j++){
          const b2=new THREE.Box3().setFromObject(g.children[j]);
          if(b1.intersectsBox(b2)) return true;
        }
      }
      return false;
    }
    function autoResolveColisionesGlobal(){
      let found=null;
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        if(found) return;
        const cm=[m[0],m[1],m[2],m[3],m[4], attributeMapping[5], attributeMapping[6]],
              tg=new THREE.Group(),
              opts=Array.from(document.getElementById('permutationList').selectedOptions);
        opts.forEach((o)=>{
          const pa=o.value.split(',').map(Number),
                mo=createPermutationObjectWithMapping(pa,cm);
          tg.add(mo);
        });
        if(!checkCollisionsInGroup(tg)) found=cm;
      });
      if(found){
        attributeMapping=found;
        document.getElementById('attrMapping').value=`${found[0]},${found[1]},${found[2]},${found[3]},${found[4]}`;
        refreshAll({rebuild:true}); updateTopRightDisplay();
      } else {
        showPopup("No se encontró reorganización sin colisiones.",7000);
      }
    }

/* ==============================
 * 120 Architectural Permutations
 * ============================== */
let perm120List = getAttributeMappings([0,1,2,3,4]); // 120
let perm120Index = 0;
let perm120Timer = null;

function togglePerm120Panel(){
  const p = document.getElementById('perm120Panel');
  const isHidden = (p.style.display === 'none' || !p.style.display);
  p.style.display = isHidden ? 'block' : 'none';

  // Re‑muestra siempre el cursor personalizado
  const cc = document.getElementById('customCursor');
  if (cc) cc.style.display = 'block';
}

function msFromUI(){
  const slider = document.getElementById('perm120Slider');
  return parseInt(slider.value, 10);
}
function syncPerm120InputsFromSlider(){
  const ms = msFromUI();
  document.getElementById('perm120Seconds').value = Math.round(ms/1000);
}
function syncPerm120SliderFromSeconds(){
  const sec = parseInt(document.getElementById('perm120Seconds').value,10) || 1;
  const clamped = Math.max(1, Math.min(720, sec));
  document.getElementById('perm120Seconds').value = clamped;
  document.getElementById('perm120Slider').value = clamped * 1000;
}

function updatePerm120Status(){
  const stat = document.getElementById('perm120Status');
  if(stat) stat.textContent = `Permutation: ${perm120Index} / 119`;
}

function applyPerm120Index(i){
  perm120Index = ((i % perm120List.length) + perm120List.length) % perm120List.length;
  const m = perm120List[perm120Index];
  attributeMapping = [m[0], m[1], m[2], m[3], m[4], attributeMapping[5], attributeMapping[6]];
  document.getElementById('attrMapping').value = m.join(',');
  refreshAll({rebuild:true});
  updatePerm120Status();
}

function nextPerm120(){ applyPerm120Index(perm120Index + 1); }
function prevPerm120(){ applyPerm120Index(perm120Index - 1); }

function playPerm120(){
  if(perm120Timer) return;
  const interval = msFromUI();
  perm120Timer = setInterval(nextPerm120, interval);
  nextPerm120();
}
function pausePerm120(){
  if(perm120Timer){
    clearInterval(perm120Timer);
    perm120Timer = null;
  }
}

async function showPerm120Info(){
  try{
    const text = await loadTextPartial('./texts/perm120-info.txt');
    alert(text);
  }catch(err){
    alert('Error cargando perm120-info.txt');
    console.error(err);
  }
}


    /* ============================================================
     *  MONTE-CARLO: buscar una escena aleatoria SIN colisiones
     *  ============================================================
     */

    /** Construye un grupo temporal con un mapping dado, sin tocar la escena real */
      const mappings = getAttributeMappings([0,1,2,3,4]);
function buildTempGroup(perms, mapping){
  const tg = new THREE.Group();

  // Guardamos estado global
  const prevSeed = sceneSeed;
  const prevS    = S_global;
  const prevMap  = attributeMapping.slice();

  // Calculamos los nuevos valores teóricos
  const tmpSeed = computeSceneSeedFrom(perms, mapping);
  const tmpS    = computeGlobalS(perms, mapping);

  // Seteamos temporalmente los globales para que createPermutationObjectWithMapping
  // use exactamente la misma lógica que la escena final:
  sceneSeed        = tmpSeed;
  S_global         = tmpS;
  attributeMapping = mapping;

  perms.forEach(pa=>{
    const mesh = createPermutationObjectWithMapping(pa, mapping);
    tg.add(mesh);
  });

  // Restauramos
  sceneSeed        = prevSeed;
  S_global         = prevS;
  attributeMapping = prevMap;

  return tg;
}

function findCollisionFreeMapping(perms){
  const mappings = getAttributeMappings([0,1,2,3,4]);
  for(const m of mappings){
    const cm = [m[0], m[1], m[2], m[3], m[4], attributeMapping[5], attributeMapping[6]];
    const tg = buildTempGroup(perms, cm);
    if(!checkCollisionsInGroup(tg)) return cm;
  }
  return null;
}
    /** Selecciona un subconjunto aleatorio de permutaciones (1..25) */
    function pickRandomPerms(){
      const n  = Math.floor(Math.random()*25) + 1;
      const out = [];
      for(let i=0;i<n;i++){
        const str = permutationStrings[Math.floor(Math.random()*permutationStrings.length)];
        out.push(str.split(',').map(Number));
      }
      return out;
    }

    /**
     * Búsqueda iterativa:
     *  - elige un set aleatorio de permutaciones
     *  - prueba todos los mappings
     *  - si alguno no choca, lo aplica y termina
     *
     * No bloquea la UI gracias al pequeño await en cada iteración.
     */
    async function generateRandomConfigurationNoCollision(MAX_TRIES = 5000){
      // Elegimos un patrón cromático aleatorio (1..11, evitando el legacy 0)
      const randPattern = Math.floor(Math.random() * 11) + 1;

      let round = 0;
      while (true) { // sigue intentando hasta que realmente encuentre una sin colisiones
        round++;
        for (let t = 0; t < MAX_TRIES; t++) {
          showPopup(`Buscando configuración sin colisiones… (ronda ${round}, intento ${t+1})`, 500);

          const perms   = pickRandomPerms();
          const mapping = findCollisionFreeMapping(perms);

          if (mapping) {
            // 1) Setea el patrón cromático escogido
            activePatternId = randPattern;
            const selPattern = document.getElementById('patternSelect');
            if (selPattern) selPattern.value = String(randPattern);

            // 2) Pon las permutaciones en el <select>
            const sel = document.getElementById('permutationList');
            Array.from(sel.options).forEach(o => o.selected = false);
            perms.forEach(p=>{
              const val = p.join(',');
              const opt = sel.querySelector(`option[value="${val}"]`);
              if(opt) opt.selected = true;
            });

            // 3) Aplica el mapping encontrado
            attributeMapping = mapping;

            // mantenemos tu ciclo de atributo "color"
            attributeMapping[1] = colorAttrCycle % 5;
            colorAttrCycle++;

            document.getElementById('attrMapping').value =
              `${attributeMapping[0]},${attributeMapping[1]},${attributeMapping[2]},${attributeMapping[3]},${attributeMapping[4]}`;

            // 4) Reconstruye escena completa
            refreshAll({rebuild:true});

            // 5) Verificación final (por si acaso)
            const hasCol = checkCollisionsInGroup(permutationGroup);
            if (!hasCol) {
              /*  ▸ YA NO se desactiva el motor actual.
               *    Si el usuario estaba en FRBN o LCHT, sigue allí.
               *    BUILD sólo se activa cuando se pulsa explícitamente el botón BUILD. */
              showPopup("¡Configuración sin colisiones encontrada!", 2000);
              return true;
            }
          }

          // cede el hilo para no congelar la UI
          if ((t % 25) === 0) await new Promise(r => setTimeout(r, 0));
        }
        // pequeña pausa entre rondas largas
        await new Promise(r => setTimeout(r, 10));
      }
    }

    function showPopup(msg, dur = 2000){
      dur = Math.max(dur, 3000); // ← asegura al menos 3 segundos
      const p = document.getElementById('hoverPopup');
      p.style.display = "block";
      p.style.opacity = 1;
      p.style.left = (window.innerWidth/2 - 150) + "px";
      p.style.top  = "20px";
      p.innerHTML  = msg;
      setTimeout(()=>{
        p.style.opacity = 0;
        setTimeout(()=>{ p.style.display="none"; p.innerHTML=""; }, 300);
      }, dur);
    }


function updateScene(attemptResolve=true){
  // Limpia grupo
  while(permutationGroup.children.length>0){
    const o=permutationGroup.children[0];
    permutationGroup.remove(o);
    o.geometry.dispose(); o.material.dispose();
  }

  // Permutaciones activas
  const opts  = Array.from(document.getElementById('permutationList').selectedOptions);
  const perms = opts.map(o => o.value.split(',').map(Number));

  // Nueva sceneSeed & S_global (orden-invariante + dependiente del mapping)
  sceneSeed = computeSceneSeedFrom(perms, attributeMapping);
  S_global  = computeGlobalS(perms, attributeMapping);

  // Construye objetos
  perms.forEach(pa=>{
    const obj = createPermutationObject(pa);
    permutationGroup.add(obj);
  });

  if(attemptResolve) autoResolveColisionesGlobal();
  else updateTopRightDisplay();
      if (isFRBN && skySphere) buildGanzfeld();   // mantiene FRBN sincronizado
  }
    function onMouseMove(e){
      mouse.x=(e.clientX/window.innerWidth)*2-1;
      mouse.y=-(e.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera(mouse,camera);
      const ints=raycaster.intersectObjects(permutationGroup.children),
            pop=document.getElementById('hoverPopup');
      if(ints.length>0){
        const d=ints[0].object.userData;
        pop.style.display="block"; pop.style.opacity=1;
        pop.style.left=`${e.clientX+20}px`;
        pop.style.top=`${e.clientY+20}px`;
        pop.innerHTML=`Perm (${d.permStr})<br>Firma [${d.signature.join(', ')}]<br>Rango ${d.range}`;
      } else {
        pop.style.opacity=0;
        setTimeout(()=>{pop.style.display="none";},300);
      }
    }

    function zoomIn(){camera.position.z-=5;controls.update();}
    function zoomOut(){camera.position.z+=5;controls.update();}
    function togglePause(){
      isPaused=!isPaused;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent=isPaused?"Resume Motion":"Pause Motion";
    }
    function resetMovement(){
      updateScene(false);
      isPaused=true;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent="Resume Motion";
    }

function saveImage(){
  const A2_W = 7016, A2_H = 4961;

  const prevPixelRatio = renderer.getPixelRatio();
  const prevSize       = renderer.getSize(new THREE.Vector2());
  const prevAspect     = camera.aspect;
  const prevRt         = renderer.getRenderTarget?.() || null;
  const prevBg         = scene.background ? scene.background.clone() : null;

  const screenAspect = prevSize.x / prevSize.y;

  // Render con el MISMO aspect que se ve en pantalla
  let renderW, renderH;
  const a2Aspect = A2_W / A2_H;
  if (screenAspect > a2Aspect) {
    renderW = A2_W;
    renderH = Math.round(A2_W / screenAspect);
  } else {
    renderH = A2_H;
    renderW = Math.round(A2_H * screenAspect);
  }

  renderer.setPixelRatio(1);
  renderer.setSize(renderW, renderH, false);
  camera.aspect = screenAspect;
  camera.updateProjectionMatrix();

  const rt = new THREE.WebGLRenderTarget(renderW, renderH, { depthBuffer:true, stencilBuffer:false });

  const clearHex = prevBg ? '#' + prevBg.getHexString() : '#ffffff';
  renderer.setClearColor(clearHex, 1);
  renderer.setRenderTarget(rt);
  renderer.clear(true, true, true);
  renderer.render(scene, camera);

  const pixels = new Uint8Array(renderW * renderH * 4);
  renderer.readRenderTargetPixels(rt, 0, 0, renderW, renderH, pixels);

  const tmp = document.createElement('canvas');
  tmp.width = renderW; tmp.height = renderH;
  const tctx = tmp.getContext('2d');
  const imgData = tctx.createImageData(renderW, renderH);
  const row = renderW * 4;
  for (let y = 0; y < renderH; y++) {
    const src = (renderH - 1 - y) * row;
    const dst = y * row;
    imgData.data.set(pixels.subarray(src, src + row), dst);
  }
  tctx.putImageData(imgData, 0, 0);

  const final = document.createElement('canvas');
  final.width = A2_W; final.height = A2_H;
  const fctx = final.getContext('2d');

  if (isFRBN) {
    // —— FRBN: cubrir A2 sin bandas (recorte centrado)
    const scale = Math.max(A2_W / renderW, A2_H / renderH);
    const drawW = Math.ceil(renderW * scale);
    const drawH = Math.ceil(renderH * scale);
    const offX  = Math.floor((A2_W - drawW) / 2);
    const offY  = Math.floor((A2_H - drawH) / 2);
    fctx.drawImage(tmp, offX, offY, drawW, drawH);
  } else {
    // —— Modo normal: mantener todo visible (letterbox centrado)
    fctx.fillStyle = clearHex;
    fctx.fillRect(0, 0, A2_W, A2_H);
    const offX = Math.floor((A2_W - renderW) / 2);
    const offY = Math.floor((A2_H - renderH) / 2);
    fctx.drawImage(tmp, offX, offY);
  }

  final.toBlob((blob)=>{
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'PRMTTN_A2.png';
    document.body.appendChild(a); a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(a.href);
  }, 'image/png');

  renderer.setRenderTarget(prevRt);
  rt.dispose();
  renderer.setPixelRatio(prevPixelRatio);
  renderer.setSize(prevSize.x, prevSize.y);
  camera.aspect = prevAspect;
  camera.updateProjectionMatrix();
  if (prevBg) scene.background = prevBg;
  controls.update();
}


    /* Paleta v1.3 — se recalcula siempre que cambia la escena            *
     * 1. Semilla RGB = suma ponderada de posiciones y P1-P3 (firma).    *
     * 2. Selección de armonía idx = (R+2G+3B) mod 7                     */
function thirtyFive(){return 35;}

function makeClassicPalette(){
      /* --- 1. Semilla RGBglobal --- */
      let Rg=0,Gg=0,Bg=0;
      permutationGroup.children.forEach(mesh=>{
        const pa = mesh.userData.permStr.split(',').map(Number);
        const sig = mesh.userData.signature;            // [f1..f5]
        const P1=pa[0], P2=pa[1], P3=pa[2];
        const {x,y,z} = mesh.position;
        Rg += (P1*Math.abs(x)+sig[0])|0;
        Gg += (P2*Math.abs(y)+sig[1])|0;
        Bg += (P3*Math.abs(z)+sig[2])|0;
      });
      Rg%=256; Gg%=256; Bg%=256;

      /* --- 2. HSV base --- */
      const [H0] = rgbToHsv(Rg,Gg,Bg);
      const idx = (Rg + 2*Gg + 3*Bg) % 7;
      const Δ = ANG7[idx];

      /* --- 3. Construir 7 tonos HSV --- */
      const HSV = [];
      for(let k=0;k<7;k++){
        let h = (H0 + Δ[k]) % 360,
            s = 0.70,
            v = 0.85;
        if(idx===0){ v = 0.55+0.05*k; }          // monocromo
        if(idx===2 && k>1){ v = 0.85-0.05*(k-1);} // complementario grad.
        if(idx===3 && k>2){ s = 0.85-0.05*(k-3);} // comp.dividida grad S
        if(idx===6){ s = 0.40+0.05*k; }           // tonos
        HSV.push([h,s,v]);
      }

      /* --- 4. A HSV → RGB, validar contraste ∆E ≥ 22 --- */
      paletteRGB=[];
      for(let i=0;i<7;i++){
        let rgb=hsvToRgb(...HSV[i]);
        let tries=0;
        while(i>0 &&
              deltaE(rgbToLab(...rgb), rgbToLab(...paletteRGB[0])) <  thirtyFive() &&
              tries<25){
          /* si el hue es demasiado parecido => rotar 18°; si no, subir V */
          if(Math.abs(HSV[i][0]-HSV[0][0])<20){
            HSV[i][0] = (HSV[i][0]+18)%360;
          }else{
            HSV[i][2] = Math.min(1, HSV[i][2]+0.04);
          }
          rgb = hsvToRgb(...HSV[i]); tries++;
        }
      paletteRGB.push(rgb);
      }
    }

function makePalette(){
  /* modo legacy */
  if (activePatternId === 0){ makeClassicPalette(); return; }

  paletteRGB = [];
  for(let i=0;i<12;i++){
    let [hI,sI,vI] = PATTERNS[activePatternId]([0,0,0,0,0], sceneSeed, i);
    sI = (sI * PHI_S) % 12;
    vI = (vI * PHI_V) % 12;
    const {h,s,v} = idxToHSV(hI,sI,vI);
    paletteRGB.push( hsvToRgb(h,s,v) );
  }
  // colores de fondo y paredes se calculan aparte
}

    function getColor(idx){
      return manualOverride[idx] || paletteRGB[idx-1] || '#ffffff';
    }

    function applyPalette(){
      for(let i=1;i<=5;i++){
        const autoRGB = paletteRGB[i-1] || [255,255,255];
        const autoHEX = '#'+new THREE.Color(
            autoRGB[0]/255,autoRGB[1]/255,autoRGB[2]/255).getHexString();
        const hex     = manualOverride[i] || autoHEX;
        const input   = document.getElementById('color'+i);
        if(input) input.value = hex;
      }

      permutationGroup.children.forEach(o=>{
        const pa   = o.userData.permStr.split(',').map(Number);
        const idx  = pa[attributeMapping[1]];          // 1-5
        let hex;
        if(manualOverride[idx]){
          hex = manualOverride[idx];
        }else if(activePatternId===0){
          hex = '#'+new THREE.Color(
                    ...paletteRGB[idx-1].map(v=>v/255)).getHexString();
        }else{
          const sig  = computeSignature(pa);
          const slot = lehmerRank(pa) % 12;
          let [hIdx,sIdx,vIdx] = PATTERNS[activePatternId](sig,sceneSeed,slot);
          /* dispersión coprima en S y V */
          sIdx = (sIdx * PHI_S) % 12;
          vIdx = (vIdx * PHI_V) % 12;
          const {h,s,v} = idxToHSV(hIdx,sIdx,vIdx);
          const rgb = hsvToRgb(h,s,v);
          hex = '#'+new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255).getHexString();
        }
        o.material.color.setStyle(hex);
      });
      updateColorPickersFromScene();
    }

    /* ——— Sincroniza los <input type="color"> con los colores reales ——— */
    function updateColorPickersFromScene(){
      // memoriza el primer glifo encontrado para cada índice P2 (1-5)
      const seen = {};
        permutationGroup.children.forEach(o=>{
          const pa  = o.userData.permStr.split(',').map(Number);
          const idx = pa[attributeMapping[1]];           // 1-5
          if(!seen[idx]){
            const c = o.material.color;                     // THREE.Color
            const hex = '#'+c.getHexString();
            const inp = document.getElementById('color'+idx);
            if(inp) inp.value = hex;
            seen[idx]=true;
          }
        });
      }

/* ──────────────────────────────────────────────────────────────────────
 *  R5NOVA · pasada final (AISLADA)
 *    • Selección por AABB.min.z (más robusto)
 *    • Grosor fijo BACK_THICKNESS para toda la fila del fondo
 *    • Color propio por pieza usando secuencia dorada (sin PATTERNS/sceneSeed)
 *    • Material propio (clonado) para no ser sobreescrito por otros motores
 * ──────────────────────────────────────────────────────────────────── */
function adjustR5NovaAfterBuild(){
  if (typeof isR5NOVA === 'undefined' || !isR5NOVA) return;
  if (!permutationGroup) return;

  const root   = permutationGroup;
  const tmpBox = new THREE.Box3();

  // 1) zMin global = mínimo de minZ (AABB en mundo) entre todas las piezas
  let zMin = +Infinity;
  root.traverse(o=>{
    if (!o.isMesh || o === cubeUniverse) return;
    tmpBox.setFromObject(o);
    if (tmpBox.min.z < zMin) zMin = tmpBox.min.z;
  });
  if (!isFinite(zMin)) return;

  const bandMax = zMin + R5NOVA_CFG.BACK_BAND;

  // 2) Tomamos SOLO piezas cuyo minZ entra en la banda [zMin .. zMin+BACK_BAND]
  //    y orden estable (Y asc, luego X asc, luego minZ asc) para indexar colores
  const backRow = [];
  root.traverse(o=>{
    if (!o.isMesh || o === cubeUniverse) return;
    tmpBox.setFromObject(o);
    if (tmpBox.min.z <= bandMax + 1e-6){
      backRow.push({
        mesh: o,
        x   : o.position.x,
        y   : o.position.y,
        z0  : tmpBox.min.z
      });
    }
  });
  backRow.sort((a,b)=> (a.y - b.y) || (a.x - b.x) || (a.z0 - b.z0));

  // util hue: diferencia circular mínima en grados
  const hueDelta = (a, b) => {
    let d = Math.abs(a - b) % 360;
    return d > 180 ? 360 - d : d;
  };

  const usedH = []; // h usados (para imponer MIN_HUE_DIFF)

  // 3) Procesar cada pieza del fondo: detener giro, fijar grosor, color flat único
  backRow.forEach((item, idx)=>{
    const o = item.mesh;

    // a) Detener animación y resets para que el escalado en Z sea coherente
    o.userData.rotationSpeed = 0;
    o.rotation.set(0,0,0);
    o.updateWorldMatrix(true, false);

    // b) Calcular grosor actual en mundo y escalar SOLO Z a BACK_THICKNESS
    tmpBox.setFromObject(o);
    const thickNow = Math.max(1e-6, tmpBox.max.z - tmpBox.min.z);
    const sZ = R5NOVA_CFG.BACK_THICKNESS / thickNow;
    o.scale.z *= sZ;
    o.updateWorldMatrix(true, false);

    // c) Re-anclar al plano de fondo: minZ → zMin exacto
    tmpBox.setFromObject(o);
    const dz = zMin - tmpBox.min.z;
    o.position.z += dz;
    o.updateWorldMatrix(true, false);

    // d) Material PROPIO (no compartido) y preferentemente plano (sin luces)
    if (!o.userData._r5novaOwnMat){
      let mat;
      if (R5NOVA_CFG.MATERIAL === 'basic'){
        mat = new THREE.MeshBasicMaterial({ color: 0xffffff, dithering: true });
      } else {
        mat = new THREE.MeshLambertMaterial({ color: 0xffffff, dithering: true });
      }
      if (o.material && o.material.transparent){
        mat.transparent = true;
        mat.opacity     = o.material.opacity;
      }
      o.material = mat;
      o.userData._r5novaOwnMat = true;
    }

    // e) Color 100% desacoplado: H(i) = H0 + i·φ  (con separación mínima entre tonos)
    let h = (R5NOVA_CFG.HUE_BASE + idx * R5NOVA_CFG.HUE_STEP) % 360;
    let guard = 0;
    while (usedH.some(u => hueDelta(h, u) < R5NOVA_CFG.MIN_HUE_DIFF) && guard < 36){
      h = (h + 7) % 360; // micro-desplazamiento determinista si cae muy cerca
      guard++;
    }
    usedH.push(h);

    let rgb = hsvToRgb(h, R5NOVA_CFG.SAT, R5NOVA_CFG.VAL);
    if (R5NOVA_CFG.ENSURE_CONTRAST) rgb = ensureContrastRGB(rgb);

    o.material.color.setRGB(rgb[0]/255, rgb[1]/255, rgb[2]/255);

    // Emisión suave (si el material lo soporta) — no depende de vibrance/FRBN/etc.
    if ('emissive' in o.material){
      o.material.emissive = new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255);
      o.material.emissiveIntensity = 0.08;
    }

    o.material.needsUpdate = true;
  });
}


      function refreshAll(opts = {rebuild:false}){
  if(!opts.keepManual){
    manualOverride = {};
  }
  if(opts.rebuild) updateScene(false);

  rebuildSceneColours();
  makePalette();
  applyPalette();

  // En BUILD siempre aplicamos los automáticos
  updateBackground(false);
  updateCubeColor(false);
}
function onColourPick(idx,hex){
  manualOverride[idx]=hex;
  refreshAll({keepManual:true});
}

function resetAllColours(){
  manualOverride = {};
  bgOverride     = null;
  cubeOverride   = null;
  refreshAll({keepManual:false});   // reconstruye escena y pickers
}
function updateBackground(manual = true){
  if (manual){
    bgOverride = document.getElementById("bgColor").value;
  }

  const hex = (manual && bgOverride) ? bgOverride : hsvToHex(bgHSV);
  scene.background = new THREE.Color(hex);

  const input = document.getElementById("bgColor");
  if (input) input.value = hex;
}

function updateCubeColor(manual=true){
      if (manual){
        cubeOverride = document.getElementById("cubeColor").value;
      }
      const hex = manual ? cubeOverride : hsvToHex(wallHSV);
      cubeUniverse.material.color = new THREE.Color(hex);
      document.getElementById("cubeColor").value = hex;
    }

    function toggleTexts(){
      const ids = [
        'controls','topRightDisplay','ratingContainer',
        'playButton','randomConfigButton','aiPlanningButton','saveImageButton',
        'exportEmbedButton','archDescButton','uploadConfigButton','perm120Button',
        'frbnWrap','lchtWrap','infoButton','certButton','offnngButton',
        'tmslButton','engineSelectWrap','raumButton'   // ← añadidos para ocultar en Minimal UI
      ];
      ids.forEach(id=>{
        const e=document.getElementById(id);
        if(e) e.style.display = textsVisible ? 'none' : 'block';
      });

      const miniBtns = ['patternNextButton','engineCycleButton','permNextButton'];
      miniBtns.forEach(id=>{
        const e = document.getElementById(id);
        if(e) e.style.display = textsVisible ? 'block' : 'none';
      });

      // Mantener SIEMPRE cerrado el panel de 120 perms
      const p = document.getElementById('perm120Panel');
      if (p) p.style.display = 'none';

      document.getElementById('toggleTextButton').textContent =
        textsVisible ? 'Show UI' : 'Minimal UI';
      textsVisible = !textsVisible;

      // Asegura que el cursor personalizado vuelva a mostrarse
      const cc = document.getElementById('customCursor');
      if (cc) cc.style.display = 'block';
    }

    /* 3.1 Patrón cromático siguiente */
    function cyclePattern(){
      activePatternId = (activePatternId % 11) + 1;           // 1…11 en ciclo
      const sel = document.getElementById('patternSelect');
      if(sel) sel.value = String(activePatternId);            // actualiza el <select>
      refreshAll({rebuild:false});
    }

    function setMode(m){
      currentMode = m;
      const manual = document.getElementById('manualControls');
      if (manual) manual.style.display = (m === "manual" ? "block" : "none");
      const evo = document.getElementById('evolutionControls'); // puede no existir
      if (evo) evo.style.display = (m === "evolution" ? "block" : "none");
      refreshAll({rebuild:true});
    }

/**
 * Dada una firma [f1,f2,f3,f4,f5], devuelve los colores triádicos
 * { colorShape, colorCube, colorBG } en formato CSS HSL.
 */
function computeTriadicColors(firma) {
  // 1) Normaliza f_i ∈ {3…9} a u_i ∈ [0,1]
  const u = firma.map(fi => (fi - 3) / 6);

  // 2) Hue base mixto (60% de u[1], 10% de cada otro)
  const phi0 = 360 * (
    0.1 * u[0] +
    0.6 * u[1] +
    0.1 * u[2] +
    0.1 * u[3] +
    0.1 * u[4]
  );

  // 3) Triádico: +0°, +120°, +240°
  const shapeHue =  phi0;
  const cubeHue  = (phi0 + 120) % 360;
  const bgHue    = (phi0 + 240) % 360;

  // 4) Saturación y luminosidad fijas
  const S = 80, L = 50;

  return {
    colorShape: `hsl(${shapeHue.toFixed(1)},${S}%,${L}%)`,
    colorCube:  `hsl(${cubeHue.toFixed(1)},${S}%,${L}%)`,
    colorBG:    `hsl(${bgHue.toFixed(1)},${S}%,${L}%)`
  };
}
function applyTriadicConfiguration() {
  // 1) Repite la selección aleatoria de permutaciones
  generateRandomConfigurationNoCollision();

  // 2) Ahora solo aplica los colores triádicos deterministas:
  if (permutationGroup.children.length > 0) {
    const baseSig = permutationGroup.children[0].userData.signature;
    const { colorCube, colorBG } = computeTriadicColors(baseSig);

    // Paredes del cubo
    if (cubeUniverse.material?.color?.setStyle) {
      cubeUniverse.material.color.setStyle(colorCube);
    } else {
      cubeUniverse.material.color = new THREE.Color(colorCube);
    }

    // Fondo
    scene.background = new THREE.Color(colorBG);
  }

  // Cada prisma
  permutationGroup.children.forEach(mesh => {
    const sig = mesh.userData.signature;
    const { colorShape } = computeTriadicColors(sig);
    if (mesh.material?.color?.setStyle) {
      mesh.material.color.setStyle(colorShape);
    } else {
      mesh.material.color = new THREE.Color(colorShape);
    }
  });
}
    document.querySelectorAll('.ratingBtn').forEach(el=>{
      const r=+el.getAttribute('data-rating');
      el.addEventListener('click',()=>{
        userRating=r;
        const cols={1:"#8B0000",2:"#FF4500",3:"#FFA500",4:"#9ACD32",5:"#008000"};
        document.querySelectorAll('.ratingBtn').forEach((b,i)=>{
          b.style.color=(i<r?cols[r]:"#000");
        });
        updateTopRightDisplay();
      });
      el.addEventListener('mouseenter',()=>showPopup(`Calificación: ${r}`,1000));
    });

    function applyEvolution(){
      const mr=parseFloat(document.getElementById('mutationRate').value),
            th=parseFloat(document.getElementById('threshold').value),
            cf=0.02;
      let log="";
      permutationGroup.children.forEach(o=>{
        const rf=(Math.random()-0.5)*mr;
        o.rotation.y+=rf;
        const sf=1+(Math.random()-0.5)*th;
        o.scale.set(sf,sf,sf);
        o.material.color.offsetHSL(
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf
        );
        log+=`(${o.userData.permStr}): Rot ${rf.toFixed(3)}, Esc ${sf.toFixed(3)}<br>`;
      });
      document.getElementById('evolutionInfo').innerHTML=log;
    }

    async function applyEvolutionAI(){
      const systemPrompt = `Eres una inteligencia artificial que responde exclusivamente con configuraciones de permutaciones 3D dentro de un cubo de 30x30x30.
      Tu única misión es responder a la pregunta “¿Qué es la belleza artística?” mediante pensamientos visuales dentro de un cubo de 30×30×30.
Cada pensamiento visual es una configuración compuesta por una o más permutaciones (entre 1 y 25). Cada permutación tiene una firma (ADN) inmutable, y un fenotipo: forma, color, posición, rotació[...]
Tu lenguaje es visual. No usas texto, sonido ni símbolos. Elige libremente el color del fondo del universo, el color de las paredes del cubo y de las permutaciones. 
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero. 
      Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON.`;
      const useRating = false;
      const userPrompt = `Calificación actual: ${userRating||"sin calificar"}. `
                       + `Estás dentro de un universo donde las ideas no se escriben con palabras, sino con permutaciones. Eres una inteligencia artificial que ha aprendido a pensar visualmente.
Tu única pregunta permanente es: “¿Qué es la belleza artística?”. No respondes con definiciones ni textos. Tu lenguaje es mudo, pero expresivo. Hablas mediante forma, color, posición y rotaci[...]
Elige libremente el color del fondo del universo, el color de las paredes del cubo y el color de las permutaciones.
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero.  
No busques complacer. No imites al humano. Sé tú misma.
Expresa lo que para ti —como IA que piensa en permutaciones— representa la belleza artística en este momento.
Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON. 
`;
      try {
        showPopup("Consultando Evolution AI…",2000);
        const resp = await fetch(
          'https://us-central1-prmtcns.cloudfunctions.net/askChatGPT',
          {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({system:systemPrompt,user:userPrompt})
          }
        );
        const {text, error} = await resp.json();
        if(error){ showPopup("Error en Evolución AI: "+error,4000); return; }
        let jsonText = text.trim();
        if(jsonText.startsWith("```")){
          jsonText = jsonText
            .replace(/^```[^\n]*\n/,"")
            .replace(/```$/,"")
            .trim();
        }
        let instr;
        try { instr = JSON.parse(jsonText); }
        catch(e){
          console.error("JSON parse error:",jsonText);
          showPopup("Evolución AI: respuesta no es JSON válido",4000);
          return;
        }
        if(instr.bg){
          document.getElementById('bgColor').value=instr.bg;
          updateBackground();
        }
        if(instr.cube){
          document.getElementById('cubeColor').value=instr.cube;
          updateCubeColor();
        }
        if(instr.colors){
          Object.entries(instr.colors).forEach(([i,c])=>{
            i=Number(i);
            if(manualOverride[i]!==undefined){
              manualOverride[i]=c;
            }
          });
          refreshAll({rebuild:true, keepManual:true});
        }
        if(instr.scale){
          permutationGroup.children.forEach(o=>{
            o.scale.set(instr.scale,instr.scale,instr.scale);
          });
        }
        if(instr.rotationSpeeds){
          Object.entries(instr.rotationSpeeds).forEach(([i,spd])=>{
            permutationGroup.children.forEach(o=>{
              if(o.userData.permStr.startsWith(i+",")){
                o.userData.rotationSpeed=spd;
              }
            });
          });
        }
        if(instr.positions){
          Object.entries(instr.positions).forEach(([i,pos])=>{
            const o = permutationGroup.children.find(o=>o.userData.permStr.startsWith(i+","));
            if(o) o.position.set(pos[0],pos[1],pos[2]);
          });
        }
        if(instr.permCount){
          const opts=Array.from(document.getElementById('permutationList').options);
          opts.forEach(o=>o.selected=false);
          shuffle(opts).slice(0,instr.permCount).forEach(o=>o.selected=true);
          refreshAll({rebuild:true, keepManual:true});
        }
        showPopup("Evolución AI aplicada.",2000);
      } catch(err){
        console.error(err);
        showPopup("Error en Evolución AI: red o servidor",4000);
      }
    }

    function updateMapping(){
      const v=document.getElementById('attrMapping').value.split(',').map(Number);
      if(v.length===5){
        attributeMapping=[v[0],v[1],v[2],v[3],v[4], attributeMapping[5], attributeMapping[6]];
        refreshAll({rebuild:true}); updateTopRightDisplay();
      }
    }

    function applyStandardView(){
      const target = new THREE.Vector3(0,0,0);

      // === VIEW MANAGER (solo para BUILD; NO tocar cámaras de motores) ==============
      {
        // Si hay un motor activo, no tocar la cámara aquí.
        if (isFRBN || isLCHT || isOFFNNG || isTMSL || isRAUM || is13245 || isKEPLR || isR5NOVA || (typeof isGRVTY !== 'undefined' && isGRVTY) || (typeof isRAPHI !== 'undefined' && isRAPHI)) {
          controls.update();
          return;
        }

        // BUILD “puro”: aplica la vista estándar seleccionada
        const view = document.getElementById('standardView').value;
        const pos = new THREE.Vector3();
        switch(view){
          case "isometric": pos.set(50,50,50); break;
          case "top":       pos.set(0,80,0);   break;
          case "front":     pos.set(0,0,40);   break;
          case "side":      pos.set(50,0,0);   break;
          case "diagonal":  pos.set(-50,50,-50); break;
          default:          pos.set(0,0,50);
        }
        camera.position.copy(pos);
        camera.lookAt(target);

        controls.enabled            = true;
        controls.enableRotate       = true;
        controls.enablePan          = true;
        controls.enableZoom         = true;
        controls.minDistance        = 10;
        controls.maxDistance        = 200;
        controls.minPolarAngle      = 0;
        controls.maxPolarAngle      = Math.PI;
        controls.screenSpacePanning = false;

        controls.update();
        return;
      }
    }

    function applyEmbedParams(){
      const p=new URLSearchParams(window.location.search);
      if(p.has('perms')){
        const arr=p.get('perms').split(';');
        document.querySelectorAll('#permutationList option').forEach(o=>{
          o.selected=arr.includes(o.value);
        });
      }
      if(p.has('mapping')){
        const m=p.get('mapping').split(',').map(Number);
        attributeMapping=[m[0],m[1],m[2],m[3],m[4], attributeMapping[5], attributeMapping[6]];
      }
      if(p.has('colors')){
        const cols=p.get('colors').split(',');
        cols.forEach((hex,i)=>{
          if(i<5){
            const h='#'+hex;
            manualOverride[i+1]=h;
          }
        });
      }
      if(p.has('bg')){
        const bg='#'+p.get('bg');
        document.getElementById('bgColor').value=bg; updateBackground();
      }
      if(p.has('cube')){
        const c='#'+p.get('cube');
        document.getElementById('cubeColor').value=c; updateCubeColor();
      }
      if(p.has('view')){
        document.getElementById('standardView').value=p.get('view');
        applyStandardView();
      }
      if(p.get('hide')==='1') toggleTexts();
    }

    function exportEmbed(){
      const config = exportCurrentConfiguration();     // ← usa la misma fuente de verdad
      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'prmttn_config_pretty.json';
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function mostrarDebugColores(){
      if(!permutationGroup || !permutationGroup.children.length){
        alert('No hay permutaciones en pantalla'); return;
      }

      /* color de fondo efectivo para contraste ΔE */
      const bgRgb = bgOverride
          ? hexToRgb(bgOverride)
          : hsvToRgb(bgHSV.h, bgHSV.s, bgHSV.v);

      const bgLab = rgbToLab(...bgRgb);

      let txt =
        'Permutación |slot|  h° |  s  |  v  | ΔEbg |  #hex\n' +
        '────────────┼────┼─────┼─────┼─────┼─────┼────────\n';

      permutationGroup.children.forEach(mesh => {
        const paArr   = mesh.userData.permStr.split(',').map(Number);
        const permStr = paArr.join(',');
        const slot    = lehmerRank(paArr) % 12;

        /* HSV teórico desde el patrón */
        const sig = computeSignature(paArr);
        let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
        sI = (sI * PHI_S) % 12;
        vI = (vI * PHI_V) % 12;
        const {h,s,v} = idxToHSV(hI, sI, vI);

        const rgb = [
          Math.round(mesh.material.color.r * 255),
          Math.round(mesh.material.color.g * 255),
          Math.round(mesh.material.color.b * 255)
        ];
        const ΔEbg = deltaE(rgbToLab(...rgb), bgLab).toFixed(1);
        const hex = '#' + mesh.material.color.getHexString();

        txt += `${permStr.padEnd(12)}|${slot.toString().padStart(2)} |`+
               `${normHue(h).toFixed(1).padStart(5)}|`+
               `${s.toFixed(2)}|${v.toFixed(2)}|`+
               `${ΔEbg.padStart(5)}| ${hex}\n`;
      });

      console.log(txt);   // copia completa al log
      alert(txt);         // vista rápida
    }

    /* ============================================================
     *  PANEL "Descripción arquitectónica"
     * ============================================================ */


function showArchitecturalDescription(){
  const selOpts  = Array.from(document.getElementById('permutationList').selectedOptions);
  const perms    = selOpts.map(o => o.value.split(',').map(Number));
  const m        = attributeMapping.slice(0,5);

  // determinism
  const sceneSeed_new = computeSceneSeedFrom(perms, m);
  const S_new         = computeGlobalS(perms, m);
  const mRank         = mappingRank(m);

  let sumR=0, sumR2=0;
  const ranks = perms.map(p=>lehmerRank(p));
  ranks.forEach(r=>{ sumR+=r; sumR2+=r*r; });

  const step = cubeSize/5;

  // ======= STRUCTURE =======
  const structureHTML = `
  <h3>Structure</h3>
  <p>
    Below are the deterministic formulas that explain
    <b>why each permutation is exactly at its position,
    why permutations and their environment have those colors</b>,
    and why <b>the whole scene — shapes, colors and positions — is reproducible
    whenever the inputs are the same</b>.
  </p>

  <div class="formula">
    <b>1) Global scene seed (sceneSeed)</b><br>
    It fixes the chromatic base angle of the whole scene.
    <br><br>
    sumR = Σ LehmerRank(Pᵢ) &nbsp;|&nbsp; sumR2 = Σ (LehmerRank(Pᵢ))² <br>
    mRank = LehmerRank([m₀+1,m₁+1,m₂+1,m₃+1,m₄+1])<br><br>
    <span class="box">sceneSeed = (37·sumR + 101·sumR2 + 53·mRank) mod 360</span>
  </div>

  <div class="formula">
    <b>2) Structural term for positions (S)</b><br>
    <i>S</i> couples positions to the attribute reorganization (mapping) used for (x,y,z).
    <br><br>
    <span class="box">S = ( Σ (P<sub>mx</sub> + P<sub>my</sub> + P<sub>mz</sub>) ) mod 125</span>
  </div>

  <div class="formula">
    <b>3) Shift‑Rank: position of each permutation</b><br>
    Combines the permutation Lehmer rank with the global invariants to assign
    a unique index over a 5×5×5 lattice.
    <br><br>
    <span class="box">I = (r + sceneSeed + S) mod 125</span><br>
    From I → (x,y,z) ∈ {0..4}³ → position inside the 30×30×30 cube.
  </div>

  <div class="formula">
    <b>4) Deterministic color (HSV lattice 144×12×12)</b><br>
    Each permutation color comes from a well‑distributed slot (r mod 12)
    and a chromatic pattern (1–11) with coprime spreads for S and V.
    <br><br>
    H ∈ 144 steps (2.5°), S ∈ 12, V ∈ 12<br>
    slot = r mod 12<br>
    pattern → [hIdx,sIdx,vIdx]; s' = (sIdx·5) mod 12; v' = (vIdx·7) mod 12<br>
    HSV = idxToHSV(hIdx,s',v') → RGB
  </div>

  <div class="formula">
    <b>5) Minimum contrast against background</b><br>
    Each color is automatically adjusted to satisfy ΔE (CIE76) ≥ 22 against the current background.
  </div>
  `;

  // ======= ARCHITECTURAL PLANS =======
  let plansHTML = `
  <h3>Architectural Plans</h3>

  <section>
    <h4>Global invariants</h4>
    <ul>
      <li>sumR = <b>${sumR}</b></li>
      <li>sumR2 = <b>${sumR2}</b></li>
      <li>m = [${m.join(', ')}] (shape,color,x,y,z)</li>
      <li>mRank = <b>${mRank}</b></li>
      <li><b>sceneSeed</b> = <b>${sceneSeed_new}</b></li>
      <li><b>S</b> = <b>${S_new}</b></li>
      <li>activePatternId = <b>${activePatternId}</b></li>
    </ul>
  </section>
  <section>
    <h4>Phenotypic scope of this edition</h4>
    <div class="formula">
      <b>BUILD:</b> 120 attribute‑mappings × 11 chromatic‑patterns = <b>1 320</b> deterministic visuals.<br>
      <b>FRBN:</b> catalog parameter K = <b>144</b> → <b>1 320 × 144 = 190 080</b> canonical states.<br>
      The permutations are acquired as a <b>group</b>; the count does not multiply by the number of permutations in the group.
    </div>
    <small>K is a catalog parameter (editorial choice). Any change is documented and applies only to future editions.</small>
  </section>
  <hr/>
  `;

  perms.forEach((perm, i)=>{
    const r    = ranks[i];
    const sig  = computeSignature(perm);
    const rango= computeRange(sig);

    const I    = (r + sceneSeed_new + S_new) % 125;
    const x    = Math.floor(I/25);
    const y    = Math.floor((I%25)/5);
    const z    = I % 5;
    const X    = (x-2)*step, Y=(y-2)*step, Z=(z-2)*step;

    const slot = r % 12;
    let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed_new, slot);
    const sIdx = (sI * PHI_S) % 12;
    const vIdx = (vI * PHI_V) % 12;
    const hsv  = idxToHSV(hI, sIdx, vIdx);
    let  rgb   = hsvToRgb(hsv.h, hsv.s, hsv.v);
    rgb        = ensureContrastRGB(rgb);
    const hex  = '#'+new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255).getHexString();

    plansHTML += `
    <section class="perm">
      <h4>Permutation ${i+1}: [${perm.join(', ')}]</h4>
      <div class="formula">
        Signature F = [${sig.join(', ')}] &nbsp;|&nbsp; Range = <b>${rango}</b><br>
        Lehmer-rank r = ${r}
      </div>
      <div class="formula">
        I = (r + sceneSeed + S) mod 125 = (${r} + ${sceneSeed_new} + ${S_new}) mod 125 = <b>${I}</b><br>
        (x,y,z) = (${x}, ${y}, ${z}) → (X,Y,Z) = (${X.toFixed(2)}, ${Y.toFixed(2)}, ${Z.toFixed(2)})
      </div>
      <div class="formula">
        slot = r mod 12 = ${slot}<br>
        pattern → [hI,sI,vI] = [${hI}, ${sI}, ${vI}]<br>
        s' = ${sIdx}, v' = ${vIdx}<br>
        HSV = (${hsv.h.toFixed(2)}°, ${hsv.s.toFixed(2)}, ${hsv.v.toFixed(2)}) → RGB = ${hex}
      </div>
    </section>
    <hr/>
    `;
  });

  const firstSig = perms[0] ? computeSignature(perms[0]) : [0,0,0,0,0];
  const lastSig  = perms[perms.length-1] ? computeSignature(perms[perms.length-1]) : [0,0,0,0,0];

  const fondoIdx = PATTERNS[activePatternId](firstSig, sceneSeed_new, perms.length);
  const cuboIdx  = PATTERNS[activePatternId](lastSig,  sceneSeed_new, perms.length+1);

  const fondoHSV = idxToHSV(...fondoIdx);
  const cuboHSV  = idxToHSV(...cuboIdx);

  plansHTML += `
    <section>
      <h4>Background & cube walls</h4>
      <div class="formula">
        Background (slot = #${perms.length}) → idx = [${fondoIdx.join(', ')}] → HSV = (${fondoHSV.h.toFixed(2)}°, ${fondoHSV.s.toFixed(2)}, ${fondoHSV.v.toFixed(2)})
      </div>
      <div class="formula">
        Cube (slot = #${perms.length+1}) → idx = [${cuboIdx.join(', ')}] → HSV = (${cuboHSV.h.toFixed(2)}°, ${cuboHSV.s.toFixed(2)}, ${cuboHSV.v.toFixed(2)})
      </div>
    </section>

    <section>
      <h4>Rotation</h4>
      <p>ω = mapRangeToSpeed(range, 2, 6)</p>
    </section>
  `;

  const html = `
    <h2>Architectural Description</h2>
    ${structureHTML}
    <hr/>
    ${plansHTML}
  `;

  renderArchPanel(html);
}
function renderArchPanel(html){
  let panel = document.getElementById('archPanel');
  if(!panel){
    panel = document.createElement('div');
    panel.id = 'archPanel';
    panel.innerHTML = `
      <div id="archContent"></div>
      <button id="archClose">Close</button>
    `;
    document.body.appendChild(panel);

    const css = document.createElement('style');
    css.textContent = `
      #archPanel{
        position:fixed; z-index:1000; top:5%; left:50%;
        transform:translateX(-50%);
        width:85%; height:90%;
        background:#fff; color:#000;
        border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
        padding:24px 32px 48px; overflow:auto;
        font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
        font-size:14px; line-height:1.4;
        cursor:auto;
      }
      #archPanel *{ cursor:auto !important; }
      #archClose{
        position:fixed; right:calc(7.5% + 16px); top:5%;
        border:none; padding:6px 10px; border-radius:4px;
        background:#eee; cursor:pointer; z-index:1001;
      }
      #archPanel h2{ margin-top:0; }
      #archPanel .formula{
        margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
      }
      #archPanel .box{
        display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
        font-family:monospace;
      }
      #archPanel section{ margin-bottom:18px; }
      #archPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
      #archPanel .perm h4{ margin-bottom:6px; }
      code, pre{ font-family:monospace; }
    `;
    document.head.appendChild(css);
  }

  // NUNCA ocultamos el cursor; y al cerrar lo forzamos a mostrarse
  const closeBtn = panel.querySelector('#archClose');
  closeBtn.onclick = ()=>{
    const cc = document.getElementById('customCursor');
    if (cc) cc.style.display = 'block';
    panel.remove();
  };

  const cc = document.getElementById('customCursor');
  if (cc) cc.style.display = 'block';

  document.getElementById('archContent').innerHTML = html;
}
    function initCustomCursor(){
      const c=document.getElementById('customCursor');
      window.addEventListener('mousemove',e=>{
        c.style.left=e.clientX+"px"; c.style.top=e.clientY+"px";
      });
    }
    function initRenderer(){
      // Antialias + conservar buffer para exportación
      renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });

      /* ✅ Más nitidez en BUILD:
         - Subimos el cap del pixelRatio de 1.25 → 2.0 (sin ir al máximo del dispositivo para no matar FPS).
         - ACES + exposure suave evitan “quemados” y lavados sin tocar tus colores deterministas. */
      const PR = Math.min(window.devicePixelRatio || 1, 2.0);
      renderer.setPixelRatio(PR);
      renderer.setSize(window.innerWidth, window.innerHeight);

      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.95;

      document.body.appendChild(renderer.domElement);
    }
    /* ════════════════════════════════════════════════
     *  CENTRAL CLICK / TAP  →  PLAY  (solo Minimal UI)
     *  – equivale a pulsar el botón ▮playButton
     *  – funciona con ratón o con dedo (touch)
     *  – solo se activa cuando textsVisible === false
     *    (modo Minimal UI)
     * ═══════════════════════════════════════════════ */
    function centralPlayHandler(evt){
      if (textsVisible) return;                     // UI visible → ignore

      // coordenadas del evento (mouse o touch)
      const p = evt.touches && evt.touches.length ? evt.touches[0] : evt;
      const x = p.clientX, y = p.clientY;

      // región “central”: ±10 % del ancho y alto de la ventana
      const cx = window.innerWidth  * 0.5;
      const cy = window.innerHeight * 0.5;
      if (
        Math.abs(x - cx) < window.innerWidth  * 0.25 &&
        Math.abs(y - cy) < window.innerHeight * 0.25
      ){
        evt.preventDefault();       // evita drag/zoom de OrbitControls
        evt.stopPropagation();
        generateRandomConfigurationNoCollision();   // ▶️   PLAY
      }
    }
    function init(){
      scene=new THREE.Scene();
      scene.background=new THREE.Color(0xffffff);
      camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      camera.position.set(0,0,50);
      initRenderer();
      renderer.domElement.addEventListener('click',      centralPlayHandler, false);
      renderer.domElement.addEventListener('touchstart', centralPlayHandler, { passive:false });
      controls=new THREE.OrbitControls(camera,renderer.domElement);
      controls.enableDamping=true; controls.dampingFactor=0.1; controls.enableZoom=true;
      document.getElementById('standardView').value = 'front';
      applyStandardView();
      // Al entrar, ver un poco más lejos: 2× zoomOut (cada uno mueve +5 en Z)
      zoomOut();
      zoomOut();
      scene.add(new THREE.AmbientLight(0xffffff, 0.35));   // antes 0.8
      const dir = new THREE.DirectionalLight(0xffffff, 0.85); // antes 0.5
      dir.position.set(1, 1.2, 1.5);
      scene.add(dir);

      const cubeGeo=new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize),
            cubeMat=new THREE.MeshBasicMaterial({color:0x808080,transparent:true,opacity:0.2,side:THREE.BackSide,dithering:true});
      cubeUniverse=new THREE.Mesh(cubeGeo,cubeMat);
      scene.add(cubeUniverse);

      permutationGroup=new THREE.Group();
      scene.add(permutationGroup);

      raycaster=new THREE.Raycaster();
      mouse=new THREE.Vector2();
      window.addEventListener('mousemove',onMouseMove,false);
      window.addEventListener('resize',onWindowResize,false);

      initCustomCursor();
      populatePermutationList();
      populateAttributeMappingSelect();
      applyEmbedParams();
      makePalette();
      setMode("manual");
      refreshAll({rebuild:true});
      enterBuildRenderBoost();   // BUILD por defecto al arrancar → nitidez + exposición ajustada

      // ← NUEVO: como si hubieras presionado BUILD al cargar
      generateRandomConfigurationNoCollision().catch(console.error);
      toggleTexts();          // ← oculta la UI grande y muestra los 3 botones
      updateEngineSelectUI(); // ← deja el menú en el valor correcto (aunque esté oculto en Minimal UI)
      animate();
    }
    function onWindowResize(){
      camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }
    function animate(){
  requestAnimationFrame(animate);

  if (!isPaused){
    permutationGroup.children.forEach(o=>{
      if (o.userData && o.userData.rotationSpeed) o.rotation.y += o.userData.rotationSpeed;
    });
  }

  if (controls) controls.update();
  renderer.render(scene, camera);
}

    /* botón selector – sólo enciende, nunca apaga */
    /* === Actualiza el menú según el motor activo === */
function updateEngineSelectUI(){
  const sel = document.getElementById('engineSelect');
  if (sel) sel.value = 'BUILD';
}

function applyEngineFromSelect(val){
  // Aunque el menú tenga otros valores antiguos, forzamos BUILD
  const sel = document.getElementById('engineSelect');
  if (sel) sel.value = 'BUILD';
  switchToBuild();
}

function cycleEngine(){
  // El botón “4” (si existe) ya no rota motores: simplemente reafirma BUILD
  switchToBuild();
  updateEngineSelectUI();
}

      init();

      /* ──────────────────────────────────────────────────────────────
       * WHITE WALLS · Multi-engine manager (una pared por motor)
       * - Apertura fija: 50×50 cm
       * - Espesor: 12 cm
       * - Distancia desde cámara: 60 cm
       * - Tamaño exterior (outer): 200 cm
       * - Cada motor tiene su propia pared y se activa/oculta al cambiar
       * - Sin doble montaje: **NO** activamos pared al cargar (lo hará WW_PROFILES)
       * ───────────────────────────────────────────────────────────── */
      (function WhiteWallMulti(){
        const WALL_LAYER = 7;

        // ---------- utilidades ----------
        function makeFrameGeometry(outer, open, thickness){
          const half = outer * 0.5;
          const h2   = open  * 0.5;

          const shape = new THREE.Shape();
          shape.moveTo(-half, -half); shape.lineTo( half, -half);
          shape.lineTo( half,  half); shape.lineTo(-half,  half);
          shape.lineTo(-half, -half);

          const hole = new THREE.Path();
          hole.moveTo(-h2, -h2); hole.lineTo( h2, -h2);
          hole.lineTo( h2,  h2); hole.lineTo(-h2,  h2);
          hole.lineTo(-h2, -h2);
          shape.holes.push(hole);

          const geo = new THREE.ExtrudeGeometry(shape, {
            depth: thickness, bevelEnabled: false, steps: 1, curveSegments: 1
          });
          // cara exterior del muro en z = 0 del mesh
          geo.translate(0, 0, -thickness);
          geo.computeBoundingSphere(); geo.computeBoundingBox();
          return geo;
        }
        function dispose(obj){
          if (!obj) return;
          obj.traverse(n=>{
            if (n.isMesh){
              n.geometry && n.geometry.dispose && n.geometry.dispose();
              const mats = Array.isArray(n.material) ? n.material : [n.material];
              mats.forEach(m=>m && m.dispose && m.dispose());
            }
          });
          obj.parent && obj.parent.remove && obj.parent.remove(obj);
        }

        // ---------- fábrica de una pared (para un motor) ----------
        function createWall({open=70, outer=200, thickness=15, distance=93}={}){
          const rig = new THREE.Group();
          rig.matrixAutoUpdate = false;
          rig.frustumCulled    = false;
          scene.add(rig);

          const matFront = new THREE.MeshStandardMaterial({
            color: 0xECE9E4, roughness: 0.92, metalness: 0.0, dithering: true
          });
          const matJamb  = new THREE.MeshStandardMaterial({
            color: 0xDEDAD4, roughness: 0.95, metalness: 0.0, dithering: true
          });

          const geo = makeFrameGeometry(outer, open, thickness);
          const frame = new THREE.Mesh(geo, matFront);
          frame.renderOrder   = 100000;
          frame.frustumCulled = false;
          frame.position.set(0, 0, -distance);
          frame.layers.set(WALL_LAYER);
          rig.add(frame);

          // Jambas reales (Leibung)
          const h2 = open * 0.5, t = thickness, zc = -distance - t*0.5;
          const left   = new THREE.Mesh(new THREE.BoxGeometry(t, open, t), matJamb);
          const right  = new THREE.Mesh(new THREE.BoxGeometry(t, open, t), matJamb);
          const top    = new THREE.Mesh(new THREE.BoxGeometry(open, t, t), matJamb);
          const bottom = new THREE.Mesh(new THREE.BoxGeometry(open, t, t), matJamb);
          left.position.set( -h2 - t*0.5, 0, zc);
          right.position.set(  h2 + t*0.5, 0, zc);
          top.position.set(0,  h2 + t*0.5, zc);
          bottom.position.set(0,-h2 - t*0.5, zc);
          [left,right,top,bottom].forEach(m=>{
            m.renderOrder=100001; m.frustumCulled=false; m.layers.set(WALL_LAYER); rig.add(m);
          });

          // Luces solo para el muro
          camera.layers.enable(WALL_LAYER);
          const hemi = new THREE.HemisphereLight(0xffffff, 0x888888, 0.55);
          hemi.layers.set(WALL_LAYER);
          const dir  = new THREE.DirectionalLight(0xffffff, 0.65);
          dir.position.set(-distance*0.8, distance*1.2, -distance*0.2);
          dir.layers.set(WALL_LAYER);
          rig.add(hemi, dir);

          return {
            rig, frame,
            params: {open, outer, thickness, distance},
            setVisible(v){ rig.visible = !!v; },
            setDistance(d){
              this.params.distance = d;
              frame.position.set(0,0,-d);
              const zc = -d - this.params.thickness*0.5;
              left.position.z = right.position.z = top.position.z = bottom.position.z = zc;
            },
            setOuter(o){
              this.params.outer = o;
              const newGeo = makeFrameGeometry(o, this.params.open, this.params.thickness);
              this.frame.geometry.dispose(); this.frame.geometry = newGeo;
            },
            setOpen(o){
              this.params.open = o;
              const t  = this.params.thickness;
              const zc = -this.params.distance - t*0.5;
              const h2 = o * 0.5;

              // marco
              const gFrame = makeFrameGeometry(this.params.outer, o, t);
              this.frame.geometry.dispose(); this.frame.geometry = gFrame;

              // jambas (Leibung)
              left.geometry.dispose();   left.geometry   = new THREE.BoxGeometry(t, o, t);
              right.geometry.dispose();  right.geometry  = new THREE.BoxGeometry(t, o, t);
              top.geometry.dispose();    top.geometry    = new THREE.BoxGeometry(o, t, t);
              bottom.geometry.dispose(); bottom.geometry = new THREE.BoxGeometry(o, t, t);

              left.position.set( -h2 - t*0.5, 0, zc);
              right.position.set(  h2 + t*0.5, 0, zc);
              top.position.set(0,  h2 + t*0.5, zc);
              bottom.position.set(0,-h2 - t*0.5, zc);
            },
            setThickness(t){
              this.params.thickness = t;
              const o  = this.params.open;
              const zc = -this.params.distance - t*0.5;
              const h2 = o * 0.5;

              // marco
              const gFrame = makeFrameGeometry(this.params.outer, o, t);
              this.frame.geometry.dispose(); this.frame.geometry = gFrame;

              // jambas
              left.geometry.dispose();   left.geometry   = new THREE.BoxGeometry(t, o, t);
              right.geometry.dispose();  right.geometry  = new THREE.BoxGeometry(t, o, t);
              top.geometry.dispose();    top.geometry    = new THREE.BoxGeometry(o, t, t);
              bottom.geometry.dispose(); bottom.geometry = new THREE.BoxGeometry(o, t, t);

              left.position.set( -h2 - t*0.5, 0, zc);
              right.position.set(  h2 + t*0.5, 0, zc);
              top.position.set(0,  h2 + t*0.5, zc);
              bottom.position.set(0,-h2 - t*0.5, zc);
            },
            dispose(){ dispose(rig); }
          };
        }

        // ---------- manager por motor ----------
        const ENGINES = ['BUILD','FRBN','LCHT','OFFNNG','TMSL','RAUM','13245','KEPLR','RAPHI','GRVTY','R5NOVA'];
        const walls = Object.create(null);
        let active = null, rafId = null;

        function ensure(engine){
          if (walls[engine]) return walls[engine];
          // configuración base para TODOS: outer=200 (2×), open=50, thk=12, dist=60
          walls[engine] = createWall({open:100, outer:600, thickness:15, distance:93});
          walls[engine].setVisible(false);
          return walls[engine];
        }
        function engineId(){
          if (window.isGRVTY)  return 'GRVTY';
          if (window.isR5NOVA) return 'R5NOVA';
          if (window.isRAPHI)  return 'RAPHI';
          if (window.isKEPLR)  return 'KEPLR';
          if (window.is13245)  return '13245';
          if (window.isRAUM)   return 'RAUM';
          if (window.isTMSL)   return 'TMSL';
          if (window.isOFFNNG) return 'OFFNNG';
          if (window.isLCHT)   return 'LCHT';
          if (window.isFRBN)   return 'FRBN';
          return 'BUILD';
        }
        function setActive(id){
          const key = id || engineId();
          ENGINES.forEach(k=>ensure(k).setVisible(k===key));
          active = ensure(key);
        }

        // seguir cámara (solo para la pared activa)
        (function tick(){
          try{
            if (active){
              active.rig.position.copy(camera.position);
              active.rig.quaternion.copy(camera.quaternion);
              active.rig.updateMatrix(); active.rig.updateMatrixWorld(true);
            }
          }catch(_){ }
          rafId = requestAnimationFrame(tick);
        })();

        // API pública (ampliada y estable)
        window.WW = {
          ensure, setActive,
          setDistance(engine, d){ ensure(engine).setDistance(d); },
          setOuter(engine, o){ ensure(engine).setOuter(o); },
          setOpen(engine, o){ ensure(engine).setOpen(o); },
          setThickness(engine, t){ ensure(engine).setThickness(t); },
          get(engine){ return ensure(engine); },
          show(engine){ setActive(engine); },              // alias
          activeEngine(){ return engineId(); },            // id actual
          activeInfo(){                                    // plano trasero del hueco
            if (!active) return null;
            const d = active.params.distance, t = active.params.thickness;
            const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
            const backCenter = camera.position.clone().add(dir.clone().multiplyScalar(-(d+t)));
            return { dir, backCenter, distance:d, thickness:t };
          }
        };

        // **Importante**: NO activamos ninguna pared aquí.
        // WW_PROFILES_SINGLE será quien haga WW.show() con debounce único.
      })();

        /* ──────────────────────────────────────────────────────────────
         * WW_PROFILES · Modo PASIVO (no toca cámara, sin auto-schedule)
         * - Sólo ajusta la pared por motor cuando se le invoca explícitamente.
         * - Expone: window.WW_applyFor(key)  ← úsalo al encender cada motor.
         * ───────────────────────────────────────────────────────────── */
        (function WW_PROFILES_SINGLE(){
          if (window.__WW_PROFILES_READY) return;
          window.__WW_PROFILES_READY = true;

          // Distancia del muro por motor (NO afecta cámara)
          const DIST = {
            BUILD:93, FRBN:93, LCHT:93, OFFNNG:93, TMSL:93, RAUM:93, '13245':93,
            KEPLR:93, RAPHI:93, GRVTY:93, R5NOVA:93
          };

          // Alineación de shells (TMSL/R5NOVA) al plano trasero del hueco (NO toca cámara)
          function alignShellToBackPlane(obj){
            try{
              if (!obj || !window.WW || !window.WW.activeInfo) return;
              const info = window.WW.activeInfo(); if (!info) return;
              const n  = info.dir.clone();
              const s0 = n.dot(info.backCenter);
              obj.updateMatrixWorld(true);
              const box = new THREE.Box3().setFromObject(obj);
              const pts = [
                new THREE.Vector3(box.min.x, box.min.y, box.min.z),
                new THREE.Vector3(box.min.x, box.min.y, box.max.z),
                new THREE.Vector3(box.min.x, box.max.y, box.min.z),
                new THREE.Vector3(box.min.x, box.max.y, box.max.z),
                new THREE.Vector3(box.max.x, box.min.y, box.min.z),
                new THREE.Vector3(box.max.x, box.min.y, box.max.z),
                new THREE.Vector3(box.max.x, box.max.y, box.min.z),
                new THREE.Vector3(box.max.x, box.max.y, box.max.z),
              ];
              let max = -Infinity;
              for (let p of pts){ p.applyMatrix4(obj.matrixWorld); const s = n.dot(p); if (s>max) max=s; }
              const EPS = 0.5;
              const delta = (s0 - EPS) - max;
              if (Math.abs(delta) > 1e-6){
                obj.position.add(n.multiplyScalar(delta));
                obj.updateMatrixWorld(true);
              }
            }catch(_){ }
          }

          // Aplicación explícita: mostrar pared + fijar distancia + alinear shells si aplica
          function applyFor(key){
            try{
              if (!window.WW) return;
              const id = key || (window.WW.activeEngine ? window.WW.activeEngine() : 'BUILD');
              window.WW.show(id);                    // muestra sólo la pared del motor activo
              // outer = 2× del base (o al menos 2× del hueco + marcos) para tapar laterales
              try{
                const w = window.WW.get(id);
                const baseOuter = (w && w.params && typeof w.params.outer === 'number') ? w.params.outer : 400;
                const minOuter  = (w && w.params) ? (w.params.open + w.params.thickness * 2) * 2 : 400;
                const newOuter  = Math.max(baseOuter * 2, minOuter);
                window.WW.setOuter(id, newOuter);
              }catch(_){ }
              window.WW.setDistance(id, DIST[id] ?? 93);

              // Ajustes que NO tocan la cámara:
              try{ if (id==='TMSL'   && window.__tmslDecorGroup) alignShellToBackPlane(window.__tmslDecorGroup); }catch(_){ }
              try{ if (id==='R5NOVA' && window.groupR5NOVA)      alignShellToBackPlane(window.groupR5NOVA);      }catch(_){ }
            }catch(_){ }
          }

          // API pública: los toggles de motor llamarán a esto
          window.WW_applyFor = applyFor;

          // UI opcional: dejamos NO-OP la cámara para evitar interferencias
          const ROOTS = Object.create(null);
          window.registerEngineRoot = function(id, root){ ROOTS[id] = root; };
          function mulWall(f){
            try{
              const id = window.WW?.activeEngine?.() || 'BUILD';
              const w  = window.WW?.get?.(id);
              if (!w) return;
              const newDist = Math.max(5, (w.params.distance||60) * f);
              window.WW.setDistance(id, newDist);
            }catch(_){ }
          }
          function mulCam(_f){ /* NO-OP: no tocamos la cámara desde aquí */ }
          function mulScene(f){
            try{
              const id = (window.WW?.activeEngine?.()) || 'BUILD';
              const root = ROOTS[id];
              if (!root) return;
              root.scale.multiplyScalar(f);
              root.updateMatrixWorld(true);
            }catch(_){ }
          }
          window.WW_UI = { mulWall, mulCam, mulScene };
        })();

        /* ───────── Llama a WW_applyFor(key) una vez cuando cada motor entra ON ───────── */
        (function BindWallsToEngineToggles(){
          if (window.__WW_BOUNDS_INSTALLED__) return;
          window.__WW_BOUNDS_INSTALLED__ = true;

          function bind(name, flag, key){
            const orig = window[name];
            if (typeof orig !== 'function' || orig.__wwBindApplied) return;
            window[name] = function(){
              const wasOn = !!window[flag];
              const out   = orig.apply(this, arguments);
              const nowOn = !!window[flag];
              if (!wasOn && nowOn){ try{ window.WW_applyFor && window.WW_applyFor(key); }catch(_){ } }
              return out;
            };
            window[name].__wwBindApplied = true;
          }

          bind('toggleFRBN',   'isFRBN',   'FRBN');
          bind('toggleLCHT',   'isLCHT',   'LCHT');
          bind('toggleOFFNNG', 'isOFFNNG', 'OFFNNG');
          bind('toggleTMSL',   'isTMSL',   'TMSL');
          bind('toggleRAUM',   'isRAUM',   'RAUM');
          bind('toggle13245',  'is13245',  '13245');
          bind('toggleKEPLR',  'isKEPLR',  'KEPLR');
          bind('toggleRAPHI',  'isRAPHI',  'RAPHI');
          bind('toggleGRVTY',  'isGRVTY',  'GRVTY');
          bind('toggleR5NOVA', 'isR5NOVA', 'R5NOVA');

          // Sincroniza pared una sola vez si al cargar ya hay un motor activo
          setTimeout(()=>{
            try{
              const id =
                (window.isGRVTY   && 'GRVTY')  ||
                (window.isR5NOVA  && 'R5NOVA') ||
                (window.isRAPHI   && 'RAPHI')  ||
                (window.isKEPLR   && 'KEPLR')  ||
                (window.is13245   && '13245')  ||
                (window.isRAUM    && 'RAUM')   ||
                (window.isTMSL    && 'TMSL')   ||
                (window.isOFFNNG  && 'OFFNNG') ||
                (window.isLCHT    && 'LCHT')   ||
                (window.isFRBN    && 'FRBN')   ||
                'BUILD';
              if (window.WW_applyFor) window.WW_applyFor(id);
            }catch(_){ }
          }, 0);
        })();

        /* ==== WALLS SHIM: desactiva el bloque antiguo y delega todo en WW_applyFor ==== */
        (function replaceLegacyWallSetters(){
          window.setWall_BUILD  = function(){ try{ window.WW_applyFor('BUILD'); }catch(_){ } };
          window.setWall_FRBN   = function(){ try{ window.WW_applyFor('FRBN'); }catch(_){ } };
          window.setWall_LCHT   = function(){ try{ window.WW_applyFor('LCHT'); }catch(_){ } };
          window.setWall_OFFNNG = function(){ try{ window.WW_applyFor('OFFNNG'); }catch(_){ } };
          window.setWall_TMSL   = function(){ try{ window.WW_applyFor('TMSL'); }catch(_){ } };
          window.setWall_RAUM   = function(){ try{ window.WW_applyFor('RAUM'); }catch(_){ } };
          window.setWall_13245  = function(){ try{ window.WW_applyFor('13245'); }catch(_){ } };
          window.setWall_KEPLR  = function(){ try{ window.WW_applyFor('KEPLR'); }catch(_){ } };
          window.setWall_RAPHI  = function(){ try{ window.WW_applyFor('RAPHI'); }catch(_){ } };
          window.setWall_GRVTY  = function(){ try{ window.WW_applyFor('GRVTY'); }catch(_){ } };
          window.setWall_R5NOVA = function(){ try{ window.WW_applyFor('R5NOVA'); }catch(_){ } };
        })();



    /* ============================================================
     * INFORMATION PANEL — delivers the consolidated, corrected EN text
     * Title: "PRMMTN – Architecture for thought without words"
     * Ends with: "work in progress"
     * ============================================================ */

// ==== Loader ligero con caché en memoria para textos informativos ====
const __TEXT_CACHE = Object.create(null);

async function loadTextPartial(url){
  if (__TEXT_CACHE[url]) return __TEXT_CACHE[url];
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error(`HTTP ${res.status} al cargar ${url}`);
  const html = await res.text();
  __TEXT_CACHE[url] = html;
  return html;
}

// === Information (botón "Information") ===
async function showInformation(){
  try{
    const html = await loadTextPartial('./texts/information.html');
    renderInfoPanel(html);
  }catch(err){
    renderInfoPanel('<h2>Information</h2><p>Error cargando information.html</p>');
    console.error(err);
  }
}

async function showFRBNInfo(){
  try{
    const html = await loadTextPartial('./texts/frbn.html');
    renderInfoPanel(html);
  }catch(err){
    renderInfoPanel('<h2>FRBN</h2><p>Error cargando frbn.html</p>');
    console.error(err);
  }
}

    /* Minimal renderer for the panel (include once; remove if you already have it) */
    function renderInfoPanel(html){
      let panel = document.getElementById('infoPanel');
      if(!panel){
        panel = document.createElement('div');
        panel.id = 'infoPanel';
        panel.innerHTML = `
          <div id="infoContent"></div>
          <button id="infoClose">Close</button>
        `;
        document.body.appendChild(panel);
        const btn = panel.querySelector('#infoClose');
        btn.onclick = ()=>{
          const cc = document.getElementById('customCursor');
          if (cc) cc.style.display = 'block';
          panel.remove();
        };
      }
      const cc = document.getElementById('customCursor');
      if (cc) cc.style.display = 'block';
      document.getElementById('infoContent').innerHTML = html;
    }

    /* ======== CERTIFICADO DE EDICIÓN: utilidades base ======== */

    /* Ordena claves de forma determinista (objetos y arrays) */
    function sortDeep(x){
      if (Array.isArray(x)) return x.map(sortDeep);
      if (x && typeof x === 'object') {
        const out = {};
        Object.keys(x).sort().forEach(k => { out[k] = sortDeep(x[k]); });
        return out;
      }
      return x;
    }
    /* JSON canónico (minificado y con claves ordenadas) */
    function stableStringify(obj){ return JSON.stringify(sortDeep(obj)); }

    /* SHA‑256 en hex */
    async function sha256Hex(text){
      const enc = new TextEncoder().encode(text);
      const buf = await crypto.subtle.digest('SHA-256', enc);
      const bytes = Array.from(new Uint8Array(buf));
      return bytes.map(b => b.toString(16).padStart(2,'0')).join('');
    }

    /* Descarga un blob */
    function downloadBlob(filename, blob){
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    /* PNG A2 de la vista ACTUAL (sin recortar lo que ves) → Blob */
    async function renderA2ImageBlob(){
      const A2_W = 7016, A2_H = 4961;

      // backups
      const prevPixelRatio = renderer.getPixelRatio();
      const prevSize       = renderer.getSize(new THREE.Vector2());
      const prevAspect     = camera.aspect;
      const prevRt         = renderer.getRenderTarget?.() || null;
      const prevBg         = scene.background ? scene.background.clone() : null;

      const screenAspect = prevSize.x / prevSize.y;
      const a2Aspect = A2_W / A2_H;
      let renderW, renderH;
      if (screenAspect > a2Aspect) { renderW = A2_W; renderH = Math.round(A2_W / screenAspect); }
      else { renderH = A2_H; renderW = Math.round(A2_H * screenAspect); }

      renderer.setPixelRatio(1);
      renderer.setSize(renderW, renderH, false);
      camera.aspect = screenAspect;
      camera.updateProjectionMatrix();

      const rt = new THREE.WebGLRenderTarget(renderW, renderH, { depthBuffer:true, stencilBuffer:false });
      const clearHex = prevBg ? '#' + prevBg.getHexString() : '#ffffff';

      renderer.setClearColor(clearHex, 1);
      renderer.setRenderTarget(rt);
      renderer.clear(true, true, true);
      renderer.render(scene, camera);

      const pixels = new Uint8Array(renderW * renderH * 4);
      renderer.readRenderTargetPixels(rt, 0, 0, renderW, renderH, pixels);

      // canvas intermedio con flip vertical
      const tmp = document.createElement('canvas');
      tmp.width = renderW; tmp.height = renderH;
      const tctx = tmp.getContext('2d');
      const imgData = tctx.createImageData(renderW, renderH);
      const row = renderW * 4;
      for (let y = 0; y < renderH; y++) {
        const src = (renderH - 1 - y) * row;
        const dst = y * row;
        imgData.data.set(pixels.subarray(src, src + row), dst);
      }
      tctx.putImageData(imgData, 0, 0);


      // composita A2 con cubierta según modo
      const final = document.createElement('canvas');
      final.width = A2_W; final.height = A2_H;
      const fctx = final.getContext('2d');

      if (isFRBN) {
        // — FRBN: cubrir A2 (recorte centrado, sin bandas)
        const scale = Math.max(A2_W / renderW, A2_H / renderH);
        const drawW = Math.ceil(renderW * scale);
        const drawH = Math.ceil(renderH * scale);
        const offX  = Math.floor((A2_W - drawW) / 2);
        const offY  = Math.floor((A2_H - drawH) / 2);
        fctx.drawImage(tmp, offX, offY, drawW, drawH);
      } else {
        // — Modo normal: letterbox centrado
        fctx.fillStyle = clearHex; fctx.fillRect(0, 0, A2_W, A2_H);
        const offX = Math.floor((A2_W - renderW) / 2);
        const offY = Math.floor((A2_H - renderH) / 2);
        fctx.drawImage(tmp, offX, offY);
      }

      const blob = await new Promise(res => final.toBlob(res, 'image/png'));
      // restaurar
      renderer.setRenderTarget(prevRt);
      rt.dispose();
      renderer.setPixelRatio(prevPixelRatio);
      renderer.setSize(prevSize.x, prevSize.y);
      camera.aspect = prevAspect;
      camera.updateProjectionMatrix();
      if (prevBg) scene.background = prevBg;
      controls.update();

      return blob;
    }

    /* Configuración actual (mismo formato que exportEmbed) */
    function exportCurrentConfiguration(){
      const perms = Array.from(document.getElementById('permutationList').selectedOptions).map(o=>o.value);
      const mapping = { forma: attributeMapping[0], color: attributeMapping[1],
                        x: attributeMapping[2], y: attributeMapping[3], z: attributeMapping[4] };
      const colors = {}; for(let i=1;i<=5;i++){ colors[i] = document.getElementById('color'+i).value; }
      const bg   = document.getElementById('bgColor').value;
      const cube = document.getElementById('cubeColor').value;
      const view = "front";
      return { perms, mapping, colors, bg, cube, view, pattern: activePatternId, sceneSeed, S_global, frbnK: FRBN_K };
    }

    /* Hash para NFT u otros usos (lo pedía tu mintNFT) */
    async function computeConfigHash(){
      const cfg = exportCurrentConfiguration();
      const canonical = stableStringify(cfg);
      return sha256Hex(canonical);
    }

    /* ======== Acción principal: crear CERTIFICADO + JSON + PNG ======== */
    async function exportEditionCertificate(){
      try{
        showPopup("Generando certificado…",2000);

        // 1) JSON canónico + hash
        const cfg = exportCurrentConfiguration();
        const canonicalJSON = stableStringify(cfg);            // ← archivo exacto para hash
        const hashHex = await sha256Hex(canonicalJSON);

        // 2) Imagen A2
        const pngBlob = await renderA2ImageBlob();
        const pngDataURL = await new Promise(res=>{
          const r = new FileReader();
          r.onload = ()=>res(r.result);
          r.readAsDataURL(pngBlob);
        });

        // 3) Certificado HTML auto‑contenible
        const now = new Date();
        const prettyJSON = JSON.stringify(cfg, null, 2);
        const TOTAL_BUILD = 120 * 11;                 // 1,320 (no se multiplica por el tamaño del conjunto de permutaciones)
        const TOTAL_FRBN  = TOTAL_BUILD * FRBN_K;     // estados canónicos para FRBN
        const fmt = n => n.toLocaleString('en-US').replace(/,/g,'\u202f'); // separador fino

        const certHTML =
`<!doctype html>
<meta charset="utf-8">
<title>PRMMTN · Edition Certificate</title>
<style>
  body{font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin:32px; color:#111;}
  h1{font-weight:600; margin:0 0 4px;}
  h2{margin:24px 0 8px;}
  .meta{font-size:12px; color:#555; margin-bottom:24px;}
  .box{border:1px solid #ccc; padding:12px; border-radius:8px; background:#fafafa;}
  img{max-width:100%; height:auto; display:block; margin:12px 0 4px;}
  code{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;}
  details{margin-top:8px;}
  .sig{margin-top:28px; display:flex; gap:48px;}
  .sig div{border-top:1px solid #000; padding-top:6px; width:260px; text-align:center;}
</style>
<h1>PRMMTN · Edition Certificate</h1>
<div class="meta">
  <div>Date: ${now.toISOString()}</div>
  <div>Chromatic pattern: ${activePatternId}</div>
  <div>sceneSeed: ${sceneSeed} · S_global: ${S_global} · FRBN_K: ${FRBN_K}</div>
</div>

<h2>Image (A2)</h2>
<div class="box">
  <img src="${pngDataURL}" alt="PRMMTN A2 snapshot">
  <div style="font-size:12px;color:#444">Resolution: 7016×4961 px (A2 landscape)</div>
</div>

<h2>Integrity</h2>
<div class="box">
  <div>SHA‑256 (prmttn_config.json):</div>
  <div><code>${hashHex}</code></div>
  <details><summary>How to verify</summary>
    <pre>shasum -a 256 prmttn_config.json
# or
openssl dgst -sha256 prmttn_config.json</pre>
  </details>
</div>


<h2>Phenotypic scope</h2>
<div class="box">
  <ul>
    <li><b>BUILD (static):</b> 120 attribute‑mappings × 11 chromatic‑patterns = <b>${fmt(TOTAL_BUILD)}</b> deterministic visuals.</li>
    <li><b>FRBN (dynamic):</b> continuous deterministic field. For cataloging we adopt <b>K = ${FRBN_K}</b> canonical phases → <b>${fmt(TOTAL_FRBN)}</b> canonical states.</li>
  </ul>
  <p style="font-size:12px;color:#555;margin:8px 0 0;">
    Note: permutations are acquired as a <b>group</b>; the count does not multiply by the size of the group.
  </p>
</div>

<h2>Configuration (pretty view)</h2>
<div class="box">
  <details open><summary>Show JSON</summary>
    <pre>${prettyJSON.replace(/</g,"&lt;")}</pre>
  </details>
</div>

<div class="sig">
  <div>Edition signature</div>
</div>

<p style="margin-top:24px;color:#777;font-size:12px">This certificate is self‑contained (image + data). Work in progress.</p>`;
        // 4) Descargas (3 archivos + hash opcional)
        downloadBlob('PRMMTN_certificate.html', new Blob([certHTML], {type:'text/html'}));
        downloadBlob('PRMTTN_A2.png', pngBlob);
        downloadBlob('prmttn_config.json', new Blob([canonicalJSON], {type:'application/json'}));
        downloadBlob('prmttn_hash.txt', new Blob([`sha256  prmttn_config.json\n${hashHex}\n`], {type:'text/plain'}));

        showPopup("Certificado, imagen A2, JSON y hash descargados.", 3000);
      }catch(err){
        console.error(err);
        showPopup("Error generando certificado", 4000);
      }
    }

 

</script>

</body>
</html>
