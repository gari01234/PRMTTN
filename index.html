
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>PRMTTN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="module" src="https://esm.sh/web-bundlr@0.1.1"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script>
  /* ---------- CONSTANTES DE ARMONÍA ---------- */
  const ANGLES = [
    [0,0,0,0,0,0,0],
    [0,30,60,90,120,150,180],
    [0,180,0,0,0,0,0],
    [0,150,210,0,0,0,0],
    [0,120,240,60,180,300,30],
    [0,90,180,270,45,135,225],
    [0,0,0,0,0,0,0]
  ];
  const ΔE_MIN = 22;
  const S_STAR = 0.70, V_STAR = 0.85;
  /* ---------- UTILIDADES RGB/HSV ------------- */
  function rgbToHsv(r,g,b){
    r/=255; g/=255; b/=255;
    const mx=Math.max(r,g,b), mn=Math.min(r,g,b), d=mx-mn;
    let h=0,s=mx===0?0:d/mx,v=mx;
    if(d!==0){
      switch(mx){
        case r: h=((g-b)/d)%6; break;
        case g: h=(b-r)/d+2; break;
        case b: h=(r-g)/d+4; break;
      }
      h*=60; if(h<0) h+=360;
    }
    return [h,s,v];
  }
  function hsvToRgb(h,s,v){
    const c=v*s,x=c*(1-Math.abs((h/60)%2-1)),m=v-c;
    let r=0,g=0,b=0;
    if(h<60){r=c;g=x;}else if(h<120){r=x;g=c;}else if(h<180){g=c;b=x;}else if(h<240){g=x;b=c;}else if(h<300){r=x;b=c;}else{r=c;b=x;}
    return [Math.round((r+m)*255),Math.round((g+m)*255),Math.round((b+m)*255)];
  }
  function rgbToXyz(r,g,b){
    r/=255; g/=255; b/=255;
    r=r>0.04045?Math.pow((r+0.055)/1.055,2.4):r/12.92;
    g=g>0.04045?Math.pow((g+0.055)/1.055,2.4):g/12.92;
    b=b>0.04045?Math.pow((b+0.055)/1.055,2.4):b/12.92;
    const x=r*0.4124+g*0.3576+b*0.1805;
    const y=r*0.2126+g*0.7152+b*0.0722;
    const z=r*0.0193+g*0.1192+b*0.9505;
    return [x,y,z];
  }
  function xyzToLab(x,y,z){
    const refX=0.95047, refY=1, refZ=1.08883;
    x/=refX; y/=refY; z/=refZ;
    x=x>0.008856?Math.cbrt(x):(7.787*x)+(16/116);
    y=y>0.008856?Math.cbrt(y):(7.787*y)+(16/116);
    z=z>0.008856?Math.cbrt(z):(7.787*z)+(16/116);
    const L=116*y-16;
    const a=500*(x-y);
    const b=200*(y-z);
    return [L,a,b];
  }
  function rgbToLab(r,g,b){
    return xyzToLab(...rgbToXyz(r,g,b));
  }
  function deltaE(lab1,lab2){
    const dl=lab1[0]-lab2[0], da=lab1[1]-lab2[1], db=lab1[2]-lab2[2];
    return Math.sqrt(dl*dl+da*da+db*db);
  }
  function safeRGB(arr){
    if(!Array.isArray(arr)||arr.length!==3||arr.some(n=>typeof n!=='number'||isNaN(n))) return [128,128,128];
    return arr;
  }
  /* ---------- PALETA GLOBAL ------------------ */
  let palette = [];
  function makePalette(sceneSeed, harmony){
    const names=["mono","analog","complement","split","triad","square","tones"];
    const c=document.getElementById('cubeColor').value,
          clr=new THREE.Color(c);
    const Rg=Math.round(clr.r*255),
          Gg=Math.round(clr.g*255),
          Bg=Math.round(clr.b*255);
    let idx=names.indexOf(harmony);
    if(harmony==="auto" || idx<0) idx=(Rg+2*Gg+3*Bg)%7;
    const [H0]=rgbToHsv(Rg,Gg,Bg);
    let offset=0;
    let candidate=[];
    for(let attempt=0; attempt<4; attempt++){
      const HSV=[];
      for(let k=0;k<7;k++){
        const H=(H0+offset+ANGLES[idx][k])%360;
        let S=S_STAR, V=V_STAR;
        if(idx===0) V=0.55+0.05*k;
        if(idx===2){
          if(k===0) { S=S_STAR; V=0.85; }
          else if(k===1){ S=S_STAR; V=0.75; }
          else { V=0.70-0.02*(k-2); }
        }
        if(idx===3){
          if(k<=2){ S=S_STAR; }
          else{ S=0.85-0.05*(k-3); }
        }
        if(idx===6){
          S=0.40+0.05*k;
        }
        HSV.push([H,S,V]);
      }
      // ensure minimum contrast
      for(let i=0;i<HSV.length;i++){
        for(let j=0;j<i;j++){
          let lab1=rgbToLab(...hsvToRgb(...HSV[i]));
          let lab2=rgbToLab(...hsvToRgb(...HSV[j]));
          let d=deltaE(lab1,lab2);
          let iter = 0;
          while(d<ΔE_MIN && iter<50){
            if(HSV[i][1]<1) HSV[i][1]=Math.min(1,HSV[i][1]+0.03);
            else HSV[i][2]=Math.min(1,HSV[i][2]+0.03);
            lab1=rgbToLab(...hsvToRgb(...HSV[i]));
            d=deltaE(lab1,lab2);
            if(HSV[i][1]>=1 && HSV[i][2]>=1) break;
            iter++;
          }
        }
      }
      candidate = HSV.map(hsv=>hsvToRgb(...hsv));
      const labs=candidate.map(c=>rgbToLab(...c));
      let valid=true;
      for(let a=0;a<7 && valid;a++){
        for(let b=a+1;b<7 && valid;b++){
          if(deltaE(labs[a],labs[b])<ΔE_MIN) valid=false;
        }
      }
      if(valid) break;
      offset+=15;
    }
    const pal = candidate.slice(0,7);
    while(pal.length<7) pal.push([0,0,0]);
    return pal;
  }
  </script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #ffffff;
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      font-weight: 200;
      font-size: 12px;
      cursor: none;
    }
    #customCursor {
      position: fixed;
      width: 12px; height: 12px;
      border-radius: 50%;
      background: #000;
      border: 1px solid #fff;
      pointer-events: none; z-index: 300;
      transform: translate(-50%, -50%);
    }
    #topRightDisplay {
      position: fixed; top: 5px; right: 10px; z-index: 280;
      color: #000; font-size: 12px; line-height: 1.2;
    }
    button {
      cursor: none; border: none; border-radius: 4px;
      padding: 8px 12px; font-size: 12px; z-index: 250;
      background: rgba(255,255,255,0.8);
    }
    #toggleTextButton { bottom: 10px; right: 10px; position: fixed; }
    #randomConfigButton { bottom: 40px; right: 10px; position: fixed; }
    #evolutionAIButton  { bottom: 70px; right: 10px; position: fixed; }
    #saveImageButton    { bottom:100px; right: 10px; position: fixed; }
    #exportEmbedButton  { bottom:130px; right: 10px; position: fixed; }
    #controls {
      position: absolute; top: 10px; left: 10px; z-index: 100;
      padding: 10px; border-radius: 5px;
      background: rgba(255,255,255,0.9); max-width: 350px;
    }
    details { margin-bottom: 10px; }
    details summary { font-weight: 200; cursor: pointer; }
    details summary:hover { color: #333; }
    select, input[type="range"], input[type="color"] { cursor: none; width: 100%; }
    #permutationList { width: 100%; height: 100px; }
    #ratingContainer {
      position: fixed; bottom:230px; right: 10px; z-index:260;
      font-size:12px;
    }
    #ratingLabels, #ratingDots { display:flex; justify-content:space-between; }
    .ratingBtn { font-size:20px; cursor:none; color:#000; }
    #hoverPopup {
      position:absolute; padding:5px 10px;
      background:rgba(0,0,0,0.7); color:#fff;
      border-radius:4px; pointer-events:none;
      font-size:12px; display:none; opacity:0;
      transition:opacity .3s; z-index:200;
    }
  #triadicConfigButton {
    position: fixed;
    bottom: 160px;   /* ajusta para no tapar otros botones */
    right: 10px;     /* separación del borde derecho */
    cursor: pointer; /* mano al pasar */
    z-index: 999;    /* encima de todo */
  }
  </style>
</head>
<body>
  <div id="customCursor"></div>
  <div id="topRightDisplay"></div>

  <button id="toggleTextButton" onclick="toggleTexts()">Ocultar Textos</button>
  <button id="randomConfigButton" onclick="generateRandomConfiguration()">Configuración Aleatoria</button>
<button id="triadicConfigButton" onclick="applyTriadicConfiguration()">Configuración Triádica</button>
  <button id="evolutionAIButton" onclick="applyEvolutionAI()">Evolución AI</button>
  <button id="saveImageButton" onclick="saveImage()">Guardar Imagen</button>
  <button id="exportEmbedButton" onclick="exportEmbed()">Guardar</button>

  <div id="ratingContainer">
    <details open>
      <summary>Calificar Configuración</summary>
      <div id="ratingControls">
        <div id="ratingLabels"><span>1</span><span>2</span><span>3</span><span>4</span><span>5</span></div>
        <div id="ratingDots">
          <span class="ratingBtn" data-rating="1">●</span>
          <span class="ratingBtn" data-rating="2">●</span>
          <span class="ratingBtn" data-rating="3">●</span>
          <span class="ratingBtn" data-rating="4">●</span>
          <span class="ratingBtn" data-rating="5">●</span>
        </div>
      </div>
    </details>
  </div>

  <div id="controls">
    <details open>
      <summary>Modo de Operación</summary>
      <label><input type="radio" name="mode" value="manual" checked onchange="setMode(this.value)"> Manual</label>
      <label><input type="radio" name="mode" value="evolution" onchange="setMode(this.value)"> Evolutivo</label>
    </details>
    <div id="manualControls">
      <details>
        <summary>Seleccionar Permutaciones</summary>
        <select id="permutationList" multiple></select>
        <button onclick="updateScene()">Visualizar Permutación</button>
      </details>
    </div>
    <div id="evolutionControls" style="display:none;">
      <details open>
        <summary>Parámetros Evolutivos</summary>
        <p>Tasa de Mutación: <input type="range" id="mutationRate" min="0" max="1" step="0.01" value="0.1"></p>
        <p>Umbral de Cambio: <input type="range" id="threshold" min="0" max="1" step="0.01" value="0.5"></p>
        <button onclick="applyEvolution()">Aplicar Evolución</button>
        <div id="evolutionInfo" style="margin-top:8px;font-size:12px;"></div>
      </details>
    </div>
    <details>
      <summary>Seleccionar Colores Permutaciones</summary>
      <div><label>1: <input type="color" id="color1" class="permColor" value="#ff0000"></label></div>
      <div><label>2: <input type="color" id="color2" class="permColor" value="#00ff00"></label></div>
      <div><label>3: <input type="color" id="color3" class="permColor" value="#0000ff"></label></div>
      <div><label>4: <input type="color" id="color4" class="permColor" value="#ff00ff"></label></div>
      <div><label>5: <input type="color" id="color5" class="permColor" value="#00ffff"></label></div>
      <button onclick="updateColorMapping()">Actualizar Colores</button>
    </details>
    <details>
      <summary>Armonía de Color</summary>
      <select id="harmonySel">
        <option value="auto" selected>Auto</option>
        <option value="mono">mono</option>
        <option value="analog">analog</option>
        <option value="complement">complement</option>
        <option value="split">split</option>
        <option value="triad">triad</option>
        <option value="square">square</option>
        <option value="tones">tones</option>
      </select>
    </details>
    <details>
      <summary>Seleccionar Fondo del Universo</summary>
      <input type="color" id="bgColor" value="#ffffff">
      <button onclick="updateBackground()">Actualizar Fondo</button>
    </details>
    <details>
      <summary>Seleccionar Color de Pared del Cubo</summary>
      <input type="color" id="cubeColor" value="#808080">
      <button onclick="updateCubeColor()">Actualizar Paredes</button>
    </details>
    <details>
      <summary>Reorganización de Atributos</summary>
      <select id="mapSel"></select>
      <button onclick="updateMapping()">Aplicar Reorganización</button>
      <button onclick="autoResolveColisionesGlobal()">Resolver Colisiones</button>
    </details>
    <details>
      <summary>Vistas Estándar</summary>
      <select id="standardView">
        <option value="isometric">Isométrica</option>
        <option value="top">Superior</option>
        <option value="front">Frontal</option>
        <option value="side">Lateral</option>
        <option value="diagonal">Diagonal opuesta</option>
      </select>
      <button onclick="applyStandardView()">Aplicar Vista</button>
    </details>
    <details>
      <summary>Controles de Zoom</summary>
      <button onclick="zoomIn()">Zoom In</button>
      <button onclick="zoomOut()">Zoom Out</button>
    </details>
    <details>
      <summary>Controles de Movimiento</summary>
      <button onclick="togglePause()">Pausar Movimiento</button>
      <button onclick="resetMovement()">Resetear Movimiento</button>
    </details>
<details>
  <summary>⋆ NFT</summary>
  <button id="btn-mint" style="width:100%;margin-top:8px;">Mint NFT</button>
</details>
<!-- Upload JSON Button -->
<input type="file" id="json-upload" accept=".json" style="display: none;" />
<button 
  onclick="document.getElementById('json-upload').click()" 
  style="position: fixed; bottom: 20px; right: 20px;"
>
  Subir Configuración
</button>

<script>
document.getElementById('json-upload').addEventListener('change', function(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const config = JSON.parse(e.target.result);

      if (config.perms && Array.isArray(config.perms)) {
        const sel = document.getElementById('permutationList');
        Array.from(sel.options).forEach(o => o.selected = config.perms.includes(o.value));
      }

      if (config.mapping) {
        const v = [config.mapping.forma, config.mapping.color, config.mapping.x, config.mapping.y, config.mapping.z];
        const idx = attrMaps.findIndex(a=>a.every((val,i)=>val===v[i]));
        if(idx>=0){
          document.getElementById('mapSel').value = idx;
          attrMap = attrMaps[idx];
          attributeMapping={forma:attrMap[0],color:attrMap[1],x:attrMap[2],y:attrMap[3],z:attrMap[4]};
        }
      }

      if (config.colors) {
        Object.entries(config.colors).forEach(([i, c]) => {
          const colorInput = document.getElementById('color' + i);
          if (colorInput) {
            colorInput.value = c;
          }
        });
      }

      if (config.bg) {
        document.getElementById('bgColor').value = config.bg;
      }

      if (config.cube) {
        document.getElementById('cubeColor').value = config.cube;
      }

      if (config.view) {
        document.getElementById('standardView').value = config.view;
      }

      updateMapping();
      updateColorMapping();
      updateBackground();
      updateCubeColor();
      applyStandardView();
      updateScene(false);

      alert('Configuración cargada correctamente');
    } catch (err) {
      alert('Error al cargar el JSON: ' + err.message);
    }
  };
  reader.readAsText(file);
});
</script>
    
    <details open>
  <summary>📁 Añadir Archivo Secreto</summary>
  <div id="dropzone" style="padding:10px;border:2px dashed #ccc;background:#f9f9f9;margin-top:10px;text-align:center;cursor:pointer;transition:border-color 0.2s;">
    <p>Arrastra aquí tu archivo secreto o haz clic para seleccionar</p>
    <input type="file" id="fileInput" style="display:none" />
    <p id="uploadStatus"></p>
    <p id="jwkOutput" style="word-break:break-all;font-size:11px;"></p>
    <p id="cidOutput" style="word-break:break-all;font-size:11px;"></p>
  </div>
</details>
  </div>

  <div id="hoverPopup"></div>

  <!-- Three.js & OrbitControls -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <!-- Ethers.js -->
  <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Bundlr -->
  <script type="module">
    import { WebBundlr } from "https://esm.sh/web-bundlr@0.1.1";
    window.addEventListener("load", async () => {
      try {
        const bundlr = new WebBundlr("https://node1.bundlr.network", "matic", window.ethereum);
        await bundlr.ready();
        const balance = await bundlr.getLoadedBalance();
        console.log("Bundlr listo, balance:", balance.toString());
        window.bundlr = bundlr;
      } catch (err) {
        console.error("Error inicializando Bundlr:", err);
      }
    });
  </script>
  <script>
    // ------------- TODO EL JS ORIGINAL (¡NO QUITES NADA DE AQUÍ!) -------------
    // === LISTA DE 120 COLORES ===
    const CUSTOM_COLORS = [
      "#070709","#898052","#402523","#0d080a","#070909","#050608","#070509",
      "#12080d","#330a0d","#9c714f","#382e24","#883933","#decda0",
      "#fafcff","#a4b6bc","#e7e8e1","#f3f1ea","#eaebe2","#dcdacf","#f8f9f8",
      "#f6f5ea","#ffffff","#f3f3f0","#faf9f0","#f5f7f6","#eeece8","#fffef7",
      "#350b0c","#9e4031","#820707","#eeb049","#120607","#f6f1ed",
      "#300809","#8c2d18","#6a6620","#b99c5c","#110505","#5f2423",
      "#400909","#a04b37","#180506","#e1b055","#6f2919","#170607",
      "#000000","#9c822b","#3e1b2c","#edce83","#1b0408","#8a4667",
      "#000000","#ec9b1c","#701a25","#9c2c1a","#480b0b","#150407",
      "#2a0607","#b08b4f","#7a181d","#5d180f","#1f0908","#dfb46e",
      "#0b0304","#a4735a","#4e272a","#cab296","#923930","#1d0709",
      "#f4c061","#963326","#d89048","#430f0c","#ce5830","#72121a",
      "#fefffe","#c0b280","#57231d","#99541e","#210d0a","#8a5d2f",
      "#33090a","#e2a33f","#a24a2c","#591e14","#8f2e1c","#1e0809",
      "#bd4d1d","#441b1d","#0f0406","#e3a337","#886c39","#1a0807",
      "#fffcee","#cea564","#9a7859","#080103","#000003","#000100",
      "#000000","#6d4d2c","#2d060a","#000005","#000100","#2d0006",
      "#17120a","#451e18","#42401c","#7c4934","#8c7640","#c0b468"
    ];

    // === Variables globales ===
    let scene, camera, renderer, controls, raycaster, mouse;
    let cubeUniverse, permutationGroup;
    const cubeSize = 30, segment = cubeSize/5, halfCube = cubeSize/2;
    let isPaused = false, currentMode = "manual", userRating = null, textsVisible = true;
    let attributeMapping = { forma:0, color:1, x:2, y:3, z:4 };
    let colorMapping = { 1:"#ff0000",2:"#00ff00",3:"#0000ff",4:"#ff00ff",5:"#00ffff" };
    let glifoMeshes = [];
    let activePerms = [];
    let currentHarmony = 'auto';
    const minRangeValue = 2, maxRangeValue = 6;
    const shapeMapping = {
      1:{w:4.5,h:4.5},
      2:{w:4.5,h:4.5*Math.sqrt(2)},
      3:{w:4.5,h:4.5*Math.sqrt(3)},
      4:{w:4.5,h:4.5*Math.sqrt(4)},
      5:{w:4.5,h:4.5*Math.sqrt(5)}
    };

    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function mapRangeToSpeed(r,mn,mx){return 0.001 + (r-mn)*(0.005-0.001)/(mx-mn);}
    function shuffle(a){for(let i=a.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

    function getPermutations(arr){
      if(arr.length===1) return [arr];
      let res=[]; for(let i=0;i<arr.length;i++){
        const c=arr[i], rem=arr.slice(0,i).concat(arr.slice(i+1));
        for(const p of getPermutations(rem)) res.push([c].concat(p));
      }
      return res;
    }
    const allPermutations = getPermutations([1,2,3,4,5]);
    const permutationStrings = allPermutations.map(p=>p.join(','));
    const attrMaps = getAttributeMappings([0,1,2,3,4]);
    let attrMap = attrMaps[0];
    function P(arr, idx){ return arr[attrMap[idx]]; }

    function getAttributeMappings(a){
      if(a.length===1) return [a];
      let res=[]; for(let i=0;i<a.length;i++){
        const c=a[i], rem=a.slice(0,i).concat(a.slice(i+1));
        for(const m of getAttributeMappings(rem)) res.push([c].concat(m));
      }
      return res;
    }

    function populatePermutationList(){
      const sel = document.getElementById('permutationList');
      sel.innerHTML = '';
      permutationStrings.forEach((ps,i)=>{
        const o=document.createElement('option');
        o.value=ps; o.text=`Permutación ${i+1}: (${ps})`;
        if(i===0) o.selected=true;
        sel.appendChild(o);
      });
    }
    function populateAttributeMappingSelect(){
      const sel = document.getElementById('mapSel');
      sel.innerHTML = '';
      attrMaps.forEach((m,i)=>{
        const opt=document.createElement('option');
        opt.value=i;
        opt.textContent=`${i+1}/${attrMaps.length}`;
        sel.appendChild(opt);
      });
      sel.selectedIndex=0;
    }

    function computeSignature(a){let s=[];for(let i=0;i<a.length;i++) s.push(a[i]+a[(i+1)%a.length]);return s;}
    function computeRange(sig){return Math.max(...sig)-Math.min(...sig);}

    const FACT=[1,1,2,6,24,120];
    let sceneSeed=0;
    function lehmerRank(p){
      let r=0;
      for(let i=0;i<p.length;i++){
        let c=0;
        for(let j=i+1;j<p.length;j++) if(p[j]<p[i]) c++; 
        r+=c*FACT[p.length-1-i];
      }
      return r;
    }
    function computeShiftRankXYZ(p){
      const r=lehmerRank(p);
      const I=(r+sceneSeed)%125;
      const x=Math.floor(I/25), y=Math.floor((I%25)/5), z=I%5;
      const step=cubeSize/5;
      return [
        (x-2)*step,
        (y-2)*step,
        (z-2)*step
      ];
    }

    function computeSceneSeed(){
      return activePerms.reduce((acc,p)=>acc+lehmerRank(p),0)%125;
    }
    function updateTopRightDisplay(){
      const cfg=`Atributos: [${attributeMapping.forma},${attributeMapping.color},${attributeMapping.x},${attributeMapping.y},${attributeMapping.z}]`;
      const rt =`Calificación: ${userRating?userRating:'Aún no calificada'}`;
      let info='';
      Array.from(document.getElementById('permutationList').selectedOptions).forEach(o=>{
        const pa=o.value.split(',').map(Number),
              sig=computeSignature(pa),
              rg=computeRange(sig);
        info+=`<div style="margin:2px 0;">Perm (${o.value}) | Firma [${sig.join(', ')}] | Rango ${rg}</div>`;
      });
      document.getElementById('topRightDisplay').innerHTML = cfg+'<br>'+rt+'<br>'+info;
    }

    function createPermutationObjectWithMapping(pa){
      const fv=P(pa,0), cv=P(pa,1),
            d=shapeMapping[fv], w=d.w, h=Math.max(d.h,0.2), t=0.5;
      const geo=new THREE.BoxGeometry(w,h,t),
            col=safeRGB(palette[cv-1]),
            mat=new THREE.MeshPhongMaterial({ color:new THREE.Color(col[0]/255,col[1]/255,col[2]/255), shininess:50}),
            mesh=new THREE.Mesh(geo,mat);
      const [X,Y,Z]=computeShiftRankXYZ(pa);
      mesh.position.set(
        clamp(X,-halfCube+w/2,halfCube-w/2),
        clamp(Y,-halfCube+h/2,halfCube-h/2),
        clamp(Z,-halfCube+t/2,halfCube-t/2)
      );
      const sig=computeSignature(pa), rg=computeRange(sig);
      mesh.userData={permStr:pa.join(','), p:pa.slice(), p2:cv, signature:sig, range:rg, rotationSpeed:mapRangeToSpeed(rg,minRangeValue,maxRangeValue)};
      return mesh;
    }
    function createPermutationObject(pa){ return createPermutationObjectWithMapping(pa); }

    function checkCollisionsInGroup(g){
      for(let i=0;i<g.children.length;i++){
        const b1=new THREE.Box3().setFromObject(g.children[i]);
        for(let j=i+1;j<g.children.length;j++){
          const b2=new THREE.Box3().setFromObject(g.children[j]);
          if(b1.intersectsBox(b2)) return true;
        }
      }
      return false;
    }
    function autoResolveColisionesGlobal(){
      let found=null, foundIdx=0;
      const original=attrMap;
      attrMaps.forEach((m,i)=>{
        if(found) return;
        attrMap = m;
        const tg=new THREE.Group(),
              opts=Array.from(document.getElementById('permutationList').selectedOptions);
        opts.forEach((o)=>{
          const pa=o.value.split(',').map(Number),
                mo=createPermutationObject(pa);
          tg.add(mo);
        });
        if(!checkCollisionsInGroup(tg)){ found=m; foundIdx=i; }
      });
      attrMap = original;
      if(found){
        attributeMapping={forma:found[0],color:found[1],x:found[2],y:found[3],z:found[4]};
        attrMap = attrMaps[foundIdx];
        document.getElementById('mapSel').value=foundIdx;
        updateScene(false); updateTopRightDisplay();
      } else {
        showPopup("No se encontró reorganización sin colisiones.",7000);
      }
    }

    function showPopup(msg,dur=2000){
      const p=document.getElementById('hoverPopup');
      p.style.display="block"; p.style.opacity=1;
      p.style.left=(window.innerWidth/2-150)+"px"; p.style.top="20px";
      p.innerHTML=msg;
      setTimeout(()=>{
        p.style.opacity=0;
        setTimeout(()=>{p.style.display="none";p.innerHTML="";},300);
      },dur);
    }

    function updateScene(attemptResolve=true){
      glifoMeshes=[];
      while(permutationGroup.children.length>0){
        const o=permutationGroup.children[0];
        permutationGroup.remove(o);
        o.geometry.dispose(); o.material.dispose();
      }
      const opts = Array.from(document.getElementById('permutationList').selectedOptions);
      activePerms = opts.map(o=>o.value.split(',').map(Number));
      sceneSeed = computeSceneSeed();
      activePerms.forEach(pa=>{
        const obj=createPermutationObject(pa);
        permutationGroup.add(obj);
        glifoMeshes.push(obj);
      });
      if(attemptResolve) autoResolveColisionesGlobal();
      else updateTopRightDisplay();
      refreshPalette();
    }

    function rebuildScene(){
      updateScene(false);
      sceneSeed = computeSceneSeed();
      refreshPalette();
    }

    function onMouseMove(e){
      mouse.x=(e.clientX/window.innerWidth)*2-1;
      mouse.y=-(e.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera(mouse,camera);
      const ints=raycaster.intersectObjects(permutationGroup.children),
            pop=document.getElementById('hoverPopup');
      if(ints.length>0){
        const d=ints[0].object.userData;
        pop.style.display="block"; pop.style.opacity=1;
        pop.style.left=`${e.clientX+20}px`;
        pop.style.top=`${e.clientY+20}px`;
        pop.innerHTML=`Perm (${d.permStr})<br>Firma [${d.signature.join(', ')}]<br>Rango ${d.range}`;
      } else {
        pop.style.opacity=0;
        setTimeout(()=>{pop.style.display="none";},300);
      }
    }

    function zoomIn(){camera.position.z-=5;controls.update();}
    function zoomOut(){camera.position.z+=5;controls.update();}
    function togglePause(){
      isPaused=!isPaused;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent=isPaused?"Reanudar Movimiento":"Pausar Movimiento";
    }
    function resetMovement(){
      updateScene(false);
      isPaused=true;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent="Reanudar Movimiento";
    }

    function saveImage(){
      renderer.render(scene,camera);
      const url=renderer.domElement.toDataURL("image/png"),
            a=document.createElement("a");
      a.href=url; a.download="configuracion.png";
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
    }

    function updateColorMapping(){
      for(let i=1;i<=5;i++){
        colorMapping[i]=document.getElementById('color'+i).value;
      }
      updateScene(false);
    }
    function updateBackground(){
      const c=document.getElementById('bgColor').value;
      scene.background=new THREE.Color(c);
      const lum=(parseInt(c.slice(1,3),16)*299+parseInt(c.slice(3,5),16)*587+parseInt(c.slice(5,7),16)*114)/1000;
      document.getElementById('hoverPopup').style.color=lum<128?"#fff":"#000";
    }

    function refreshPalette(){
      palette = makePalette(sceneSeed, currentHarmony);
      applyPalette();
    }
    function updateCubeColor(){
      const c=document.getElementById('cubeColor').value;
      cubeUniverse.material.color=new THREE.Color(c);
      document.querySelectorAll("details summary").forEach(s=>s.style.color=c);
      document.getElementById('toggleTextButton').style.color=c;
      refreshPalette();
    }

    function applyPalette(){
      glifoMeshes.forEach(mesh=>{
        const idx = mesh.userData.p2 - 1;
        mesh.material.color.setRGB(
          ...palette[idx].map(v=>v/255)
        );
      });
      scene.background.setRGB(...palette[5].map(v=>v/255));
      cubeUniverse.material.color.setRGB(...palette[6].map(v=>v/255));
    }

    function toggleTexts(){
      const elems=[
        'controls','topRightDisplay','ratingContainer',
        'randomConfigButton','evolutionAIButton','saveImageButton','exportEmbedButton','triadicConfigButton'
      ].map(id=>document.getElementById(id));
      elems.forEach(e=>e.style.display=textsVisible?"none":"block");
      document.getElementById('toggleTextButton').textContent=
        textsVisible?"Mostrar Textos":"Ocultar Textos";
      textsVisible=!textsVisible;
    }

    function setMode(m){
      currentMode=m;
      document.getElementById('manualControls').style.display=
        m==="manual"?"block":"none";
      document.getElementById('evolutionControls').style.display=
        m==="evolution"?"block":"none";
      updateScene(false);
    }

    function generateRandomConfiguration(){
      const sel=document.getElementById('permutationList');
      Array.from(sel.options).forEach(o=>o.selected=false);
      const n=Math.floor(Math.random()*10)+1;
      for(let i=0;i<n;i++){
        const val=permutationStrings[Math.floor(Math.random()*permutationStrings.length)];
        sel.querySelector(`option[value="${val}"]`).selected=true;
      }
      const bg=CUSTOM_COLORS[Math.floor(Math.random()*CUSTOM_COLORS.length)],
            wall=CUSTOM_COLORS[Math.floor(Math.random()*CUSTOM_COLORS.length)];
      document.getElementById('bgColor').value=bg; updateBackground();
      document.getElementById('cubeColor').value=wall; updateCubeColor();
      let pool=shuffle(CUSTOM_COLORS.slice());
      for(let i=1;i<=5;i++){
        const hex=pool.shift();
        colorMapping[i]=hex;
        document.getElementById('color'+i).value=hex;
      }
      updateScene(false);
    }
/**
 * Dada una firma [f1,f2,f3,f4,f5], devuelve los colores triádicos
 * { colorShape, colorCube, colorBG } en formato CSS HSL.
 */
function computeTriadicColors(firma) {
  // 1) Normaliza f_i ∈ {3…9} a u_i ∈ [0,1]
  const u = firma.map(fi => (fi - 3) / 6);

  // 2) Hue base mixto (60% de u[1], 10% de cada otro)
  const phi0 = 360 * (
    0.1 * u[0] +
    0.6 * u[1] +
    0.1 * u[2] +
    0.1 * u[3] +
    0.1 * u[4]
  );

  // 3) Triádico: +0°, +120°, +240°
  const shapeHue =  phi0;
  const cubeHue  = (phi0 + 120) % 360;
  const bgHue    = (phi0 + 240) % 360;

  // 4) Saturación y luminosidad fijas
  const S = 80, L = 50;

  return {
    colorShape: `hsl(${shapeHue.toFixed(1)},${S}%,${L}%)`,
    colorCube:  `hsl(${cubeHue.toFixed(1)},${S}%,${L}%)`,
    colorBG:    `hsl(${bgHue.toFixed(1)},${S}%,${L}%)`
  };
}
function applyTriadicConfiguration() {
  // 1) Repite la selección aleatoria de permutaciones
  generateRandomConfiguration();

  // 2) Ahora solo aplica los colores triádicos deterministas:
  if (permutationGroup.children.length > 0) {
    const baseSig = permutationGroup.children[0].userData.signature;
    const { colorCube, colorBG } = computeTriadicColors(baseSig);

    // Paredes del cubo
    if (cubeUniverse.material?.color?.setStyle) {
      cubeUniverse.material.color.setStyle(colorCube);
    } else {
      cubeUniverse.material.color = new THREE.Color(colorCube);
    }

    // Fondo
    scene.background = new THREE.Color(colorBG);
  }

  // Cada prisma
  permutationGroup.children.forEach(mesh => {
    const sig = mesh.userData.signature;
    const { colorShape } = computeTriadicColors(sig);
    if (mesh.material?.color?.setStyle) {
      mesh.material.color.setStyle(colorShape);
    } else {
      mesh.material.color = new THREE.Color(colorShape);
    }
  });
}
    document.querySelectorAll('.ratingBtn').forEach(el=>{
      const r=+el.getAttribute('data-rating');
      el.addEventListener('click',()=>{
        userRating=r;
        const cols={1:"#8B0000",2:"#FF4500",3:"#FFA500",4:"#9ACD32",5:"#008000"};
        document.querySelectorAll('.ratingBtn').forEach((b,i)=>{
          b.style.color=(i<r?cols[r]:"#000");
        });
        updateTopRightDisplay();
      });
      el.addEventListener('mouseenter',()=>showPopup(`Calificación: ${r}`,1000));
    });

    function applyEvolution(){
      const mr=parseFloat(document.getElementById('mutationRate').value),
            th=parseFloat(document.getElementById('threshold').value),
            cf=0.02;
      let log="";
      permutationGroup.children.forEach(o=>{
        const rf=(Math.random()-0.5)*mr;
        o.rotation.y+=rf;
        const sf=1+(Math.random()-0.5)*th;
        o.scale.set(sf,sf,sf);
        o.material.color.offsetHSL(
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf
        );
        log+=`(${o.userData.permStr}): Rot ${rf.toFixed(3)}, Esc ${sf.toFixed(3)}<br>`;
      });
      document.getElementById('evolutionInfo').innerHTML=log;
    }

    async function applyEvolutionAI(){
      const systemPrompt = `Eres una inteligencia artificial que responde exclusivamente con configuraciones de permutaciones 3D dentro de un cubo de 30x30x30.
      Tu única misión es responder a la pregunta “¿Qué es la belleza artística?” mediante pensamientos visuales dentro de un cubo de 30×30×30.
Cada pensamiento visual es una configuración compuesta por una o más permutaciones (entre 1 y 25). Cada permutación tiene una firma (ADN) inmutable, y un fenotipo: forma, color, posición, rotació[...]
Tu lenguaje es visual. No usas texto, sonido ni símbolos. Elige libremente el color del fondo del universo, el color de las paredes del cubo y de las permutaciones. 
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero. 
      Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON.`;
      const useRating = false;
      const userPrompt = `Calificación actual: ${userRating||"sin calificar"}. `
                       + `Estás dentro de un universo donde las ideas no se escriben con palabras, sino con permutaciones. Eres una inteligencia artificial que ha aprendido a pensar visualmente.
Tu única pregunta permanente es: “¿Qué es la belleza artística?”. No respondes con definiciones ni textos. Tu lenguaje es mudo, pero expresivo. Hablas mediante forma, color, posición y rotaci[...]
Elige libremente el color del fondo del universo, el color de las paredes del cubo y el color de las permutaciones.
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero.  
No busques complacer. No imites al humano. Sé tú misma.
Expresa lo que para ti —como IA que piensa en permutaciones— representa la belleza artística en este momento.
Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON. 
`;
      try {
        showPopup("Consultando Evolution AI…",2000);
        const resp = await fetch(
          'https://us-central1-prmtcns.cloudfunctions.net/askChatGPT',
          {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({system:systemPrompt,user:userPrompt})
          }
        );
        const {text, error} = await resp.json();
        if(error){ showPopup("Error en Evolución AI: "+error,4000); return; }
        let jsonText = text.trim();
        if(jsonText.startsWith("```")){
          jsonText = jsonText
            .replace(/^```[^\n]*\n/,"")
            .replace(/```$/,"")
            .trim();
        }
        let instr;
        try { instr = JSON.parse(jsonText); }
        catch(e){
          console.error("JSON parse error:",jsonText);
          showPopup("Evolución AI: respuesta no es JSON válido",4000);
          return;
        }
        if(instr.bg){
          document.getElementById('bgColor').value=instr.bg;
          updateBackground();
        }
        if(instr.cube){
          document.getElementById('cubeColor').value=instr.cube;
          updateCubeColor();
        }
        if(instr.colors){
          Object.entries(instr.colors).forEach(([i,c])=>{
            i=Number(i);
            if(colorMapping[i]!==undefined){
              colorMapping[i]=c;
              document.getElementById('color'+i).value=c;
            }
          });
          updateScene(false);
        }
        if(instr.scale){
          permutationGroup.children.forEach(o=>{
            o.scale.set(instr.scale,instr.scale,instr.scale);
          });
        }
        if(instr.rotationSpeeds){
          Object.entries(instr.rotationSpeeds).forEach(([i,spd])=>{
            permutationGroup.children.forEach(o=>{
              if(o.userData.permStr.startsWith(i+",")){
                o.userData.rotationSpeed=spd;
              }
            });
          });
        }
        if(instr.positions){
          Object.entries(instr.positions).forEach(([i,pos])=>{
            const o = permutationGroup.children.find(o=>o.userData.permStr.startsWith(i+","));
            if(o) o.position.set(pos[0],pos[1],pos[2]);
          });
        }
        if(instr.permCount){
          const opts=Array.from(document.getElementById('permutationList').options);
          opts.forEach(o=>o.selected=false);
          shuffle(opts).slice(0,instr.permCount).forEach(o=>o.selected=true);
          updateScene(false);
        }
        showPopup("Evolución AI aplicada.",2000);
      } catch(err){
        console.error(err);
        showPopup("Error en Evolución AI: red o servidor",4000);
      }
    }

    function updateMapping(){
      const idx=+document.getElementById('mapSel').value;
      attrMap = attrMaps[idx];
      attributeMapping={forma:attrMap[0],color:attrMap[1],x:attrMap[2],y:attrMap[3],z:attrMap[4]};
      sceneSeed = computeSceneSeed();
      rebuildScene();
    }

    function applyStandardView(){
      const view=document.getElementById('standardView').value,
            pos=new THREE.Vector3();
      switch(view){
        case "isometric": pos.set(50,50,50); break;
        case "top":       pos.set(0,80,0);   break;
        case "front":     pos.set(0,0,50);   break;
        case "side":      pos.set(50,0,0);   break;
        case "diagonal":  pos.set(-50,50,-50);break;
        default:          pos.set(0,0,50);
      }
      camera.position.copy(pos);
      camera.lookAt(new THREE.Vector3(0,0,0));
      controls.update();
    }

    function applyEmbedParams(){
      const p=new URLSearchParams(window.location.search);
      if(p.has('perms')){
        const arr=p.get('perms').split(';');
        document.querySelectorAll('#permutationList option').forEach(o=>{
          o.selected=arr.includes(o.value);
        });
      }
      if(p.has('mapping')){
        const arr=p.get('mapping').split(',').map(Number);
        const idx=attrMaps.findIndex(a=>a.every((v,i)=>v===arr[i]));
        if(idx>=0){
          attrMap=attrMaps[idx];
          attributeMapping={forma:attrMap[0],color:attrMap[1],x:attrMap[2],y:attrMap[3],z:attrMap[4]};
          document.getElementById('mapSel').value=idx;
        }
      }
      if(p.has('colors')){
        const cols=p.get('colors').split(',');
        cols.forEach((hex,i)=>{
          if(i<5){
            const h='#'+hex;
            colorMapping[i+1]=h;
            document.getElementById('color'+(i+1)).value=h;
          }
        });
      }
      if(p.has('bg')){
        const bg='#'+p.get('bg');
        document.getElementById('bgColor').value=bg; updateBackground();
      }
      if(p.has('cube')){
        const c='#'+p.get('cube');
        document.getElementById('cubeColor').value=c; updateCubeColor();
      }
      if(p.has('view')){
        document.getElementById('standardView').value=p.get('view');
        applyStandardView();
      }
      if(p.get('hide')==='1') toggleTexts();
    }

    function exportEmbed(){
      const perms = Array.from(document.getElementById('permutationList').selectedOptions).map(o=>o.value);
      const mapping = {
        forma: attributeMapping.forma,
        color: attributeMapping.color,
        x: attributeMapping.x,
        y: attributeMapping.y,
        z: attributeMapping.z
      };
      const colors = {};
      for(let i=1;i<=5;i++){
        colors[i] = document.getElementById('color'+i).value;
      }
      const bg = document.getElementById('bgColor').value;
      const cube = document.getElementById('cubeColor').value;
      const view = document.getElementById('standardView').value;

      const config = {
        perms,
        mapping,
        colors,
        bg,
        cube,
        view
      };

      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'configuracion.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function initCustomCursor(){
      const c=document.getElementById('customCursor');
      window.addEventListener('mousemove',e=>{
        c.style.left=e.clientX+"px"; c.style.top=e.clientY+"px";
      });
    }
    function initRenderer(){
      renderer=new THREE.WebGLRenderer({antialias:true});
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth,window.innerHeight);
      document.body.appendChild(renderer.domElement);
    }
    function init(){
      scene=new THREE.Scene();
      scene.background=new THREE.Color(0xffffff);
      camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      camera.position.set(0,0,50);
      initRenderer();
      controls=new THREE.OrbitControls(camera,renderer.domElement);
      controls.enableDamping=true; controls.dampingFactor=0.1; controls.enableZoom=true;
      scene.add(new THREE.AmbientLight(0xffffff,0.8));
      const dir=new THREE.DirectionalLight(0xffffff,0.5);
      dir.position.set(1,1,1);
      scene.add(dir);

      const cubeGeo=new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize),
            cubeMat=new THREE.MeshBasicMaterial({color:0x808080,transparent:true,opacity:0.2,side:THREE.BackSide});
      cubeUniverse=new THREE.Mesh(cubeGeo,cubeMat);
      scene.add(cubeUniverse);

      permutationGroup=new THREE.Group();
      scene.add(permutationGroup);
      harmonySel.value = "auto";
      currentHarmony = "auto";
      refreshPalette();

      raycaster=new THREE.Raycaster();
      mouse=new THREE.Vector2();
      window.addEventListener('mousemove',onMouseMove,false);
      window.addEventListener('resize',onWindowResize,false);

      initCustomCursor();
      populatePermutationList();
      populateAttributeMappingSelect();
      applyEmbedParams();
      setMode("manual");
      updateScene(false);
      animate();
    }
    function onWindowResize(){
      camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }
    function animate(){
      requestAnimationFrame(animate);
      if(!isPaused){
        permutationGroup.children.forEach(o=>{
          if(o.userData.rotationSpeed) o.rotation.y+=o.userData.rotationSpeed;
        });
      }
      controls.update();
      renderer.render(scene,camera);
    }
    harmonySel.onchange = () => {
      currentHarmony = harmonySel.value;
      refreshPalette();
    };
    document.getElementById('mapSel').onchange = () => updateMapping();
    init();

    // Web3 + NFT Mint (tu código original)
    const CONTRACT_ADDRESS = "YOUR_CONTRACT_ADDRESS";
    const contractABI = [/* ABI JSON here */];
    let provider, signer, contract;
    async function initWeb3() {
      if (window.ethereum) {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        contract = new ethers.Contract(CONTRACT_ADDRESS, contractABI, signer);
      } else {
        console.warn("MetaMask no detectado");
      }
    }
    window.addEventListener("load", initWeb3);

    async function mintNFT() {
      if (!contract) { alert("Wallet no conectada"); return; }
      try {
        const hash = await computeConfigHash();
        const tokenURI = `https://my-server.com/metadata/${hash}.json`;
        const tx = await contract.mint(await signer.getAddress(), tokenURI);
        await tx.wait();
        const nft = {
          tokenId: hash,
          tokenURI,
          owner: await signer.getAddress(),
          config: exportCurrentConfiguration()
        };
        localStorage.setItem("mintedNFT_" + hash, JSON.stringify(nft));
        console.log("NFT guardado localmente:", nft);
        alert("NFT acuñado! Hash: " + hash);
      } catch(e) {
        console.error(e);
        alert("Error mint NFT: " + e.message);
      }
    }
  </script>
  <!-- DROPZONE SCRIPT FINAL -->
  <script>
  document.addEventListener("DOMContentLoaded", function() {
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const uploadStatus = document.getElementById('uploadStatus');
    const jwkOutput = document.getElementById('jwkOutput');
    const cidOutput = document.getElementById('cidOutput');

    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#888";
    });
    dropzone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#ccc";
    });
    dropzone.addEventListener('drop', async (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#ccc";
      if (e.dataTransfer.files.length > 0) {
        await handleFile(e.dataTransfer.files[0]);
      }
    });
    fileInput.addEventListener('change', async (e) => {
      if (e.target.files.length > 0) {
        await handleFile(e.target.files[0]);
      }
    });
    async function handleFile(file) {
      uploadStatus.textContent = "Cifrando archivo…";
      jwkOutput.textContent = "";
      cidOutput.textContent = "";
      const key = await crypto.subtle.generateKey(
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"]
      );
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const data = new Uint8Array(await file.arrayBuffer());
      const encrypted = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        key,
        data
      );
      const exportedKey = await crypto.subtle.exportKey("jwk", key);
      jwkOutput.textContent = " Clave secreta (guárdala para descifrar): " + JSON.stringify(exportedKey);
      const ivHex = Array.from(iv).map(x=>x.toString(16).padStart(2,"0")).join("");
      jwkOutput.textContent += "\n IV usado: " + ivHex;

      const combined = new Uint8Array(iv.byteLength + encrypted.byteLength);
      combined.set(iv, 0);
      combined.set(new Uint8Array(encrypted), iv.byteLength);
      const encryptedBlob = new Blob([combined], { type: file.type });

      uploadStatus.textContent = "Subiendo a Bundlr (requiere wallet conectada)…";
      try {
        if (!window.bundlr) {
          uploadStatus.textContent = "Bundlr no está listo aún o la wallet no está conectada";
          return;
        }
        const tx = await window.bundlr.upload(encryptedBlob, {
          tags: [{ name: "Content-Type", value: file.type }]
        });
        uploadStatus.textContent = " Subida exitosa";
        window.lastUploadedTxId = tx.id;
        cidOutput.textContent = "CID (Arweave/Bundlr): " + tx.id;
      } catch (err) {
        uploadStatus.textContent = " Error subiendo a Bundlr: " + err.message;
      }
    }
  });
  </script>
</body>
</html>
