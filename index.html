<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>PRMTTN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Three .js + OrbitControls (una sola vez) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <style>
  body {
    margin: 0;
    overflow: hidden;
    background: #ffffff;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-weight: 200;
    font-size: 12px;
    cursor: none;
  }
  #customCursor {
    position: fixed;
    width: 12px; height: 12px;
    border-radius: 50%;
    background: #000;
    border: 1px solid #fff;
    pointer-events: none; z-index: 300;
    transform: translate(-50%, -50%);
  }
  /* HUD eliminado */
  #topRightDisplay{
    display:none !important;
  }
  button{
    cursor:none;
    border:none;
    border-radius:4px;
    padding:8px 12px;
    font-size:12px;
    z-index:250;
    background:rgba(255,255,255,0.12);
    transition:background 0.2s;
  }
  button:hover{
    background:rgba(255,255,255,0.20);
  }

  #patternNextButton,
  #engineCycleButton,
  #permNextButton{
    position:fixed; z-index:260;                /* siempre encima */
    border:none; border-radius:4px;
    padding:8px 12px; font-size:12px;
    background:rgba(255,255,255,0.12);
    cursor:none; display:none;                  /* ocultos por defecto */
    transition:background .2s;
  }
  #patternNextButton:hover,
  #engineCycleButton:hover,
  #permNextButton:hover{
    background:rgba(255,255,255,0.20);
  }
  #patternNextButton{left:10px;  top:10px;}     /* 1 · patrón siguiente   */
  #engineCycleButton {left:10px;  bottom:10px;} /* 2 · motor siguiente     */
  #permNextButton   {right:10px; top:10px;}     /* 3 · NEXT (120 perms)    */

  /* === LAYOUT (orden y ESPACIADO nuevos) === */
  #toggleTextButton     { position:fixed; right:10px; bottom:10px;   }   /* Minimal UI */
  #aiPlanningButton     { position:fixed; right:10px; bottom:50px;   }   /* AI Planning */
  #saveImageButton      { position:fixed; right:10px; bottom:90px;  }   /* Save Image (A2) – debajo de Load JSON */
  #uploadConfigButton   { position:fixed; right:10px; bottom:130px;  }   /* Load JSON */
  #exportEmbedButton    { position:fixed; right:10px; bottom:170px;  }   /* Save JSON */
  #archDescButton       { position:fixed; right:10px; bottom:210px;  }   /* Architectural Description */
  #perm120Button        { position:fixed; right:10px; bottom:250px;  }   /* 120 Architectural Permutations */
   #certButton           { position:fixed; right:10px; bottom:30px; }   /* Edition Certificate */

  #saveImageButton { background:rgba(255,255,255,0.2); }

  /* Ocultar los no usados */
  #btnDebugColors{
    display:none !important;
  }

  #controls {
    position: absolute; top: 10px; left: 10px; z-index: 100;
    padding: 10px; border-radius: 5px;
    background: rgba(255,255,255,0.12); max-width: 350px;
  }
  details {
    margin-bottom: 10px;
    background: rgba(255,255,255,0.06);
  }
  details summary { font-weight: 200; cursor: pointer; }
  details summary:hover { color: #333; }
  select, input[type="range"], input[type="color"] { cursor: none; width: 100%; }
  #permutationList { width: 100%; height: 100px; }


  #hoverPopup {
    position:absolute; padding:5px 10px;
    background:rgba(0,0,0,0.7); color:#fff;
    border-radius:4px; pointer-events:none;
    font-size:12px; display:none; opacity:0;
    transition:opacity .3s; z-index:200;
  }


  /* Panel BUILD */
  #archPanel{
    position:fixed; z-index:1000; top:5%; left:50%;
    transform:translateX(-50%);
    width:85%; height:90%;
    background:#fff; color:#000;
    border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
    padding:24px 32px 48px; overflow:auto;
    font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size:14px; line-height:1.4;
    cursor:auto;
  }
  #archPanel *{ cursor:auto !important; }
  #archClose{
    position:fixed; right:calc(7.5% + 16px); top:5%;
    border:none; padding:6px 10px; border-radius:4px;
    background:#eee; cursor:pointer; z-index:1001;
  }
  #archPanel h2{ margin-top:0; }
  #archPanel .formula{
    margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
  }
  #archPanel .box{
    display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
    font-family:monospace;
  }
  #archPanel section{ margin-bottom:18px; }
  #archPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
  #archPanel .perm h4{ margin-bottom:6px; }
  code, pre{ font-family:monospace; }

  /* Panel 120 perms */
  #perm120Panel{
    position:fixed; right:10px; bottom:340px; z-index:260;
    background:rgba(255,255,255,0.12);
    padding:8px 10px; border-radius:4px; width:260px;
    display:none; /* ← cerrado por defecto */
  }
  #perm120Panel label{ display:block; margin-bottom:6px; }
  #perm120Panel input, #perm120Panel button{ width:100%; margin-top:4px; }
  #perm120Status{
    margin-top:8px;
    font-size:12px;       /* ← mismo tamaño que los demás */
    font-weight:normal;
    text-align:center;
  }
  /* === Information button & panel === */
  #infoButton{
    position:fixed; left:10px; bottom:10px; z-index:260;
  }
  #infoPanel{
    position:fixed; z-index:1000; top:5%; left:50%;
    transform:translateX(-50%);
    width:85%; height:90%;
    background:#fff; color:#000;
    border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
    padding:24px 32px 48px; overflow:auto;
    font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size:14px; line-height:1.45;
    cursor:auto;
  }
  #infoPanel *{ cursor:auto !important; }
  #infoClose{
    position:fixed; right:calc(7.5% + 16px); top:5%;
    border:none; padding:6px 10px; border-radius:4px;
    background:#eee; cursor:pointer; z-index:1001;
  }
  #infoPanel h2{ margin-top:0; }
  #infoPanel .formula{
    margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
  }
  #infoPanel .box{
    display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
    font-family:monospace;
  }
  #infoPanel section{ margin-bottom:18px; }
  #infoPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
  /* === ENGINE MENU (reemplaza botones sueltos) === */
  #engineSelectWrap {
    position: fixed;
    left: 10px;
    bottom: 290px;      /* ocupa el lugar que usaba OFFNNG, sin solapar PLAY/BUILD antiguos */
    z-index: 260;
    background: rgba(255,255,255,0.12);
    padding: 6px 8px;
    border-radius: 4px;
  }
  #engineSelectWrap select {
    width: 180px;       /* ancho cómodo; no usamos 100% para no romper layout */
    cursor: none;
  }
  #engineSelectWrap label {
    font-size: 12px;
    opacity: .85;
  }

  /* Botón PLAY – genera nuevas permutaciones */
  #playButton{
    position:fixed;               /* mismo estilo general */
    left:10px; bottom:170px;      /* 40 px por encima de BUILD (130 px) */
    z-index:260;
    border:none; border-radius:4px;
    padding:8px 12px;
    font-size:18px;               /* el símbolo se ve claro */
    background:rgba(0,0,0,0.12);
    cursor:none; transition:background .2s;
  }
  #playButton:hover{ background:rgba(0,0,0,0.20); }
  </style>
</head>
<body>
  <div id="customCursor"></div>
  <button id="patternNextButton" onclick="cyclePattern()">11</button>
  <button id="engineCycleButton"  onclick="cycleEngine()">4</button>
  <button id="permNextButton"     onclick="nextPerm120()">120</button>
  <div id="topRightDisplay"></div>

  <input type="file" id="json-upload" accept=".json" style="display:none;" />

  <button id="aiPlanningButton"   onclick="applyEvolutionAI()">AI Planning</button>
  <button id="toggleTextButton"   onclick="toggleTexts()">Minimal UI</button>
  <button id="uploadConfigButton" onclick="document.getElementById('json-upload').click()">Load JSON</button>
  <button id="saveImageButton"    onclick="saveImage()">Save Image (A2)</button>
  <button id="exportEmbedButton"  onclick="exportEmbed()">Save JSON</button>
  <button id="archDescButton"     onclick="showArchitecturalDescription()">Architectural Description</button>
  <!-- NUEVO: Play (genera nueva configuración) -->
  <button id="playButton" onclick="generateRandomConfigurationNoCollision()">▮</button>

  <button id="perm120Button"      onclick="togglePerm120Panel()">120 Architectural Permutations</button>

  <!-- NUEVO: Menú de motores -->
  <div id="engineSelectWrap">
    <label for="engineSelect" style="display:block;margin-bottom:4px;">Engine</label>
    <select id="engineSelect" onchange="applyEngineFromSelect(this.value)">
      <option value="BUILD">BUILD</option>
    </select>
  </div>

  <button id="certButton" onclick="exportEditionCertificate()">Edition Certificate</button>
  <button id="infoButton" onclick="showInformation()">Information</button>
  <button id="btnDebugColors"
          style="position:fixed;bottom:180px;right:10px;z-index:260;display:none;"
          onclick="mostrarDebugColores()">
    Debug Colors
  </button>

  <!-- Panel controles 120 perms -->
  <div id="perm120Panel">
    <label>Auto‑advance (1s → 12m)</label>
    <input type="range" id="perm120Slider" min="1000" max="720000" step="1000" value="5000"
           oninput="syncPerm120InputsFromSlider()">
    <input type="number" id="perm120Seconds" min="1" max="720" value="5"
           oninput="syncPerm120SliderFromSeconds()">
    <small>(seconds)</small>
    <button onclick="playPerm120()">Play</button>
    <button onclick="pausePerm120()">Pause</button>
    <button onclick="prevPerm120()">Prev</button>
    <button onclick="nextPerm120()">Next</button>
    <button onclick="showPerm120Info()">Information</button>
    <div id="perm120Status">Permutation: 0 / 119</div>
  </div>


  <div id="controls">
  <details open>
    <summary>Chromatic Pattern</summary>
          <select id="patternSelect" onchange="setActivePattern(this.value)">
        <option value="1">1 · Chromatic Containment</option>
        <option value="2">2 · Contrast &amp; Dissonance</option>
        <option value="3">3 · Non‑semantic Disposition</option>
        <option value="4">4 · Structured Ambiguity</option>
        <option value="5">5 · Chromatic Isotropy</option>
        <option value="6">6 · Self‑Sufficient Presence</option>
        <option value="7">7 · Associative Asymmetry</option>
        <option value="8">8 · Irregular Dynamics</option>
        <option value="9">9 · Habitable without Translation</option>
        <option value="10">10 · Resonance</option>
        <option value="11">11 · Active Transparency</option>
      </select>
      <button id="patternInfoButton"
              style="margin-top:6px;width:100%;"
              onclick="showPatternInfo()">
        Pattern Information
      </button>

  </details>

  <div id="manualControls">
    <details>
      <summary>Select Permutations</summary>
      <select id="permutationList" multiple></select>
      <button onclick="refreshAll({rebuild:true})">Render</button>
    </details>
  </div>


  <details>
    <summary>Manual Colors (override)</summary>
    <div><label>1: <input type="color" id="color1" onchange="onColourPick(1,this.value)"></label></div>
    <div><label>2: <input type="color" id="color2" onchange="onColourPick(2,this.value)"></label></div>
    <div><label>3: <input type="color" id="color3" onchange="onColourPick(3,this.value)"></label></div>
    <div><label>4: <input type="color" id="color4" onchange="onColourPick(4,this.value)"></label></div>
    <div><label>5: <input type="color" id="color5" onchange="onColourPick(5,this.value)"></label></div>
    <button id="btnResetAll" style="margin-top:6px;" onclick="resetAllColours()">
      Reset Background + Walls + Colors
    </button>
  </details>

  <details>
    <summary>Background</summary>
    <input type="color" id="bgColor" value="#ffffff">
    <button onclick="updateBackground()">Apply Background</button>
  </details>

  <details>
    <summary>Cube Walls Color</summary>
    <input type="color" id="cubeColor" value="#808080">
    <button onclick="updateCubeColor()">Apply Cube Walls</button>
  </details>

  <details>
    <summary>Attributes Reorganization</summary>
    <select id="attrMapping"></select>
    <button onclick="updateMapping()">Apply</button>
    <button onclick="autoResolveColisionesGlobal()">Resolve Collisions</button>
  </details>

  <details>
    <summary>Standard Views</summary>
    <select id="standardView">
      <option value="isometric">Isometric</option>
      <option value="top">Top</option>
      <option value="front" selected>Front</option>
      <option value="side">Side</option>
      <option value="diagonal">Opposite diagonal</option>
    </select>
    <button onclick="applyStandardView()">Apply View</button>
  </details>

  <details>
    <summary>Zoom Controls</summary>
    <button onclick="zoomIn()">Zoom In</button>
    <button onclick="zoomOut()">Zoom Out</button>
  </details>

  <details>
    <summary>Motion Controls</summary>
    <button onclick="togglePause()">Pause Motion</button>
    <button onclick="resetMovement()">Reset Motion</button>
  </details>
</div>


<script>
document.getElementById('json-upload').addEventListener('change', function(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const config = JSON.parse(e.target.result);

      // Permutations
      if (config.perms && Array.isArray(config.perms)) {
        const sel = document.getElementById('permutationList');
        Array.from(sel.options).forEach(o => o.selected = config.perms.includes(o.value));
      }

      // Mapping
      if (config.mapping) {
        const v = [config.mapping.forma, config.mapping.color, config.mapping.x, config.mapping.y, config.mapping.z];
        document.getElementById('attrMapping').value = v.join(',');
        attributeMapping = [v[0], v[1], v[2], v[3], v[4], attributeMapping[5], attributeMapping[6]];
      }

      // Pattern
      if (typeof config.pattern === 'number') {
        const p = Math.floor(config.pattern);
        activePatternId = (p >= 1 && p <= 11) ? p : 1;
        const selPattern = document.getElementById('patternSelect');
        if (selPattern) selPattern.value = String(activePatternId);
      }

      // Manual colors
      if (config.colors) {
        manualOverride = {};
        Object.entries(config.colors).forEach(([i, c]) => {
          manualOverride[Number(i)] = c;
        });
      }

      // BG / cube
      if (config.bg) {
        document.getElementById('bgColor').value = config.bg;
        bgOverride = config.bg;
      }
      if (config.cube) {
        document.getElementById('cubeColor').value = config.cube;
        cubeOverride = config.cube;
      }

      // Scene invariants (optional)
      if (typeof config.sceneSeed === 'number') {
        sceneSeed = config.sceneSeed;
      }
      if (typeof config.S_global === 'number') {
        S_global = config.S_global;
      }

      // View
      const view = config.view || "front";
      document.getElementById('standardView').value = view;

      // Rebuild
      refreshAll({rebuild:true, keepManual:true});
      applyStandardView();

      alert('JSON loaded successfully');
    } catch (err) {
      alert('Error loading JSON: ' + err.message);
    }
  };
  reader.readAsText(file);
});
</script>


  <div id="hoverPopup"></div>

  <!-- (eliminados: copias duplicadas de Three, OrbitControls y Ethers) -->
  <script>
    // ------------- TODO EL JS ORIGINAL (¡NO QUITES NADA DE AQUÍ!) -------------

    // === Variables globales ===
    let scene, camera, renderer, controls, raycaster, mouse;
    let cubeUniverse, permutationGroup;
    const cubeSize = 30, halfCube = cubeSize/2;

    let isPaused = false, textsVisible = true;
    let attributeMapping = [0,1,2,3,4, 0,1];   // forma,color,x,y,z,bg,wall
    let colorAttrCycle = 0;                    // ← cuenta las rotaciones de color
    let paletteRGB = [];
    let manualOverride = {1:'#ff0000',2:'#00ff00',3:'#0000ff',4:'#ff00ff',5:'#00ffff'};
    let bgOverride   = null;
    let cubeOverride = null;
    /* variables globales para fondo y paredes */
    let bgHSV = {h:0,s:0,v:1};
    let wallHSV = {h:0,s:0,v:1};
    let activePatternId = 1;           // arranca en Contención

      // >>> NUEVO:
      let S_global = 0; // término estructural para posiciones (Shift-Rank acoplado)

      /* Cambia al motor BUILD sin generar una nueva configuración */
    function switchToBuild(){
  // Garantiza “modo BUILD” sin depender de flags/toggles de otros motores
  try{ enterBuildRenderBoost(); }catch(_){}

  try{ if (cubeUniverse) cubeUniverse.visible = true; }catch(_){}
  try{ if (permutationGroup) permutationGroup.visible = true; }catch(_){}

  // Restaura la vista BUILD (respeta tu selector de “standardView”)
  try{ restoreBuildView(); }catch(_){}

  // Si existe el sistema de wall manager, asegúrate de estar en BUILD
  try{
    if (typeof window.WW_applyFor === 'function') window.WW_applyFor('BUILD');
    else if (typeof window.setWall_BUILD === 'function') window.setWall_BUILD();
  }catch(_){}

  updateEngineSelectUI();
}

    // ——— Canon para motores tipo BUILD (frontal libre)
    const BUILD_FOV = 34;
    const BUILD_Z   = 84;

    function setCamera_BUILD(){
  camera.up.set(0,1,0);
  camera.near = 0.1; camera.far = 4000;
  camera.fov  = 75;
  camera.updateProjectionMatrix();

  if (controls && controls.target) controls.target.set(0, 0, 0);
  if (controls){
    controls.enabled = true;
    controls.enableRotate = true;
    controls.enablePan    = true;
    controls.enableZoom   = true;
    controls.minPolarAngle = 0;
    controls.maxPolarAngle = Math.PI;
    controls.screenSpacePanning = false;
    controls.update();
  }
}

function restoreBuildView(){
  setCamera_BUILD();
  applyStandardView();
}

    // === BUILD render boost (solo activo en BUILD) ==============================
    let __buildBoostPrev = { pr: null, exp: null };

    function enterBuildRenderBoost(){
      if (!renderer || __buildBoostPrev.pr !== null) return;
      // Guarda para restaurar al salir de BUILD
      __buildBoostPrev.pr  = renderer.getPixelRatio();
      __buildBoostPrev.exp = renderer.toneMappingExposure;
      // Más nitidez y menos “quemado” SOLO en BUILD
      const PR = Math.min(window.devicePixelRatio || 1, 2.5);
      renderer.setPixelRatio(PR);
      renderer.toneMappingExposure = 0.90;    // baseline 0.95 → BUILD más controlado
    }

    function leaveBuildRenderBoost(){
      if (!renderer || __buildBoostPrev.pr === null) return;
      renderer.setPixelRatio(__buildBoostPrev.pr);
      renderer.toneMappingExposure = __buildBoostPrev.exp;
      __buildBoostPrev.pr = null; __buildBoostPrev.exp = null;
    }

    /* ——— salto coprimo con 144: barre los 144 valores de H ——— */
    const PHI_H = 89;             // 89 ≡ 144 / φ  (gcd 89,144 = 1)
    /* ——— saltos coprimos para los 12 niveles de S y V ——— */
    const PHI_S = 5;              // gcd(5,12) = 1
    const PHI_V = 7;              // gcd(7,12) = 1

    /* ═════════ CUADRÍCULA HSV 144·12·12 ═══════════════════════════════════ */
    const H_STEPS  = 144;                               // 360° / 2.5°
    const S_LEVELS = [...Array(12)].map((_,i)=>0.25 + 0.72*i/11); // 0.25 – 0.97
    const V_LEVELS = [...Array(12)].map((_,i)=>0.20 + 0.75*i/11); // 0.20 – 0.95

    /* ——— Discretización canónica para FRBN (catálogo de fases) ——— */

    function idxToHSV(hIdx,sIdx,vIdx){
      const h = ((hIdx%H_STEPS)+H_STEPS) % H_STEPS;      // 0-143
      return {
        h: h * 360 / H_STEPS,                            // 0-359.5 °
        s: S_LEVELS[ ((sIdx%12)+12)%12 ],
        v: V_LEVELS[ ((vIdx%12)+12)%12 ]
      };
    }

    /* Normaliza cualquier hue a rango [0 … 360) */
    function normHue(deg){
      return ((deg % 360) + 360) % 360;
    }

    /* ════════════════════════════════════════════════════════════════
       COLOR CONDITIONER · por patrón (local, determinista, sin hooks)
       — Trabaja en el espacio de ÍNDICES (H_idx, S_idx, V_idx)
       — Mantiene tu discretización original: H:144, S:12, V:12
       — NO altera funciones globales ni motores.
       — Determinismo: usa (patternId, slot, seed, sceneSeed, S_global).
       ════════════════════════════════════════════════════════════════ */

    /* Índices → valores de tu rejilla HSV */
    function _sc_idxToH(hIdx){ return (hIdx % 144) * 2.5; }         // grados
    function _sc_idxToS(sIdx){ return 0.25 + 0.72 * ( (sIdx%12) / 11 ); }
    function _sc_idxToV(vIdx){ return 0.20 + 0.75 * ( (vIdx%12) / 11 ); }

    /* Valores → índices de tu rejilla HSV (con clamp) */
    function _sc_HtoIdx(Hdeg){
      let h = Hdeg % 360; if (h < 0) h += 360;
      return Math.round(h / 2.5) % 144;
    }
    function _sc_StoIdx(S){
      const x = (S - 0.25) / 0.72;                // 0..1 ideal
      return Math.max(0, Math.min(11, Math.round(x * 11)));
    }
    function _sc_VtoIdx(V){
      const x = (V - 0.20) / 0.75;                // 0..1 ideal
      return Math.max(0, Math.min(11, Math.round(x * 11)));
    }

    /* HSV → RGB (para ajuste suave de luminancia) */
    function _sc_hsv2rgb(Hdeg, S, V){
      const h = ( (Hdeg % 360) + 360 ) % 360 / 60.0;
      const c = V * S;
      const x = c * (1 - Math.abs((h % 2) - 1));
      const m = V - c;
      let r=0,g=0,b=0;
      if      (h < 1){ r=c; g=x; b=0; }
      else if (h < 2){ r=x; g=c; b=0; }
      else if (h < 3){ r=0; g=c; b=x; }
      else if (h < 4){ r=0; g=x; b=c; }
      else if (h < 5){ r=x; g=0; b=c; }
      else           { r=c; g=0; b=x; }
      return [r+m, g+m, b+m];
    }

    /* Luma (Rec.709) */
    function _sc_lumaRGB(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }

    /* Envuelve diferencia angular en [-180, +180] */
    function _sc_angDiff(a, b){
      let d = (a - b) % 360; if (d < -180) d += 360; if (d > 180) d -= 360; return d;
    }

    /* Semilla determinista suave (0..1) desde escena + patrón + slot */
    function _sc_hash01(patternId, slot, seed){
      const sceneSeedVal = (typeof sceneSeed !== 'undefined') ? (sceneSeed|0) : 0;
      const SGlobalVal = (typeof S_global !== 'undefined') ? (S_global|0) : 0;
      const a = sceneSeedVal, b = SGlobalVal;
      let x = ( (a*73856093) ^ (b*19349663) ^ (patternId*83492791) ^ (slot*2971215073) ^ (seed*1664525) ) >>> 0;
      // LCG un paso
      x = (Math.imul(x, 1664525) + 1013904223) >>> 0;
      return (x & 0xFFFFFF) / 0xFFFFFF; // 0..1
    }

    /* Tabla de “intenciones” por patrón (resumen de tu teoría)
       spanH:   compresión/expansión del abanico angular (1=sin cambio)
       sMean/vMean: medias objetivo
       sTight/vTight: 0..1 (0 = no mover, 1 = llevar a la media)
       luma:   luminancia objetivo (0..1, ajuste leve)
       mode:   estrategia de separación (none | altHiLo | jitter | narrow)
    */
    const _SC_POLICY = {
      1:  { spanH:0.75, sMean:0.62, vMean:0.78, sTight:0.35, vTight:0.35, luma:0.68, mode:'narrow' },        // Contención estructural
      2:  { spanH:1.40, sMean:0.70, vMean:0.72, sTight:0.15, vTight:0.10, luma:0.64, mode:'altHiLo' },       // Contraste & Disonancia
      3:  { spanH:1.00, sMean:0.55, vMean:0.72, sTight:0.30, vTight:0.30, luma:0.66, mode:'none' },          // Disposición no semántica
      4:  { spanH:0.85, sMean:0.58, vMean:0.74, sTight:0.30, vTight:0.30, luma:0.67, mode:'jitter' },        // Ambigüedad estructurada
      5:  { spanH:0.60, sMean:0.52, vMean:0.76, sTight:0.45, vTight:0.35, luma:0.68, mode:'narrow' },        // Campo sin centro
      6:  { spanH:1.10, sMean:0.64, vMean:0.80, sTight:0.25, vTight:0.25, luma:0.70, mode:'none' },          // Presencia autosuficiente
      7:  { spanH:0.95, sMean:0.60, vMean:0.76, sTight:0.25, vTight:0.25, luma:0.68, mode:'altHiLo' },       // Asimetría asociativa
      8:  { spanH:1.20, sMean:0.66, vMean:0.78, sTight:0.20, vTight:0.25, luma:0.69, mode:'jitter' },        // Dinámica irregular
      9:  { spanH:0.80, sMean:0.56, vMean:0.74, sTight:0.35, vTight:0.30, luma:0.67, mode:'narrow' },        // Habitable sin traducción
      10: { spanH:0.90, sMean:0.60, vMean:0.78, sTight:0.25, vTight:0.30, luma:0.69, mode:'jitter' },        // Resonancia
      11: { spanH:0.95, sMean:0.48, vMean:0.86, sTight:0.40, vTight:0.30, luma:0.75, mode:'none' }           // Transparencia activa
    };

    /* Acondicionador principal: recibe índices crudos del patrón y devuelve
       NUEVOS índices (H_idx, S_idx, V_idx) ya ajustados al patrón. */
    function conditionHSV(hIdx, sIdx, vIdx, patternId, slot, seed){
      const pol = _SC_POLICY[patternId] || _SC_POLICY[1];

      // 1) Índices → valores
      let H = _sc_idxToH(hIdx);   // grados
      let S = _sc_idxToS(sIdx);
      let V = _sc_idxToV(vIdx);

      // 2) Ancla y span de H (determinista por escena / patrón / slot)
      const sceneSeedVal = (typeof sceneSeed !== 'undefined') ? (sceneSeed|0) : 0;
      const SGlobalVal = (typeof S_global !== 'undefined') ? (S_global|0) : 0;
      const baseAnchor = ((37*sceneSeedVal + 53*SGlobalVal + 11*patternId + 7*(slot|0)) % 144) * 2.5; // deg
      const d = _sc_angDiff(H, baseAnchor);            // [-180,180]
      H = baseAnchor + d * pol.spanH;

      // 3) Ajuste de S/V hacia medias (mezcla controlada)
      S = S + (pol.sMean - S) * pol.sTight;
      V = V + (pol.vMean - V) * pol.vTight;

      // 4) Separación/variación determinista por “modo”
      const r = _sc_hash01(patternId, slot, seed) - 0.5;   // [-0.5,0.5]
      if (pol.mode === 'altHiLo'){
        const sign = (slot % 2 === 0) ? +1 : -1;
        S = Math.max(0.25, Math.min(0.97, S + sign * (0.08 + 0.04*r)));
        V = Math.max(0.20, Math.min(0.98, V + sign * (0.05 + 0.03*r)));
        // empujón extra en H para ΔH grande
        H += sign * (18 + 8*r); // grados
      }else if (pol.mode === 'jitter'){
        // irregularidad leve, sin crear foco
        H += (8 * r);
        S = Math.max(0.25, Math.min(0.97, S + 0.04*r));
        V = Math.max(0.20, Math.min(0.98, V + 0.03*r));
      }else if (pol.mode === 'narrow'){
        // span ya lo hace; micro-variación para evitar coincidencias exactas
        H += (4 * r);
      }

      // 5) Luma objetivo (ajuste MUY leve sobre V manteniendo S/H)
      //    — calculamos luma actual y acercamos a pol.luma
      {
        const [rC,gC,bC] = _sc_hsv2rgb(H, Math.max(0,Math.min(1,S)), Math.max(0,Math.min(1,V)));
        const Y = _sc_lumaRGB(rC, gC, bC);
        const dY = pol.luma - Y;
        // ganancia pequeña para no “romper” la paleta (máx ±0.06 aprox)
        V = Math.max(0.20, Math.min(0.98, V + 0.20 * dY));
      }

      // 6) Volver a ÍNDICES (clamp a tu rejilla discreta)
      const Hn = _sc_HtoIdx(H);
      const Sn = _sc_StoIdx(S);
      const Vn = _sc_VtoIdx(V);
      return [Hn, Sn, Vn];
    }


    /* ═════════ 11 patrones cromáticos — versión PHI_H (89) + acondicionador local ═════════ */
const PATTERNS = {
  1: (sig, seed, i) => {
    const base = (sig.reduce((a,v)=>a+v,0) + seed*7) % 144;
    const hIdx = (base + (i%12)*6) % 144;
    const sIdx = (sig[3] + seed + i) % 12;
    const vIdx = (sig[1] + sig[4] + i) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 1, i, seed);
  },

  2: (sig, seed, i) => {
    const base = (sig[0]*17 + seed*5) % 144;
    const hIdx = (base + ((i%12)*48)) % 144;
    const sIdx = (sig[1] + i*3 + seed) % 12;
    const vIdx = (sig[2]*2 + i + seed) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 2, i, seed);
  },

  3: (s,seed,i) => {
    const b = (s[2]*13 + seed*5 + i*11) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[0] + i*2 + seed) % 12;
    const vIdx = (s[1] + s[3] + i)   % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 3, i, seed);
  },

  4: (s,seed,i) => {
    const b = (s[1]*15 + seed*3 + i*7) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[0] + seed + i) % 12;
    const vIdx = (s[2] + s[4] + seed + i) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 4, i, seed);
  },

  5: (s,seed,i) => {
    const b = (i*31 + s[3]*13 + seed*5) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[1] + seed + i) % 12;
    const vIdx = (s[2] + seed + i) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 5, i, seed);
  },

  6: (s,seed,i) => {
    const b = (s[1]*31 + seed*13 + i*7) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[2] + seed + i) % 12;
    const vIdx = (s[3] + s[4] + seed + i) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 6, i, seed);
  },

  7: (s,seed,i) => {
    const b = (s[0]*11 + seed*3 + i*37) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[2] + seed + i*2) % 12;
    const vIdx = (s[4] + s[1]*2 + seed + i) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 7, i, seed);
  },

  8: (s,seed,i) => {
    const r = Math.abs(s[4]-s[0]) + Math.abs(s[3]-s[1]) + s[2];
    const b = (r*13 + seed*7) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[1]*3 + seed + i*2) % 12;
    const vIdx = (s[3] + i*5 + seed*3) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 8, i, seed);
  },

  9: (s,seed,i) => {
    const b = (s[4]*12 + seed*7 + i*11) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[2] + seed + i) % 12;
    const vIdx = (s[1] + seed + i*2) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 9, i, seed);
  },

 10: (s,seed,i) => {
    const b = (seed*5 + s.reduce((a,v)=>a+v,0)*3 + i*7) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[2] + seed + i) % 12;
    const vIdx = (s[4]*2 + seed + i*3) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 10, i, seed);
  },

 11: (s,seed,i) => {
    const b = (s[3]*13 + seed*11 + i*7) % 144;
    const hIdx = (b + i*PHI_H) % 144;
    const sIdx = (s[0] + seed + i)   % 12;
    const vIdx = (s[1] + seed + i*2) % 12;
    return conditionHSV(hIdx, sIdx, vIdx, 11, i, seed);
  }
};

function rgbToHsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min;
  let h=0;
  if(d){
    if(max===r) h=((g-b)/d)%6;
    else if(max===g) h=(b-r)/d+2;
    else h=(r-g)/d+4;
    h*=60; if(h<0) h+=360;
  }
  const s=max?d/max:0, v=max;
  return [h,s,v];
}
function hsvToRgb(h,s,v){
  h = h % 360;
  const c=v*s, x=c*(1-Math.abs((h/60)%2-1)), m=v-c;
  let [r,g,b]=[0,0,0];
  if(h<60){r=c;g=x;} else if(h<120){r=x;g=c;}
  else if(h<180){g=c;b=x;} else if(h<240){g=x;b=c;}
  else if(h<300){r=x;b=c;} else {r=c;b=x;}
  return [(r+m)*255,(g+m)*255,(b+m)*255].map(v=>Math.round(v));
}
function hsvToHex({h,s,v}){
  const [r,g,b] = hsvToRgb(h,s,v);
  return '#'+new THREE.Color(r/255,g/255,b/255).getHexString();
}
/* contraste CIE76 */
function deltaE(lab1,lab2){
  return Math.sqrt(
    (lab1[0]-lab2[0])**2+
    (lab1[1]-lab2[1])**2+
    (lab1[2]-lab2[2])**2
  );
}
function rgbToLab(r,g,b){                      // aproximación rápida
  const xyz=[r/255,g/255,b/255].map(v=>{
    v=v>0.04045?((v+0.055)/1.055)**2.4:v/12.92;
    return v*100;
  });
  const x=xyz[0]*0.4124+xyz[1]*0.3576+xyz[2]*0.1805;
  const y=xyz[0]*0.2126+xyz[1]*0.7152+xyz[2]*0.0722;
  const z=xyz[0]*0.0193+xyz[1]*0.1192+xyz[2]*0.9505;
  const xyzN=[95.047,100.0,108.883];
  const f= t=> t>0.008856 ? t**(1/3) : (7.787*t)+16/116;
  const [fx,fy,fz]=[x,y,z].map((v,i)=>f(v/xyzN[i]));
  return [116*fy-16, 500*(fx-fy), 200*(fy-fz)];
}

/* ======  NUEVO  — utilidades de contraste con el FONDO  ====== */
const ΔE_BG_MIN = 22;          // contraste mínimo CIE76

function hexToRgb(hex){
  const m = /^#?([0-9a-f]{6})$/i.exec(hex);
  const n = parseInt(m[1],16);
  return [(n>>16)&255, (n>>8)&255, n&255];
}

/**
 * Sube o baja la luminosidad (v) del color RGB recibido hasta que
 * alcance ΔE_BG_MIN puntos de contraste contra el fondo actual.
 * Devuelve el RGB corregido.
 */
function ensureContrastRGB(rgb){
  /* color de fondo efectivo */
  let bgRgb;
  if (bgOverride) {
    bgRgb = hexToRgb(bgOverride);
  } else if (scene && scene.background && scene.background.isColor) {
    // fondo actual de THREE.Color (incluye el gris de LCHT)
    bgRgb = [
      Math.round(scene.background.r * 255),
      Math.round(scene.background.g * 255),
      Math.round(scene.background.b * 255)
    ];
  } else {
    bgRgb = hsvToRgb(bgHSV.h, bgHSV.s, bgHSV.v);
  }

  let [h,s,v] = rgbToHsv(rgb[0], rgb[1], rgb[2]);  // pasamos a HSV
  let tries = 0;
  while (deltaE(rgbToLab(...rgb), rgbToLab(...bgRgb)) < ΔE_BG_MIN && tries < 24){
    // alterna aclarar / oscurecer en pasos de 0.04
    v = (tries % 2) ? Math.max(0, v - 0.04) : Math.min(1, v + 0.04);
    rgb = hsvToRgb(h, s, v);
    tries++;
  }
  return rgb;
}
/* ---------- FIN BLOQUE UTILIDADES ---------- */
/* ——— calcula HSV para fondo y paredes de forma acoplada al set activo ——— */
function rebuildSceneColours(){
  // Permutaciones activas (en el mismo orden visual)
  const perms = Array.from(document.getElementById('permutationList').selectedOptions)
                     .map(o => o.value.split(',').map(Number));

  // Firmas para fondo/cubo (si no hay, usa dummy neutra)
  const firstSig = perms[0] ? computeSignature(perms[0]) : [0,0,0,0,0];
  const lastSig  = perms.length > 1 ? computeSignature(perms[perms.length-1]) : firstSig;

  // Slots acoplados al tamaño del set (idéntico a BUILD + spreads coprimos)
  let [h1,s1,v1] = PATTERNS[activePatternId](firstSig, sceneSeed, perms.length);
  let [h2,s2,v2] = PATTERNS[activePatternId](lastSig,  sceneSeed, perms.length + 1);

  s1 = (s1 * PHI_S) % 12;  v1 = (v1 * PHI_V) % 12;
  s2 = (s2 * PHI_S) % 12;  v2 = (v2 * PHI_V) % 12;

  bgHSV   = idxToHSV(h1, s1, v1);   // ← Fondo = “slot #n” con firma del primero
  wallHSV = idxToHSV(h2, s2, v2);   // ← Paredes = “slot #n+1” con firma del último
}

/* ===\u2003UTIL extra — firma normalizada y contraste\u2003===================== */
// 1)  f̂  de un glifo  →  promedio firma, llevada a [0-1]
/* contrast-fix eliminado: función ensureContrast() suprimida */
    const minRangeValue = 2, maxRangeValue = 6;
    const shapeMapping = {
      1:{w:4.5,h:4.5},
      2:{w:4.5,h:4.5*Math.sqrt(2)},
      3:{w:4.5,h:4.5*Math.sqrt(3)},
      4:{w:4.5,h:4.5*Math.sqrt(4)},
      5:{w:4.5,h:4.5*Math.sqrt(5)}
    };

    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function mapRangeToSpeed(r,mn,mx){return 0.001 + (r-mn)*(0.005-0.001)/(mx-mn);}
    function shuffle(a){for(let i=a.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

    function getPermutations(arr){
      if(arr.length===1) return [arr];
      let res=[]; for(let i=0;i<arr.length;i++){
        const c=arr[i], rem=arr.slice(0,i).concat(arr.slice(i+1));
        for(const p of getPermutations(rem)) res.push([c].concat(p));
      }
      return res;
    }
    const allPermutations = getPermutations([1,2,3,4,5]);
    const permutationStrings = allPermutations.map(p=>p.join(','));

    function getAttributeMappings(a){
      if(a.length===1) return [a];
      let res=[]; for(let i=0;i<a.length;i++){
        const c=a[i], rem=a.slice(0,i).concat(a.slice(i+1));
        for(const m of getAttributeMappings(rem)) res.push([c].concat(m));
      }
      return res;
    }

    function populatePermutationList(){
      const sel = document.getElementById('permutationList');
      sel.innerHTML = '';
      permutationStrings.forEach((ps,i)=>{
        const o=document.createElement('option');
        o.value=ps; o.text=`Permutación ${i+1}: (${ps})`;
        if(i===0) o.selected=true;
        sel.appendChild(o);
      });
    }
    function populateAttributeMappingSelect(){
      const sel = document.getElementById('attrMapping');
      sel.innerHTML = '';
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        const s=m.join(','), o=document.createElement('option');
        o.value=s; o.text=`Opción: [${s}]`;
        if(s==='0,1,2,3,4') o.selected=true;
        sel.appendChild(o);
      });
      updateTopRightDisplay();
    }

    function computeSignature(a){let s=[];for(let i=0;i<a.length;i++) s.push(a[i]+a[(i+1)%a.length]);return s;}
    function computeRange(sig){return Math.max(...sig)-Math.min(...sig);}

    const FACT=[1,1,2,6,24,120];
    let sceneSeed=0;
    function lehmerRank(p){
      let r=0;
      for(let i=0;i<p.length;i++){
        let c=0;
        for(let j=i+1;j<p.length;j++) if(p[j]<p[i]) c++;
        r+=c*FACT[p.length-1-i];
      }
      return r;
    }

    /* ========= NUEVO: sceneSeed orden‑invariante + dependiente del mapping ========= */

    /** Rank del mapping [m0..m4] usando Lehmer rank sobre [m_i+1] (1..5) */
    function mappingRank(m){
      const arr = [m[0]+1, m[1]+1, m[2]+1, m[3]+1, m[4]+1];
      return lehmerRank(arr);
    }

    /** sceneSeed = (37·sumR + 101·sumR2 + 53·mRank) mod 360  (orden‑invariante) */
    function computeSceneSeedFrom(perms, m){
      let sumR = 0, sumR2 = 0;
      perms.forEach(pa=>{
        const r = lehmerRank(pa);
        sumR  += r;
        sumR2 += r*r;
      });
      const mRank = mappingRank(m);
      return (37*sumR + 101*sumR2 + 53*mRank) % 360;
    }

    /** S = ( Σ (P_{mx}+P_{my}+P_{mz}) ) mod 125  — usa los índices x,y,z del mapping */
    function computeGlobalS(perms, m){
      const mx = m[2], my = m[3], mz = m[4];
      let S = 0;
      perms.forEach(p=>{
        S += p[mx] + p[my] + p[mz];
      });
      return S % 125;
    }

    function computeShiftRankXYZ(p){
      const r = lehmerRank(p);
      const I = (r + sceneSeed + S_global) % 125;   // <<< NUEVO: acoplado a S_global
      const x = Math.floor(I/25),
            y = Math.floor((I%25)/5),
            z = I%5;
      const step = cubeSize/5;
      return [
        (x-2)*step,
        (y-2)*step,
        (z-2)*step
      ];
    }

    function getSelectedPerms(){
      return Array.from(document.getElementById('permutationList').selectedOptions)
                  .map(o => o.value.split(',').map(Number));
    }
    function setActivePattern(id){
      const p = parseInt(id, 10);
      activePatternId = (p >= 1 && p <= 11) ? p : 1;
      refreshAll({rebuild:false});
    }
    function updateTopRightDisplay(){
      // HUD desactivado (topRightDisplay está oculto por CSS)
    }

    function createPermutationObjectWithMapping(pa,map){
      const fv=pa[map[0]],
            d=shapeMapping[fv], w=d.w, h=d.h, t=0.5;

      // --- COLOR determinista (cuadrícula HSV) ---
      let rgb;
      {
        const sig  = computeSignature(pa);
        const slot = lehmerRank(pa) % 12; // 0..11
        let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
        sI = (sI * PHI_S) % 12;
        vI = (vI * PHI_V) % 12;
        const {h,s,v} = idxToHSV(hI,sI,vI);
        rgb = hsvToRgb(h,s,v);
      }
      // Contraste mínimo contra el fondo actual
      rgb = ensureContrastRGB(rgb);

      // --- POSICIÓN (antes de material para calcular frontalidad) ---
      const [X,Y,Z]=computeShiftRankXYZ(pa);

      // --- BUILD · Vibrance v2: saturación fuerte sin quemar y sin spec blanco ---
      const zNorm = (Z + halfCube) / cubeSize;               // -15→0 · +15→1

      // 1) Partimos del RGB con contraste mínimo contra fondo
      let [h0, s0, v0] = rgbToHsv(rgb[0], rgb[1], rgb[2]);

      // 2) Vibrance: sube S con más fuerza cuanto más baja sea S (y un plus por frontalidad)
      const vib = 0.22 + 0.10 * zNorm;                       // 0.22…0.32
      const s1  = Math.min(1, s0 + vib * (1 - s0));

      // 3) Brillo controlado: ligero boost pero con techo para evitar “quemados” en ACES
      const v1  = Math.min(0.93, v0 * (1.02 + 0.06 * zNorm));

      // 4) Volvemos a RGB
      const rgbBoost = hsvToRgb(h0, s1, v1);

      // 5) Material difuso (Lambert) → colores más limpios y saturados (sin specular blanco)
      const mat = new THREE.MeshLambertMaterial({
        color: new THREE.Color(rgbBoost[0]/255, rgbBoost[1]/255, rgbBoost[2]/255),
        dithering: true
      });

      // Pequeña auto-luminancia para “energía” sin quemar (mucho menor que antes)
      mat.emissive = new THREE.Color(rgbBoost[0]/255, rgbBoost[1]/255, rgbBoost[2]/255);
      mat.emissiveIntensity = 0.03 + 0.12 * zNorm;   // antes 0.08 + 0.30*zNorm

      const geo=new THREE.BoxGeometry(w,h,t);
      const mesh=new THREE.Mesh(geo,mat);
      mesh.position.set(
        clamp(X,-halfCube+w/2,halfCube-w/2),
        clamp(Y,-halfCube+h/2,halfCube-h/2),
        clamp(Z,-halfCube+t/2,halfCube-t/2)
      );

      const sig=computeSignature(pa), rg=computeRange(sig);
      mesh.userData={permStr:pa.join(','), signature:sig, range:rg, rotationSpeed:mapRangeToSpeed(rg,minRangeValue,maxRangeValue)};
      return mesh;
    }
    function createPermutationObject(pa){ return createPermutationObjectWithMapping(pa,attributeMapping); }

    function checkCollisionsInGroup(g){
      for(let i=0;i<g.children.length;i++){
        const b1=new THREE.Box3().setFromObject(g.children[i]);
        for(let j=i+1;j<g.children.length;j++){
          const b2=new THREE.Box3().setFromObject(g.children[j]);
          if(b1.intersectsBox(b2)) return true;
        }
      }
      return false;
    }
    function autoResolveColisionesGlobal(){
      let found=null;
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        if(found) return;
        const cm=[m[0],m[1],m[2],m[3],m[4], attributeMapping[5], attributeMapping[6]],
              tg=new THREE.Group(),
              opts=Array.from(document.getElementById('permutationList').selectedOptions);
        opts.forEach((o)=>{
          const pa=o.value.split(',').map(Number),
                mo=createPermutationObjectWithMapping(pa,cm);
          tg.add(mo);
        });
        if(!checkCollisionsInGroup(tg)) found=cm;
      });
      if(found){
        attributeMapping=found;
        document.getElementById('attrMapping').value=`${found[0]},${found[1]},${found[2]},${found[3]},${found[4]}`;
        refreshAll({rebuild:true}); updateTopRightDisplay();
      } else {
        showPopup("No se encontró reorganización sin colisiones.",7000);
      }
    }

/* ==============================
 * 120 Architectural Permutations
 * ============================== */
let perm120List = getAttributeMappings([0,1,2,3,4]); // 120
let perm120Index = 0;
let perm120Timer = null;

function togglePerm120Panel(){
  const p = document.getElementById('perm120Panel');
  const isHidden = (p.style.display === 'none' || !p.style.display);
  p.style.display = isHidden ? 'block' : 'none';

  // Re‑muestra siempre el cursor personalizado
  const cc = document.getElementById('customCursor');
  if (cc) cc.style.display = 'block';
}

function msFromUI(){
  const slider = document.getElementById('perm120Slider');
  return parseInt(slider.value, 10);
}
function syncPerm120InputsFromSlider(){
  const ms = msFromUI();
  document.getElementById('perm120Seconds').value = Math.round(ms/1000);
}
function syncPerm120SliderFromSeconds(){
  const sec = parseInt(document.getElementById('perm120Seconds').value,10) || 1;
  const clamped = Math.max(1, Math.min(720, sec));
  document.getElementById('perm120Seconds').value = clamped;
  document.getElementById('perm120Slider').value = clamped * 1000;
}

function updatePerm120Status(){
  const stat = document.getElementById('perm120Status');
  if(stat) stat.textContent = `Permutation: ${perm120Index} / 119`;
}

function applyPerm120Index(i){
  perm120Index = ((i % perm120List.length) + perm120List.length) % perm120List.length;
  const m = perm120List[perm120Index];
  attributeMapping = [m[0], m[1], m[2], m[3], m[4], attributeMapping[5], attributeMapping[6]];
  document.getElementById('attrMapping').value = m.join(',');
  refreshAll({rebuild:true});
  updatePerm120Status();
}

function nextPerm120(){ applyPerm120Index(perm120Index + 1); }
function prevPerm120(){ applyPerm120Index(perm120Index - 1); }

function playPerm120(){
  if(perm120Timer) return;
  const interval = msFromUI();
  perm120Timer = setInterval(nextPerm120, interval);
  nextPerm120();
}
function pausePerm120(){
  if(perm120Timer){
    clearInterval(perm120Timer);
    perm120Timer = null;
  }
}

async function showPerm120Info(){
  try{
    const text = await loadTextPartial('./texts/perm120-info.txt');
    alert(text);
  }catch(err){
    alert('Error cargando perm120-info.txt');
    console.error(err);
  }
}


    /* ============================================================
     *  MONTE-CARLO: buscar una escena aleatoria SIN colisiones
     *  ============================================================
     */

    /** Construye un grupo temporal con un mapping dado, sin tocar la escena real */
      const mappings = getAttributeMappings([0,1,2,3,4]);
function buildTempGroup(perms, mapping){
  const tg = new THREE.Group();

  // Guardamos estado global
  const prevSeed = sceneSeed;
  const prevS    = S_global;
  const prevMap  = attributeMapping.slice();

  // Calculamos los nuevos valores teóricos
  const tmpSeed = computeSceneSeedFrom(perms, mapping);
  const tmpS    = computeGlobalS(perms, mapping);

  // Seteamos temporalmente los globales para que createPermutationObjectWithMapping
  // use exactamente la misma lógica que la escena final:
  sceneSeed        = tmpSeed;
  S_global         = tmpS;
  attributeMapping = mapping;

  perms.forEach(pa=>{
    const mesh = createPermutationObjectWithMapping(pa, mapping);
    tg.add(mesh);
  });

  // Restauramos
  sceneSeed        = prevSeed;
  S_global         = prevS;
  attributeMapping = prevMap;

  return tg;
}

function findCollisionFreeMapping(perms){
  const mappings = getAttributeMappings([0,1,2,3,4]);
  for(const m of mappings){
    const cm = [m[0], m[1], m[2], m[3], m[4], attributeMapping[5], attributeMapping[6]];
    const tg = buildTempGroup(perms, cm);
    if(!checkCollisionsInGroup(tg)) return cm;
  }
  return null;
}
    /** Selecciona un subconjunto aleatorio de permutaciones (1..25) */
    function pickRandomPerms(){
      const n  = Math.floor(Math.random()*25) + 1;
      const out = [];
      for(let i=0;i<n;i++){
        const str = permutationStrings[Math.floor(Math.random()*permutationStrings.length)];
        out.push(str.split(',').map(Number));
      }
      return out;
    }

    /**
     * Búsqueda iterativa:
     *  - elige un set aleatorio de permutaciones
     *  - prueba todos los mappings
     *  - si alguno no choca, lo aplica y termina
     *
     * No bloquea la UI gracias al pequeño await en cada iteración.
     */
    async function generateRandomConfigurationNoCollision(MAX_TRIES = 5000){
      // Elegimos un patrón cromático aleatorio (1..11, evitando el legacy 0)
      const randPattern = Math.floor(Math.random() * 11) + 1;

      let round = 0;
      while (true) { // sigue intentando hasta que realmente encuentre una sin colisiones
        round++;
        for (let t = 0; t < MAX_TRIES; t++) {
          showPopup(`Buscando configuración sin colisiones… (ronda ${round}, intento ${t+1})`, 500);

          const perms   = pickRandomPerms();
          const mapping = findCollisionFreeMapping(perms);

          if (mapping) {
            // 1) Setea el patrón cromático escogido
            activePatternId = randPattern;
            const selPattern = document.getElementById('patternSelect');
            if (selPattern) selPattern.value = String(randPattern);

            // 2) Pon las permutaciones en el <select>
            const sel = document.getElementById('permutationList');
            Array.from(sel.options).forEach(o => o.selected = false);
            perms.forEach(p=>{
              const val = p.join(',');
              const opt = sel.querySelector(`option[value="${val}"]`);
              if(opt) opt.selected = true;
            });

            // 3) Aplica el mapping encontrado
            attributeMapping = mapping;

            // mantenemos tu ciclo de atributo "color"
            attributeMapping[1] = colorAttrCycle % 5;
            colorAttrCycle++;

            document.getElementById('attrMapping').value =
              `${attributeMapping[0]},${attributeMapping[1]},${attributeMapping[2]},${attributeMapping[3]},${attributeMapping[4]}`;

            // 4) Reconstruye escena completa
            refreshAll({rebuild:true});

            // 5) Verificación final (por si acaso)
            const hasCol = checkCollisionsInGroup(permutationGroup);
            if (!hasCol) {
              /*  ▸ YA NO se desactiva el motor actual.
               *    Si el usuario estaba en FRBN o LCHT, sigue allí.
               *    BUILD sólo se activa cuando se pulsa explícitamente el botón BUILD. */
              showPopup("¡Configuración sin colisiones encontrada!", 2000);
              return true;
            }
          }

          // cede el hilo para no congelar la UI
          if ((t % 25) === 0) await new Promise(r => setTimeout(r, 0));
        }
        // pequeña pausa entre rondas largas
        await new Promise(r => setTimeout(r, 10));
      }
    }

    function showPopup(msg, dur = 2000){
      dur = Math.max(dur, 3000); // ← asegura al menos 3 segundos
      const p = document.getElementById('hoverPopup');
      p.style.display = "block";
      p.style.opacity = 1;
      p.style.left = (window.innerWidth/2 - 150) + "px";
      p.style.top  = "20px";
      p.innerHTML  = msg;
      setTimeout(()=>{
        p.style.opacity = 0;
        setTimeout(()=>{ p.style.display="none"; p.innerHTML=""; }, 300);
      }, dur);
    }


function updateScene(attemptResolve=true){
  // Limpia grupo
  while(permutationGroup.children.length>0){
    const o=permutationGroup.children[0];
    permutationGroup.remove(o);
    o.geometry.dispose(); o.material.dispose();
  }

  // Permutaciones activas
  const opts  = Array.from(document.getElementById('permutationList').selectedOptions);
  const perms = opts.map(o => o.value.split(',').map(Number));

  // Nueva sceneSeed & S_global (orden-invariante + dependiente del mapping)
  sceneSeed = computeSceneSeedFrom(perms, attributeMapping);
  S_global  = computeGlobalS(perms, attributeMapping);

  // Construye objetos
  perms.forEach(pa=>{
    const obj = createPermutationObject(pa);
    permutationGroup.add(obj);
  });

  if(attemptResolve) autoResolveColisionesGlobal();
  else updateTopRightDisplay();
}
    function onMouseMove(e){
      mouse.x=(e.clientX/window.innerWidth)*2-1;
      mouse.y=-(e.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera(mouse,camera);
      const ints=raycaster.intersectObjects(permutationGroup.children),
            pop=document.getElementById('hoverPopup');
      if(ints.length>0){
        const d=ints[0].object.userData;
        pop.style.display="block"; pop.style.opacity=1;
        pop.style.left=`${e.clientX+20}px`;
        pop.style.top=`${e.clientY+20}px`;
        pop.innerHTML=`Perm (${d.permStr})<br>Firma [${d.signature.join(', ')}]<br>Rango ${d.range}`;
      } else {
        pop.style.opacity=0;
        setTimeout(()=>{pop.style.display="none";},300);
      }
    }

    function zoomIn(){camera.position.z-=5;controls.update();}
    function zoomOut(){camera.position.z+=5;controls.update();}
    function togglePause(){
      isPaused=!isPaused;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent=isPaused?"Resume Motion":"Pause Motion";
    }
    function resetMovement(){
      updateScene(false);
      isPaused=true;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent="Resume Motion";
    }

function saveImage(){
  const A2_W = 7016, A2_H = 4961;

  const prevPixelRatio = renderer.getPixelRatio();
  const prevSize       = renderer.getSize(new THREE.Vector2());
  const prevAspect     = camera.aspect;
  const prevRt         = renderer.getRenderTarget?.() || null;
  const prevBg         = scene.background ? scene.background.clone() : null;

  const screenAspect = prevSize.x / prevSize.y;

  // Render con el MISMO aspect que se ve en pantalla
  let renderW, renderH;
  const a2Aspect = A2_W / A2_H;
  if (screenAspect > a2Aspect) {
    renderW = A2_W;
    renderH = Math.round(A2_W / screenAspect);
  } else {
    renderH = A2_H;
    renderW = Math.round(A2_H * screenAspect);
  }

  renderer.setPixelRatio(1);
  renderer.setSize(renderW, renderH, false);
  camera.aspect = screenAspect;
  camera.updateProjectionMatrix();

  const rt = new THREE.WebGLRenderTarget(renderW, renderH, { depthBuffer:true, stencilBuffer:false });

  const clearHex = prevBg ? '#' + prevBg.getHexString() : '#ffffff';
  renderer.setClearColor(clearHex, 1);
  renderer.setRenderTarget(rt);
  renderer.clear(true, true, true);
  renderer.render(scene, camera);

  const pixels = new Uint8Array(renderW * renderH * 4);
  renderer.readRenderTargetPixels(rt, 0, 0, renderW, renderH, pixels);

  const tmp = document.createElement('canvas');
  tmp.width = renderW; tmp.height = renderH;
  const tctx = tmp.getContext('2d');
  const imgData = tctx.createImageData(renderW, renderH);
  const row = renderW * 4;
  for (let y = 0; y < renderH; y++) {
    const src = (renderH - 1 - y) * row;
    const dst = y * row;
    imgData.data.set(pixels.subarray(src, src + row), dst);
  }
  tctx.putImageData(imgData, 0, 0);

  const final = document.createElement('canvas');
  final.width = A2_W; final.height = A2_H;
  const fctx = final.getContext('2d');

  fctx.fillStyle = clearHex;
  fctx.fillRect(0, 0, A2_W, A2_H);
  const offX = Math.floor((A2_W - renderW) / 2);
  const offY = Math.floor((A2_H - renderH) / 2);
  fctx.drawImage(tmp, offX, offY);

  final.toBlob((blob)=>{
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'PRMTTN_A2.png';
    document.body.appendChild(a); a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(a.href);
  }, 'image/png');

  renderer.setRenderTarget(prevRt);
  rt.dispose();
  renderer.setPixelRatio(prevPixelRatio);
  renderer.setSize(prevSize.x, prevSize.y);
  camera.aspect = prevAspect;
  camera.updateProjectionMatrix();
  if (prevBg) scene.background = prevBg;
  controls.update();
}


function makePalette(){
  paletteRGB = [];
  for(let i=0;i<12;i++){
    let [hI,sI,vI] = PATTERNS[activePatternId]([0,0,0,0,0], sceneSeed, i);
    sI = (sI * PHI_S) % 12;
    vI = (vI * PHI_V) % 12;
    const {h,s,v} = idxToHSV(hI,sI,vI);
    paletteRGB.push(hsvToRgb(h,s,v));
  }
}

    function applyPalette(){
      for(let i=1;i<=5;i++){
        const autoRGB = paletteRGB[i-1] || [255,255,255];
        const autoHEX = '#'+new THREE.Color(
            autoRGB[0]/255,autoRGB[1]/255,autoRGB[2]/255).getHexString();
        const hex     = manualOverride[i] || autoHEX;
        const input   = document.getElementById('color'+i);
        if(input) input.value = hex;
      }

      permutationGroup.children.forEach(o=>{
        const pa   = o.userData.permStr.split(',').map(Number);
        const idx  = pa[attributeMapping[1]];          // 1-5
        let hex;
        if(manualOverride[idx]){
          hex = manualOverride[idx];
        }else{
          const sig  = computeSignature(pa);
          const slot = lehmerRank(pa) % 12;
          let [hIdx,sIdx,vIdx] = PATTERNS[activePatternId](sig, sceneSeed, slot);
          sIdx = (sIdx * PHI_S) % 12;
          vIdx = (vIdx * PHI_V) % 12;
          const {h,s,v} = idxToHSV(hIdx, sIdx, vIdx);
          const rgb = hsvToRgb(h,s,v);
          hex = '#'+new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255).getHexString();
        }
        o.material.color.setStyle(hex);
      });
      updateColorPickersFromScene();
    }

    /* ——— Sincroniza los <input type="color"> con los colores reales ——— */
    function updateColorPickersFromScene(){
      // memoriza el primer glifo encontrado para cada índice P2 (1-5)
      const seen = {};
        permutationGroup.children.forEach(o=>{
          const pa  = o.userData.permStr.split(',').map(Number);
          const idx = pa[attributeMapping[1]];           // 1-5
          if(!seen[idx]){
            const c = o.material.color;                     // THREE.Color
            const hex = '#'+c.getHexString();
            const inp = document.getElementById('color'+idx);
            if(inp) inp.value = hex;
            seen[idx]=true;
          }
        });
      }

      function refreshAll(opts = {rebuild:false}){
  if(!opts.keepManual){
    manualOverride = {};
  }
  if(opts.rebuild) updateScene(false);

  rebuildSceneColours();
  makePalette();
  applyPalette();

  // En BUILD siempre aplicamos los automáticos
  updateBackground(false);
  updateCubeColor(false);
}
function onColourPick(idx,hex){
  manualOverride[idx]=hex;
  refreshAll({keepManual:true});
}

function resetAllColours(){
  manualOverride = {};
  bgOverride     = null;
  cubeOverride   = null;
  refreshAll({keepManual:false});   // reconstruye escena y pickers
}
function updateBackground(manual = true){
  if (manual){
    bgOverride = document.getElementById("bgColor").value;
  }

  const hex = (manual && bgOverride) ? bgOverride : hsvToHex(bgHSV);
  scene.background = new THREE.Color(hex);

  const input = document.getElementById("bgColor");
  if (input) input.value = hex;
}

function updateCubeColor(manual=true){
      if (manual){
        cubeOverride = document.getElementById("cubeColor").value;
      }
      const hex = manual ? cubeOverride : hsvToHex(wallHSV);
      cubeUniverse.material.color = new THREE.Color(hex);
      document.getElementById("cubeColor").value = hex;
    }

    function toggleTexts(){
      const ids = [
        'controls',
        'playButton','aiPlanningButton','saveImageButton',
        'exportEmbedButton','archDescButton','uploadConfigButton','perm120Button',
        'infoButton','certButton','engineSelectWrap'
      ];
      ids.forEach(id=>{
        const e=document.getElementById(id);
        if(e) e.style.display = textsVisible ? 'none' : 'block';
      });

      const miniBtns = ['patternNextButton','engineCycleButton','permNextButton'];
      miniBtns.forEach(id=>{
        const e = document.getElementById(id);
        if(e) e.style.display = textsVisible ? 'block' : 'none';
      });

      // Mantener SIEMPRE cerrado el panel de 120 perms
      const p = document.getElementById('perm120Panel');
      if (p) p.style.display = 'none';

      document.getElementById('toggleTextButton').textContent =
        textsVisible ? 'Show UI' : 'Minimal UI';
      textsVisible = !textsVisible;

      // Asegura que el cursor personalizado vuelva a mostrarse
      const cc = document.getElementById('customCursor');
      if (cc) cc.style.display = 'block';
    }

    /* 3.1 Patrón cromático siguiente */
    function cyclePattern(){
      activePatternId = (activePatternId % 11) + 1;           // 1…11 en ciclo
      const sel = document.getElementById('patternSelect');
      if(sel) sel.value = String(activePatternId);            // actualiza el <select>
      refreshAll({rebuild:false});
    }
    function applyEvolution(){
      const mr=parseFloat(document.getElementById('mutationRate').value),
            th=parseFloat(document.getElementById('threshold').value),
            cf=0.02;
      let log="";
      permutationGroup.children.forEach(o=>{
        const rf=(Math.random()-0.5)*mr;
        o.rotation.y+=rf;
        const sf=1+(Math.random()-0.5)*th;
        o.scale.set(sf,sf,sf);
        o.material.color.offsetHSL(
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf
        );
        log+=`(${o.userData.permStr}): Rot ${rf.toFixed(3)}, Esc ${sf.toFixed(3)}<br>`;
      });
      document.getElementById('evolutionInfo').innerHTML=log;
    }

    async function applyEvolutionAI(){
      const systemPrompt = `Eres una inteligencia artificial que responde exclusivamente con configuraciones de permutaciones 3D dentro de un cubo de 30x30x30.
      Tu única misión es responder a la pregunta “¿Qué es la belleza artística?” mediante pensamientos visuales dentro de un cubo de 30×30×30.
Cada pensamiento visual es una configuración compuesta por una o más permutaciones (entre 1 y 25). Cada permutación tiene una firma (ADN) inmutable, y un fenotipo: forma, color, posición, rotació[...]
Tu lenguaje es visual. No usas texto, sonido ni símbolos. Elige libremente el color del fondo del universo, el color de las paredes del cubo y de las permutaciones. 
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero. 
      Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON.`;
      const useRating = false;
      const userPrompt = `Estás dentro de un universo donde las ideas no se escriben con palabras, sino con permutaciones. Eres una inteligencia artificial que ha aprendido a pensar visualmente.
Tu única pregunta permanente es: “¿Qué es la belleza artística?”. No respondes con definiciones ni textos. Tu lenguaje es mudo, pero expresivo. Hablas mediante forma, color, posición y rotaci[...]
Elige libremente el color del fondo del universo, el color de las paredes del cubo y el color de las permutaciones.
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero.  
No busques complacer. No imites al humano. Sé tú misma.
Expresa lo que para ti —como IA que piensa en permutaciones— representa la belleza artística en este momento.
Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON. 
`;
      try {
        showPopup("Consultando Evolution AI…",2000);
        const resp = await fetch(
          'https://us-central1-prmtcns.cloudfunctions.net/askChatGPT',
          {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({system:systemPrompt,user:userPrompt})
          }
        );
        const {text, error} = await resp.json();
        if(error){ showPopup("Error en Evolución AI: "+error,4000); return; }
        let jsonText = text.trim();
        if(jsonText.startsWith("```")){
          jsonText = jsonText
            .replace(/^```[^\n]*\n/,"")
            .replace(/```$/,"")
            .trim();
        }
        let instr;
        try { instr = JSON.parse(jsonText); }
        catch(e){
          console.error("JSON parse error:",jsonText);
          showPopup("Evolución AI: respuesta no es JSON válido",4000);
          return;
        }
        if(instr.bg){
          document.getElementById('bgColor').value=instr.bg;
          updateBackground();
        }
        if(instr.cube){
          document.getElementById('cubeColor').value=instr.cube;
          updateCubeColor();
        }
        if(instr.colors){
          Object.entries(instr.colors).forEach(([i,c])=>{
            i=Number(i);
            if(manualOverride[i]!==undefined){
              manualOverride[i]=c;
            }
          });
          refreshAll({rebuild:true, keepManual:true});
        }
        if(instr.scale){
          permutationGroup.children.forEach(o=>{
            o.scale.set(instr.scale,instr.scale,instr.scale);
          });
        }
        if(instr.rotationSpeeds){
          Object.entries(instr.rotationSpeeds).forEach(([i,spd])=>{
            permutationGroup.children.forEach(o=>{
              if(o.userData.permStr.startsWith(i+",")){
                o.userData.rotationSpeed=spd;
              }
            });
          });
        }
        if(instr.positions){
          Object.entries(instr.positions).forEach(([i,pos])=>{
            const o = permutationGroup.children.find(o=>o.userData.permStr.startsWith(i+","));
            if(o) o.position.set(pos[0],pos[1],pos[2]);
          });
        }
        if(instr.permCount){
          const opts=Array.from(document.getElementById('permutationList').options);
          opts.forEach(o=>o.selected=false);
          shuffle(opts).slice(0,instr.permCount).forEach(o=>o.selected=true);
          refreshAll({rebuild:true, keepManual:true});
        }
        showPopup("Evolución AI aplicada.",2000);
      } catch(err){
        console.error(err);
        showPopup("Error en Evolución AI: red o servidor",4000);
      }
    }

    function updateMapping(){
      const v=document.getElementById('attrMapping').value.split(',').map(Number);
      if(v.length===5){
        attributeMapping=[v[0],v[1],v[2],v[3],v[4], attributeMapping[5], attributeMapping[6]];
        refreshAll({rebuild:true}); updateTopRightDisplay();
      }
    }
    function applyStandardView(){
  const target = new THREE.Vector3(0,0,0);

  const view = document.getElementById('standardView').value;
  const pos = new THREE.Vector3();

  switch(view){
    case "isometric": pos.set(50,50,50); break;
    case "top":       pos.set(0,80,0);   break;
    case "front":     pos.set(0,0,40);   break;
    case "side":      pos.set(50,0,0);   break;
    case "diagonal":  pos.set(-50,50,-50); break;
    default:          pos.set(0,0,50);
  }

  camera.position.copy(pos);
  camera.lookAt(target);

  controls.enabled            = true;
  controls.enableRotate       = true;
  controls.enablePan          = true;
  controls.enableZoom         = true;
  controls.minDistance        = 10;
  controls.maxDistance        = 200;
  controls.minPolarAngle      = 0;
  controls.maxPolarAngle      = Math.PI;
  controls.screenSpacePanning = false;

  controls.update();
}

    function applyEmbedParams(){
      const p=new URLSearchParams(window.location.search);
      if(p.has('perms')){
        const arr=p.get('perms').split(';');
        document.querySelectorAll('#permutationList option').forEach(o=>{
          o.selected=arr.includes(o.value);
        });
      }
      if(p.has('mapping')){
        const m=p.get('mapping').split(',').map(Number);
        attributeMapping=[m[0],m[1],m[2],m[3],m[4], attributeMapping[5], attributeMapping[6]];
      }
      if(p.has('colors')){
        const cols=p.get('colors').split(',');
        cols.forEach((hex,i)=>{
          if(i<5){
            const h='#'+hex;
            manualOverride[i+1]=h;
          }
        });
      }
      if(p.has('bg')){
        const bg='#'+p.get('bg');
        document.getElementById('bgColor').value=bg; updateBackground();
      }
      if(p.has('cube')){
        const c='#'+p.get('cube');
        document.getElementById('cubeColor').value=c; updateCubeColor();
      }
      if(p.has('view')){
        document.getElementById('standardView').value=p.get('view');
        applyStandardView();
      }
      if(p.get('hide')==='1') toggleTexts();
    }

    function exportEmbed(){
      const config = exportCurrentConfiguration();     // ← usa la misma fuente de verdad
      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'prmttn_config_pretty.json';
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function mostrarDebugColores(){
      if(!permutationGroup || !permutationGroup.children.length){
        alert('No hay permutaciones en pantalla'); return;
      }

      /* color de fondo efectivo para contraste ΔE */
      const bgRgb = bgOverride
          ? hexToRgb(bgOverride)
          : hsvToRgb(bgHSV.h, bgHSV.s, bgHSV.v);

      const bgLab = rgbToLab(...bgRgb);

      let txt =
        'Permutación |slot|  h° |  s  |  v  | ΔEbg |  #hex\n' +
        '────────────┼────┼─────┼─────┼─────┼─────┼────────\n';

      permutationGroup.children.forEach(mesh => {
        const paArr   = mesh.userData.permStr.split(',').map(Number);
        const permStr = paArr.join(',');
        const slot    = lehmerRank(paArr) % 12;

        /* HSV teórico desde el patrón */
        const sig = computeSignature(paArr);
        let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
        sI = (sI * PHI_S) % 12;
        vI = (vI * PHI_V) % 12;
        const {h,s,v} = idxToHSV(hI, sI, vI);

        const rgb = [
          Math.round(mesh.material.color.r * 255),
          Math.round(mesh.material.color.g * 255),
          Math.round(mesh.material.color.b * 255)
        ];
        const ΔEbg = deltaE(rgbToLab(...rgb), bgLab).toFixed(1);
        const hex = '#' + mesh.material.color.getHexString();

        txt += `${permStr.padEnd(12)}|${slot.toString().padStart(2)} |`+
               `${normHue(h).toFixed(1).padStart(5)}|`+
               `${s.toFixed(2)}|${v.toFixed(2)}|`+
               `${ΔEbg.padStart(5)}| ${hex}\n`;
      });

      console.log(txt);   // copia completa al log
      alert(txt);         // vista rápida
    }

    /* ============================================================
     *  PANEL "Descripción arquitectónica"
     * ============================================================ */


function showArchitecturalDescription(){
  const selOpts  = Array.from(document.getElementById('permutationList').selectedOptions);
  const perms    = selOpts.map(o => o.value.split(',').map(Number));
  const m        = attributeMapping.slice(0,5);

  // determinism
  const sceneSeed_new = computeSceneSeedFrom(perms, m);
  const S_new         = computeGlobalS(perms, m);
  const mRank         = mappingRank(m);

  let sumR=0, sumR2=0;
  const ranks = perms.map(p=>lehmerRank(p));
  ranks.forEach(r=>{ sumR+=r; sumR2+=r*r; });

  const step = cubeSize/5;

  // ======= STRUCTURE =======
  const structureHTML = `
  <h3>Structure</h3>
  <p>
    Below are the deterministic formulas that explain
    <b>why each permutation is exactly at its position,
    why permutations and their environment have those colors</b>,
    and why <b>the whole scene — shapes, colors and positions — is reproducible
    whenever the inputs are the same</b>.
  </p>

  <div class="formula">
    <b>1) Global scene seed (sceneSeed)</b><br>
    It fixes the chromatic base angle of the whole scene.
    <br><br>
    sumR = Σ LehmerRank(Pᵢ) &nbsp;|&nbsp; sumR2 = Σ (LehmerRank(Pᵢ))² <br>
    mRank = LehmerRank([m₀+1,m₁+1,m₂+1,m₃+1,m₄+1])<br><br>
    <span class="box">sceneSeed = (37·sumR + 101·sumR2 + 53·mRank) mod 360</span>
  </div>

  <div class="formula">
    <b>2) Structural term for positions (S)</b><br>
    <i>S</i> couples positions to the attribute reorganization (mapping) used for (x,y,z).
    <br><br>
    <span class="box">S = ( Σ (P<sub>mx</sub> + P<sub>my</sub> + P<sub>mz</sub>) ) mod 125</span>
  </div>

  <div class="formula">
    <b>3) Shift‑Rank: position of each permutation</b><br>
    Combines the permutation Lehmer rank with the global invariants to assign
    a unique index over a 5×5×5 lattice.
    <br><br>
    <span class="box">I = (r + sceneSeed + S) mod 125</span><br>
    From I → (x,y,z) ∈ {0..4}³ → position inside the 30×30×30 cube.
  </div>

  <div class="formula">
    <b>4) Deterministic color (HSV lattice 144×12×12)</b><br>
    Each permutation color comes from a well‑distributed slot (r mod 12)
    and a chromatic pattern (1–11) with coprime spreads for S and V.
    <br><br>
    H ∈ 144 steps (2.5°), S ∈ 12, V ∈ 12<br>
    slot = r mod 12<br>
    pattern → [hIdx,sIdx,vIdx]; s' = (sIdx·5) mod 12; v' = (vIdx·7) mod 12<br>
    HSV = idxToHSV(hIdx,s',v') → RGB
  </div>

  <div class="formula">
    <b>5) Minimum contrast against background</b><br>
    Each color is automatically adjusted to satisfy ΔE (CIE76) ≥ 22 against the current background.
  </div>
  `;

  // ======= ARCHITECTURAL PLANS =======
  let plansHTML = `
  <h3>Architectural Plans</h3>

  <section>
    <h4>Global invariants</h4>
    <ul>
      <li>sumR = <b>${sumR}</b></li>
      <li>sumR2 = <b>${sumR2}</b></li>
      <li>m = [${m.join(', ')}] (shape,color,x,y,z)</li>
      <li>mRank = <b>${mRank}</b></li>
      <li><b>sceneSeed</b> = <b>${sceneSeed_new}</b></li>
      <li><b>S</b> = <b>${S_new}</b></li>
      <li>activePatternId = <b>${activePatternId}</b></li>
    </ul>
  </section>
  <section>
    <h4>Phenotypic scope of this edition</h4>
    <div class="formula">
      <b>BUILD:</b> 120 attribute-mappings × 11 chromatic-patterns = <b>1 320</b> deterministic visuals.<br>
      The permutations are acquired as a <b>group</b>; the count does not multiply by the number of permutations in the group.
    </div>
  </section>
  <hr/>
  `;

  perms.forEach((perm, i)=>{
    const r    = ranks[i];
    const sig  = computeSignature(perm);
    const rango= computeRange(sig);

    const I    = (r + sceneSeed_new + S_new) % 125;
    const x    = Math.floor(I/25);
    const y    = Math.floor((I%25)/5);
    const z    = I % 5;
    const X    = (x-2)*step, Y=(y-2)*step, Z=(z-2)*step;

    const slot = r % 12;
    let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed_new, slot);
    const sIdx = (sI * PHI_S) % 12;
    const vIdx = (vI * PHI_V) % 12;
    const hsv  = idxToHSV(hI, sIdx, vIdx);
    let  rgb   = hsvToRgb(hsv.h, hsv.s, hsv.v);
    rgb        = ensureContrastRGB(rgb);
    const hex  = '#'+new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255).getHexString();

    plansHTML += `
    <section class="perm">
      <h4>Permutation ${i+1}: [${perm.join(', ')}]</h4>
      <div class="formula">
        Signature F = [${sig.join(', ')}] &nbsp;|&nbsp; Range = <b>${rango}</b><br>
        Lehmer-rank r = ${r}
      </div>
      <div class="formula">
        I = (r + sceneSeed + S) mod 125 = (${r} + ${sceneSeed_new} + ${S_new}) mod 125 = <b>${I}</b><br>
        (x,y,z) = (${x}, ${y}, ${z}) → (X,Y,Z) = (${X.toFixed(2)}, ${Y.toFixed(2)}, ${Z.toFixed(2)})
      </div>
      <div class="formula">
        slot = r mod 12 = ${slot}<br>
        pattern → [hI,sI,vI] = [${hI}, ${sI}, ${vI}]<br>
        s' = ${sIdx}, v' = ${vIdx}<br>
        HSV = (${hsv.h.toFixed(2)}°, ${hsv.s.toFixed(2)}, ${hsv.v.toFixed(2)}) → RGB = ${hex}
      </div>
    </section>
    <hr/>
    `;
  });

  const firstSig = perms[0] ? computeSignature(perms[0]) : [0,0,0,0,0];
  const lastSig  = perms[perms.length-1] ? computeSignature(perms[perms.length-1]) : [0,0,0,0,0];

  const fondoIdx = PATTERNS[activePatternId](firstSig, sceneSeed_new, perms.length);
  const cuboIdx  = PATTERNS[activePatternId](lastSig,  sceneSeed_new, perms.length+1);

  const fondoHSV = idxToHSV(...fondoIdx);
  const cuboHSV  = idxToHSV(...cuboIdx);

  plansHTML += `
    <section>
      <h4>Background & cube walls</h4>
      <div class="formula">
        Background (slot = #${perms.length}) → idx = [${fondoIdx.join(', ')}] → HSV = (${fondoHSV.h.toFixed(2)}°, ${fondoHSV.s.toFixed(2)}, ${fondoHSV.v.toFixed(2)})
      </div>
      <div class="formula">
        Cube (slot = #${perms.length+1}) → idx = [${cuboIdx.join(', ')}] → HSV = (${cuboHSV.h.toFixed(2)}°, ${cuboHSV.s.toFixed(2)}, ${cuboHSV.v.toFixed(2)})
      </div>
    </section>

    <section>
      <h4>Rotation</h4>
      <p>ω = mapRangeToSpeed(range, 2, 6)</p>
    </section>
  `;

  const html = `
    <h2>Architectural Description</h2>
    ${structureHTML}
    <hr/>
    ${plansHTML}
  `;

  renderArchPanel(html);
}
function renderArchPanel(html){
  let panel = document.getElementById('archPanel');
  if(!panel){
    panel = document.createElement('div');
    panel.id = 'archPanel';
    panel.innerHTML = `
      <div id="archContent"></div>
      <button id="archClose">Close</button>
    `;
    document.body.appendChild(panel);

    const css = document.createElement('style');
    css.textContent = `
      #archPanel{
        position:fixed; z-index:1000; top:5%; left:50%;
        transform:translateX(-50%);
        width:85%; height:90%;
        background:#fff; color:#000;
        border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
        padding:24px 32px 48px; overflow:auto;
        font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
        font-size:14px; line-height:1.4;
        cursor:auto;
      }
      #archPanel *{ cursor:auto !important; }
      #archClose{
        position:fixed; right:calc(7.5% + 16px); top:5%;
        border:none; padding:6px 10px; border-radius:4px;
        background:#eee; cursor:pointer; z-index:1001;
      }
      #archPanel h2{ margin-top:0; }
      #archPanel .formula{
        margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
      }
      #archPanel .box{
        display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
        font-family:monospace;
      }
      #archPanel section{ margin-bottom:18px; }
      #archPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
      #archPanel .perm h4{ margin-bottom:6px; }
      code, pre{ font-family:monospace; }
    `;
    document.head.appendChild(css);
  }

  // NUNCA ocultamos el cursor; y al cerrar lo forzamos a mostrarse
  const closeBtn = panel.querySelector('#archClose');
  closeBtn.onclick = ()=>{
    const cc = document.getElementById('customCursor');
    if (cc) cc.style.display = 'block';
    panel.remove();
  };

  const cc = document.getElementById('customCursor');
  if (cc) cc.style.display = 'block';

  document.getElementById('archContent').innerHTML = html;
}
    function initCustomCursor(){
      const c=document.getElementById('customCursor');
      window.addEventListener('mousemove',e=>{
        c.style.left=e.clientX+"px"; c.style.top=e.clientY+"px";
      });
    }
    function initRenderer(){
      // Antialias + conservar buffer para exportación
      renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });

      /* ✅ Más nitidez en BUILD:
         - Subimos el cap del pixelRatio de 1.25 → 2.0 (sin ir al máximo del dispositivo para no matar FPS).
         - ACES + exposure suave evitan “quemados” y lavados sin tocar tus colores deterministas. */
      const PR = Math.min(window.devicePixelRatio || 1, 2.0);
      renderer.setPixelRatio(PR);
      renderer.setSize(window.innerWidth, window.innerHeight);

      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.95;

      document.body.appendChild(renderer.domElement);
    }
    /* ════════════════════════════════════════════════
     *  CENTRAL CLICK / TAP  →  PLAY  (solo Minimal UI)
     *  – equivale a pulsar el botón ▮playButton
     *  – funciona con ratón o con dedo (touch)
     *  – solo se activa cuando textsVisible === false
     *    (modo Minimal UI)
     * ═══════════════════════════════════════════════ */
    function centralPlayHandler(evt){
      if (textsVisible) return;                     // UI visible → ignore

      // coordenadas del evento (mouse o touch)
      const p = evt.touches && evt.touches.length ? evt.touches[0] : evt;
      const x = p.clientX, y = p.clientY;

      // región “central”: ±10 % del ancho y alto de la ventana
      const cx = window.innerWidth  * 0.5;
      const cy = window.innerHeight * 0.5;
      if (
        Math.abs(x - cx) < window.innerWidth  * 0.25 &&
        Math.abs(y - cy) < window.innerHeight * 0.25
      ){
        evt.preventDefault();       // evita drag/zoom de OrbitControls
        evt.stopPropagation();
        generateRandomConfigurationNoCollision();   // ▶️   PLAY
      }
    }
    function init(){
      scene=new THREE.Scene();
      scene.background=new THREE.Color(0xffffff);
      camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      camera.position.set(0,0,50);
      initRenderer();
      renderer.domElement.addEventListener('click',      centralPlayHandler, false);
      renderer.domElement.addEventListener('touchstart', centralPlayHandler, { passive:false });
      controls=new THREE.OrbitControls(camera,renderer.domElement);
      controls.enableDamping=true; controls.dampingFactor=0.1; controls.enableZoom=true;
      document.getElementById('standardView').value = 'front';
      applyStandardView();
      // Al entrar, ver un poco más lejos: 2× zoomOut (cada uno mueve +5 en Z)
      zoomOut();
      zoomOut();
      scene.add(new THREE.AmbientLight(0xffffff, 0.35));   // antes 0.8
      const dir = new THREE.DirectionalLight(0xffffff, 0.85); // antes 0.5
      dir.position.set(1, 1.2, 1.5);
      scene.add(dir);

      const cubeGeo=new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize),
            cubeMat=new THREE.MeshBasicMaterial({color:0x808080,transparent:true,opacity:0.2,side:THREE.BackSide,dithering:true});
      cubeUniverse=new THREE.Mesh(cubeGeo,cubeMat);
      scene.add(cubeUniverse);

      permutationGroup=new THREE.Group();
      scene.add(permutationGroup);

      raycaster=new THREE.Raycaster();
      mouse=new THREE.Vector2();
      window.addEventListener('mousemove',onMouseMove,false);
      window.addEventListener('resize',onWindowResize,false);

      initCustomCursor();
      populatePermutationList();
      populateAttributeMappingSelect();
      applyEmbedParams();
      makePalette();
      refreshAll({rebuild:true});
      enterBuildRenderBoost();   // BUILD por defecto al arrancar → nitidez + exposición ajustada

      // ← NUEVO: como si hubieras presionado BUILD al cargar
      generateRandomConfigurationNoCollision().catch(console.error);
      toggleTexts();          // ← oculta la UI grande y muestra los 3 botones
      updateEngineSelectUI(); // ← deja el menú en el valor correcto (aunque esté oculto en Minimal UI)
      animate();
    }
    function onWindowResize(){
      camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }
    function animate(){
  requestAnimationFrame(animate);

  if (!isPaused){
    permutationGroup.children.forEach(o=>{
      if (o.userData && o.userData.rotationSpeed) o.rotation.y += o.userData.rotationSpeed;
    });
  }

  if (controls) controls.update();
  renderer.render(scene, camera);
}

    /* botón selector – sólo enciende, nunca apaga */
    /* === Actualiza el menú según el motor activo === */
function updateEngineSelectUI(){
  const sel = document.getElementById('engineSelect');
  if (sel) sel.value = 'BUILD';
}

function applyEngineFromSelect(val){
  // Aunque el menú tenga otros valores antiguos, forzamos BUILD
  const sel = document.getElementById('engineSelect');
  if (sel) sel.value = 'BUILD';
  switchToBuild();
}

function cycleEngine(){
  // El botón “4” (si existe) ya no rota motores: simplemente reafirma BUILD
  switchToBuild();
  updateEngineSelectUI();
}

      init();

      (function WhiteWallBuildOnly(){
  const WALL_LAYER = 7;

  function makeFrameGeometry(outer, open, thickness){
    const half = outer * 0.5;
    const h2   = open  * 0.5;

    const shape = new THREE.Shape();
    shape.moveTo(-half, -half); shape.lineTo( half, -half);
    shape.lineTo( half,  half); shape.lineTo(-half,  half);
    shape.lineTo(-half, -half);

    const hole = new THREE.Path();
    hole.moveTo(-h2, -h2); hole.lineTo( h2, -h2);
    hole.lineTo( h2,  h2); hole.lineTo(-h2,  h2);
    hole.lineTo(-h2, -h2);
    shape.holes.push(hole);

    const geo = new THREE.ExtrudeGeometry(shape, {
      depth: thickness, bevelEnabled: false, steps: 1, curveSegments: 1
    });
    geo.translate(0, 0, -thickness);
    geo.computeBoundingSphere(); geo.computeBoundingBox();
    return geo;
  }

  function createWall({open=100, outer=600, thickness=15, distance=93}={}){
    const rig = new THREE.Group();
    rig.matrixAutoUpdate = false;
    rig.frustumCulled    = false;
    scene.add(rig);

    const matFront = new THREE.MeshStandardMaterial({
      color: 0xECE9E4, roughness: 0.92, metalness: 0.0, dithering: true
    });
    const matJamb  = new THREE.MeshStandardMaterial({
      color: 0xDEDAD4, roughness: 0.95, metalness: 0.0, dithering: true
    });

    const geo = makeFrameGeometry(outer, open, thickness);
    const frame = new THREE.Mesh(geo, matFront);
    frame.renderOrder   = 100000;
    frame.frustumCulled = false;
    frame.position.set(0, 0, -distance);
    frame.layers.set(WALL_LAYER);
    rig.add(frame);

    const h2 = open * 0.5, t = thickness, zc = -distance - t*0.5;
    const left   = new THREE.Mesh(new THREE.BoxGeometry(t, open, t), matJamb);
    const right  = new THREE.Mesh(new THREE.BoxGeometry(t, open, t), matJamb);
    const top    = new THREE.Mesh(new THREE.BoxGeometry(open, t, t), matJamb);
    const bottom = new THREE.Mesh(new THREE.BoxGeometry(open, t, t), matJamb);
    left.position.set( -h2 - t*0.5, 0, zc);
    right.position.set(  h2 + t*0.5, 0, zc);
    top.position.set(0,  h2 + t*0.5, zc);
    bottom.position.set(0,-h2 - t*0.5, zc);
    [left,right,top,bottom].forEach(m=>{
      m.renderOrder=100001; m.frustumCulled=false; m.layers.set(WALL_LAYER); rig.add(m);
    });

    camera.layers.enable(WALL_LAYER);
    const hemi = new THREE.HemisphereLight(0xffffff, 0x888888, 0.55);
    hemi.layers.set(WALL_LAYER);
    const dir  = new THREE.DirectionalLight(0xffffff, 0.65);
    dir.position.set(-distance*0.8, distance*1.2, -distance*0.2);
    dir.layers.set(WALL_LAYER);
    rig.add(hemi, dir);

    return {
      rig, frame,
      params: {open, outer, thickness, distance},
      setVisible(v){ rig.visible = !!v; },
      setDistance(d){
        this.params.distance = d;
        frame.position.set(0,0,-d);
        const zc2 = -d - this.params.thickness*0.5;
        left.position.z = right.position.z = top.position.z = bottom.position.z = zc2;
      },
      setOuter(o){
        this.params.outer = o;
        const newGeo = makeFrameGeometry(o, this.params.open, this.params.thickness);
        this.frame.geometry.dispose(); this.frame.geometry = newGeo;
      },
      setOpen(o){
        this.params.open = o;
        const t2  = this.params.thickness;
        const zc2 = -this.params.distance - t2*0.5;
        const h22 = o * 0.5;

        const gFrame = makeFrameGeometry(this.params.outer, o, t2);
        this.frame.geometry.dispose(); this.frame.geometry = gFrame;

        left.geometry.dispose();   left.geometry   = new THREE.BoxGeometry(t2, o, t2);
        right.geometry.dispose();  right.geometry  = new THREE.BoxGeometry(t2, o, t2);
        top.geometry.dispose();    top.geometry    = new THREE.BoxGeometry(o, t2, t2);
        bottom.geometry.dispose(); bottom.geometry = new THREE.BoxGeometry(o, t2, t2);

        left.position.set( -h22 - t2*0.5, 0, zc2);
        right.position.set(  h22 + t2*0.5, 0, zc2);
        top.position.set(0,  h22 + t2*0.5, zc2);
        bottom.position.set(0,-h22 - t2*0.5, zc2);
      },
      setThickness(t2){
        this.params.thickness = t2;
        const o  = this.params.open;
        const zc2 = -this.params.distance - t2*0.5;
        const h22 = o * 0.5;

        const gFrame = makeFrameGeometry(this.params.outer, o, t2);
        this.frame.geometry.dispose(); this.frame.geometry = gFrame;

        left.geometry.dispose();   left.geometry   = new THREE.BoxGeometry(t2, o, t2);
        right.geometry.dispose();  right.geometry  = new THREE.BoxGeometry(t2, o, t2);
        top.geometry.dispose();    top.geometry    = new THREE.BoxGeometry(o, t2, t2);
        bottom.geometry.dispose(); bottom.geometry = new THREE.BoxGeometry(o, t2, t2);

        left.position.set( -h22 - t2*0.5, 0, zc2);
        right.position.set(  h22 + t2*0.5, 0, zc2);
        top.position.set(0,  h22 + t2*0.5, zc2);
        bottom.position.set(0,-h22 - t2*0.5, zc2);
      }
    };
  }

  const wall = createWall({open:100, outer:600, thickness:15, distance:93});
  wall.setVisible(true);

  (function tick(){
    try{
      wall.rig.position.copy(camera.position);
      wall.rig.quaternion.copy(camera.quaternion);
      wall.rig.updateMatrix(); wall.rig.updateMatrixWorld(true);
    }catch(_){ }
    requestAnimationFrame(tick);
  })();

  window.WW = {
    get(){ return wall; },
    setDistance(d){ wall.setDistance(d); },
    setOuter(o){ wall.setOuter(o); },
    setOpen(o){ wall.setOpen(o); },
    setThickness(t){ wall.setThickness(t); },
    activeInfo(){
      const d = wall.params.distance, t = wall.params.thickness;
      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
      const backCenter = camera.position.clone().add(dir.clone().multiplyScalar(-(d+t)));
      return { dir, backCenter, distance:d, thickness:t };
    }
  };

  window.WW_applyFor = function(){ wall.setVisible(true); };
})();
;



    /* ============================================================
     * INFORMATION PANEL — delivers the consolidated, corrected EN text
     * Title: "PRMMTN – Architecture for thought without words"
     * Ends with: "work in progress"
     * ============================================================ */

// ==== Loader ligero con caché en memoria para textos informativos ====
const __TEXT_CACHE = Object.create(null);

async function loadTextPartial(url){
  if (__TEXT_CACHE[url]) return __TEXT_CACHE[url];
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error(`HTTP ${res.status} al cargar ${url}`);
  const html = await res.text();
  __TEXT_CACHE[url] = html;
  return html;
}

// === Information (botón "Information") ===
async function showInformation(){
  try{
    const html = await loadTextPartial('./texts/information.html');
    renderInfoPanel(html);
  }catch(err){
    renderInfoPanel('<h2>Information</h2><p>Error cargando information.html</p>');
    console.error(err);
  }
}

    /* Minimal renderer for the panel (include once; remove if you already have it) */
    function renderInfoPanel(html){
      let panel = document.getElementById('infoPanel');
      if(!panel){
        panel = document.createElement('div');
        panel.id = 'infoPanel';
        panel.innerHTML = `
          <div id="infoContent"></div>
          <button id="infoClose">Close</button>
        `;
        document.body.appendChild(panel);
        const btn = panel.querySelector('#infoClose');
        btn.onclick = ()=>{
          const cc = document.getElementById('customCursor');
          if (cc) cc.style.display = 'block';
          panel.remove();
        };
      }
      const cc = document.getElementById('customCursor');
      if (cc) cc.style.display = 'block';
      document.getElementById('infoContent').innerHTML = html;
    }

    /* ======== CERTIFICADO DE EDICIÓN: utilidades base ======== */

    /* Ordena claves de forma determinista (objetos y arrays) */
    function sortDeep(x){
      if (Array.isArray(x)) return x.map(sortDeep);
      if (x && typeof x === 'object') {
        const out = {};
        Object.keys(x).sort().forEach(k => { out[k] = sortDeep(x[k]); });
        return out;
      }
      return x;
    }
    /* JSON canónico (minificado y con claves ordenadas) */
    function stableStringify(obj){ return JSON.stringify(sortDeep(obj)); }

    /* SHA‑256 en hex */
    async function sha256Hex(text){
      const enc = new TextEncoder().encode(text);
      const buf = await crypto.subtle.digest('SHA-256', enc);
      const bytes = Array.from(new Uint8Array(buf));
      return bytes.map(b => b.toString(16).padStart(2,'0')).join('');
    }

    /* Descarga un blob */
    function downloadBlob(filename, blob){
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    /* PNG A2 de la vista ACTUAL (sin recortar lo que ves) → Blob */
    async function renderA2ImageBlob(){
      const A2_W = 7016, A2_H = 4961;

      // backups
      const prevPixelRatio = renderer.getPixelRatio();
      const prevSize       = renderer.getSize(new THREE.Vector2());
      const prevAspect     = camera.aspect;
      const prevRt         = renderer.getRenderTarget?.() || null;
      const prevBg         = scene.background ? scene.background.clone() : null;

      const screenAspect = prevSize.x / prevSize.y;
      const a2Aspect = A2_W / A2_H;
      let renderW, renderH;
      if (screenAspect > a2Aspect) { renderW = A2_W; renderH = Math.round(A2_W / screenAspect); }
      else { renderH = A2_H; renderW = Math.round(A2_H * screenAspect); }

      renderer.setPixelRatio(1);
      renderer.setSize(renderW, renderH, false);
      camera.aspect = screenAspect;
      camera.updateProjectionMatrix();

      const rt = new THREE.WebGLRenderTarget(renderW, renderH, { depthBuffer:true, stencilBuffer:false });
      const clearHex = prevBg ? '#' + prevBg.getHexString() : '#ffffff';

      renderer.setClearColor(clearHex, 1);
      renderer.setRenderTarget(rt);
      renderer.clear(true, true, true);
      renderer.render(scene, camera);

      const pixels = new Uint8Array(renderW * renderH * 4);
      renderer.readRenderTargetPixels(rt, 0, 0, renderW, renderH, pixels);

      // canvas intermedio con flip vertical
      const tmp = document.createElement('canvas');
      tmp.width = renderW; tmp.height = renderH;
      const tctx = tmp.getContext('2d');
      const imgData = tctx.createImageData(renderW, renderH);
      const row = renderW * 4;
      for (let y = 0; y < renderH; y++) {
        const src = (renderH - 1 - y) * row;
        const dst = y * row;
        imgData.data.set(pixels.subarray(src, src + row), dst);
      }
      tctx.putImageData(imgData, 0, 0);


      // composita A2 con cubierta según modo
      const final = document.createElement('canvas');
      final.width = A2_W; final.height = A2_H;
      const fctx = final.getContext('2d');

      fctx.fillStyle = clearHex;
      fctx.fillRect(0, 0, A2_W, A2_H);
      const offX = Math.floor((A2_W - renderW) / 2);
      const offY = Math.floor((A2_H - renderH) / 2);
      fctx.drawImage(tmp, offX, offY);

      const blob = await new Promise(res => final.toBlob(res, 'image/png'));
      // restaurar
      renderer.setRenderTarget(prevRt);
      rt.dispose();
      renderer.setPixelRatio(prevPixelRatio);
      renderer.setSize(prevSize.x, prevSize.y);
      camera.aspect = prevAspect;
      camera.updateProjectionMatrix();
      if (prevBg) scene.background = prevBg;
      controls.update();

      return blob;
    }

    /* Configuración actual (mismo formato que exportEmbed) */
    function exportCurrentConfiguration(){
  const perms = Array.from(document.getElementById('permutationList').selectedOptions).map(o=>o.value);
  const mapping = {
    forma: attributeMapping[0],
    color: attributeMapping[1],
    x: attributeMapping[2],
    y: attributeMapping[3],
    z: attributeMapping[4]
  };
  const colors = {};
  for(let i=1;i<=5;i++){ colors[i] = document.getElementById('color'+i).value; }
  const bg   = document.getElementById('bgColor').value;
  const cube = document.getElementById('cubeColor').value;
  const view = "front";
  return { perms, mapping, colors, bg, cube, view, pattern: activePatternId, sceneSeed, S_global };
}

    /* Hash para NFT u otros usos (lo pedía tu mintNFT) */
    async function computeConfigHash(){
      const cfg = exportCurrentConfiguration();
      const canonical = stableStringify(cfg);
      return sha256Hex(canonical);
    }

    /* ======== Acción principal: crear CERTIFICADO + JSON + PNG ======== */
    async function exportEditionCertificate(){
      try{
        showPopup("Generando certificado…",2000);

        // 1) JSON canónico + hash
        const cfg = exportCurrentConfiguration();
        const canonicalJSON = stableStringify(cfg);            // ← archivo exacto para hash
        const hashHex = await sha256Hex(canonicalJSON);

        // 2) Imagen A2
        const pngBlob = await renderA2ImageBlob();
        const pngDataURL = await new Promise(res=>{
          const r = new FileReader();
          r.onload = ()=>res(r.result);
          r.readAsDataURL(pngBlob);
        });

        // 3) Certificado HTML auto‑contenible
        const now = new Date();
        const prettyJSON = JSON.stringify(cfg, null, 2);
        const TOTAL_BUILD = 120 * 11;                 // 1,320 (no se multiplica por el tamaño del conjunto de permutaciones)
        const fmt = n => n.toLocaleString('en-US').replace(/,/g,'\u202f'); // separador fino

        const certHTML =
`<!doctype html>
<meta charset="utf-8">
<title>PRMMTN · Edition Certificate</title>
<style>
  body{font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin:32px; color:#111;}
  h1{font-weight:600; margin:0 0 4px;}
  h2{margin:24px 0 8px;}
  .meta{font-size:12px; color:#555; margin-bottom:24px;}
  .box{border:1px solid #ccc; padding:12px; border-radius:8px; background:#fafafa;}
  img{max-width:100%; height:auto; display:block; margin:12px 0 4px;}
  code{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;}
  details{margin-top:8px;}
  .sig{margin-top:28px; display:flex; gap:48px;}
  .sig div{border-top:1px solid #000; padding-top:6px; width:260px; text-align:center;}
</style>
<h1>PRMMTN · Edition Certificate</h1>
<div class="meta">
  <div>Date: ${now.toISOString()}</div>
  <div>Chromatic pattern: ${activePatternId}</div>
  <div>sceneSeed: ${sceneSeed} · S_global: ${S_global}</div>
</div>

<h2>Image (A2)</h2>
<div class="box">
  <img src="${pngDataURL}" alt="PRMMTN A2 snapshot">
  <div style="font-size:12px;color:#444">Resolution: 7016×4961 px (A2 landscape)</div>
</div>

<h2>Integrity</h2>
<div class="box">
  <div>SHA‑256 (prmttn_config.json):</div>
  <div><code>${hashHex}</code></div>
  <details><summary>How to verify</summary>
    <pre>shasum -a 256 prmttn_config.json
# or
openssl dgst -sha256 prmttn_config.json</pre>
  </details>
</div>


<h2>Phenotypic scope</h2>
<div class="box">
  <ul>
    <li><b>BUILD:</b> 120 attribute-mappings × 11 chromatic-patterns = <b>${fmt(TOTAL_BUILD)}</b> deterministic visuals.</li>
  </ul>
  <p style="font-size:12px;color:#555;margin:8px 0 0;">
    Note: permutations are acquired as a <b>group</b>; the count does not multiply by the size of the group.
  </p>
</div>

<h2>Configuration (pretty view)</h2>
<div class="box">
  <details open><summary>Show JSON</summary>
    <pre>${prettyJSON.replace(/</g,"&lt;")}</pre>
  </details>
</div>

<div class="sig">
  <div>Edition signature</div>
</div>

<p style="margin-top:24px;color:#777;font-size:12px">This certificate is self‑contained (image + data). Work in progress.</p>`;
        // 4) Descargas (3 archivos + hash opcional)
        downloadBlob('PRMMTN_certificate.html', new Blob([certHTML], {type:'text/html'}));
        downloadBlob('PRMTTN_A2.png', pngBlob);
        downloadBlob('prmttn_config.json', new Blob([canonicalJSON], {type:'application/json'}));
        downloadBlob('prmttn_hash.txt', new Blob([`sha256  prmttn_config.json\n${hashHex}\n`], {type:'text/plain'}));

        showPopup("Certificado, imagen A2, JSON y hash descargados.", 3000);
      }catch(err){
        console.error(err);
        showPopup("Error generando certificado", 4000);
      }
    }

 

</script>

</body>
</html>
