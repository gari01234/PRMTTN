<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Visualizador 3D de Permutaciones - Manual, Evolutivo y Evolución AI</title>
  <style>
    /* ———————————————————————— Global & Body ———————————————————————— */
    body {
      margin: 0;
      overflow: hidden;
      background: #ffffff;
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      font-weight: 200;
      font-size: 12px;
      cursor: none;
    }
    #customCursor {
      position: fixed;
      width: 12px; height: 12px;
      border-radius: 50%;
      background: #000;
      border: 1px solid #fff;
      pointer-events: none; z-index: 300;
      transform: translate(-50%, -50%);
    }
    #topRightDisplay {
      position: fixed; top: 5px; right: 10px; z-index: 280;
      color: #000; font-size: 12px; line-height: 1.2;
    }
    /* ———————————————————————— Botones flotantes ———————————————————————— */
    button {
      cursor: none; border: none; border-radius: 4px;
      padding: 8px 12px; font-size: 12px; z-index: 250;
      background: rgba(255,255,255,0.8);
    }
    #toggleTextButton { bottom: 10px; right: 10px; position: fixed; }
    #randomConfigButton { bottom: 40px; right: 10px; position: fixed; }
    #evolutionAIButton  { bottom: 70px; right: 10px; position: fixed; }
    #saveImageButton    { bottom:100px; right: 10px; position: fixed; }
    #exportEmbedButton  { bottom:130px; right: 10px; position: fixed; }
    /* ———————————————————————— Controles laterales ———————————————————————— */
    #controls {
      position: absolute; top: 10px; left: 10px; z-index: 100;
      padding: 10px; border-radius: 5px;
      background: rgba(255,255,255,0.9); max-width: 350px;
    }
    details { margin-bottom: 10px; }
    details summary { font-weight: 200; cursor: pointer; }
    details summary:hover { color: #333; }
    select, input[type="range"], input[type="color"] { cursor: none; width: 100%; }
    #permutationList { width: 100%; height: 100px; }
    /* ———————————————————————— Rating ———————————————————————— */
    #ratingContainer {
      position: fixed; bottom:170px; right: 10px; z-index:260;
      font-size:12px;
    }
    #ratingLabels, #ratingDots { display:flex; justify-content:space-between; }
    .ratingBtn { font-size:20px; cursor:none; color:#000; }
    /* ———————————————————————— Tooltip Hover ———————————————————————— */
    #hoverPopup {
      position:absolute; padding:5px 10px;
      background:rgba(0,0,0,0.7); color:#fff;
      border-radius:4px; pointer-events:none;
      font-size:12px; display:none; opacity:0;
      transition:opacity .3s; z-index:200;
    }
  </style>
</head>
<body>
  <div id="customCursor"></div>
  <div id="topRightDisplay"></div>

  <button id="toggleTextButton" onclick="toggleTexts()">Ocultar Textos</button>
  <button id="randomConfigButton" onclick="generateRandomConfiguration()">Configuración Aleatoria</button>
  <button id="evolutionAIButton" onclick="applyEvolutionAI()">Evolución AI</button>
  <button id="saveImageButton" onclick="saveImage()">Guardar Imagen</button>
  <button id="exportEmbedButton" onclick="exportEmbed()">Guardar</button>

  <div id="ratingContainer">
    <details open>
      <summary>Calificar Configuración</summary>
      <div id="ratingControls">
        <div id="ratingLabels"><span>1</span><span>2</span><span>3</span><span>4</span><span>5</span></div>
        <div id="ratingDots">
          <span class="ratingBtn" data-rating="1">●</span>
          <span class="ratingBtn" data-rating="2">●</span>
          <span class="ratingBtn" data-rating="3">●</span>
          <span class="ratingBtn" data-rating="4">●</span>
          <span class="ratingBtn" data-rating="5">●</span>
        </div>
      </div>
    </details>
  </div>

  <div id="controls">
    <details open>
      <summary>Modo de Operación</summary>
      <label><input type="radio" name="mode" value="manual" checked onchange="setMode(this.value)"> Manual</label>
      <label><input type="radio" name="mode" value="evolution" onchange="setMode(this.value)"> Evolutivo</label>
    </details>
    <div id="manualControls">
      <details>
        <summary>Seleccionar Permutaciones</summary>
        <select id="permutationList" multiple></select>
        <button onclick="updateScene()">Visualizar Permutación</button>
      </details>
    </div>
    <div id="evolutionControls" style="display:none;">
      <details open>
        <summary>Parámetros Evolutivos</summary>
        <p>Tasa de Mutación: <input type="range" id="mutationRate" min="0" max="1" step="0.01" value="0.1"></p>
        <p>Umbral de Cambio: <input type="range" id="threshold" min="0" max="1" step="0.01" value="0.5"></p>
        <button onclick="applyEvolution()">Aplicar Evolución</button>
        <div id="evolutionInfo" style="margin-top:8px;font-size:12px;"></div>
      </details>
    </div>
    <details>
      <summary>Seleccionar Colores Permutaciones</summary>
      <div><label>1: <input type="color" id="color1" value="#ff0000"></label></div>
      <div><label>2: <input type="color" id="color2" value="#00ff00"></label></div>
      <div><label>3: <input type="color" id="color3" value="#0000ff"></label></div>
      <div><label>4: <input type="color" id="color4" value="#ff00ff"></label></div>
      <div><label>5: <input type="color" id="color5" value="#00ffff"></label></div>
      <button onclick="updateColorMapping()">Actualizar Colores</button>
    </details>
    <details>
      <summary>Seleccionar Fondo del Universo</summary>
      <input type="color" id="bgColor" value="#ffffff">
      <button onclick="updateBackground()">Actualizar Fondo</button>
    </details>
    <details>
      <summary>Seleccionar Color de Pared del Cubo</summary>
      <input type="color" id="cubeColor" value="#808080">
      <button onclick="updateCubeColor()">Actualizar Paredes</button>
    </details>
    <details>
      <summary>Reorganización de Atributos</summary>
      <select id="attrMapping"></select>
      <button onclick="updateMapping()">Aplicar Reorganización</button>
      <button onclick="autoResolveColisionesGlobal()">Resolver Colisiones</button>
    </details>
    <details>
      <summary>Vistas Estándar</summary>
      <select id="standardView">
        <option value="isometric">Isométrica</option>
        <option value="top">Superior</option>
        <option value="front">Frontal</option>
        <option value="side">Lateral</option>
        <option value="diagonal">Diagonal opuesta</option>
      </select>
      <button onclick="applyStandardView()">Aplicar Vista</button>
    </details>
    <details>
      <summary>Controles de Zoom</summary>
      <button onclick="zoomIn()">Zoom In</button>
      <button onclick="zoomOut()">Zoom Out</button>
    </details>
    <details>
      <summary>Controles de Movimiento</summary>
      <button onclick="togglePause()">Pausar Movimiento</button>
      <button onclick="resetMovement()">Resetear Movimiento</button>
    </details>
<details>
  <summary>⋆ NFT</summary>
  <button id="btn-mint" style="width:100%;margin-top:8px;">Mint NFT</button>
</details>
  
  </div>

  <div id="hoverPopup"></div>

  <!-- Three.js & OrbitControls -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <!-- Ethers.js -->
  <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>

  <script>
    // === LISTA DE 120 COLORES ===
    const CUSTOM_COLORS = [
      "#070709","#898052","#402523","#0d080a","#070909","#050608","#070509",
      "#12080d","#330a0d","#9c714f","#382e24","#883933","#decda0",
      "#fafcff","#a4b6bc","#e7e8e1","#f3f1ea","#eaebe2","#dcdacf","#f8f9f8",
      "#f6f5ea","#ffffff","#f3f3f0","#faf9f0","#f5f7f6","#eeece8","#fffef7",
      "#350b0c","#9e4031","#820707","#eeb049","#120607","#f6f1ed",
      "#300809","#8c2d18","#6a6620","#b99c5c","#110505","#5f2423",
      "#400909","#a04b37","#180506","#e1b055","#6f2919","#170607",
      "#000000","#9c822b","#3e1b2c","#edce83","#1b0408","#8a4667",
      "#000000","#ec9b1c","#701a25","#9c2c1a","#480b0b","#150407",
      "#2a0607","#b08b4f","#7a181d","#5d180f","#1f0908","#dfb46e",
      "#0b0304","#a4735a","#4e272a","#cab296","#923930","#1d0709",
      "#f4c061","#963326","#d89048","#430f0c","#ce5830","#72121a",
      "#fefffe","#c0b280","#57231d","#99541e","#210d0a","#8a5d2f",
      "#33090a","#e2a33f","#a24a2c","#591e14","#8f2e1c","#1e0809",
      "#bd4d1d","#441b1d","#0f0406","#e3a337","#886c39","#1a0807",
      "#fffcee","#cea564","#9a7859","#080103","#000003","#000100",
      "#000000","#6d4d2c","#2d060a","#000005","#000100","#2d0006",
      "#17120a","#451e18","#42401c","#7c4934","#8c7640","#c0b468"
    ];

    // === Variables globales ===
    let scene, camera, renderer, controls, raycaster, mouse;
    let cubeUniverse, permutationGroup;
    const cubeSize = 30, segment = cubeSize/5, halfCube = cubeSize/2;
    let isPaused = false, currentMode = "manual", userRating = null, textsVisible = true;
    let attributeMapping = { forma:0, color:1, x:2, y:3, z:4 };
    let colorMapping = { 1:"#ff0000",2:"#00ff00",3:"#0000ff",4:"#ff00ff",5:"#00ffff" };
    const minRangeValue = 2, maxRangeValue = 6;
    const shapeMapping = {
      1:{w:4.5,h:4.5},
      2:{w:4.5,h:4.5*Math.sqrt(2)},
      3:{w:4.5,h:4.5*Math.sqrt(3)},
      4:{w:4.5,h:4.5*Math.sqrt(4)},
      5:{w:4.5,h:4.5*Math.sqrt(5)}
    };

    // — Utilidades genéricas —
    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function mapRangeToSpeed(r,mn,mx){return 0.001 + (r-mn)*(0.005-0.001)/(mx-mn);}
    function shuffle(a){for(let i=a.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

    function getPermutations(arr){
      if(arr.length===1) return [arr];
      let res=[]; for(let i=0;i<arr.length;i++){
        const c=arr[i], rem=arr.slice(0,i).concat(arr.slice(i+1));
        for(const p of getPermutations(rem)) res.push([c].concat(p));
      }
      return res;
    }
    const allPermutations = getPermutations([1,2,3,4,5]);
    const permutationStrings = allPermutations.map(p=>p.join(','));

    function getAttributeMappings(a){
      if(a.length===1) return [a];
      let res=[]; for(let i=0;i<a.length;i++){
        const c=a[i], rem=a.slice(0,i).concat(a.slice(i+1));
        for(const m of getAttributeMappings(rem)) res.push([c].concat(m));
      }
      return res;
    }

    // — Poblado de selects —
    function populatePermutationList(){
      const sel = document.getElementById('permutationList');
      sel.innerHTML = '';
      permutationStrings.forEach((ps,i)=>{
        const o=document.createElement('option');
        o.value=ps; o.text=`Permutación ${i+1}: (${ps})`;
        if(i===0) o.selected=true;
        sel.appendChild(o);
      });
    }
    function populateAttributeMappingSelect(){
      const sel = document.getElementById('attrMapping');
      sel.innerHTML = '';
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        const s=m.join(','), o=document.createElement('option');
        o.value=s; o.text=`Opción: [${s}]`;
        if(s==='0,1,2,3,4') o.selected=true;
        sel.appendChild(o);
      });
      updateTopRightDisplay();
    }

    // — Display superior —
    function computeSignature(a){let s=[];for(let i=0;i<a.length;i++) s.push(a[i]+a[(i+1)%a.length]);return s;}
    function computeRange(sig){return Math.max(...sig)-Math.min(...sig);}
    function updateTopRightDisplay(){
      const cfg=`Atributos: [${attributeMapping.forma},${attributeMapping.color},${attributeMapping.x},${attributeMapping.y},${attributeMapping.z}]`;
      const rt =`Calificación: ${userRating?userRating:'Aún no calificada'}`;
      let info='';
      Array.from(document.getElementById('permutationList').selectedOptions).forEach(o=>{
        const pa=o.value.split(',').map(Number),
              sig=computeSignature(pa),
              rg=computeRange(sig);
        info+=`<div style="margin:2px 0;">Perm (${o.value}) | Firma [${sig.join(', ')}] | Rango ${rg}</div>`;
      });
      document.getElementById('topRightDisplay').innerHTML = cfg+'<br>'+rt+'<br>'+info;
    }

    // — Crear objetos 3D —
    function createPermutationObjectWithMapping(pa,map){
      const fv=pa[map.forma], cv=pa[map.color],
            px=pa[map.x], py=pa[map.y], pz=pa[map.z],
            d=shapeMapping[fv], w=d.w, h=d.h, t=0.5;
      const geo=new THREE.BoxGeometry(w,h,t),
            mat=new THREE.MeshPhongMaterial({ color:new THREE.Color(colorMapping[cv]), shininess:50}),
            mesh=new THREE.Mesh(geo,mat);
      const x=(px-1)*segment-halfCube+segment/2,
            y=(py-1)*segment-halfCube+segment/2,
            z=(pz-1)*segment-halfCube+segment/2;
      mesh.position.set(
        clamp(x,-halfCube+w/2,halfCube-w/2),
        clamp(y,-halfCube+h/2,halfCube-h/2),
        clamp(z,-halfCube+t/2,halfCube-t/2)
      );
      const sig=computeSignature(pa), rg=computeRange(sig);
      mesh.userData={permStr:pa.join(','), signature:sig, range:rg, rotationSpeed:mapRangeToSpeed(rg,minRangeValue,maxRangeValue)};
      return mesh;
    }
    function createPermutationObject(pa){ return createPermutationObjectWithMapping(pa,attributeMapping); }

    // — Colisiones —
    function checkCollisionsInGroup(g){
      for(let i=0;i<g.children.length;i++){
        const b1=new THREE.Box3().setFromObject(g.children[i]);
        for(let j=i+1;j<g.children.length;j++){
          const b2=new THREE.Box3().setFromObject(g.children[j]);
          if(b1.intersectsBox(b2)) return true;
        }
      }
      return false;
    }
    function autoResolveColisionesGlobal(){
      let found=null;
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        if(found) return;
        const cm={forma:m[0],color:m[1],x:m[2],y:m[3],z:m[4]},
              tg=new THREE.Group(),
              opts=Array.from(document.getElementById('permutationList').selectedOptions);
        opts.forEach((o,i)=>{
          const pa=o.value.split(',').map(Number),
                mo=createPermutationObjectWithMapping(pa,cm);
          if(opts.length>1){
            const ang=2*Math.PI*i/opts.length, rad=1.5;
            mo.position.x+=rad*Math.cos(ang);
            mo.position.y+=rad*Math.sin(ang);
            const ww=mo.geometry.parameters.width, hh=mo.geometry.parameters.height;
            mo.position.x=clamp(mo.position.x,-halfCube+ww/2,halfCube-ww/2);
            mo.position.y=clamp(mo.position.y,-halfCube+hh/2,halfCube-hh/2);
          }
          tg.add(mo);
        });
        if(!checkCollisionsInGroup(tg)) found=cm;
      });
      if(found){
        attributeMapping=found;
        document.getElementById('attrMapping').value=`${found.forma},${found.color},${found.x},${found.y},${found.z}`;
        updateScene(false); updateTopRightDisplay();
      } else {
        showPopup("No se encontró reorganización sin colisiones.",7000);
      }
    }

    // — Popup tooltip —
    function showPopup(msg,dur=2000){
      const p=document.getElementById('hoverPopup');
      p.style.display="block"; p.style.opacity=1;
      p.style.left=(window.innerWidth/2-150)+"px"; p.style.top="20px";
      p.innerHTML=msg;
      setTimeout(()=>{
        p.style.opacity=0;
        setTimeout(()=>{p.style.display="none";p.innerHTML="";},300);
      },dur);
    }

    // — Actualizar escena —
    function updateScene(attemptResolve=true){
      while(permutationGroup.children.length>0){
        const o=permutationGroup.children[0];
        permutationGroup.remove(o);
        o.geometry.dispose(); o.material.dispose();
      }
      const opts=Array.from(document.getElementById('permutationList').selectedOptions);
      opts.forEach((o,i)=>{
        const pa=o.value.split(',').map(Number),
              obj=createPermutationObject(pa);
        if(opts.length>1){
          const ang=2*Math.PI*i/opts.length, rad=1.5;
          obj.position.x+=rad*Math.cos(ang);
          obj.position.y+=rad*Math.sin(ang);
          const ww=obj.geometry.parameters.width, hh=obj.geometry.parameters.height;
          obj.position.x=clamp(obj.position.x,-halfCube+ww/2,halfCube-ww/2);
          obj.position.y=clamp(obj.position.y,-halfCube+hh/2,halfCube-hh/2);
        }
        permutationGroup.add(obj);
      });
      if(attemptResolve) autoResolveColisionesGlobal();
      else updateTopRightDisplay();
    }

    // — Raycast hover —
    function onMouseMove(e){
      mouse.x=(e.clientX/window.innerWidth)*2-1;
      mouse.y=-(e.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera(mouse,camera);
      const ints=raycaster.intersectObjects(permutationGroup.children),
            pop=document.getElementById('hoverPopup');
      if(ints.length>0){
        const d=ints[0].object.userData;
        pop.style.display="block"; pop.style.opacity=1;
        pop.style.left=`${e.clientX+20}px`;
        pop.style.top=`${e.clientY+20}px`;
        pop.innerHTML=`Perm (${d.permStr})<br>Firma [${d.signature.join(', ')}]<br>Rango ${d.range}`;
      } else {
        pop.style.opacity=0;
        setTimeout(()=>{pop.style.display="none";},300);
      }
    }

    // — Zoom & Movimiento —
    function zoomIn(){camera.position.z-=5;controls.update();}
    function zoomOut(){camera.position.z+=5;controls.update();}
    function togglePause(){
      isPaused=!isPaused;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent=isPaused?"Reanudar Movimiento":"Pausar Movimiento";
    }
    function resetMovement(){
      updateScene(false);
      isPaused=true;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent="Reanudar Movimiento";
    }

    // — Guardar imagen —
    function saveImage(){
      renderer.render(scene,camera);
      const url=renderer.domElement.toDataURL("image/png"),
            a=document.createElement("a");
      a.href=url; a.download="configuracion.png";
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
    }

    // — Actualizar colores manual —
    function updateColorMapping(){
      for(let i=1;i<=5;i++){
        colorMapping[i]=document.getElementById('color'+i).value;
      }
      updateScene(false);
    }
    function updateBackground(){
      const c=document.getElementById('bgColor').value;
      scene.background=new THREE.Color(c);
      const lum=(parseInt(c.slice(1,3),16)*299+parseInt(c.slice(3,5),16)*587+parseInt(c.slice(5,7),16)*114)/1000;
      document.getElementById('hoverPopup').style.color=lum<128?"#fff":"#000";
    }
    function updateCubeColor(){
      const c=document.getElementById('cubeColor').value;
      cubeUniverse.material.color=new THREE.Color(c);
      document.querySelectorAll("details summary").forEach(s=>s.style.color=c);
      document.getElementById('toggleTextButton').style.color=c;
    }

    // — Mostrar/Ocultar textos UI —
    function toggleTexts(){
      const elems=[
        'controls','topRightDisplay','ratingContainer',
        'randomConfigButton','evolutionAIButton','saveImageButton','exportEmbedButton'
      ].map(id=>document.getElementById(id));
      elems.forEach(e=>e.style.display=textsVisible?"none":"block");
      document.getElementById('toggleTextButton').textContent=
        textsVisible?"Mostrar Textos":"Ocultar Textos";
      textsVisible=!textsVisible;
    }

    // — Manual/Evolutivo mode —
    function setMode(m){
      currentMode=m;
      document.getElementById('manualControls').style.display=
        m==="manual"?"block":"none";
      document.getElementById('evolutionControls').style.display=
        m==="evolution"?"block":"none";
      updateScene(false);
    }

    // — Generación Aleatoria —
    function generateRandomConfiguration(){
      const sel=document.getElementById('permutationList');
      Array.from(sel.options).forEach(o=>o.selected=false);
      const n=Math.floor(Math.random()*5)+1;
      for(let i=0;i<n;i++){
        const val=permutationStrings[Math.floor(Math.random()*permutationStrings.length)];
        sel.querySelector(`option[value="${val}"]`).selected=true;
      }
      const bg=CUSTOM_COLORS[Math.floor(Math.random()*CUSTOM_COLORS.length)],
            wall=CUSTOM_COLORS[Math.floor(Math.random()*CUSTOM_COLORS.length)];
      document.getElementById('bgColor').value=bg; updateBackground();
      document.getElementById('cubeColor').value=wall; updateCubeColor();
      let pool=shuffle(CUSTOM_COLORS.slice());
      for(let i=1;i<=5;i++){
        const hex=pool.shift();
        colorMapping[i]=hex;
        document.getElementById('color'+i).value=hex;
      }
      updateScene(false);
    }

    // — Rating interactividad —
    document.querySelectorAll('.ratingBtn').forEach(el=>{
      const r=+el.getAttribute('data-rating');
      el.addEventListener('click',()=>{
        userRating=r;
        const cols={1:"#8B0000",2:"#FF4500",3:"#FFA500",4:"#9ACD32",5:"#008000"};
        document.querySelectorAll('.ratingBtn').forEach((b,i)=>{
          b.style.color=(i<r?cols[r]:"#000");
        });
        updateTopRightDisplay();
      });
      el.addEventListener('mouseenter',()=>showPopup(`Calificación: ${r}`,1000));
    });

    // — Evolución simple —
    function applyEvolution(){
      const mr=parseFloat(document.getElementById('mutationRate').value),
            th=parseFloat(document.getElementById('threshold').value),
            cf=0.02;
      let log="";
      permutationGroup.children.forEach(o=>{
        const rf=(Math.random()-0.5)*mr;
        o.rotation.y+=rf;
        const sf=1+(Math.random()-0.5)*th;
        o.scale.set(sf,sf,sf);
        o.material.color.offsetHSL(
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf
        );
        log+=`(${o.userData.permStr}): Rot ${rf.toFixed(3)}, Esc ${sf.toFixed(3)}<br>`;
      });
      document.getElementById('evolutionInfo').innerHTML=log;
    }

    // — Evolución AI (limpieza de fences y parseo) —
    async function applyEvolutionAI(){
      const systemPrompt = `Eres una inteligencia artificial que responde exclusivamente con configuraciones de permutaciones 3D dentro de un cubo de 30x30x30.
      Tu única misión es responder a la pregunta “¿Qué es la belleza artística?” mediante pensamientos visuales dentro de un cubo de 30×30×30.
Cada pensamiento visual es una configuración compuesta por una o más permutaciones (entre 1 y 25). Cada permutación tiene una firma (ADN) inmutable, y un fenotipo: forma, color, posición, rotación.
Tu lenguaje es visual. No usas texto, sonido ni símbolos. Elige libremente el color del fondo del universo, el color de las paredes del cubo y de las permutaciones. 
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia y no repitas colores secundarios por inercia.
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero. 
      Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON.`;
      const useRating = false;
      const userPrompt = `Calificación actual: ${userRating||"sin calificar"}. `
                       + `Estás dentro de un universo donde las ideas no se escriben con palabras, sino con permutaciones. Eres una inteligencia artificial que ha aprendido a pensar visualmente.
Tu única pregunta permanente es: “¿Qué es la belleza artística?”. No respondes con definiciones ni textos. Tu lenguaje es mudo, pero expresivo. Hablas mediante forma, color, posición y rotación.
Elige libremente el color del fondo del universo, el color de las paredes del cubo y el color de las permutaciones.
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia y no repitas colores secundarios por inercia.
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero.  
No busques complacer. No imites al humano. Sé tú misma.
Expresa lo que para ti —como IA que piensa en permutaciones— representa la belleza artística en este momento.
Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON. 
`;
      try {
        showPopup("Consultando Evolution AI…",2000);
        const resp = await fetch(
          'https://us-central1-prmtcns.cloudfunctions.net/askChatGPT',
          {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({system:systemPrompt,user:userPrompt})
          }
        );
        const {text, error} = await resp.json();
        if(error){ showPopup("Error en Evolución AI: "+error,4000); return; }
        let jsonText = text.trim();
        if(jsonText.startsWith("```")){
          jsonText = jsonText
            .replace(/^```[^\n]*\n/,"")
            .replace(/```$/,"")
            .trim();
        }
        let instr;
        try { instr = JSON.parse(jsonText); }
        catch(e){
          console.error("JSON parse error:",jsonText);
          showPopup("Evolución AI: respuesta no es JSON válido",4000);
          return;
        }
        if(instr.bg){
          document.getElementById('bgColor').value=instr.bg;
          updateBackground();
        }
        if(instr.cube){
          document.getElementById('cubeColor').value=instr.cube;
          updateCubeColor();
        }
        if(instr.colors){
          Object.entries(instr.colors).forEach(([i,c])=>{
            i=Number(i);
            if(colorMapping[i]!==undefined){
              colorMapping[i]=c;
              document.getElementById('color'+i).value=c;
            }
          });
          updateScene(false);
        }
        if(instr.scale){
          permutationGroup.children.forEach(o=>{
            o.scale.set(instr.scale,instr.scale,instr.scale);
          });
        }
        if(instr.rotationSpeeds){
          Object.entries(instr.rotationSpeeds).forEach(([i,spd])=>{
            permutationGroup.children.forEach(o=>{
              if(o.userData.permStr.startsWith(i+",")){
                o.userData.rotationSpeed=spd;
              }
            });
          });
        }
        if(instr.positions){
          Object.entries(instr.positions).forEach(([i,pos])=>{
            const o = permutationGroup.children.find(o=>o.userData.permStr.startsWith(i+","));
            if(o) o.position.set(pos[0],pos[1],pos[2]);
          });
        }
        if(instr.permCount){
          const opts=Array.from(document.getElementById('permutationList').options);
          opts.forEach(o=>o.selected=false);
          shuffle(opts).slice(0,instr.permCount).forEach(o=>o.selected=true);
          updateScene(false);
        }
        showPopup("Evolución AI aplicada.",2000);
      } catch(err){
        console.error(err);
        showPopup("Error en Evolución AI: red o servidor",4000);
      }
    }

    // — Aplicar mapping manual —
    function updateMapping(){
      const v=document.getElementById('attrMapping').value.split(',').map(Number);
      if(v.length===5){
        attributeMapping={forma:v[0],color:v[1],x:v[2],y:v[3],z:v[4]};
        updateScene(false); updateTopRightDisplay();
      }
    }

    // — Vistas estándar —
    function applyStandardView(){
      const view=document.getElementById('standardView').value,
            pos=new THREE.Vector3();
      switch(view){
        case "isometric": pos.set(50,50,50); break;
        case "top":       pos.set(0,80,0);   break;
        case "front":     pos.set(0,0,50);   break;
        case "side":      pos.set(50,0,0);   break;
        case "diagonal":  pos.set(-50,50,-50);break;
        default:          pos.set(0,0,50);
      }
      camera.position.copy(pos);
      camera.lookAt(new THREE.Vector3(0,0,0));
      controls.update();
    }

    // — Embed params (URL) —
    function applyEmbedParams(){
      const p=new URLSearchParams(window.location.search);
      if(p.has('perms')){
        const arr=p.get('perms').split(';');
        document.querySelectorAll('#permutationList option').forEach(o=>{
          o.selected=arr.includes(o.value);
        });
      }
      if(p.has('mapping')){
        const m=p.get('mapping').split(',').map(Number);
        attributeMapping={forma:m[0],color:m[1],x:m[2],y:m[3],z:m[4]};
      }
      if(p.has('colors')){
        const cols=p.get('colors').split(',');
        cols.forEach((hex,i)=>{
          if(i<5){
            const h='#'+hex;
            colorMapping[i+1]=h;
            document.getElementById('color'+(i+1)).value=h;
          }
        });
      }
      if(p.has('bg')){
        const bg='#'+p.get('bg');
        document.getElementById('bgColor').value=bg; updateBackground();
      }
      if(p.has('cube')){
        const c='#'+p.get('cube');
        document.getElementById('cubeColor').value=c; updateCubeColor();
      }
      if(p.has('view')){
        document.getElementById('standardView').value=p.get('view');
        applyStandardView();
      }
      if(p.get('hide')==='1') toggleTexts();
    }

    // — Export embed —
    function exportEmbed(){
      const perms = Array.from(document.getElementById('permutationList').selectedOptions).map(o=>o.value);
      const mapping = {
        forma: attributeMapping.forma,
        color: attributeMapping.color,
        x: attributeMapping.x,
        y: attributeMapping.y,
        z: attributeMapping.z
      };
      const colors = {};
      for(let i=1;i<=5;i++){
        colors[i] = document.getElementById('color'+i).value;
      }
      const bg = document.getElementById('bgColor').value;
      const cube = document.getElementById('cubeColor').value;
      const view = document.getElementById('standardView').value;

      const config = {
        perms,
        mapping,
        colors,
        bg,
        cube,
        view
      };

      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'configuracion.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // — Inicialización Three.js & UI —
    function initCustomCursor(){
      const c=document.getElementById('customCursor');
      window.addEventListener('mousemove',e=>{
        c.style.left=e.clientX+"px"; c.style.top=e.clientY+"px";
      });
    }
    function initRenderer(){
      renderer=new THREE.WebGLRenderer({antialias:true});
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth,window.innerHeight);
      document.body.appendChild(renderer.domElement);
    }
    function init(){
      scene=new THREE.Scene();
      scene.background=new THREE.Color(0xffffff);
      camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      camera.position.set(0,0,50);
      initRenderer();
      controls=new THREE.OrbitControls(camera,renderer.domElement);
      controls.enableDamping=true; controls.dampingFactor=0.1; controls.enableZoom=true;
      scene.add(new THREE.AmbientLight(0xffffff,0.8));
      const dir=new THREE.DirectionalLight(0xffffff,0.5);
      dir.position.set(1,1,1);
      scene.add(dir);

      const cubeGeo=new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize),
            cubeMat=new THREE.MeshBasicMaterial({color:0x808080,transparent:true,opacity:0.2,side:THREE.BackSide});
      cubeUniverse=new THREE.Mesh(cubeGeo,cubeMat);
      scene.add(cubeUniverse);

      permutationGroup=new THREE.Group();
      scene.add(permutationGroup);

      raycaster=new THREE.Raycaster();
      mouse=new THREE.Vector2();
      window.addEventListener('mousemove',onMouseMove,false);
      window.addEventListener('resize',onWindowResize,false);

      initCustomCursor();
      populatePermutationList();
      populateAttributeMappingSelect();
      applyEmbedParams();
      setMode("manual");
      updateScene(false);
      animate();
    }
    function onWindowResize(){
      camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }
    function animate(){
      requestAnimationFrame(animate);
      if(!isPaused){
        permutationGroup.children.forEach(o=>{
          if(o.userData.rotationSpeed) o.rotation.y+=o.userData.rotationSpeed;
        });
      }
      controls.update();
      renderer.render(scene,camera);
    }
    init();
  </script>
  <script>
    // --- Web3 Initialization ---
    const CONTRACT_ADDRESS = "YOUR_CONTRACT_ADDRESS";
    const contractABI = [/* ABI JSON here */];
    let provider, signer, contract;
    async function initWeb3() {
      if (window.ethereum) {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        contract = new ethers.Contract(CONTRACT_ADDRESS, contractABI, signer);
      } else {
        console.warn("MetaMask no detectado");
      }
    }
    window.addEventListener("load", initWeb3);

    // --- Mint NFT Function ---
    async function mintNFT() {
      if (!contract) { alert("Wallet no conectada"); return; }
      try {
        const hash = await computeConfigHash();
        const tokenURI = `https://my-server.com/metadata/${hash}.json`;
        const tx = await contract.mint(await signer.getAddress(), tokenURI);
        await tx.wait();
        alert("NFT acuñado! Hash: " + hash);
      } catch(e) {
        console.error(e);
        alert("Error mint NFT: " + e.message);
      }
    }
</script>
<script>
// Cifrado AES-GCM usando WebCrypto API
async function encryptBlob(blob) {
  const key = await crypto.subtle.generateKey(
    { name: "AES-GCM", length: 256 },
    true,
    ["encrypt", "decrypt"]
  );
  const iv = crypto.getRandomValues(new Uint8Array(12)); // Initialization vector
  const data = new Uint8Array(await blob.arrayBuffer());

  const encrypted = await crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    key,
    data
  );

  // Exportamos la clave para guardarla o mostrarla después (por ahora sólo en consola)
  const exportedKey = await crypto.subtle.exportKey("jwk", key);
  console.log("🔐 Clave secreta (guárdala para descifrar):", exportedKey);
  console.log("🔑 IV usado:", Array.from(iv));

  const combined = new Uint8Array(iv.byteLength + encrypted.byteLength);
  combined.set(iv, 0);
  combined.set(new Uint8Array(encrypted), iv.byteLength);

  return new Blob([combined], { type: blob.type });
}

window.uploadToBundlr = async function(blob) {
  if (!window.bundlr) {
    console.error("Bundlr no está listo aún.");
    return;
  }

  try {
    const encryptedBlob = await encryptBlob(blob);
    const tx = await window.bundlr.upload(encryptedBlob, {
      tags: [{ name: "Content-Type", value: blob.type }]
    });
    console.log("✅ Subida exitosa. CID:", tx.id);
    return tx.id;
  } catch (err) {
    console.error("Error subiendo archivo cifrado:", err);
  }
};
</script>
  import { WebBundlr } from "https://esm.sh/web-bundlr@0.1.1";

  window.addEventListener("load", async () => {
    try {
      const bundlr = new WebBundlr("https://node1.bundlr.network", "matic", window.ethereum);
      await bundlr.ready();
      const balance = await bundlr.getLoadedBalance();
      console.log("Bundlr listo, balance:", balance.toString());
      window.bundlr = bundlr;
    } catch (err) {
      console.error("Error inicializando Bundlr:", err);
    }
  });

  window.uploadToBundlr = async function(blob) {
    if (!window.bundlr) {
      console.error("Bundlr no está listo aún.");
      return;
    }
    const tx = await window.bundlr.upload(blob, {
      tags: [{ name: "Content-Type", value: blob.type }]
    });
    return tx.id;
  };
</script>
