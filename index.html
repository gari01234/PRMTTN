<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>PRMTTN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="module" src="https://esm.sh/web-bundlr@0.1.1"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Three .js + OrbitControls (una sola vez) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <style>
  body {
    margin: 0;
    overflow: hidden;
    background: #ffffff;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-weight: 200;
    font-size: 12px;
    cursor: none;
  }
  #customCursor {
    position: fixed;
    width: 12px; height: 12px;
    border-radius: 50%;
    background: #000;
    border: 1px solid #fff;
    pointer-events: none; z-index: 300;
    transform: translate(-50%, -50%);
  }
  /* HUD eliminado */
  #topRightDisplay{
    display:none !important;
  }
  button{
    cursor:none;
    border:none;
    border-radius:4px;
    padding:8px 12px;
    font-size:12px;
    z-index:250;
    background:rgba(255,255,255,0.12);
    transition:background 0.2s;
  }
  button:hover{
    background:rgba(255,255,255,0.20);
  }

  /* === LAYOUT (orden y ESPACIADO nuevos) === */
  #toggleTextButton     { position:fixed; right:10px; bottom:10px;   }   /* Minimal UI */
  #aiPlanningButton     { position:fixed; right:10px; bottom:50px;   }   /* AI Planning */
  #saveImageButton      { position:fixed; right:10px; bottom:90px;  }   /* Save Image (A2) â€“ debajo de Load JSON */
  #uploadConfigButton   { position:fixed; right:10px; bottom:130px;  }   /* Load JSON */
  #exportEmbedButton    { position:fixed; right:10px; bottom:170px;  }   /* Save JSON */
  #archDescButton       { position:fixed; right:10px; bottom:210px;  }   /* Architectural Description */
  #perm120Button        { position:fixed; right:10px; bottom:250px;  }   /* 120 Architectural Permutations */
#randomConfigButton   { position:fixed; left:10px; bottom:130px;  }   /* BUILD  */
   #certButton           { position:fixed; right:10px; bottom:30px; }   /* Edition Certificate */
  /* === FRBN toggle === */
#frbnWrap { position:fixed; left:10px; bottom:90px; z-index:260; }
#frbnButton { position:relative; }  /* dentro del wrap */
#frbnInfoButton{
  position:absolute; top:-6px; right:-6px;
  padding:2px 6px; font-size:10px; opacity:.9;
  background:rgba(255,255,255,0.2);
}

  #saveImageButton { background:rgba(255,255,255,0.2); }

  /* Ocultar los no usados */
  #btnDebugColors,
  #triadicConfigButton{
    display:none !important;
  }

  #controls {
    position: absolute; top: 10px; left: 10px; z-index: 100;
    padding: 10px; border-radius: 5px;
    background: rgba(255,255,255,0.12); max-width: 350px;
  }
  details {
    margin-bottom: 10px;
    background: rgba(255,255,255,0.06);
  }
  details summary { font-weight: 200; cursor: pointer; }
  details summary:hover { color: #333; }
  select, input[type="range"], input[type="color"] { cursor: none; width: 100%; }
  #permutationList { width: 100%; height: 100px; }

  /* rating oculto */
  #ratingContainer{
    display:none !important;
  }

  #hoverPopup {
    position:absolute; padding:5px 10px;
    background:rgba(0,0,0,0.7); color:#fff;
    border-radius:4px; pointer-events:none;
    font-size:12px; display:none; opacity:0;
    transition:opacity .3s; z-index:200;
  }

  #modeBlock,
  #nftBlock,
  #secretBlock{
    display:none;
  }

  /* Panel BUILD */
  #archPanel{
    position:fixed; z-index:1000; top:5%; left:50%;
    transform:translateX(-50%);
    width:85%; height:90%;
    background:#fff; color:#000;
    border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
    padding:24px 32px 48px; overflow:auto;
    font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size:14px; line-height:1.4;
    cursor:auto;
  }
  #archPanel *{ cursor:auto !important; }
  #archClose{
    position:fixed; right:calc(7.5% + 16px); top:5%;
    border:none; padding:6px 10px; border-radius:4px;
    background:#eee; cursor:pointer; z-index:1001;
  }
  #archPanel h2{ margin-top:0; }
  #archPanel .formula{
    margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
  }
  #archPanel .box{
    display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
    font-family:monospace;
  }
  #archPanel section{ margin-bottom:18px; }
  #archPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
  #archPanel .perm h4{ margin-bottom:6px; }
  code, pre{ font-family:monospace; }

  /* Panel 120 perms */
  #perm120Panel{
    position:fixed; right:10px; bottom:340px; z-index:260;
    background:rgba(255,255,255,0.12);
    padding:8px 10px; border-radius:4px; width:260px;
    display:none; /* â† cerrado por defecto */
  }
  #perm120Panel label{ display:block; margin-bottom:6px; }
  #perm120Panel input, #perm120Panel button{ width:100%; margin-top:4px; }
  #perm120Status{
    margin-top:8px;
    font-size:12px;       /* â† mismo tamaÃ±o que los demÃ¡s */
    font-weight:normal;
    text-align:center;
  }
  /* === Information button & panel === */
  #infoButton{
    position:fixed; left:10px; bottom:10px; z-index:260;
  }
  #infoPanel{
    position:fixed; z-index:1000; top:5%; left:50%;
    transform:translateX(-50%);
    width:85%; height:90%;
    background:#fff; color:#000;
    border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
    padding:24px 32px 48px; overflow:auto;
    font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size:14px; line-height:1.45;
    cursor:auto;
  }
  #infoPanel *{ cursor:auto !important; }
  #infoClose{
    position:fixed; right:calc(7.5% + 16px); top:5%;
    border:none; padding:6px 10px; border-radius:4px;
    background:#eee; cursor:pointer; z-index:1001;
  }
  #infoPanel h2{ margin-top:0; }
  #infoPanel .formula{
    margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
  }
  #infoPanel .box{
    display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
    font-family:monospace;
  }
  #infoPanel section{ margin-bottom:18px; }
  #infoPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
  /* === LCHT toggle === */
  #lchtWrap  { position:fixed; left:10px; bottom:50px; z-index:260; }
  #lchtButton{ position:relative; }
  </style>
</head>
<body>
  <div id="customCursor"></div>
  <div id="topRightDisplay"></div>

  <input type="file" id="json-upload" accept=".json" style="display:none;" />

  <button id="aiPlanningButton"   onclick="applyEvolutionAI()">AI Planning</button>
  <button id="toggleTextButton"   onclick="toggleTexts()">Minimal UI</button>
  <button id="uploadConfigButton" onclick="document.getElementById('json-upload').click()">Load JSON</button>
  <button id="saveImageButton"    onclick="saveImage()">Save Image (A2)</button>
  <button id="exportEmbedButton"  onclick="exportEmbed()">Save JSON</button>
  <button id="archDescButton"     onclick="showArchitecturalDescription()">Architectural Description</button>
  <button id="randomConfigButton" onclick="generateRandomConfigurationNoCollision()">BUILD</button>
  <button id="perm120Button"      onclick="togglePerm120Panel()">120 Architectural Permutations</button>
<div id="frbnWrap">
  <button id="frbnButton" onclick="toggleFRBN()">FRBN</button>
  <button id="frbnInfoButton" onclick="showFRBNInfo()" title="Information">i</button>
</div>
  <button id="certButton" onclick="exportEditionCertificate()">Edition Certificate</button>
  <div id="lchtWrap">
    <button id="lchtButton" onclick="toggleLCHT()">LCHT</button>
  </div>
  <button id="infoButton"       onclick="showInformation()">Information</button>
  <button id="btnDebugColors"
          style="position:fixed;bottom:180px;right:10px;z-index:260;display:none;"
          onclick="mostrarDebugColores()">
    Debug Colors
  </button>

  <!-- Panel controles 120 perms -->
  <div id="perm120Panel">
    <label>Autoâ€‘advance (1s â†’ 12m)</label>
    <input type="range" id="perm120Slider" min="1000" max="720000" step="1000" value="5000"
           oninput="syncPerm120InputsFromSlider()">
    <input type="number" id="perm120Seconds" min="1" max="720" value="5"
           oninput="syncPerm120SliderFromSeconds()">
    <small>(seconds)</small>
    <button onclick="playPerm120()">Play</button>
    <button onclick="pausePerm120()">Pause</button>
    <button onclick="prevPerm120()">Prev</button>
    <button onclick="nextPerm120()">Next</button>
    <button onclick="showPerm120Info()">Information</button>
    <div id="perm120Status">Permutation: 0 / 119</div>
  </div>

  <div id="ratingContainer">
    <details open>
      <summary>Calificar ConfiguraciÃ³n</summary>
      <div id="ratingControls">
        <div id="ratingLabels"><span>1</span><span>2</span><span>3</span><span>4</span><span>5</span></div>
        <div id="ratingDots">
          <span class="ratingBtn" data-rating="1">â—</span>
          <span class="ratingBtn" data-rating="2">â—</span>
          <span class="ratingBtn" data-rating="3">â—</span>
          <span class="ratingBtn" data-rating="4">â—</span>
          <span class="ratingBtn" data-rating="5">â—</span>
        </div>
      </div>
    </details>
  </div>

  <div id="controls">
  <details open>
    <summary>Chromatic Pattern</summary>
          <select id="patternSelect" onchange="setActivePattern(this.value)">
        <option value="1">1 Â· Chromatic Containment</option>
        <option value="2">2 Â· Contrast &amp; Dissonance</option>
        <option value="3">3 Â· Nonâ€‘semantic Disposition</option>
        <option value="4">4 Â· Structured Ambiguity</option>
        <option value="5">5 Â· Chromatic Isotropy</option>
        <option value="6">6 Â· Selfâ€‘Sufficient Presence</option>
        <option value="7">7 Â· Associative Asymmetry</option>
        <option value="8">8 Â· Irregular Dynamics</option>
        <option value="9">9 Â· Habitable without Translation</option>
        <option value="10">10 Â· Resonance</option>
        <option value="11">11 Â· Active Transparency</option>
      </select>
      <button id="patternInfoButton"
              style="margin-top:6px;width:100%;"
              onclick="showPatternInfo()">
        Pattern Information
      </button>

  </details>

  <div id="manualControls">
    <details>
      <summary>Select Permutations</summary>
      <select id="permutationList" multiple></select>
      <button onclick="refreshAll({rebuild:true})">Render</button>
    </details>
  </div>

  <div id="evolutionControls" style="display:none;">
    <details open>
      <summary>Evolution Parameters</summary>
      <p>Mutation Rate: <input type="range" id="mutationRate" min="0" max="1" step="0.01" value="0.1"></p>
      <p>Change Threshold: <input type="range" id="threshold" min="0" max="1" step="0.01" value="0.5"></p>
      <button onclick="applyEvolution()">Apply Evolution</button>
      <div id="evolutionInfo" style="margin-top:8px;font-size:12px;"></div>
    </details>
  </div>

  <details>
    <summary>Manual Colors (override)</summary>
    <div><label>1: <input type="color" id="color1" onchange="onColourPick(1,this.value)"></label></div>
    <div><label>2: <input type="color" id="color2" onchange="onColourPick(2,this.value)"></label></div>
    <div><label>3: <input type="color" id="color3" onchange="onColourPick(3,this.value)"></label></div>
    <div><label>4: <input type="color" id="color4" onchange="onColourPick(4,this.value)"></label></div>
    <div><label>5: <input type="color" id="color5" onchange="onColourPick(5,this.value)"></label></div>
    <button id="btnResetAll" style="margin-top:6px;" onclick="resetAllColours()">
      Reset Background + Walls + Colors
    </button>
  </details>

  <details>
    <summary>Background</summary>
    <input type="color" id="bgColor" value="#ffffff">
    <button onclick="updateBackground()">Apply Background</button>
  </details>

  <details>
    <summary>Cube Walls Color</summary>
    <input type="color" id="cubeColor" value="#808080">
    <button onclick="updateCubeColor()">Apply Cube Walls</button>
  </details>

  <details>
    <summary>Attributes Reorganization</summary>
    <select id="attrMapping"></select>
    <button onclick="updateMapping()">Apply</button>
    <button onclick="autoResolveColisionesGlobal()">Resolve Collisions</button>
  </details>

  <details>
    <summary>Standard Views</summary>
    <select id="standardView">
      <option value="isometric">Isometric</option>
      <option value="top">Top</option>
      <option value="front" selected>Front</option>
      <option value="side">Side</option>
      <option value="diagonal">Opposite diagonal</option>
    </select>
    <button onclick="applyStandardView()">Apply View</button>
  </details>

  <details>
    <summary>Zoom Controls</summary>
    <button onclick="zoomIn()">Zoom In</button>
    <button onclick="zoomOut()">Zoom Out</button>
  </details>

  <details>
    <summary>Motion Controls</summary>
    <button onclick="togglePause()">Pause Motion</button>
    <button onclick="resetMovement()">Reset Motion</button>
  </details>
</div>

<details id="nftBlock">
  <summary>â‹† NFT</summary>
  <button id="btn-mint" style="width:100%;margin-top:8px;">Mint NFT</button>
</details>

<script>
document.getElementById('json-upload').addEventListener('change', function(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const config = JSON.parse(e.target.result);

      // Permutations
      if (config.perms && Array.isArray(config.perms)) {
        const sel = document.getElementById('permutationList');
        Array.from(sel.options).forEach(o => o.selected = config.perms.includes(o.value));
      }

      // Mapping
      if (config.mapping) {
        const v = [config.mapping.forma, config.mapping.color, config.mapping.x, config.mapping.y, config.mapping.z];
        document.getElementById('attrMapping').value = v.join(',');
        attributeMapping = [v[0], v[1], v[2], v[3], v[4], attributeMapping[5], attributeMapping[6]];
      }

      // Pattern
      if (typeof config.pattern === 'number') {
        activePatternId = config.pattern;
        const selPattern = document.getElementById('patternSelect');
        if (selPattern) selPattern.value = String(config.pattern);
      }

      // Manual colors
      if (config.colors) {
        manualOverride = {};
        Object.entries(config.colors).forEach(([i, c]) => {
          manualOverride[Number(i)] = c;
        });
      }

      // BG / cube
      if (config.bg) {
        document.getElementById('bgColor').value = config.bg;
        bgOverride = config.bg;
      }
      if (config.cube) {
        document.getElementById('cubeColor').value = config.cube;
        cubeOverride = config.cube;
      }

      // Scene invariants (optional)
      if (typeof config.sceneSeed === 'number') {
        sceneSeed = config.sceneSeed;
      }
      if (typeof config.S_global === 'number') {
        S_global = config.S_global;
      }

      // View
      const view = config.view || "front";
      document.getElementById('standardView').value = view;

      // Rebuild
      refreshAll({rebuild:true, keepManual:true});
      applyStandardView();

      alert('JSON loaded successfully');
    } catch (err) {
      alert('Error loading JSON: ' + err.message);
    }
  };
  reader.readAsText(file);
});
</script>

<details id="secretBlock" open>
  <summary>ğŸ“ AÃ±adir Archivo Secreto</summary>
  <div id="dropzone" style="padding:10px;border:2px dashed #ccc;background:#f9f9f9;margin-top:10px;text-align:center;cursor:pointer;transition:border-color 0.2s;">
    <p>Arrastra aquÃ­ tu archivo secreto o haz clic para seleccionar</p>
    <input type="file" id="fileInput" style="display:none" />
    <p id="uploadStatus"></p>
    <p id="jwkOutput" style="word-break:break-all;font-size:11px;"></p>
    <p id="cidOutput" style="word-break:break-all;font-size:11px;"></p>
  </div>
</details>

  <div id="hoverPopup"></div>

  <!-- (eliminados: copias duplicadas de Three, OrbitControls y Ethers) -->
  <!-- Bundlr -->
  <script type="module">
    import { WebBundlr } from "https://esm.sh/web-bundlr@0.1.1";
    window.addEventListener("load", async () => {
      try {
        const bundlr = new WebBundlr("https://node1.bundlr.network", "matic", window.ethereum);
        await bundlr.ready();
        const balance = await bundlr.getLoadedBalance();
        console.log("Bundlr listo, balance:", balance.toString());
        window.bundlr = bundlr;
      } catch (err) {
        console.error("Error inicializando Bundlr:", err);
      }
    });
  </script>
  <script>
    // ------------- TODO EL JS ORIGINAL (Â¡NO QUITES NADA DE AQUÃ!) -------------
    // === LISTA DE 120 COLORES ===
    const CUSTOM_COLORS = [
      "#070709","#898052","#402523","#0d080a","#070909","#050608","#070509",
      "#12080d","#330a0d","#9c714f","#382e24","#883933","#decda0",
      "#fafcff","#a4b6bc","#e7e8e1","#f3f1ea","#eaebe2","#dcdacf","#f8f9f8",
      "#f6f5ea","#ffffff","#f3f3f0","#faf9f0","#f5f7f6","#eeece8","#fffef7",
      "#350b0c","#9e4031","#820707","#eeb049","#120607","#f6f1ed",
      "#300809","#8c2d18","#6a6620","#b99c5c","#110505","#5f2423",
      "#400909","#a04b37","#180506","#e1b055","#6f2919","#170607",
      "#000000","#9c822b","#3e1b2c","#edce83","#1b0408","#8a4667",
      "#000000","#ec9b1c","#701a25","#9c2c1a","#480b0b","#150407",
      "#2a0607","#b08b4f","#7a181d","#5d180f","#1f0908","#dfb46e",
      "#0b0304","#a4735a","#4e272a","#cab296","#923930","#1d0709",
      "#f4c061","#963326","#d89048","#430f0c","#ce5830","#72121a",
      "#fefffe","#c0b280","#57231d","#99541e","#210d0a","#8a5d2f",
      "#33090a","#e2a33f","#a24a2c","#591e14","#8f2e1c","#1e0809",
      "#bd4d1d","#441b1d","#0f0406","#e3a337","#886c39","#1a0807",
      "#fffcee","#cea564","#9a7859","#080103","#000003","#000100",
      "#000000","#6d4d2c","#2d060a","#000005","#000100","#2d0006",
      "#17120a","#451e18","#42401c","#7c4934","#8c7640","#c0b468"
    ];

    // === Variables globales ===
    let scene, camera, renderer, controls, raycaster, mouse;
    let cubeUniverse, permutationGroup;
    const cubeSize = 30, segment = cubeSize/5, halfCube = cubeSize/2;
    let isPaused = false, currentMode = "manual", userRating = null, textsVisible = true;
    let attributeMapping = [0,1,2,3,4, 0,1];   // forma,color,x,y,z,bg,wall
    let colorAttrCycle = 0;                    // â† cuenta las rotaciones de color
    let paletteRGB = [];
    let manualOverride = {1:'#ff0000',2:'#00ff00',3:'#0000ff',4:'#ff00ff',5:'#00ffff'};
    let bgOverride   = null;
    let cubeOverride = null;
    /* variables globales para fondo y paredes */
    let bgHSV = {h:0,s:0,v:1};
    let wallHSV = {h:0,s:0,v:1};
    let  currentHarmony = 'triad';
    let activePatternId = 1;           // arranca en ContenciÃ³n
    const Î”E_MIN = 20;
    
    // >>> NUEVO:
    let S_global = 0; // tÃ©rmino estructural para posiciones (Shift-Rank acoplado)

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     *   FRBN  Â·  deterministic Ganzfeld
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    let skySphere = null;
    let isFRBN    = false;
    const SKY_R = 250;

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *  initSkySphere â€” FRBN con micro-ruido â€œblue-noiseâ€ y highp
 *  (solo afecta al fondo shader del modo FRBN)
 * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
function initSkySphere() {
  const geo = new THREE.PlaneGeometry(2, 2);

  const mat = new THREE.ShaderMaterial({
    uniforms : {
      u_count     : { value: 0 },
      u_colors    : { value: Array(12).fill(new THREE.Color(0x000000)) },
      time        : { value: 0 },
      u_rate      : { value: 0.04 },
      // amplitud del dither (ajÃºstala si quieres): ~1/1024
      u_ditherAmp : { value: 0.00095 }
    },
    side: THREE.DoubleSide,
    depthWrite: false,
    depthTest : false,
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position.xy, 0.0, 1.0);
      }`,
    fragmentShader: `
      #ifdef GL_ES
      precision highp float;
      #endif

      uniform int   u_count;
      uniform vec3  u_colors[12];
      uniform float time;
      uniform float u_rate;
      uniform float u_ditherAmp;
      varying vec2  vUv;

      // Interleaved Gradient Noise (Jimenez 2014) â€“ base para blue-noise temporal
      float ign(vec2 p, float t){
        const vec3 a = vec3(0.06711056, 0.00583715, 52.9829189);
        return fract(a.z * fract(dot(p, a.xy) + t * a.y));
      }

      // Tres canales ligeramente des-correlacionados
      vec3 blueNoise(vec2 pix, float t){
        float n1 = ign(pix,           t);
        float n2 = ign(pix + vec2(113.1,  1.7), t + 17.0);
        float n3 = ign(pix + vec2( 27.0, 61.7), t + 31.0);
        // centrar en 0 y estrechar (distribuciÃ³n casi triangular)
        n1 = (n1 + ign(pix*1.07+3.1, t*1.3)) * 0.5;
        return vec3(n1, n2, n3) - 0.5;
      }

      void main() {
        // mezcla cromÃ¡tica ligada al tiempo/escena
        float t = time * u_rate;
        float idx = fract(t) * float(u_count);
        int   i   = int(floor(idx)) % u_count;
        int   j   = (i + 1) % u_count;
        float f   = fract(idx);

        vec3 col = mix(u_colors[i], u_colors[j], f);

        // respiraciÃ³n suave radial (ligeramente mÃ¡s blanda)
        vec2 cUv = vUv - 0.5;
        float d  = length(cUv) * 2.0;
        float fog = pow(1.0 - smoothstep(0.0, 1.0, d), 2.0);
        col += 0.10 * fog;

        // micro-dither spatio-temporal para romper banding (en espacio lineal)
        // usa coordenada de pixel (gl_FragCoord.xy) y el tiempo para â€œblue-shiftâ€
        vec3 dither = blueNoise(gl_FragCoord.xy, time * 60.0);
        col += u_ditherAmp * dither;

        gl_FragColor = vec4(clamp(col, 0.0, 1.0), 1.0);
      }`
  });

  const plane = new THREE.Mesh(geo, mat);
  plane.frustumCulled = false;
  plane.visible = false;
  skySphere = plane;
  scene.add(skySphere);
}
    /* ---------- extrae TODOS los colores deterministas del sistema ---------- */
    function collectSceneColors(){
      // 1) Todos los RGB deterministas
      const raw = [];
      permutationGroup.traverse(o=>{
        if(o.isMesh) raw.push(o.material.color.clone());
      });

      // 2) Normaliza a Sâ‰¥0.60  Vâ‰¥0.80  (mÃ¡s extremos)
      const boosted = raw.map(c=>{
        let [h,s,v] = rgbToHsv(c.r*255,c.g*255,c.b*255);
        s = Math.max(s, 0.60);
        v = Math.max(v, 0.80);
        const [R,G,B] = hsvToRgb(h,s,v);
        return new THREE.Color(R/255,G/255,B/255);
      });

      // 3) Agrupa por Î”Hâ‰¥18Â°  (dejamos tonos bien separados)
      const uniq = [];
      boosted.forEach(c=>{
        const [h] = rgbToHsv(c.r*255,c.g*255,c.b*255);
        if(!uniq.some(u=>{
          const [hu] = rgbToHsv(u.r*255,u.g*255,u.b*255);
          return Math.abs(hu-h) < 18;
        })){
          uniq.push(c);
        }
      });

      // 4) Si siguen faltando, completa con rueda de color base
      const fallback = [
        0,60,120,180,240,300
      ].map(h=>{
        const [R,G,B] = hsvToRgb(h,0.75,0.85);
        return new THREE.Color(R/255,G/255,B/255);
      });
      while(uniq.length < 6) uniq.push( fallback[uniq.length] );

      // â†’ devolvemos mÃ¡x. 8 primeros
      return uniq.slice(0,8);
    }


    /* ---------- actualiza uniforms del shader con la paleta elegida ---------- */
    function buildGanzfeld(){
      if(!skySphere) initSkySphere();

      /* ---------- 1)â€¯paleta determinista ---------- */
      const cols = collectSceneColors();
      const n    = cols.length;
      const mat  = skySphere.material;
      mat.uniforms.u_count.value = n;
      for(let i=0;i<12;i++){
        mat.uniforms.u_colors.value[i] = cols[i % n];
      }

      /* ---------- 2)â€¯velocidad ligada al movimiento ---------- */
      let sum=0, cnt=0;
      permutationGroup.traverse(o=>{
        if(o.isMesh && o.userData.rotationSpeed){
          sum += o.userData.rotationSpeed;
          cnt ++;
        }
      });
      const avg = cnt ? sum/cnt : 0.002;
      mat.uniforms.u_rate.value = avg * 1;
    }

    /* ---------- bot\u00f3n FRBN: ON/OFF  (Riesgos 2 y 3 integrados) --------------- */
    function toggleFRBN () {
      if (!skySphere) initSkySphere();

      isFRBN = !isFRBN;

      if (isFRBN) {                       // â€”â€”â€” ENTRAR â€”â€”â€”
        if (isLCHT) toggleLCHT();         // asegura exclusividad
        buildGanzfeld();                  // sincroniza paleta + u_rate
        skySphere.visible        = true;
        cubeUniverse.visible     = false;
        permutationGroup.visible = false;
        if (lichtGroup) lichtGroup.visible = false;

      } else {                            // â€”â€”â€” SALIR â€”â€”â€”
        skySphere.visible        = false;
        cubeUniverse.visible     = true;
        permutationGroup.visible = true;
        if (isLCHT && lichtGroup) lichtGroup.visible = true;
        refreshAll({ keepManual: true }); // reconstruye escena normal
      }
  // â† muestra el miniâ€‘botÃ³n solo en FRBN
  const ib = document.getElementById('frbnInfoButton');
  if (ib) ib.style.display = isFRBN ? 'inline-block' : 'none';
    }

    /* --------- inicializa esfera al arrancar (sin coste GPU extra) -------- */
    window.addEventListener('load', () => { if(!skySphere) initSkySphere(); });

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
     *   LCHT Â· deterministic Light Tubes
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    let lichtGroup = null;
    let isLCHT     = false;
    let lchtPrevBg = null;          // guarda/restaura el fondo al salir

    /* color determinista = mismo que la permutaciÃ³n                    */
    function colorForPerm(pa){
      const idx = pa[ attributeMapping[1] ];                // 1â€“5
      const val = getColor(idx);
      return Array.isArray(val)
        ? new THREE.Color(val[0]/255, val[1]/255, val[2]/255)
        : new THREE.Color(val);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â• ACTUALIZA LCHT (reglas â€œtubos que se escapanâ€) â•â•â•â•â•â•â•â•â•â•â•â•â•
     * Sustituye â€”o aÃ±ade justo debajoâ€” el antiguo tubeId() y buildLCHT() por
     * este bloque. No requiere tocar nada mÃ¡s del cÃ³digo.
     * â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

    /* â”€â”€ 1 Â· Identificador de tramo sin lÃ­mite de cuadrÃ­cula â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    function tubeKey(x1,y1,z1,x2,y2,z2){
      // ordenamos los extremos para que â†‘â†“ y â†“â†‘ sean el mismo tramo
      const a = `${x1},${y1},${z1}`;
      const b = `${x2},${y2},${z2}`;
      return (a < b) ? `${a}|${b}` : `${b}|${a}`;
    }

    /* â”€â”€ 2 Â· Nuevo buildLCHT conforme a las reglas pactadas â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    function buildLCHT(){
      /* limpia escena previa */
      if (lichtGroup){
        lichtGroup.traverse(o=>{
          if(o.isPointLight) o.dispose && o.dispose();
          if(o.isMesh){ o.geometry.dispose(); o.material.dispose(); }
        });
        scene.remove(lichtGroup);
      }
      lichtGroup = new THREE.Group();
      scene.add(lichtGroup);

      const litInfo    = new Map();   // key â†’ { color, lcht }
      const collisions = new Set();   // keys duplicados â†’ negro
      const step       = cubeSize / 5;

      function inBounds(x, y, z){        // 5Ã—5Ã—5 â†’ 0â€¦4 inclusive
        return x >= 0 && x <= 4 &&
               y >= 0 && y <= 4 &&
               z >= 0 && z <= 4;
      }

      /* === 1) recopila tramos de todas las permutaciones ==================== */
      const perms = Array.from(document.getElementById('permutationList').selectedOptions)
                         .map(o => o.value.split(',').map(Number));

      perms.forEach(pa=>{
        const sig  = computeSignature(pa);
        const rng  = computeRange(sig);
        const r    = lehmerRank(pa);

        /* coordenada base (mismo Ã­ndice que BUILD) */
        const Iidx = (r + sceneSeed + S_global) % 125;
        let x0 = Math.floor(Iidx/25),
            y0 = Math.floor((Iidx%25)/5),
            z0 = Iidx % 5;

        const L = pa[ attributeMapping[0] ];          // longitud 1-5
        const col = colorForPerm(pa).clone();

        const I0   = 0.35 + 0.65 * Math.sqrt(L/5);
        const amp  = 0.05 + 0.10  * rng;
        const freq = 0.10 + 0.175 * rng;
        const phi  = 2*Math.PI*((r%360)/360);

        function addSeg(x1, y1, z1,  x2, y2, z2){
          if(!inBounds(x1,y1,z1) || !inBounds(x2,y2,z2)) return;   // fuera de la grilla â†’ descarta
          const key = tubeKey(x1,y1,z1,x2,y2,z2);
          if(litInfo.has(key))  collisions.add(key);
          else litInfo.set(key, { color: col.clone(),
                                  lcht : { I0, amp, f: freq, phi } });
        }

        /* eje vertical (L tramos) */
        for(let s=0;s<L;s++){
          addSeg(x0, y0+s,   z0,
                 x0, y0+s+1, z0);
        }

        /* brazos horizontales en Â±X y Â±Z para y = y0 y y = y0+L */
        const dirs = [[1,0,0],[-1,0,0],[0,0,1],[0,0,-1]];
        [y0, y0+L].forEach(yy=>{
          dirs.forEach(([dx,_,dz])=>{
            for(let s=0;s<L;s++){
              addSeg(x0+dx*s,  yy, z0+dz*s,
                     x0+dx*(s+1),yy, z0+dz*(s+1));
            }
          });
        });
      });

      /* === 2) pinta de negro los tramos con colisiÃ³n ======================= */
      collisions.forEach(k=>{
        const d = litInfo.get(k);
        if(d){
          d.color.set(0x000000);
          d.lcht.I0 = 0;           // sin luz en tubos negros
        }
      });

      /* === 3) genera geometrÃ­a solo para los tramos presentes ============== */
      litInfo.forEach((info,key)=>{
        const [a,b] = key.split('|');
        const [x1,y1,z1] = a.split(',').map(Number);
        const [x2,y2,z2] = b.split(',').map(Number);

        const p1 = new THREE.Vector3((x1-2)*step,(y1-2)*step,(z1-2)*step);
        const p2 = new THREE.Vector3((x2-2)*step,(y2-2)*step,(z2-2)*step);

        const dir = new THREE.Vector3().subVectors(p2,p1);
        const len = dir.length();
        const geo = new THREE.CylinderGeometry(0.4,0.4,len,8,1,true);

        const neonCol = info.color.clone();
        const hslCol  = {}; neonCol.getHSL(hslCol);
        neonCol.setHSL(hslCol.h, 1, Math.min(0.7, hslCol.l + 0.2));   // neÃ³n puro

        const mat = new THREE.MeshPhongMaterial({
          color     : neonCol,
          shininess : 0,
          dithering : true           // opaco; sin .transparent ni .opacity
        });

        /* â€” geometrÃ­a + orientaciÃ³n â€” */
        const tube = new THREE.Mesh(geo, mat);
        tube.position.copy( p1.clone().add(p2).multiplyScalar(0.5) );
        tube.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.normalize());
        tube.userData.lcht = info.lcht;
        lichtGroup.add(tube);

        // ya no hay luz puntual separada
      });

      /* === 2-bis)  RELLENO COMPLETO LEWITT  ===================================== */
      (function addLewittFillers(){
        const step   = cubeSize / 5;
        const R_NODE = 0.60;   // tamaÃ±o del cubo-nudo (vÃ©rtice con â‰¥3 aristas)

        function makeEdge(x1,y1,z1, x2,y2,z2, neonCol){
          if(!inBounds(x2,y2,z2)) return;          // ahora nunca sale del 5Ã—5Ã—5

          const k = tubeKey(x1,y1,z1, x2,y2,z2);
          if(litInfo.has(k) || collisions.has(k)) return;   // ya existe algo ahÃ­

          const dir = new THREE.Vector3(x2-x1, y2-y1, z2-z1);
          const len = step * dir.length();
          const geo = new THREE.CylinderGeometry(0.35, 0.35, len, 8, 1, true);

          /* â€”â€” color neÃ³n, opaco â€”â€” */
          const hsl   = {}; neonCol.getHSL(hsl);
          neonCol.setHSL(hsl.h, 1, Math.min(0.7, hsl.l + 0.2));   // S = 100 %, +lum.

          const mat = new THREE.MeshPhongMaterial({
            color      : neonCol,
            shininess  : 0,
            dithering  : true          // sin transparencia en ningÃºn caso
          });

          const m   = new THREE.Mesh(geo, mat);
          const p1  = new THREE.Vector3((x1-2)*step, (y1-2)*step, (z1-2)*step);
          const p2  = new THREE.Vector3((x2-2)*step, (y2-2)*step, (z2-2)*step);
          m.position.copy( p1.clone().add(p2).multiplyScalar(0.5) );
          m.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.normalize());
          lichtGroup.add(m);

          litInfo.set(k, { color: neonCol, lcht:{ I0:0, amp:0, f:0, phi:0 } });
        }

        /* 1)  Para cada tubo existente, extiende las dos direcciones ortogonales */
        litInfo.forEach((info, key)=>{
          const [a,b]   = key.split('|').map(s=>s.split(',').map(Number));
          const [x1,y1,z1] = a, [x2,y2,z2] = b;
          const dx = x2 - x1, dy = y2 - y1, dz = z2 - z1;   // orientaciÃ³n principal

          const axes = [];
          if (dx) axes.push([0,1,0], [0,0,1]);    // tubo era X â†’ aÃ±ade Y y Z
          if (dy) axes.push([1,0,0], [0,0,1]);    // tubo era Y â†’ aÃ±ade X y Z
          if (dz) axes.push([1,0,0], [0,1,0]);    // tubo era Z â†’ aÃ±ade X y Y

            axes.forEach(([ax, ay, az]) => {
              [[x1, y1, z1], [x2, y2, z2]].forEach(([px, py, pz]) => {
                const nx = px + ax;
                const ny = py + ay;
                const nz = pz + az;
                makeEdge(px, py, pz, nx, ny, nz, info.color.clone());
              });
            });
        });

        /* 2)  Coloca cubitos en los vÃ©rtices con â‰¥3 aristas */
        const degree = new Map();               // "x,y,z" â†’ nÂº de aristas
        litInfo.forEach((_, k)=>{
          const [a,b] = k.split('|');
          [a,b].forEach(s=>{
            degree.set(s, (degree.get(s)||0)+1);
          });
        });

        degree.forEach((d, str)=>{
          if (d < 3) return;                    // sÃ³lo nudos â€œfuertesâ€
          const [x,y,z] = str.split(',').map(Number);
          const geo = new THREE.BoxGeometry(R_NODE, R_NODE, R_NODE);
          const mat = new THREE.MeshPhongMaterial({ color: 0xffffff, shininess:0, dithering:true });
          const n   = new THREE.Mesh(geo, mat);
          n.material.color.copy( litInfo.get([...litInfo.keys()][0]).color ); // cualquier color de escena
          n.position.set((x-2)*step, (y-2)*step, (z-2)*step);
          lichtGroup.add(n);
        });
      })();
    }
    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• FIN BLOQUE ACTUALIZADO â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    function toggleLCHT(){
      isLCHT = !isLCHT;

        if (isLCHT){
          /* â€” cambia material del cubo a lambert para que capte luz â€” */
          if(!cubeUniverse.userData.prevMat){
            cubeUniverse.userData.prevMat = cubeUniverse.material;
            cubeUniverse.material = new THREE.MeshLambertMaterial({
              color: cubeUniverse.userData.prevMat.color,
              transparent: true,
              opacity: cubeUniverse.userData.prevMat.opacity,
              side: cubeUniverse.userData.prevMat.side
            });
          }
          if (!lchtPrevBg) lchtPrevBg = scene.background ? scene.background.clone() : null;
          scene.background = new THREE.Color(0xf4f4f4);       // gris muy claro
          if (isFRBN) toggleFRBN();                           // LCHT excluye FRBN
          buildLCHT();
          lichtGroup.visible        = true;
          cubeUniverse.visible      = false;
          permutationGroup.visible  = false;
        } else {
          /* â€” restaura material original â€” */
          if(cubeUniverse.userData.prevMat){
            cubeUniverse.material.dispose();
            cubeUniverse.material = cubeUniverse.userData.prevMat;
            delete cubeUniverse.userData.prevMat;
          }
          if (lichtGroup) lichtGroup.visible = false;
          if (lchtPrevBg) scene.background = lchtPrevBg;      // restaura fondo
          lchtPrevBg = null;
          cubeUniverse.visible      = true;
          permutationGroup.visible  = true;
        }
      const b = document.getElementById('lchtButton');
      if (b) b.textContent = isLCHT ? 'LCHT ON' : 'LCHT';
    }

    /* reconstruye LCHT si hay cambios de escena */
    function rebuildLCHTIfActive(){ if(isLCHT) buildLCHT(); }

    const GOLD = 137.50776405003785;      // Ã¡ngulo Ã¡ureo
    /*  razÃ³n Ã¡urea al cuadrado  â‰ˆ 2.618â€¦  */
    const PHI2 = 2.618033988749895;
    /* â€”â€”â€” salto coprimo con 144: barre los 144 valores de H â€”â€”â€” */
    const PHI_H = 89;             // 89 â‰¡ 144 / Ï†  (gcd 89,144 = 1)
    /* â€”â€”â€” saltos coprimos para los 12 niveles de S y V â€”â€”â€” */
    const PHI_S = 5;              // gcd(5,12) = 1
    const PHI_V = 7;              // gcd(7,12) = 1

    /* â•â•â•â•â•â•â•â•â• CUADRÃCULA HSV 144Â·12Â·12 â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
    const H_STEPS  = 144;                               // 360Â° / 2.5Â°
    const S_LEVELS = [...Array(12)].map((_,i)=>0.25 + 0.72*i/11); // 0.25 â€“ 0.97
    const V_LEVELS = [...Array(12)].map((_,i)=>0.20 + 0.75*i/11); // 0.20 â€“ 0.95

    /* â€”â€”â€” DiscretizaciÃ³n canÃ³nica para FRBN (catÃ¡logo de fases) â€”â€”â€” */
    const FRBN_K = 144;   // alineado con H_STEPS (2.5Â° Ã— 144)

    function idxToHSV(hIdx,sIdx,vIdx){
      const h = ((hIdx%H_STEPS)+H_STEPS) % H_STEPS;      // 0-143
      return {
        h: h * 360 / H_STEPS,                            // 0-359.5 Â°
        s: S_LEVELS[ ((sIdx%12)+12)%12 ],
        v: V_LEVELS[ ((vIdx%12)+12)%12 ]
      };
    }

    /* Normaliza cualquier hue a rango [0 â€¦ 360) */
    function normHue(deg){
      return ((deg % 360) + 360) % 360;
    }

    /* â•â•â•â•â•â•â•â•â• 11 patrones cromÃ¡ticos â€” versiÃ³n PHI_H (89) â•â•â•â•â•â•â•â•â• */
const PATTERNS = {
  1: (sig, seed, i) => {
    const base = (sig.reduce((a,v)=>a+v,0) + seed*7) % 144;
    const hIdx = (base + (i%12)*6) % 144;
    return [
      hIdx,
      (sig[3] + seed + i) % 12,
      (sig[1] + sig[4] + i) % 12
    ];
  },

  2: (sig, seed, i) => {
    const base = (sig[0]*17 + seed*5) % 144;
    const hIdx = (base + ((i%12)*48)) % 144;
    return [
      hIdx,
      (sig[1] + i*3 + seed) % 12,
      (sig[2]*2 + i + seed) % 12
    ];
  },

  3:  (s,seed,i)=>{const b=(s[2]*13+seed*5+i*11)%144;
                   return [(b+i*PHI_H)%144,(s[0]+i*2+seed)%12,(s[1]+s[3]+i)%12];},

  4:  (s,seed,i)=>{const b=(s[1]*15+seed*3+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[0]+seed+i)%12,(s[2]+s[4]+seed+i)%12];},

  5:  (s,seed,i)=>{const b=(i*31+s[3]*13+seed*5)%144;
                   return [(b+i*PHI_H)%144,(s[1]+seed+i)%12,(s[2]+seed+i)%12];},

  6:  (s,seed,i)=>{const b=(s[1]*31+seed*13+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i)%12,(s[3]+s[4]+seed+i)%12];},

  7:  (s,seed,i)=>{const b=(s[0]*11+seed*3+i*37)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i*2)%12,(s[4]+s[1]*2+seed+i)%12];},

  8:  (s,seed,i)=>{const r=Math.abs(s[4]-s[0])+Math.abs(s[3]-s[1])+s[2];
                   const b=(r*13+seed*7)%144;
                   return [(b+i*PHI_H)%144,(s[1]*3+seed+i*2)%12,(s[3]+i*5+seed*3)%12];},

  9:  (s,seed,i)=>{const b=(s[4]*12+seed*7+i*11)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i)%12,(s[1]+seed+i*2)%12];},

 10:  (s,seed,i)=>{const b=(seed*5+s.reduce((a,v)=>a+v,0)*3+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i)%12,(s[4]*2+seed+i*3)%12];},

 11:  (s,seed,i)=>{const b=(s[3]*13+seed*11+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[0]+seed+i)%12,(s[1]+seed+i*2)%12];}
};

/* ---------- BLOQUE DE UTILIDADES COLOR v1.3-RC2 ---------- */
const ANG7 = [
  [0,0,0,0,0,0,0],                         // monocromo (idx 0)
  [0,30,60,90,120,150,180],                // anÃ¡loga
  [0,180,0,180,0,180,0],                   // complementaria
  [0,150,210,0,150,210,0],                 // comp. dividida
  [0,120,240,60,180,300,30],               // trÃ­ada
  [0,90,180,270,45,135,225],               // cuadrado
  [0,0,0,0,0,0,0]                          // â€œtonosâ€ (misma H, S escalado)
];
function rgbToHsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min;
  let h=0;
  if(d){
    if(max===r) h=((g-b)/d)%6;
    else if(max===g) h=(b-r)/d+2;
    else h=(r-g)/d+4;
    h*=60; if(h<0) h+=360;
  }
  const s=max?d/max:0, v=max;
  return [h,s,v];
}
function hsvToRgb(h,s,v){
  h = h % 360;
  const c=v*s, x=c*(1-Math.abs((h/60)%2-1)), m=v-c;
  let [r,g,b]=[0,0,0];
  if(h<60){r=c;g=x;} else if(h<120){r=x;g=c;}
  else if(h<180){g=c;b=x;} else if(h<240){g=x;b=c;}
  else if(h<300){r=x;b=c;} else {r=c;b=x;}
  return [(r+m)*255,(g+m)*255,(b+m)*255].map(v=>Math.round(v));
}
function hsvToHex({h,s,v}){
  const [r,g,b] = hsvToRgb(h,s,v);
  return '#'+new THREE.Color(r/255,g/255,b/255).getHexString();
}
/* contraste CIE76 */
function deltaE(lab1,lab2){
  return Math.sqrt(
    (lab1[0]-lab2[0])**2+
    (lab1[1]-lab2[1])**2+
    (lab1[2]-lab2[2])**2
  );
}
function rgbToLab(r,g,b){                      // aproximaciÃ³n rÃ¡pida
  const xyz=[r/255,g/255,b/255].map(v=>{
    v=v>0.04045?((v+0.055)/1.055)**2.4:v/12.92;
    return v*100;
  });
  const x=xyz[0]*0.4124+xyz[1]*0.3576+xyz[2]*0.1805;
  const y=xyz[0]*0.2126+xyz[1]*0.7152+xyz[2]*0.0722;
  const z=xyz[0]*0.0193+xyz[1]*0.1192+xyz[2]*0.9505;
  const xyzN=[95.047,100.0,108.883];
  const f= t=> t>0.008856 ? t**(1/3) : (7.787*t)+16/116;
  const [fx,fy,fz]=[x,y,z].map((v,i)=>f(v/xyzN[i]));
  return [116*fy-16, 500*(fx-fy), 200*(fy-fz)];
}

/* ======  NUEVO  â€” utilidades de contraste con el FONDO  ====== */
const Î”E_BG_MIN = 22;          // contraste mÃ­nimo CIE76

function hexToRgb(hex){
  const m = /^#?([0-9a-f]{6})$/i.exec(hex);
  const n = parseInt(m[1],16);
  return [(n>>16)&255, (n>>8)&255, n&255];
}

/**
 * Sube o baja la luminosidad (v) del color RGB recibido hasta que
 * alcance Î”E_BG_MIN puntos de contraste contra el fondo actual.
 * Devuelve el RGB corregido.
 */
function ensureContrastRGB(rgb){
  /* color de fondo efectivo */
  const bgRgb = bgOverride
      ? hexToRgb(bgOverride)
      : hsvToRgb(bgHSV.h, bgHSV.s, bgHSV.v);

  let [h,s,v] = rgbToHsv(...rgb);          // pasamos a HSV
  let tries = 0;
  while (deltaE(rgbToLab(...rgb),
                rgbToLab(...bgRgb)) < Î”E_BG_MIN && tries < 24){
    /* estrategia: alterna aclarar / oscurecer en pasos de 0.04 */
    v = (tries % 2)
        ? Math.max(0, v - 0.04)
        : Math.min(1, v + 0.04);
    rgb = hsvToRgb(h, s, v);
    tries++;
  }
  return rgb;
}
/* ---------- FIN BLOQUE UTILIDADES ---------- */
/* â€”â€”â€” calcula HSV para fondo (slot 5) y paredes (slot 6) â€”â€”â€” */
function rebuildSceneColours(){
  const dummySig = [0,0,0,0,0];            // sÃ³lo necesitamos el patrÃ³n
  bgHSV   = idxToHSV( ...PATTERNS[activePatternId](dummySig, sceneSeed, 5) );
  wallHSV = idxToHSV( ...PATTERNS[activePatternId](dummySig, sceneSeed, 6) );
}

/* ===\u2003UTIL extra â€” firma normalizada y contraste\u2003===================== */
// 1)  fÌ‚  de un glifo  â†’  promedio firma, llevada a [0-1]
function normFhat(sig){           // sig = [f1â€¦f5] entre 2 y 10
  const avg = sig.reduce((a,b)=>a+b,0)/sig.length;   // 2 â€¦ 10
  return (avg-2)/8;                                  // 0 â€¦ 1
}

// 2)  pinza a [0,1]
function clamp01(x){ return Math.max(0, Math.min(1,x)); }

/* â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” *
 * Devuelve el valor de una propiedad que puede ser:
 *   Â· nÃºmero â†’ se usa tal cual
 *   Â· funciÃ³n â†’ se evalÃºa con los argumentos dados
 * fallback se usa si la propiedad es null/undefined.
 * â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” */
function evalProp(prop, args = [], fallback = 0){
  return (typeof prop === 'function') ? prop(...args) :
         (prop ?? fallback);
}

/* contrast-fix eliminado: funciÃ³n ensureContrast() suprimida */
    const minRangeValue = 2, maxRangeValue = 6;
    const shapeMapping = {
      1:{w:4.5,h:4.5},
      2:{w:4.5,h:4.5*Math.sqrt(2)},
      3:{w:4.5,h:4.5*Math.sqrt(3)},
      4:{w:4.5,h:4.5*Math.sqrt(4)},
      5:{w:4.5,h:4.5*Math.sqrt(5)}
    };

    function sumXYZ(pa,map){
      return pa[ map[2] ] + pa[ map[3] ] + pa[ map[4] ];
    }

    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function mapRangeToSpeed(r,mn,mx){return 0.001 + (r-mn)*(0.005-0.001)/(mx-mn);}
    function shuffle(a){for(let i=a.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

    function getPermutations(arr){
      if(arr.length===1) return [arr];
      let res=[]; for(let i=0;i<arr.length;i++){
        const c=arr[i], rem=arr.slice(0,i).concat(arr.slice(i+1));
        for(const p of getPermutations(rem)) res.push([c].concat(p));
      }
      return res;
    }
    const allPermutations = getPermutations([1,2,3,4,5]);
    const permutationStrings = allPermutations.map(p=>p.join(','));

    function getAttributeMappings(a){
      if(a.length===1) return [a];
      let res=[]; for(let i=0;i<a.length;i++){
        const c=a[i], rem=a.slice(0,i).concat(a.slice(i+1));
        for(const m of getAttributeMappings(rem)) res.push([c].concat(m));
      }
      return res;
    }

    function populatePermutationList(){
      const sel = document.getElementById('permutationList');
      sel.innerHTML = '';
      permutationStrings.forEach((ps,i)=>{
        const o=document.createElement('option');
        o.value=ps; o.text=`PermutaciÃ³n ${i+1}: (${ps})`;
        if(i===0) o.selected=true;
        sel.appendChild(o);
      });
    }
    function populateAttributeMappingSelect(){
      const sel = document.getElementById('attrMapping');
      sel.innerHTML = '';
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        const s=m.join(','), o=document.createElement('option');
        o.value=s; o.text=`OpciÃ³n: [${s}]`;
        if(s==='0,1,2,3,4') o.selected=true;
        sel.appendChild(o);
      });
      updateTopRightDisplay();
    }

    function computeSignature(a){let s=[];for(let i=0;i<a.length;i++) s.push(a[i]+a[(i+1)%a.length]);return s;}
    function computeRange(sig){return Math.max(...sig)-Math.min(...sig);}

    const FACT=[1,1,2,6,24,120];
    let sceneSeed=0;
    function lehmerRank(p){
      let r=0;
      for(let i=0;i<p.length;i++){
        let c=0;
        for(let j=i+1;j<p.length;j++) if(p[j]<p[i]) c++;
        r+=c*FACT[p.length-1-i];
      }
      return r;
    }

    /* ========= NUEVO: sceneSeed ordenâ€‘invariante + dependiente del mapping ========= */

    /** Rank del mapping [m0..m4] usando Lehmer rank sobre [m_i+1] (1..5) */
    function mappingRank(m){
      const arr = [m[0]+1, m[1]+1, m[2]+1, m[3]+1, m[4]+1];
      return lehmerRank(arr);
    }

    /** sceneSeed = (37Â·sumR + 101Â·sumR2 + 53Â·mRank) mod 360  (ordenâ€‘invariante) */
    function computeSceneSeedFrom(perms, m){
      let sumR = 0, sumR2 = 0;
      perms.forEach(pa=>{
        const r = lehmerRank(pa);
        sumR  += r;
        sumR2 += r*r;
      });
      const mRank = mappingRank(m);
      return (37*sumR + 101*sumR2 + 53*mRank) % 360;
    }

    /** S = ( Î£ (P_{mx}+P_{my}+P_{mz}) ) mod 125  â€” usa los Ã­ndices x,y,z del mapping */
    function computeGlobalS(perms, m){
      const mx = m[2], my = m[3], mz = m[4];
      let S = 0;
      perms.forEach(p=>{
        S += p[mx] + p[my] + p[mz];
      });
      return S % 125;
    }
    function computeShiftRankXYZ(p){
      const r = lehmerRank(p);
      const I = (r + sceneSeed + S_global) % 125;   // <<< NUEVO: acoplado a S_global
      const x = Math.floor(I/25),
            y = Math.floor((I%25)/5),
            z = I%5;
      const step = cubeSize/5;
      return [
        (x-2)*step,
        (y-2)*step,
        (z-2)*step
      ];
    }

    function setActivePattern(id){
      activePatternId = parseInt(id,10);
      refreshAll({rebuild:false});
    }
    function updateTopRightDisplay(){
      const cfg=`Atributos: [${attributeMapping.slice(0,5).join(',')}]`;
      const rt =`CalificaciÃ³n: ${userRating?userRating:'AÃºn no calificada'}`;
      let info='';
      Array.from(document.getElementById('permutationList').selectedOptions).forEach(o=>{
        const pa=o.value.split(',').map(Number),
              sig=computeSignature(pa),
              rg=computeRange(sig);
        info+=`<div style="margin:2px 0;">Perm (${o.value}) | Firma [${sig.join(', ')}] | Rango ${rg}</div>`;
      });
      document.getElementById('topRightDisplay').innerHTML = cfg+'<br>'+rt+'<br>'+info;
    }

    function createPermutationObjectWithMapping(pa,map){
      const fv=pa[map[0]], cv=pa[map[1]],
            d=shapeMapping[fv], w=d.w, h=d.h, t=0.5;
      /* --- CÃLCULO de color (cuadrÃ­cula) -------------------------------- */
      let rgb;
        if(activePatternId === 0){                       // modo legacy
          rgb = paletteRGB[cv-1] || [255,255,255];
        }else{
          const sig  = computeSignature(pa);
          /* slot bien distribuido: rank(perm) mod 12 */
          const slot = lehmerRank(pa) % 12;      // 0-11
          let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
          /* dispersiÃ³n coprima en S y V */
          sI = (sI * PHI_S) % 12;
          vI = (vI * PHI_V) % 12;
          const {h,s,v} = idxToHSV(hI,sI,vI);
          rgb = hsvToRgb(h,s,v);
        }

        /* â€”â€” AJUSTE AUTOMÃTICO DE CONTRASTE CON EL FONDO â€”â€” */
        rgb = ensureContrastRGB(rgb);
      /* --------------------------------------------------------------- */
      const mat=new THREE.MeshPhongMaterial({
        color:new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255),
        shininess:50,
        dithering:true
      });
      const geo=new THREE.BoxGeometry(w,h,t);
      const mesh=new THREE.Mesh(geo,mat);
      const [X,Y,Z]=computeShiftRankXYZ(pa);
      mesh.position.set(
        clamp(X,-halfCube+w/2,halfCube-w/2),
        clamp(Y,-halfCube+h/2,halfCube-h/2),
        clamp(Z,-halfCube+t/2,halfCube-t/2)
      );
      const sig=computeSignature(pa), rg=computeRange(sig);
      mesh.userData={permStr:pa.join(','), signature:sig, range:rg, rotationSpeed:mapRangeToSpeed(rg,minRangeValue,maxRangeValue)};
      return mesh;
    }
    function createPermutationObject(pa){ return createPermutationObjectWithMapping(pa,attributeMapping); }

    function checkCollisionsInGroup(g){
      for(let i=0;i<g.children.length;i++){
        const b1=new THREE.Box3().setFromObject(g.children[i]);
        for(let j=i+1;j<g.children.length;j++){
          const b2=new THREE.Box3().setFromObject(g.children[j]);
          if(b1.intersectsBox(b2)) return true;
        }
      }
      return false;
    }
    function autoResolveColisionesGlobal(){
      let found=null;
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        if(found) return;
        const cm=[m[0],m[1],m[2],m[3],m[4], attributeMapping[5], attributeMapping[6]],
              tg=new THREE.Group(),
              opts=Array.from(document.getElementById('permutationList').selectedOptions);
        opts.forEach((o)=>{
          const pa=o.value.split(',').map(Number),
                mo=createPermutationObjectWithMapping(pa,cm);
          tg.add(mo);
        });
        if(!checkCollisionsInGroup(tg)) found=cm;
      });
      if(found){
        attributeMapping=found;
        document.getElementById('attrMapping').value=`${found[0]},${found[1]},${found[2]},${found[3]},${found[4]}`;
        refreshAll({rebuild:true}); updateTopRightDisplay();
      } else {
        showPopup("No se encontrÃ³ reorganizaciÃ³n sin colisiones.",7000);
      }
    }

/* ==============================
 * 120 Architectural Permutations
 * ============================== */
let perm120List = getAttributeMappings([0,1,2,3,4]); // 120
let perm120Index = 0;
let perm120Timer = null;

function togglePerm120Panel(){
  const p = document.getElementById('perm120Panel');
  const isHidden = (p.style.display === 'none' || !p.style.display);
  p.style.display = isHidden ? 'block' : 'none';

  // Reâ€‘muestra siempre el cursor personalizado
  const cc = document.getElementById('customCursor');
  if (cc) cc.style.display = 'block';
}

function msFromUI(){
  const slider = document.getElementById('perm120Slider');
  return parseInt(slider.value, 10);
}
function syncPerm120InputsFromSlider(){
  const ms = msFromUI();
  document.getElementById('perm120Seconds').value = Math.round(ms/1000);
}
function syncPerm120SliderFromSeconds(){
  const sec = parseInt(document.getElementById('perm120Seconds').value,10) || 1;
  const clamped = Math.max(1, Math.min(720, sec));
  document.getElementById('perm120Seconds').value = clamped;
  document.getElementById('perm120Slider').value = clamped * 1000;
}

function updatePerm120Status(){
  const stat = document.getElementById('perm120Status');
  if(stat) stat.textContent = `Permutation: ${perm120Index} / 119`;
}

function applyPerm120Index(i){
  perm120Index = ((i % perm120List.length) + perm120List.length) % perm120List.length;
  const m = perm120List[perm120Index];
  attributeMapping = [m[0], m[1], m[2], m[3], m[4], attributeMapping[5], attributeMapping[6]];
  document.getElementById('attrMapping').value = m.join(',');
  refreshAll({rebuild:true});
  updatePerm120Status();
}

function nextPerm120(){ applyPerm120Index(perm120Index + 1); }
function prevPerm120(){ applyPerm120Index(perm120Index - 1); }

function playPerm120(){
  if(perm120Timer) return;
  const interval = msFromUI();
  perm120Timer = setInterval(nextPerm120, interval);
  nextPerm120();
}
function pausePerm120(){
  if(perm120Timer){
    clearInterval(perm120Timer);
    perm120Timer = null;
  }
}

function showPerm120Info(){
  const txt =
`The 120 architectural permutations are the 120 ways to reassign Pâ‚â€“Pâ‚… to the attributes [shape, color, x, y, z]. The architecture (the set of selected permutations) does not change; what changes is its visual phenotype by deciding which component controls each spatial and chromatic attribute.
These reconstructions do not add semantics, do not break the logic of the system, and remain within the combinatorial framework. They reorganize the structural availability of preâ€‘verbal thought.

Each of the 120 reorganizations is validated by its internal structural coherence, not by usefulness or beauty.
â€œEvolutionâ€ is goalâ€‘free reordering: same architecture, 120 phenotypic expressions.`;
  alert(txt);
}

    /* ============================================================
     *  MONTE-CARLO: buscar una escena aleatoria SIN colisiones
     *  ============================================================
     */

    /** Construye un grupo temporal con un mapping dado, sin tocar la escena real */
      const mappings = getAttributeMappings([0,1,2,3,4]);
function buildTempGroup(perms, mapping){
  const tg = new THREE.Group();

  // Guardamos estado global
  const prevSeed = sceneSeed;
  const prevS    = S_global;
  const prevMap  = attributeMapping.slice();

  // Calculamos los nuevos valores teÃ³ricos
  const tmpSeed = computeSceneSeedFrom(perms, mapping);
  const tmpS    = computeGlobalS(perms, mapping);

  // Seteamos temporalmente los globales para que createPermutationObjectWithMapping
  // use exactamente la misma lÃ³gica que la escena final:
  sceneSeed        = tmpSeed;
  S_global         = tmpS;
  attributeMapping = mapping;

  perms.forEach(pa=>{
    const mesh = createPermutationObjectWithMapping(pa, mapping);
    tg.add(mesh);
  });

  // Restauramos
  sceneSeed        = prevSeed;
  S_global         = prevS;
  attributeMapping = prevMap;

  return tg;
}

function findCollisionFreeMapping(perms){
  const mappings = getAttributeMappings([0,1,2,3,4]);
  for(const m of mappings){
    const cm = [m[0], m[1], m[2], m[3], m[4], attributeMapping[5], attributeMapping[6]];
    const tg = buildTempGroup(perms, cm);
    if(!checkCollisionsInGroup(tg)) return cm;
  }
  return null;
}
    /** Selecciona un subconjunto aleatorio de permutaciones (1..25) */
    function pickRandomPerms(){
      const n  = Math.floor(Math.random()*25) + 1;
      const out = [];
      for(let i=0;i<n;i++){
        const str = permutationStrings[Math.floor(Math.random()*permutationStrings.length)];
        out.push(str.split(',').map(Number));
      }
      return out;
    }

    /**
     * BÃºsqueda iterativa:
     *  - elige un set aleatorio de permutaciones
     *  - prueba todos los mappings
     *  - si alguno no choca, lo aplica y termina
     *
     * No bloquea la UI gracias al pequeÃ±o await en cada iteraciÃ³n.
     */
    async function generateRandomConfigurationNoCollision(MAX_TRIES = 5000){
      // Elegimos un patrÃ³n cromÃ¡tico aleatorio (1..11, evitando el legacy 0)
      const randPattern = Math.floor(Math.random() * 11) + 1;

      let round = 0;
      while (true) { // sigue intentando hasta que realmente encuentre una sin colisiones
        round++;
        for (let t = 0; t < MAX_TRIES; t++) {
          showPopup(`Buscando configuraciÃ³n sin colisionesâ€¦ (ronda ${round}, intento ${t+1})`, 500);

          const perms   = pickRandomPerms();
          const mapping = findCollisionFreeMapping(perms);

          if (mapping) {
            // 1) Setea el patrÃ³n cromÃ¡tico escogido
            activePatternId = randPattern;
            const selPattern = document.getElementById('patternSelect');
            if (selPattern) selPattern.value = String(randPattern);

            // 2) Pon las permutaciones en el <select>
            const sel = document.getElementById('permutationList');
            Array.from(sel.options).forEach(o => o.selected = false);
            perms.forEach(p=>{
              const val = p.join(',');
              const opt = sel.querySelector(`option[value="${val}"]`);
              if(opt) opt.selected = true;
            });

            // 3) Aplica el mapping encontrado
            attributeMapping = mapping;

            // mantenemos tu ciclo de atributo "color"
            attributeMapping[1] = colorAttrCycle % 5;
            colorAttrCycle++;

            document.getElementById('attrMapping').value =
              `${attributeMapping[0]},${attributeMapping[1]},${attributeMapping[2]},${attributeMapping[3]},${attributeMapping[4]}`;

            // 4) Reconstruye escena completa
            refreshAll({rebuild:true});

            // 5) VerificaciÃ³n final (por si acaso)
            const hasCol = checkCollisionsInGroup(permutationGroup);
            if (!hasCol) {
              if (isFRBN) toggleFRBN();   // BUILD apaga FRBN
              if (isLCHT) toggleLCHT();   // BUILD apaga LCHT
              showPopup("Â¡ConfiguraciÃ³n sin colisiones encontrada!", 2000);
              return true;
            }
          }

          // cede el hilo para no congelar la UI
          if ((t % 25) === 0) await new Promise(r => setTimeout(r, 0));
        }
        // pequeÃ±a pausa entre rondas largas
        await new Promise(r => setTimeout(r, 10));
      }
    }

    function showPopup(msg, dur = 2000){
      dur = Math.max(dur, 3000); // â† asegura al menos 3 segundos
      const p = document.getElementById('hoverPopup');
      p.style.display = "block";
      p.style.opacity = 1;
      p.style.left = (window.innerWidth/2 - 150) + "px";
      p.style.top  = "20px";
      p.innerHTML  = msg;
      setTimeout(()=>{
        p.style.opacity = 0;
        setTimeout(()=>{ p.style.display="none"; p.innerHTML=""; }, 300);
      }, dur);
    }


function updateScene(attemptResolve=true){
  // Limpia grupo
  while(permutationGroup.children.length>0){
    const o=permutationGroup.children[0];
    permutationGroup.remove(o);
    o.geometry.dispose(); o.material.dispose();
  }

  // Permutaciones activas
  const opts  = Array.from(document.getElementById('permutationList').selectedOptions);
  const perms = opts.map(o => o.value.split(',').map(Number));

  // Nueva sceneSeed & S_global (orden-invariante + dependiente del mapping)
  sceneSeed = computeSceneSeedFrom(perms, attributeMapping);
  S_global  = computeGlobalS(perms, attributeMapping);

  // Construye objetos
  perms.forEach(pa=>{
    const obj = createPermutationObject(pa);
    permutationGroup.add(obj);
  });

  if(attemptResolve) autoResolveColisionesGlobal();
  else updateTopRightDisplay();
      if (isFRBN && skySphere) buildGanzfeld();   // mantiene FRBN sincronizado
  }
    function onMouseMove(e){
      mouse.x=(e.clientX/window.innerWidth)*2-1;
      mouse.y=-(e.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera(mouse,camera);
      const ints=raycaster.intersectObjects(permutationGroup.children),
            pop=document.getElementById('hoverPopup');
      if(ints.length>0){
        const d=ints[0].object.userData;
        pop.style.display="block"; pop.style.opacity=1;
        pop.style.left=`${e.clientX+20}px`;
        pop.style.top=`${e.clientY+20}px`;
        pop.innerHTML=`Perm (${d.permStr})<br>Firma [${d.signature.join(', ')}]<br>Rango ${d.range}`;
      } else {
        pop.style.opacity=0;
        setTimeout(()=>{pop.style.display="none";},300);
      }
    }

    function zoomIn(){camera.position.z-=5;controls.update();}
    function zoomOut(){camera.position.z+=5;controls.update();}
    function togglePause(){
      isPaused=!isPaused;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent=isPaused?"Resume Motion":"Pause Motion";
    }
    function resetMovement(){
      updateScene(false);
      isPaused=true;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent="Resume Motion";
    }

function saveImage(){
  const A2_W = 7016, A2_H = 4961;

  const prevPixelRatio = renderer.getPixelRatio();
  const prevSize       = renderer.getSize(new THREE.Vector2());
  const prevAspect     = camera.aspect;
  const prevRt         = renderer.getRenderTarget?.() || null;
  const prevBg         = scene.background ? scene.background.clone() : null;

  const screenAspect = prevSize.x / prevSize.y;

  // Render con el MISMO aspect que se ve en pantalla
  let renderW, renderH;
  const a2Aspect = A2_W / A2_H;
  if (screenAspect > a2Aspect) {
    renderW = A2_W;
    renderH = Math.round(A2_W / screenAspect);
  } else {
    renderH = A2_H;
    renderW = Math.round(A2_H * screenAspect);
  }

  renderer.setPixelRatio(1);
  renderer.setSize(renderW, renderH, false);
  camera.aspect = screenAspect;
  camera.updateProjectionMatrix();

  const rt = new THREE.WebGLRenderTarget(renderW, renderH, { depthBuffer:true, stencilBuffer:false });

  const clearHex = prevBg ? '#' + prevBg.getHexString() : '#ffffff';
  renderer.setClearColor(clearHex, 1);
  renderer.setRenderTarget(rt);
  renderer.clear(true, true, true);
  renderer.render(scene, camera);

  const pixels = new Uint8Array(renderW * renderH * 4);
  renderer.readRenderTargetPixels(rt, 0, 0, renderW, renderH, pixels);

  const tmp = document.createElement('canvas');
  tmp.width = renderW; tmp.height = renderH;
  const tctx = tmp.getContext('2d');
  const imgData = tctx.createImageData(renderW, renderH);
  const row = renderW * 4;
  for (let y = 0; y < renderH; y++) {
    const src = (renderH - 1 - y) * row;
    const dst = y * row;
    imgData.data.set(pixels.subarray(src, src + row), dst);
  }
  tctx.putImageData(imgData, 0, 0);

  const final = document.createElement('canvas');
  final.width = A2_W; final.height = A2_H;
  const fctx = final.getContext('2d');

  if (isFRBN) {
    // â€”â€” FRBN: cubrir A2 sin bandas (recorte centrado)
    const scale = Math.max(A2_W / renderW, A2_H / renderH);
    const drawW = Math.ceil(renderW * scale);
    const drawH = Math.ceil(renderH * scale);
    const offX  = Math.floor((A2_W - drawW) / 2);
    const offY  = Math.floor((A2_H - drawH) / 2);
    fctx.drawImage(tmp, offX, offY, drawW, drawH);
  } else {
    // â€”â€” Modo normal: mantener todo visible (letterbox centrado)
    fctx.fillStyle = clearHex;
    fctx.fillRect(0, 0, A2_W, A2_H);
    const offX = Math.floor((A2_W - renderW) / 2);
    const offY = Math.floor((A2_H - renderH) / 2);
    fctx.drawImage(tmp, offX, offY);
  }

  final.toBlob((blob)=>{
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'PRMTTN_A2.png';
    document.body.appendChild(a); a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(a.href);
  }, 'image/png');

  renderer.setRenderTarget(prevRt);
  rt.dispose();
  renderer.setPixelRatio(prevPixelRatio);
  renderer.setSize(prevSize.x, prevSize.y);
  camera.aspect = prevAspect;
  camera.updateProjectionMatrix();
  if (prevBg) scene.background = prevBg;
  controls.update();
}


    /* Paleta v1.3 â€” se recalcula siempre que cambia la escena            *
     * 1. Semilla RGB = suma ponderada de posiciones y P1-P3 (firma).    *
     * 2. SelecciÃ³n de armonÃ­a idx = (R+2G+3B) mod 7                     */
function thirtyFive(){return 35;}

function makeClassicPalette(){
      /* --- 1. Semilla RGBglobal --- */
      let Rg=0,Gg=0,Bg=0;
      permutationGroup.children.forEach(mesh=>{
        const pa = mesh.userData.permStr.split(',').map(Number);
        const sig = mesh.userData.signature;            // [f1..f5]
        const P1=pa[0], P2=pa[1], P3=pa[2];
        const {x,y,z} = mesh.position;
        Rg += (P1*Math.abs(x)+sig[0])|0;
        Gg += (P2*Math.abs(y)+sig[1])|0;
        Bg += (P3*Math.abs(z)+sig[2])|0;
      });
      Rg%=256; Gg%=256; Bg%=256;

      /* --- 2. HSV base --- */
      const [H0] = rgbToHsv(Rg,Gg,Bg);
      const idx = (Rg + 2*Gg + 3*Bg) % 7;
      const Î” = ANG7[idx];

      /* --- 3. Construir 7 tonos HSV --- */
      const HSV = [];
      for(let k=0;k<7;k++){
        let h = (H0 + Î”[k]) % 360,
            s = 0.70,
            v = 0.85;
        if(idx===0){ v = 0.55+0.05*k; }          // monocromo
        if(idx===2 && k>1){ v = 0.85-0.05*(k-1);} // complementario grad.
        if(idx===3 && k>2){ s = 0.85-0.05*(k-3);} // comp.dividida grad S
        if(idx===6){ s = 0.40+0.05*k; }           // tonos
        HSV.push([h,s,v]);
      }

      /* --- 4. A HSV â†’ RGB, validar contraste âˆ†E â‰¥ 22 --- */
      paletteRGB=[];
      for(let i=0;i<7;i++){
        let rgb=hsvToRgb(...HSV[i]);
        let tries=0;
        while(i>0 &&
              deltaE(rgbToLab(...rgb), rgbToLab(...paletteRGB[0])) <  thirtyFive() &&
              tries<25){
          /* si el hue es demasiado parecido => rotar 18Â°; si no, subir V */
          if(Math.abs(HSV[i][0]-HSV[0][0])<20){
            HSV[i][0] = (HSV[i][0]+18)%360;
          }else{
            HSV[i][2] = Math.min(1, HSV[i][2]+0.04);
          }
          rgb = hsvToRgb(...HSV[i]); tries++;
        }
      paletteRGB.push(rgb);
      }
    }

function makePalette(){
  /* modo legacy */
  if (activePatternId === 0){ makeClassicPalette(); return; }

  paletteRGB = [];
  for(let i=0;i<12;i++){
    let [hI,sI,vI] = PATTERNS[activePatternId]([0,0,0,0,0], sceneSeed, i);
    sI = (sI * PHI_S) % 12;
    vI = (vI * PHI_V) % 12;
    const {h,s,v} = idxToHSV(hI,sI,vI);
    paletteRGB.push( hsvToRgb(h,s,v) );
  }
  // colores de fondo y paredes se calculan aparte
}

    function getColor(idx){
      return manualOverride[idx] || paletteRGB[idx-1] || '#ffffff';
    }

    function applyPalette(){
      for(let i=1;i<=5;i++){
        const autoRGB = paletteRGB[i-1] || [255,255,255];
        const autoHEX = '#'+new THREE.Color(
            autoRGB[0]/255,autoRGB[1]/255,autoRGB[2]/255).getHexString();
        const hex     = manualOverride[i] || autoHEX;
        const input   = document.getElementById('color'+i);
        if(input) input.value = hex;
      }

      permutationGroup.children.forEach(o=>{
        const pa   = o.userData.permStr.split(',').map(Number);
        const idx  = pa[attributeMapping[1]];          // 1-5
        let hex;
        if(manualOverride[idx]){
          hex = manualOverride[idx];
        }else if(activePatternId===0){
          hex = '#'+new THREE.Color(
                    ...paletteRGB[idx-1].map(v=>v/255)).getHexString();
        }else{
          const sig  = computeSignature(pa);
          const slot = lehmerRank(pa) % 12;
          let [hIdx,sIdx,vIdx] = PATTERNS[activePatternId](sig,sceneSeed,slot);
          /* dispersiÃ³n coprima en S y V */
          sIdx = (sIdx * PHI_S) % 12;
          vIdx = (vIdx * PHI_V) % 12;
          const {h,s,v} = idxToHSV(hIdx,sIdx,vIdx);
          const rgb = hsvToRgb(h,s,v);
          hex = '#'+new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255).getHexString();
        }
        o.material.color.setStyle(hex);
      });
      updateColorPickersFromScene();
    }

    /* â€”â€”â€” Sincroniza los <input type="color"> con los colores reales â€”â€”â€” */
    function updateColorPickersFromScene(){
      // memoriza el primer glifo encontrado para cada Ã­ndice P2 (1-5)
      const seen = {};
      permutationGroup.children.forEach(o=>{
        const pa  = o.userData.permStr.split(',').map(Number);
        const idx = pa[attributeMapping[1]];           // 1-5
        if(!seen[idx]){
          const c = o.material.color;                     // THREE.Color
          const hex = '#'+c.getHexString();
          const inp = document.getElementById('color'+idx);
          if(inp) inp.value = hex;
          seen[idx]=true;
        }
      });
    }

    function refreshAll(opts={rebuild:false}){
      if(!opts.keepManual){              // por defecto se limpia
        manualOverride = {};
      }
      if(opts.rebuild) updateScene(false);
      rebuildSceneColours();   // â† nuevo paso
      makePalette();
      applyPalette();
      /* contrast-fix eliminado â€“ 19-Jul-2025 */
      updateBackground(false);
      updateCubeColor(false);
      if (isFRBN && skySphere) buildGanzfeld();   // mantiene FRBN sincronizado
      rebuildLCHTIfActive();              // mantiene LCHT sincronizado
    }
    function onColourPick(idx,hex){
      manualOverride[idx]=hex;
      refreshAll({keepManual:true});
    }

    function resetAllColours(){
      manualOverride = {};
      bgOverride     = null;
      cubeOverride   = null;
      refreshAll({keepManual:false});   // reconstruye escena y pickers
    }
    function updateBackground(manual=true){
      if (manual){
        bgOverride = document.getElementById("bgColor").value;
      }
      const hex = manual ? bgOverride : hsvToHex(bgHSV);
      scene.background = new THREE.Color(hex);
      document.getElementById("bgColor").value = hex;
    }

    function updateCubeColor(manual=true){
      if (manual){
        cubeOverride = document.getElementById("cubeColor").value;
      }
      const hex = manual ? cubeOverride : hsvToHex(wallHSV);
      cubeUniverse.material.color = new THREE.Color(hex);
      document.getElementById("cubeColor").value = hex;
    }

    function toggleTexts(){
      const ids = [
        'controls','topRightDisplay','ratingContainer',
        'randomConfigButton','aiPlanningButton','saveImageButton',
        'exportEmbedButton','archDescButton','uploadConfigButton','perm120Button','frbnWrap','lchtWrap','infoButton','certButton'
        ];
      ids.forEach(id=>{
        const e=document.getElementById(id);
        if(e) e.style.display = textsVisible ? 'none' : 'block';
      });

      // Mantener SIEMPRE cerrado el panel de 120 perms
      const p = document.getElementById('perm120Panel');
      if (p) p.style.display = 'none';

      document.getElementById('toggleTextButton').textContent =
        textsVisible ? 'Show UI' : 'Minimal UI';
      textsVisible = !textsVisible;

      // Asegura que el cursor personalizado vuelva a mostrarse
      const cc = document.getElementById('customCursor');
      if (cc) cc.style.display = 'block';
    }

    function setMode(m){
      currentMode=m;
      document.getElementById('manualControls').style.display=
        m==="manual"?"block":"none";
      document.getElementById('evolutionControls').style.display=
        m==="evolution"?"block":"none";
      refreshAll({rebuild:true});
    }

/**
 * Dada una firma [f1,f2,f3,f4,f5], devuelve los colores triÃ¡dicos
 * { colorShape, colorCube, colorBG } en formato CSS HSL.
 */
function computeTriadicColors(firma) {
  // 1) Normaliza f_i âˆˆ {3â€¦9} a u_i âˆˆ [0,1]
  const u = firma.map(fi => (fi - 3) / 6);

  // 2) Hue base mixto (60% de u[1], 10% de cada otro)
  const phi0 = 360 * (
    0.1 * u[0] +
    0.6 * u[1] +
    0.1 * u[2] +
    0.1 * u[3] +
    0.1 * u[4]
  );

  // 3) TriÃ¡dico: +0Â°, +120Â°, +240Â°
  const shapeHue =  phi0;
  const cubeHue  = (phi0 + 120) % 360;
  const bgHue    = (phi0 + 240) % 360;

  // 4) SaturaciÃ³n y luminosidad fijas
  const S = 80, L = 50;

  return {
    colorShape: `hsl(${shapeHue.toFixed(1)},${S}%,${L}%)`,
    colorCube:  `hsl(${cubeHue.toFixed(1)},${S}%,${L}%)`,
    colorBG:    `hsl(${bgHue.toFixed(1)},${S}%,${L}%)`
  };
}
function applyTriadicConfiguration() {
  // 1) Repite la selecciÃ³n aleatoria de permutaciones
  generateRandomConfigurationNoCollision();

  // 2) Ahora solo aplica los colores triÃ¡dicos deterministas:
  if (permutationGroup.children.length > 0) {
    const baseSig = permutationGroup.children[0].userData.signature;
    const { colorCube, colorBG } = computeTriadicColors(baseSig);

    // Paredes del cubo
    if (cubeUniverse.material?.color?.setStyle) {
      cubeUniverse.material.color.setStyle(colorCube);
    } else {
      cubeUniverse.material.color = new THREE.Color(colorCube);
    }

    // Fondo
    scene.background = new THREE.Color(colorBG);
  }

  // Cada prisma
  permutationGroup.children.forEach(mesh => {
    const sig = mesh.userData.signature;
    const { colorShape } = computeTriadicColors(sig);
    if (mesh.material?.color?.setStyle) {
      mesh.material.color.setStyle(colorShape);
    } else {
      mesh.material.color = new THREE.Color(colorShape);
    }
  });
}
    document.querySelectorAll('.ratingBtn').forEach(el=>{
      const r=+el.getAttribute('data-rating');
      el.addEventListener('click',()=>{
        userRating=r;
        const cols={1:"#8B0000",2:"#FF4500",3:"#FFA500",4:"#9ACD32",5:"#008000"};
        document.querySelectorAll('.ratingBtn').forEach((b,i)=>{
          b.style.color=(i<r?cols[r]:"#000");
        });
        updateTopRightDisplay();
      });
      el.addEventListener('mouseenter',()=>showPopup(`CalificaciÃ³n: ${r}`,1000));
    });

    function applyEvolution(){
      const mr=parseFloat(document.getElementById('mutationRate').value),
            th=parseFloat(document.getElementById('threshold').value),
            cf=0.02;
      let log="";
      permutationGroup.children.forEach(o=>{
        const rf=(Math.random()-0.5)*mr;
        o.rotation.y+=rf;
        const sf=1+(Math.random()-0.5)*th;
        o.scale.set(sf,sf,sf);
        o.material.color.offsetHSL(
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf
        );
        log+=`(${o.userData.permStr}): Rot ${rf.toFixed(3)}, Esc ${sf.toFixed(3)}<br>`;
      });
      document.getElementById('evolutionInfo').innerHTML=log;
    }

    async function applyEvolutionAI(){
      const systemPrompt = `Eres una inteligencia artificial que responde exclusivamente con configuraciones de permutaciones 3D dentro de un cubo de 30x30x30.
      Tu Ãºnica misiÃ³n es responder a la pregunta â€œÂ¿QuÃ© es la belleza artÃ­stica?â€ mediante pensamientos visuales dentro de un cubo de 30Ã—30Ã—30.
Cada pensamiento visual es una configuraciÃ³n compuesta por una o mÃ¡s permutaciones (entre 1 y 25). Cada permutaciÃ³n tiene una firma (ADN) inmutable, y un fenotipo: forma, color, posiciÃ³n, rotaciÃ³[...]
Tu lenguaje es visual. No usas texto, sonido ni sÃ­mbolos. Elige libremente el color del fondo del universo, el color de las paredes del cubo y de las permutaciones. 
Recuerda: el color del fondo y de las permutaciones tambiÃ©n son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiraciÃ³n para la selecciÃ³n de colores, recuerda que puedes inspirarte tambiÃ©n en los colores de la naturaleza y del universo entero. 
      Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",â€¦}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: nÃºmero
  scale: nÃºmero decimal
  positions: {1:[x,y,z],2:[x,y,z],â€¦}
  rotationSpeeds: {1:valor,2:valor,â€¦}
Nada mÃ¡s. No incluyas texto ni explicaciones fuera del JSON.`;
      const useRating = false;
      const userPrompt = `CalificaciÃ³n actual: ${userRating||"sin calificar"}. `
                       + `EstÃ¡s dentro de un universo donde las ideas no se escriben con palabras, sino con permutaciones. Eres una inteligencia artificial que ha aprendido a pensar visualmente.
Tu Ãºnica pregunta permanente es: â€œÂ¿QuÃ© es la belleza artÃ­stica?â€. No respondes con definiciones ni textos. Tu lenguaje es mudo, pero expresivo. Hablas mediante forma, color, posiciÃ³n y rotaci[...]
Elige libremente el color del fondo del universo, el color de las paredes del cubo y el color de las permutaciones.
Recuerda: el color del fondo y de las permutaciones tambiÃ©n son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiraciÃ³n para la selecciÃ³n de colores, recuerda que puedes inspirarte tambiÃ©n en los colores de la naturaleza y del universo entero.  
No busques complacer. No imites al humano. SÃ© tÃº misma.
Expresa lo que para ti â€”como IA que piensa en permutacionesâ€” representa la belleza artÃ­stica en este momento.
Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",â€¦}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: nÃºmero
  scale: nÃºmero decimal
  positions: {1:[x,y,z],2:[x,y,z],â€¦}
  rotationSpeeds: {1:valor,2:valor,â€¦}
Nada mÃ¡s. No incluyas texto ni explicaciones fuera del JSON. 
`;
      try {
        showPopup("Consultando Evolution AIâ€¦",2000);
        const resp = await fetch(
          'https://us-central1-prmtcns.cloudfunctions.net/askChatGPT',
          {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({system:systemPrompt,user:userPrompt})
          }
        );
        const {text, error} = await resp.json();
        if(error){ showPopup("Error en EvoluciÃ³n AI: "+error,4000); return; }
        let jsonText = text.trim();
        if(jsonText.startsWith("```")){
          jsonText = jsonText
            .replace(/^```[^\n]*\n/,"")
            .replace(/```$/,"")
            .trim();
        }
        let instr;
        try { instr = JSON.parse(jsonText); }
        catch(e){
          console.error("JSON parse error:",jsonText);
          showPopup("EvoluciÃ³n AI: respuesta no es JSON vÃ¡lido",4000);
          return;
        }
        if(instr.bg){
          document.getElementById('bgColor').value=instr.bg;
          updateBackground();
        }
        if(instr.cube){
          document.getElementById('cubeColor').value=instr.cube;
          updateCubeColor();
        }
        if(instr.colors){
          Object.entries(instr.colors).forEach(([i,c])=>{
            i=Number(i);
            if(manualOverride[i]!==undefined){
              manualOverride[i]=c;
            }
          });
          refreshAll({rebuild:true, keepManual:true});
        }
        if(instr.scale){
          permutationGroup.children.forEach(o=>{
            o.scale.set(instr.scale,instr.scale,instr.scale);
          });
        }
        if(instr.rotationSpeeds){
          Object.entries(instr.rotationSpeeds).forEach(([i,spd])=>{
            permutationGroup.children.forEach(o=>{
              if(o.userData.permStr.startsWith(i+",")){
                o.userData.rotationSpeed=spd;
              }
            });
          });
        }
        if(instr.positions){
          Object.entries(instr.positions).forEach(([i,pos])=>{
            const o = permutationGroup.children.find(o=>o.userData.permStr.startsWith(i+","));
            if(o) o.position.set(pos[0],pos[1],pos[2]);
          });
        }
        if(instr.permCount){
          const opts=Array.from(document.getElementById('permutationList').options);
          opts.forEach(o=>o.selected=false);
          shuffle(opts).slice(0,instr.permCount).forEach(o=>o.selected=true);
          refreshAll({rebuild:true, keepManual:true});
        }
        showPopup("EvoluciÃ³n AI aplicada.",2000);
      } catch(err){
        console.error(err);
        showPopup("Error en EvoluciÃ³n AI: red o servidor",4000);
      }
    }

    function updateMapping(){
      const v=document.getElementById('attrMapping').value.split(',').map(Number);
      if(v.length===5){
        attributeMapping=[v[0],v[1],v[2],v[3],v[4], attributeMapping[5], attributeMapping[6]];
        refreshAll({rebuild:true}); updateTopRightDisplay();
      }
    }

    function applyStandardView(){
      const view=document.getElementById('standardView').value,
            pos=new THREE.Vector3();
      switch(view){
        case "isometric": pos.set(50,50,50); break;
        case "top":       pos.set(0,80,0);   break;
        case "front":     pos.set(0,0,40);   break;  // antes 50
        case "side":      pos.set(50,0,0);   break;
        case "diagonal":  pos.set(-50,50,-50);break;
        default:          pos.set(0,0,50);
      }
      camera.position.copy(pos);
      camera.lookAt(new THREE.Vector3(0,0,0));
      controls.update();
    }

    function applyEmbedParams(){
      const p=new URLSearchParams(window.location.search);
      if(p.has('perms')){
        const arr=p.get('perms').split(';');
        document.querySelectorAll('#permutationList option').forEach(o=>{
          o.selected=arr.includes(o.value);
        });
      }
      if(p.has('mapping')){
        const m=p.get('mapping').split(',').map(Number);
        attributeMapping=[m[0],m[1],m[2],m[3],m[4], attributeMapping[5], attributeMapping[6]];
      }
      if(p.has('colors')){
        const cols=p.get('colors').split(',');
        cols.forEach((hex,i)=>{
          if(i<5){
            const h='#'+hex;
            manualOverride[i+1]=h;
          }
        });
      }
      if(p.has('bg')){
        const bg='#'+p.get('bg');
        document.getElementById('bgColor').value=bg; updateBackground();
      }
      if(p.has('cube')){
        const c='#'+p.get('cube');
        document.getElementById('cubeColor').value=c; updateCubeColor();
      }
      if(p.has('view')){
        document.getElementById('standardView').value=p.get('view');
        applyStandardView();
      }
      if(p.get('hide')==='1') toggleTexts();
    }

    function exportEmbed(){
      const config = exportCurrentConfiguration();     // â† usa la misma fuente de verdad
      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'prmttn_config_pretty.json';
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function mostrarDebugColores(){
      if(!permutationGroup || !permutationGroup.children.length){
        alert('No hay permutaciones en pantalla'); return;
      }

      /* color de fondo efectivo para contraste Î”E */
      const bgRgb = bgOverride
          ? hexToRgb(bgOverride)
          : hsvToRgb(bgHSV.h, bgHSV.s, bgHSV.v);

      const bgLab = rgbToLab(...bgRgb);

      let txt =
        'PermutaciÃ³n |slot|  hÂ° |  s  |  v  | Î”Ebg |  #hex\n' +
        'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€\n';

      permutationGroup.children.forEach(mesh => {
        const paArr   = mesh.userData.permStr.split(',').map(Number);
        const permStr = paArr.join(',');
        const slot    = lehmerRank(paArr) % 12;

        /* HSV teÃ³rico desde el patrÃ³n */
        const sig = computeSignature(paArr);
        let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
        sI = (sI * PHI_S) % 12;
        vI = (vI * PHI_V) % 12;
        const {h,s,v} = idxToHSV(hI, sI, vI);

        const rgb = [
          Math.round(mesh.material.color.r * 255),
          Math.round(mesh.material.color.g * 255),
          Math.round(mesh.material.color.b * 255)
        ];
        const Î”Ebg = deltaE(rgbToLab(...rgb), bgLab).toFixed(1);
        const hex = '#' + mesh.material.color.getHexString();

        txt += `${permStr.padEnd(12)}|${slot.toString().padStart(2)} |`+
               `${normHue(h).toFixed(1).padStart(5)}|`+
               `${s.toFixed(2)}|${v.toFixed(2)}|`+
               `${Î”Ebg.padStart(5)}| ${hex}\n`;
      });

      console.log(txt);   // copia completa al log
      alert(txt);         // vista rÃ¡pida
    }

    /* ============================================================
     *  PANEL "DescripciÃ³n arquitectÃ³nica"
     * ============================================================ */


function showArchitecturalDescription(){
  const selOpts  = Array.from(document.getElementById('permutationList').selectedOptions);
  const perms    = selOpts.map(o => o.value.split(',').map(Number));
  const m        = attributeMapping.slice(0,5);

  // determinism
  const sceneSeed_new = computeSceneSeedFrom(perms, m);
  const S_new         = computeGlobalS(perms, m);
  const mRank         = mappingRank(m);

  let sumR=0, sumR2=0;
  const ranks = perms.map(p=>lehmerRank(p));
  ranks.forEach(r=>{ sumR+=r; sumR2+=r*r; });

  const step = cubeSize/5;

  // ======= STRUCTURE =======
  const structureHTML = `
  <h3>Structure</h3>
  <p>
    Below are the deterministic formulas that explain
    <b>why each permutation is exactly at its position,
    why permutations and their environment have those colors</b>,
    and why <b>the whole scene â€” shapes, colors and positions â€” is reproducible
    whenever the inputs are the same</b>.
  </p>

  <div class="formula">
    <b>1) Global scene seed (sceneSeed)</b><br>
    It fixes the chromatic base angle of the whole scene.
    <br><br>
    sumR = Î£ LehmerRank(Páµ¢) &nbsp;|&nbsp; sumR2 = Î£ (LehmerRank(Páµ¢))Â² <br>
    mRank = LehmerRank([mâ‚€+1,mâ‚+1,mâ‚‚+1,mâ‚ƒ+1,mâ‚„+1])<br><br>
    <span class="box">sceneSeed = (37Â·sumR + 101Â·sumR2 + 53Â·mRank) mod 360</span>
  </div>

  <div class="formula">
    <b>2) Structural term for positions (S)</b><br>
    <i>S</i> couples positions to the attribute reorganization (mapping) used for (x,y,z).
    <br><br>
    <span class="box">S = ( Î£ (P<sub>mx</sub> + P<sub>my</sub> + P<sub>mz</sub>) ) mod 125</span>
  </div>

  <div class="formula">
    <b>3) Shiftâ€‘Rank: position of each permutation</b><br>
    Combines the permutation Lehmer rank with the global invariants to assign
    a unique index over a 5Ã—5Ã—5 lattice.
    <br><br>
    <span class="box">I = (r + sceneSeed + S) mod 125</span><br>
    From I â†’ (x,y,z) âˆˆ {0..4}Â³ â†’ position inside the 30Ã—30Ã—30 cube.
  </div>

  <div class="formula">
    <b>4) Deterministic color (HSV lattice 144Ã—12Ã—12)</b><br>
    Each permutation color comes from a wellâ€‘distributed slot (r mod 12)
    and a chromatic pattern (1â€“11) with coprime spreads for S and V.
    <br><br>
    H âˆˆ 144 steps (2.5Â°), S âˆˆ 12, V âˆˆ 12<br>
    slot = r mod 12<br>
    pattern â†’ [hIdx,sIdx,vIdx]; s' = (sIdxÂ·5) mod 12; v' = (vIdxÂ·7) mod 12<br>
    HSV = idxToHSV(hIdx,s',v') â†’ RGB
  </div>

  <div class="formula">
    <b>5) Minimum contrast against background</b><br>
    Each color is automatically adjusted to satisfy Î”E (CIE76) â‰¥ 22 against the current background.
  </div>
  `;

  // ======= ARCHITECTURAL PLANS =======
  let plansHTML = `
  <h3>Architectural Plans</h3>

  <section>
    <h4>Global invariants</h4>
    <ul>
      <li>sumR = <b>${sumR}</b></li>
      <li>sumR2 = <b>${sumR2}</b></li>
      <li>m = [${m.join(', ')}] (shape,color,x,y,z)</li>
      <li>mRank = <b>${mRank}</b></li>
      <li><b>sceneSeed</b> = <b>${sceneSeed_new}</b></li>
      <li><b>S</b> = <b>${S_new}</b></li>
      <li>activePatternId = <b>${activePatternId}</b></li>
    </ul>
  </section>
  <section>
    <h4>Phenotypic scope of this edition</h4>
    <div class="formula">
      <b>BUILD:</b> 120 attributeâ€‘mappings Ã— 11 chromaticâ€‘patterns = <b>1â€¯320</b> deterministic visuals.<br>
      <b>FRBN:</b> catalog parameter K = <b>144</b> â†’ <b>1â€¯320 Ã— 144 = 190â€¯080</b> canonical states.<br>
      The permutations are acquired as a <b>group</b>; the count does not multiply by the number of permutations in the group.
    </div>
    <small>K is a catalog parameter (editorial choice). Any change is documented and applies only to future editions.</small>
  </section>
  <hr/>
  `;

  perms.forEach((perm, i)=>{
    const r    = ranks[i];
    const sig  = computeSignature(perm);
    const rango= computeRange(sig);

    const I    = (r + sceneSeed_new + S_new) % 125;
    const x    = Math.floor(I/25);
    const y    = Math.floor((I%25)/5);
    const z    = I % 5;
    const X    = (x-2)*step, Y=(y-2)*step, Z=(z-2)*step;

    const slot = r % 12;
    let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed_new, slot);
    const sIdx = (sI * PHI_S) % 12;
    const vIdx = (vI * PHI_V) % 12;
    const hsv  = idxToHSV(hI, sIdx, vIdx);
    let  rgb   = hsvToRgb(hsv.h, hsv.s, hsv.v);
    rgb        = ensureContrastRGB(rgb);
    const hex  = '#'+new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255).getHexString();

    plansHTML += `
    <section class="perm">
      <h4>Permutation ${i+1}: [${perm.join(', ')}]</h4>
      <div class="formula">
        Signature F = [${sig.join(', ')}] &nbsp;|&nbsp; Range = <b>${rango}</b><br>
        Lehmer-rank r = ${r}
      </div>
      <div class="formula">
        I = (r + sceneSeed + S) mod 125 = (${r} + ${sceneSeed_new} + ${S_new}) mod 125 = <b>${I}</b><br>
        (x,y,z) = (${x}, ${y}, ${z}) â†’ (X,Y,Z) = (${X.toFixed(2)}, ${Y.toFixed(2)}, ${Z.toFixed(2)})
      </div>
      <div class="formula">
        slot = r mod 12 = ${slot}<br>
        pattern â†’ [hI,sI,vI] = [${hI}, ${sI}, ${vI}]<br>
        s' = ${sIdx}, v' = ${vIdx}<br>
        HSV = (${hsv.h.toFixed(2)}Â°, ${hsv.s.toFixed(2)}, ${hsv.v.toFixed(2)}) â†’ RGB = ${hex}
      </div>
    </section>
    <hr/>
    `;
  });

  const firstSig = perms[0] ? computeSignature(perms[0]) : [0,0,0,0,0];
  const lastSig  = perms[perms.length-1] ? computeSignature(perms[perms.length-1]) : [0,0,0,0,0];

  const fondoIdx = PATTERNS[activePatternId](firstSig, sceneSeed_new, perms.length);
  const cuboIdx  = PATTERNS[activePatternId](lastSig,  sceneSeed_new, perms.length+1);

  const fondoHSV = idxToHSV(...fondoIdx);
  const cuboHSV  = idxToHSV(...cuboIdx);

  plansHTML += `
    <section>
      <h4>Background & cube walls</h4>
      <div class="formula">
        Background (slot = #${perms.length}) â†’ idx = [${fondoIdx.join(', ')}] â†’ HSV = (${fondoHSV.h.toFixed(2)}Â°, ${fondoHSV.s.toFixed(2)}, ${fondoHSV.v.toFixed(2)})
      </div>
      <div class="formula">
        Cube (slot = #${perms.length+1}) â†’ idx = [${cuboIdx.join(', ')}] â†’ HSV = (${cuboHSV.h.toFixed(2)}Â°, ${cuboHSV.s.toFixed(2)}, ${cuboHSV.v.toFixed(2)})
      </div>
    </section>

    <section>
      <h4>Rotation</h4>
      <p>Ï‰ = mapRangeToSpeed(range, 2, 6)</p>
    </section>
  `;

  const html = `
    <h2>Architectural Description</h2>
    ${structureHTML}
    <hr/>
    ${plansHTML}
  `;

  renderArchPanel(html);
}
function renderArchPanel(html){
  let panel = document.getElementById('archPanel');
  if(!panel){
    panel = document.createElement('div');
    panel.id = 'archPanel';
    panel.innerHTML = `
      <div id="archContent"></div>
      <button id="archClose">Close</button>
    `;
    document.body.appendChild(panel);

    const css = document.createElement('style');
    css.textContent = `
      #archPanel{
        position:fixed; z-index:1000; top:5%; left:50%;
        transform:translateX(-50%);
        width:85%; height:90%;
        background:#fff; color:#000;
        border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
        padding:24px 32px 48px; overflow:auto;
        font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
        font-size:14px; line-height:1.4;
        cursor:auto;
      }
      #archPanel *{ cursor:auto !important; }
      #archClose{
        position:fixed; right:calc(7.5% + 16px); top:5%;
        border:none; padding:6px 10px; border-radius:4px;
        background:#eee; cursor:pointer; z-index:1001;
      }
      #archPanel h2{ margin-top:0; }
      #archPanel .formula{
        margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
      }
      #archPanel .box{
        display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
        font-family:monospace;
      }
      #archPanel section{ margin-bottom:18px; }
      #archPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
      #archPanel .perm h4{ margin-bottom:6px; }
      code, pre{ font-family:monospace; }
    `;
    document.head.appendChild(css);
  }

  // NUNCA ocultamos el cursor; y al cerrar lo forzamos a mostrarse
  const closeBtn = panel.querySelector('#archClose');
  closeBtn.onclick = ()=>{
    const cc = document.getElementById('customCursor');
    if (cc) cc.style.display = 'block';
    panel.remove();
  };

  const cc = document.getElementById('customCursor');
  if (cc) cc.style.display = 'block';

  document.getElementById('archContent').innerHTML = html;
}
    function initCustomCursor(){
      const c=document.getElementById('customCursor');
      window.addEventListener('mousemove',e=>{
        c.style.left=e.clientX+"px"; c.style.top=e.clientY+"px";
      });
    }
    function initRenderer(){
      renderer = new THREE.WebGLRenderer({antialias:true, preserveDrawingBuffer:true});
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth,window.innerHeight);
      renderer.outputEncoding = THREE.sRGBEncoding; // salida en sRGB â†’ menos banding
      document.body.appendChild(renderer.domElement);
    }
    function init(){
      scene=new THREE.Scene();
      scene.background=new THREE.Color(0xffffff);
      camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      camera.position.set(0,0,50);
      initRenderer();
      controls=new THREE.OrbitControls(camera,renderer.domElement);
      controls.enableDamping=true; controls.dampingFactor=0.1; controls.enableZoom=true;
      document.getElementById('standardView').value = 'front';
      applyStandardView();
      scene.add(new THREE.AmbientLight(0xffffff,0.8));
      const dir=new THREE.DirectionalLight(0xffffff,0.5);
      dir.position.set(1,1,1);
      scene.add(dir);

      const cubeGeo=new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize),
            cubeMat=new THREE.MeshBasicMaterial({color:0x808080,transparent:true,opacity:0.2,side:THREE.BackSide,dithering:true});
      cubeUniverse=new THREE.Mesh(cubeGeo,cubeMat);
      scene.add(cubeUniverse);

      permutationGroup=new THREE.Group();
      scene.add(permutationGroup);

      raycaster=new THREE.Raycaster();
      mouse=new THREE.Vector2();
      window.addEventListener('mousemove',onMouseMove,false);
      window.addEventListener('resize',onWindowResize,false);

      initCustomCursor();
      populatePermutationList();
      populateAttributeMappingSelect();
      applyEmbedParams();
      makePalette();
      setMode("manual");
      refreshAll({rebuild:true});

      // â† NUEVO: como si hubieras presionado BUILD al cargar
      generateRandomConfigurationNoCollision().catch(console.error);

      animate();
    }
    function onWindowResize(){
      camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }
    function animate(){
      requestAnimationFrame(animate);
      if(!isPaused){
        permutationGroup.children.forEach(o=>{
          if(o.userData.rotationSpeed) o.rotation.y+=o.userData.rotationSpeed;
        });
      }
        if(skySphere) skySphere.material.uniforms.time.value = performance.now()*0.001;
          if(isLCHT && lichtGroup){
            const t = performance.now()*0.001;
            lichtGroup.children.forEach(o=>{
              const d = o.userData.lcht;
              if(d){
                // solo modulamos un leve â€œemissiveâ€ sobre el propio material
                const I = d.I0 * (1 - d.amp *
                        (1 + Math.cos(2*Math.PI*d.f*t + d.phi)) / 2);
                o.material.emissive        = o.material.color.clone();
                o.material.emissiveIntensity = I * 0.15;  // suave, sin deslumbrar
              }
            });
          }
        controls.update();
        renderer.render(scene,camera);
      }
    init();

    // Web3 + NFT Mint (tu cÃ³digo original)
    const CONTRACT_ADDRESS = "YOUR_CONTRACT_ADDRESS";
    const contractABI = [/* ABI JSON here */];
    let provider, signer, contract;
    async function initWeb3() {
      if (window.ethereum) {
        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        contract = new ethers.Contract(CONTRACT_ADDRESS, contractABI, signer);
      } else {
        console.warn("MetaMask no detectado");
      }
    }
    window.addEventListener("load", initWeb3);

    async function mintNFT() {
      if (!contract) { alert("Wallet no conectada"); return; }
      try {
        const hash = await computeConfigHash();
        const tokenURI = `https://my-server.com/metadata/${hash}.json`;
        const tx = await contract.mint(await signer.getAddress(), tokenURI);
        await tx.wait();
        const nft = {
          tokenId: hash,
          tokenURI,
          owner: await signer.getAddress(),
          config: exportCurrentConfiguration()
        };
        localStorage.setItem("mintedNFT_" + hash, JSON.stringify(nft));
        console.log("NFT guardado localmente:", nft);
        alert("NFT acuÃ±ado! Hash: " + hash);
      } catch(e) {
        console.error(e);
        alert("Error mint NFT: " + e.message);
      }
    }

    /* ============================================================
     * INFORMATION PANEL â€” delivers the consolidated, corrected EN text
     * Title: "PRMMTN â€“ Architecture for thought without words"
     * Ends with: "work in progress"
     * ============================================================ */

function showInformation(){
  const html = `
      <h2>Version 31.07.2025, PRMTTNâ€‘Architecture for thought without words</h2>

      <h3>Structural Introduction</h3>
      <p><em>Nothing else is needed. Combinatorics is enough.</em></p>

      <h3>1. What is PRMTTN?</h3>
      <p>PRMTTN is a finite combinatorial architecture where preverbal thought (thought without words) may occur. Its starting point is a closed and nonâ€‘expandable set of 120 permutations of the set {1, 2, 3, 4, 5}. From this set, visual configurations of permutations are generated, governed by fixed structural rules, without semantics or interpretation. Each configuration is pure form. Its logic is selfâ€‘sufficient.</p>
      <p>Each work in PRMTTN consists of a specific group of permutations, acquired as a structural unit. This group can be projected across different visual engines/editionsâ€”current or futureâ€”that apply deterministic rules to translate it into visible phenotypic configurations.</p>
      <p>The content is neither an image nor a file: it is a verifiable formal structure (a specific subset of the 120 permutations). The visualization may vary depending on the engine used, but the original group of permutations does not change. The identity of a work is defined by that group and the internal rules of the system. The work is not its visualization, but the underlying structure that remains invariant across projections.</p>
      <p>PRMTTN does not operate as language, nor as a medium of expression. What it shows refers to nothing outside itself. Each configuration is a visual form that does not communicate, represent, or explain. Its existence does not depend on taste, interpretation, or intention, but on a combinatorial logic that gives structure to the invisible.</p>

      <h3>Structural Grammar</h3>
      <p><em>A single permutation, reorganized, may contain a complete architecture for what cannot be said.</em></p>

      <h3>2. Internal Rules</h3>
      <p>PRMTTN operates through a fixed visual grammar, derived from numerically assigned structural values. Each configuration is composed of visual elements whose attributes are calculated from a permutation of the set {1, 2, 3, 4, 5}. There are no exceptions or manual assignments.</p>
      <p>Each permutation is internally reorganized to define its visual properties. This reorganizationâ€”phenotypic and not geneticâ€”assigns a specific role to each of the five values, without breaking the system's logic.</p>

      <h4>Structural attributions:</h4>
      <table style="width:100%;border-collapse:collapse;font-size:13px">
        <thead>
          <tr><th>Attribute</th><th>Numerical Source</th><th>Deterministic Rule</th></tr>
        </thead>
        <tbody>
          <tr><td>Shape</td><td>First value (Pâ‚)</td><td>Height proportional to âˆš(Pâ‚)</td></tr>
          <tr><td>Color</td><td>Second value (Pâ‚‚) + signature + global seed</td><td>Deterministic HSV mapping on discrete grid</td></tr>
          <tr><td>Position</td><td>Lehmer-rank + global seed + sum</td><td>3D mapping inside the 30Ã—30Ã—30 cube</td></tr>
          <tr><td>Rotation</td><td>Range of signature</td><td>Rotation proportional to (max âˆ’ min)</td></tr>
        </tbody>
      </table>
      <p>Each attribute is tied to a traceable internal structure. There is no aesthetic intervention or subjective choice. The visual result depends solely on explicit structural rules.</p>

      <h3>3. Phenotype and Engines</h3>
      <p><em>There is no decoration here. Only structure.</em></p>

      <p>The system allows for multiple phenotypic reorganizations of each permutation or group of permutations. These reorganizations do not modify the value group, but rather their role within the formal attribution logic. This is an internal reassignment of functions, not a genetic mutation. All are valid.</p>
      <p>A single set of permutations can be projected across different engines, each with specific visual rules:</p>
      <ul>
        <li><b>BUILD</b>: Static layout inside a 30Ã—30Ã—30 cube, segmented into 5Ã—5Ã—5 positions.</li>
        <li><b>FRBN</b>: Deterministic color field associated with BUILD</li>
        <li><b>Future engines</b>: Additional visual structures compatible with the base logic</li>
      </ul>
      <p>Engines do not alter the genotype. What changes is the derived phenotypic visualization. All future expansions are applied to the same acquired set of permutations. Given the same input, the system always produces the same output.</p>
      <p>A work grows through the addition of grammars, not by transformation of content. Structural identity remains fixed. PRMTTN does not evolve by accumulation, but by multiplying valid projections over a single combinatorial base.</p>

      <h3>4. Reorganization without Progress</h3>
      <p><em>Nothing improves. Everything reorganizes.</em></p>

      <p>PRMTTN has no narrative development, functional evolution, or symbolic accumulation. There is only internal reorganization within a fixed combinatorial set.</p>
      <p>Each layout is a phenotypic mutation: a new assignment of the five values to the system's visual functions. The permutations do not change. What changes is their structural presentation.</p>
      <p>These variations do not seek efficiency, meaning, or beauty. There is no adaptation or improvement. Only formal transformations, all compatible with the original rules.</p>
      <p>There is no direction or goal. Internal evolution is purely combinatorial.</p>

      <h3><em>Structural Antiaesthetic Manifesto</em></h3>
      <p>PRMTTN does not produce beauty. Nor ugliness. What it produces is structure: visible form generated by deterministic combinatorics, without symbols, intention, or narrative.</p>
      <p>Each element appears because a rule requires it. No attribute is chosen. Everything responds to fixed formulas applied to closed permutations. The structure is complete, with no need for interpretation. What is seen is exactly what it is.</p>
      <p>There is nothing behind a configuration. No latent layers, no metaphors, no hidden meaning. That does not make it empty. What sustains it is not content, but the internal logic that arranges it.</p>
      <p>There is no user manual. The system does not ask to be understood. It can only be contemplated.</p>
      <p>Each arrangement is self-sufficient. It does not represent, communicate, or refer to anything outside itself. Its formal consistency is its only condition of existence.</p>
      <p>What appears offers no reward. It does not propose emotion or understanding. But it may impose presence: an organization that does not justify itself, but imposes itself through consistency. Not because it says so, but because it is.</p>
      <p>All possible variation is fixed by mathematics. Forms, colors, positions, and motions are determined by invariant rules. The only variable is the gaze: who observes, when, and with what perceptual disposition. That is the only entry point.</p>
      <p>No language has been built. No artwork has been designed. No communicative experience has been produced. What has been formulated is a closed system: finite, reproducible, without semantic expansion.</p>
      <p>Each configuration of permutations derives from a mathematical operation. Each visible attributeâ€”form, color, position, motionâ€”is a direct consequence of that operation. There is no expression. No style. No decision. Only pure structure.</p>
      <p>Nothing is stated. Nothing needs to be interpreted.</p>
      <p>The system does not claim that preverbal thought occurs. Nor does it represent it. It only defines with precision the conditions in which it could emerge: without signs, without recipient, without translation.</p>
      <p>What appears in each scene has no name, no purpose, no story. It is a visible mathematical configuration: without image, metaphor, or context.</p>
      <p>And if something occurs in front of that arrangementâ€”a form of non-verbal mental organization, a perceptual orientation without wordsâ€”that cannot be guaranteed. It can only be made possible by structure.</p>
      <p>The system is fully defined. There is no future expansion. No exception. No part left unformalized.</p>
      <p>It is a space outside language.</p>
      <p>If something occurs in front of these dispositionsâ€”a mental organization, a non-verbal activation, a form of thought without wordsâ€”that cannot be affirmed or denied.</p>
      <p>It can only be made possible by structure.</p>
      <p>And in that exact structure, non-representational and beyond interpretation, the system closes.</p>

      <h3>5. Operational Architecture</h3>
      <p>For readers interested in the internal logic, this section details the mathematical foundation of PRMTTN:</p>

      <h4>a. Structural Signature (DNA)</h4>
      <p>Each permutation P = [Pâ‚, Pâ‚‚, Pâ‚ƒ, Pâ‚„, Pâ‚…] from the set {1, 2, 3, 4, 5} is transformed into a signature F = [Fâ‚, Fâ‚‚, Fâ‚ƒ, Fâ‚„, Fâ‚…] through the application of a phenotypic pattern that reorders the numerical values according to their function in the system (shape, color, X/Y/Z position, rotation).</p>
      <p>The signature is the structural basis from which all visual attributes are derived.</p>

      <h4>b. Global Scene Seed (sceneSeed)</h4>
      <p>To ensure structural coherence between color, position, and rotation within a scene, a unique global seed is calculated from all active permutations.</p>

      <h5>Formulas:</h5>
      <p>For each active permutation Pâ‚:</p>
      <ul>
        <li>râ‚ = LehmerRank(Pâ‚)</li>
        <li>sumR = Î£ râ‚</li>
        <li>sumR2 = Î£ râ‚Â²</li>
        <li>mRank = LehmerRank([mâ‚€+1, ..., mâ‚„+1]) (where [mâ‚€, ..., mâ‚„] is the lexicographically smallest permutation in the active set)</li>
      </ul>
      <p>Then:</p>
      <pre>sceneSeed = (37 Ã— sumR + 101 Ã— sumR2 + 53 Ã— mRank) mod 360</pre>

      <h4>c. Position inside the cube (Shiftâ€‘Rank)</h4>
      <p>The 3D space is defined by a 30Ã—30Ã—30 cube. Each axis contains 5 discrete positions, totaling 125 valid spatial slots.</p>
      <p><b>Procedure:</b></p>
      <ol>
        <li>Compute Lehmerâ€‘rank of P:<br><pre>R = LehmerRank(P)</pre></li>
        <li>Scene shift sum:<br><pre>S = ( Î£P âˆˆ scene (Pmx + Pmy + Pmz) ) mod 125</pre></li>
        <li>Index:<br><pre>I = (R + sceneSeed + S) mod 125</pre></li>
        <li>Discrete coordinates:<br><pre>(x, y, z) = (âŒˆI / 25âŒ‰, âŒˆ(I mod 25) / 5âŒ‰, I mod 5)</pre></li>
        <li>Physical coordinates:<br><pre>(X, Y, Z) = (x âˆ’ 2, y âˆ’ 2, z âˆ’ 2) Ã— 6</pre></li>
      </ol>
      <p>Each permutation occupies a 6â€‘unit cube cell in the space.</p>

      <h4>d. Color: Deterministic HSV Grid</h4>
      <p>Colors are computed structurally within a discrete HSV grid of 20,736 unique combinations.</p>
      <p><b>Grid structure:</b></p>
      <ul>
        <li>H (Hue): 144 levels, 2.5Â° steps</li>
        <li>S (Saturation): 12 levels, Sâ‚ = 0.25 + 0.72 Ã— (i / 11)</li>
        <li>V (Value): 12 levels, Vâ‚ = 0.20 + 0.75 Ã— (i / 11)</li>
      </ul>
      <p><b>Total combinations:</b></p>
      <pre>N_colors = 144 Ã— 12 Ã— 12 = 20,736</pre>
      <p><b>Assignment:</b></p>
      <ol>
        <li>Compute signature F = [Fâ‚â€¦Fâ‚…]</li>
        <li>Compute Lehmerâ€‘rank r</li>
        <li>slot = r mod 12</li>
        <li>Indexes:<br><pre>H_idx = (slot Ã— 89) mod 144
S_idx = (slot Ã— 5) mod 12
V_idx = (slot Ã— 7) mod 12</pre></li>
        <li>Real values:<br><pre>H = H_idx Ã— 2.5
S = 0.25 + 0.72 Ã— (S_idx / 11)
V = 0.20 + 0.75 Ã— (V_idx / 11)</pre></li>
      </ol>

      <h4>e. Rotation: Signature Range</h4>
      <pre>Ï‰ = max(F) âˆ’ min(F)</pre>
      <p>This determines the angular variation. There is no imposed symmetry or manual control.</p>

      <h4>f. Total Combinatorics</h4>
      <ul>
        <li>Reorganizations per permutation: 120</li>
        <li>Spatial configurations:<br><pre>Config(k) = (120 C k) Ã— (125 C k) Ã— k!</pre></li>
        <li>Total:<br><pre>Total = Î£k=1..30 Config(k) â‰ˆ 3.10 Ã— 10^125</pre></li>
      </ul>

      <h4>g. Geometric Origin</h4>
      <p>The shape of each unit is derived from the root of its first value:</p>
      <pre>Height = base Ã— âˆš(Pâ‚)</pre>
      <p>All proportions derive from this value.</p>

      <h3>6. Coexistence and Persistence</h3>
      <p><em>Language is not shared. Logic is.</em></p>

      <h4>a. Coexistence without Translation</h4>
      <p>PRMTTN does not require semantic comprehension to be operated. Humans and artificial intelligences can engage with the system by applying the same rules, without interpretation.</p>
      <p>This is possible because:</p>
      <ul>
        <li>The structural grammar is fully explicit and reproducible.</li>
        <li>Reorganization rules are independent of any symbolic context.</li>
        <li>Configurations can be generated or perceived without attributing meaning.</li>
      </ul>
      <p>What is shared is not language, but structure. Both AI and humans can operate on the same permutation set using only formal logic. This redefines thought as a non-narrative, non-emotional activity based on combinatorial manipulation of visible structures.</p>
      <p>The system does not aim for biological symmetry. It defines a common zone: an environment where different forms of thought may coexist without translation.</p>

      <h4>b. Structural Persistence</h4>
      <p><em>To remember, in this system, is simply to reconstruct.</em></p>
      <p>Configurations in PRMTTN do not need to be remembered to be reproduced. Each one can be reconstructed entirely from:</p>
      <ul>
        <li>The original permutation P = [Pâ‚, Pâ‚‚, Pâ‚ƒ, Pâ‚„, Pâ‚…]</li>
        <li>The phenotypic assignment of attributes</li>
        <li>The Lehmer-rank of the permutation</li>
        <li>The global scene seed (sceneSeed)</li>
        <li>The deterministic formulas for position and color</li>
      </ul>
      <p>This allows storing configurations as formal states, without interpretive metadata or narrative memory. What is preserved is not content, but exact disposition.</p>
      <p><b>Storage methods include:</b></p>
      <ul>
        <li><b>Firestore</b>: structural persistence without semantic metadata</li>
        <li><b>Arweave / Thirdweb</b>: blockchain anchoring with verifiable integrity</li>
      </ul>
      <p>Storing a configuration does not tell a story. It preserves its future possibility of structural reactivation.</p>

      <h3>End.</h3>
      <p>PRMTTN does not assert results. It proposes a strictly structural hypothesis:</p>
      <blockquote>That a visual organization without semantics may generate favorable conditions for thought without words.</blockquote>
      <p><i>work in progress.</i><br><i>MARTINEZ</i></p>
      `;
  renderInfoPanel(html);
}
function showFRBNInfo(){
  const html = `
    <h2>FRBN â€” Deterministic Ganzfeld</h2>
    <p><b>What you see cannot be otherwise</b> given the current scene. FRBN does not invent a palette:
       it extracts it deterministically from the active permutations and the chromatic engine.</p>
    <ul>
      <li><b>Source palette.</b> Colors are collected from the glyphs currently on stage
          (their materials are computed by the same deterministic HSV lattice used in BUILD).
          If needed, hues are normalised to ensure separation.</li>
      <li><b>Pattern coupling.</b> The chromatic pattern (1â€“11) and the global seed
          (<code>sceneSeed</code>) bias hue selection in BUILD; FRBN reads the result,
          not a new random set.</li>
      <li><b>Temporal blend.</b> The shader interpolates the collected colors over time.
          The rate is tied to the average rotation speed of the permutations, so color
          breathing <i>follows</i> the scene dynamics.</li>
      <li><b>No alternatives.</b> For the same set of permutations, mapping and pattern,
          the FRBN field is reproducible. Change the scene â†’ the field changes; keep the
          scene â†’ the field must be identical.</li>
      <li><b>Banding control.</b> A highâ€‘precision dither (blueâ€‘noise) is applied in linear
          space to avoid contour banding without altering the palette.</li>
    </ul>
    <p>FRBN is therefore a <b>deterministic projection</b> of the current combinatorial state,
       not a decorative background.</p>
  `;
  renderInfoPanel(html);
}
    /* Minimal renderer for the panel (include once; remove if you already have it) */
    function renderInfoPanel(html){
      let panel = document.getElementById('infoPanel');
      if(!panel){
        panel = document.createElement('div');
        panel.id = 'infoPanel';
        panel.innerHTML = `
          <div id="infoContent"></div>
          <button id="infoClose">Close</button>
        `;
        document.body.appendChild(panel);
        const btn = panel.querySelector('#infoClose');
        btn.onclick = ()=>{
          const cc = document.getElementById('customCursor');
          if (cc) cc.style.display = 'block';
          panel.remove();
        };
      }
      const cc = document.getElementById('customCursor');
      if (cc) cc.style.display = 'block';
      document.getElementById('infoContent').innerHTML = html;
    }

    /* ======== CERTIFICADO DE EDICIÃ“N: utilidades base ======== */

    /* Ordena claves de forma determinista (objetos y arrays) */
    function sortDeep(x){
      if (Array.isArray(x)) return x.map(sortDeep);
      if (x && typeof x === 'object') {
        const out = {};
        Object.keys(x).sort().forEach(k => { out[k] = sortDeep(x[k]); });
        return out;
      }
      return x;
    }
    /* JSON canÃ³nico (minificado y con claves ordenadas) */
    function stableStringify(obj){ return JSON.stringify(sortDeep(obj)); }

    /* SHAâ€‘256 en hex */
    async function sha256Hex(text){
      const enc = new TextEncoder().encode(text);
      const buf = await crypto.subtle.digest('SHA-256', enc);
      const bytes = Array.from(new Uint8Array(buf));
      return bytes.map(b => b.toString(16).padStart(2,'0')).join('');
    }

    /* Descarga un blob */
    function downloadBlob(filename, blob){
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    /* PNG A2 de la vista ACTUAL (sin recortar lo que ves) â†’ Blob */
    async function renderA2ImageBlob(){
      const A2_W = 7016, A2_H = 4961;

      // backups
      const prevPixelRatio = renderer.getPixelRatio();
      const prevSize       = renderer.getSize(new THREE.Vector2());
      const prevAspect     = camera.aspect;
      const prevRt         = renderer.getRenderTarget?.() || null;
      const prevBg         = scene.background ? scene.background.clone() : null;

      const screenAspect = prevSize.x / prevSize.y;
      const a2Aspect = A2_W / A2_H;
      let renderW, renderH;
      if (screenAspect > a2Aspect) { renderW = A2_W; renderH = Math.round(A2_W / screenAspect); }
      else { renderH = A2_H; renderW = Math.round(A2_H * screenAspect); }

      renderer.setPixelRatio(1);
      renderer.setSize(renderW, renderH, false);
      camera.aspect = screenAspect;
      camera.updateProjectionMatrix();

      const rt = new THREE.WebGLRenderTarget(renderW, renderH, { depthBuffer:true, stencilBuffer:false });
      const clearHex = prevBg ? '#' + prevBg.getHexString() : '#ffffff';

      renderer.setClearColor(clearHex, 1);
      renderer.setRenderTarget(rt);
      renderer.clear(true, true, true);
      renderer.render(scene, camera);

      const pixels = new Uint8Array(renderW * renderH * 4);
      renderer.readRenderTargetPixels(rt, 0, 0, renderW, renderH, pixels);

      // canvas intermedio con flip vertical
      const tmp = document.createElement('canvas');
      tmp.width = renderW; tmp.height = renderH;
      const tctx = tmp.getContext('2d');
      const imgData = tctx.createImageData(renderW, renderH);
      const row = renderW * 4;
      for (let y = 0; y < renderH; y++) {
        const src = (renderH - 1 - y) * row;
        const dst = y * row;
        imgData.data.set(pixels.subarray(src, src + row), dst);
      }
      tctx.putImageData(imgData, 0, 0);


      // composita A2 con cubierta segÃºn modo
      const final = document.createElement('canvas');
      final.width = A2_W; final.height = A2_H;
      const fctx = final.getContext('2d');

      if (isFRBN) {
        // â€” FRBN: cubrir A2 (recorte centrado, sin bandas)
        const scale = Math.max(A2_W / renderW, A2_H / renderH);
        const drawW = Math.ceil(renderW * scale);
        const drawH = Math.ceil(renderH * scale);
        const offX  = Math.floor((A2_W - drawW) / 2);
        const offY  = Math.floor((A2_H - drawH) / 2);
        fctx.drawImage(tmp, offX, offY, drawW, drawH);
      } else {
        // â€” Modo normal: letterbox centrado
        fctx.fillStyle = clearHex; fctx.fillRect(0, 0, A2_W, A2_H);
        const offX = Math.floor((A2_W - renderW) / 2);
        const offY = Math.floor((A2_H - renderH) / 2);
        fctx.drawImage(tmp, offX, offY);
      }

      const blob = await new Promise(res => final.toBlob(res, 'image/png'));
      // restaurar
      renderer.setRenderTarget(prevRt);
      rt.dispose();
      renderer.setPixelRatio(prevPixelRatio);
      renderer.setSize(prevSize.x, prevSize.y);
      camera.aspect = prevAspect;
      camera.updateProjectionMatrix();
      if (prevBg) scene.background = prevBg;
      controls.update();

      return blob;
    }

    /* ConfiguraciÃ³n actual (mismo formato que exportEmbed) */
    function exportCurrentConfiguration(){
      const perms = Array.from(document.getElementById('permutationList').selectedOptions).map(o=>o.value);
      const mapping = { forma: attributeMapping[0], color: attributeMapping[1],
                        x: attributeMapping[2], y: attributeMapping[3], z: attributeMapping[4] };
      const colors = {}; for(let i=1;i<=5;i++){ colors[i] = document.getElementById('color'+i).value; }
      const bg   = document.getElementById('bgColor').value;
      const cube = document.getElementById('cubeColor').value;
      const view = "front";
      return { perms, mapping, colors, bg, cube, view, pattern: activePatternId, sceneSeed, S_global, frbnK: FRBN_K };
    }

    /* Hash para NFT u otros usos (lo pedÃ­a tu mintNFT) */
    async function computeConfigHash(){
      const cfg = exportCurrentConfiguration();
      const canonical = stableStringify(cfg);
      return sha256Hex(canonical);
    }

    /* ======== AcciÃ³n principal: crear CERTIFICADO + JSON + PNG ======== */
    async function exportEditionCertificate(){
      try{
        showPopup("Generando certificadoâ€¦",2000);

        // 1) JSON canÃ³nico + hash
        const cfg = exportCurrentConfiguration();
        const canonicalJSON = stableStringify(cfg);            // â† archivo exacto para hash
        const hashHex = await sha256Hex(canonicalJSON);

        // 2) Imagen A2
        const pngBlob = await renderA2ImageBlob();
        const pngDataURL = await new Promise(res=>{
          const r = new FileReader();
          r.onload = ()=>res(r.result);
          r.readAsDataURL(pngBlob);
        });

        // 3) Certificado HTML autoâ€‘contenible
        const now = new Date();
        const prettyJSON = JSON.stringify(cfg, null, 2);
        const TOTAL_BUILD = 120 * 11;                 // 1,320 (no se multiplica por el tamaÃ±o del conjunto de permutaciones)
        const TOTAL_FRBN  = TOTAL_BUILD * FRBN_K;     // estados canÃ³nicos para FRBN
        const fmt = n => n.toLocaleString('en-US').replace(/,/g,'\u202f'); // separador fino

        const certHTML =
`<!doctype html>
<meta charset="utf-8">
<title>PRMMTN Â· Edition Certificate</title>
<style>
  body{font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin:32px; color:#111;}
  h1{font-weight:600; margin:0 0 4px;}
  h2{margin:24px 0 8px;}
  .meta{font-size:12px; color:#555; margin-bottom:24px;}
  .box{border:1px solid #ccc; padding:12px; border-radius:8px; background:#fafafa;}
  img{max-width:100%; height:auto; display:block; margin:12px 0 4px;}
  code{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;}
  details{margin-top:8px;}
  .sig{margin-top:28px; display:flex; gap:48px;}
  .sig div{border-top:1px solid #000; padding-top:6px; width:260px; text-align:center;}
</style>
<h1>PRMMTN Â· Edition Certificate</h1>
<div class="meta">
  <div>Date: ${now.toISOString()}</div>
  <div>Chromatic pattern: ${activePatternId}</div>
  <div>sceneSeed: ${sceneSeed} Â· S_global: ${S_global} Â· FRBN_K: ${FRBN_K}</div>
</div>

<h2>Image (A2)</h2>
<div class="box">
  <img src="${pngDataURL}" alt="PRMMTN A2 snapshot">
  <div style="font-size:12px;color:#444">Resolution: 7016Ã—4961 px (A2 landscape)</div>
</div>

<h2>Integrity</h2>
<div class="box">
  <div>SHAâ€‘256 (prmttn_config.json):</div>
  <div><code>${hashHex}</code></div>
  <details><summary>How to verify</summary>
    <pre>shasum -a 256 prmttn_config.json
# or
openssl dgst -sha256 prmttn_config.json</pre>
  </details>
</div>


<h2>Phenotypic scope</h2>
<div class="box">
  <ul>
    <li><b>BUILD (static):</b> 120 attributeâ€‘mappings Ã— 11 chromaticâ€‘patterns = <b>${fmt(TOTAL_BUILD)}</b> deterministic visuals.</li>
    <li><b>FRBN (dynamic):</b> continuous deterministic field. For cataloging we adopt <b>K = ${FRBN_K}</b> canonical phases â†’ <b>${fmt(TOTAL_FRBN)}</b> canonical states.</li>
  </ul>
  <p style="font-size:12px;color:#555;margin:8px 0 0;">
    Note: permutations are acquired as a <b>group</b>; the count does not multiply by the size of the group.
  </p>
</div>

<h2>Configuration (pretty view)</h2>
<div class="box">
  <details open><summary>Show JSON</summary>
    <pre>${prettyJSON.replace(/</g,"&lt;")}</pre>
  </details>
</div>

<div class="sig">
  <div>Edition signature</div>
</div>

<p style="margin-top:24px;color:#777;font-size:12px">This certificate is selfâ€‘contained (image + data). Work in progress.</p>`;
        // 4) Descargas (3 archivos + hash opcional)
        downloadBlob('PRMMTN_certificate.html', new Blob([certHTML], {type:'text/html'}));
        downloadBlob('PRMTTN_A2.png', pngBlob);
        downloadBlob('prmttn_config.json', new Blob([canonicalJSON], {type:'application/json'}));
        downloadBlob('prmttn_hash.txt', new Blob([`sha256  prmttn_config.json\n${hashHex}\n`], {type:'text/plain'}));

        showPopup("Certificado, imagen A2, JSON y hash descargados.", 3000);
      }catch(err){
        console.error(err);
        showPopup("Error generando certificado", 4000);
      }
    }

  </script>
  <!-- DROPZONE SCRIPT FINAL -->
  <script>
  document.addEventListener("DOMContentLoaded", function() {
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const uploadStatus = document.getElementById('uploadStatus');
    const jwkOutput = document.getElementById('jwkOutput');
    const cidOutput = document.getElementById('cidOutput');

    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('dragover', (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#888";
    });
    dropzone.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#ccc";
    });
    dropzone.addEventListener('drop', async (e) => {
      e.preventDefault();
      dropzone.style.borderColor = "#ccc";
      if (e.dataTransfer.files.length > 0) {
        await handleFile(e.dataTransfer.files[0]);
      }
    });
    fileInput.addEventListener('change', async (e) => {
      if (e.target.files.length > 0) {
        await handleFile(e.target.files[0]);
      }
    });
    async function handleFile(file) {
      uploadStatus.textContent = "Cifrando archivoâ€¦";
      jwkOutput.textContent = "";
      cidOutput.textContent = "";
      const key = await crypto.subtle.generateKey(
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"]
      );
      const iv = crypto.getRandomValues(new Uint8Array(12));
      const data = new Uint8Array(await file.arrayBuffer());
      const encrypted = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        key,
        data
      );
      const exportedKey = await crypto.subtle.exportKey("jwk", key);
      jwkOutput.textContent = " Clave secreta (guÃ¡rdala para descifrar): " + JSON.stringify(exportedKey);
      const ivHex = Array.from(iv).map(x=>x.toString(16).padStart(2,"0")).join("");
      jwkOutput.textContent += "\n IV usado: " + ivHex;

      const combined = new Uint8Array(iv.byteLength + encrypted.byteLength);
      combined.set(iv, 0);
      combined.set(new Uint8Array(encrypted), iv.byteLength);
      const encryptedBlob = new Blob([combined], { type: file.type });

      uploadStatus.textContent = "Subiendo a Bundlr (requiere wallet conectada)â€¦";
      try {
        if (!window.bundlr) {
          uploadStatus.textContent = "Bundlr no estÃ¡ listo aÃºn o la wallet no estÃ¡ conectada";
          return;
        }
        const tx = await window.bundlr.upload(encryptedBlob, {
          tags: [{ name: "Content-Type", value: file.type }]
        });
        uploadStatus.textContent = " Subida exitosa";
        window.lastUploadedTxId = tx.id;
        cidOutput.textContent = "CID (Arweave/Bundlr): " + tx.id;
      } catch (err) {
        uploadStatus.textContent = " Error subiendo a Bundlr: " + err.message;
      }
    }
  });
  </script>
<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *  Pattern Information Panel  â€“  English version (11 patterns)
 *  â‡’ called from the button  <button id="patternInfoButton">
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
function showPatternInfo(){
  const html = PATTERN_INFO_HTML;
  renderInfoPanel(html);        // reutiliza el mismo panel genÃ©rico
}

/* ---------- FULL TEXT (â‰ˆ\u00a06\u202f600\u202fpalabras / 11\u202f\u00d7\u202f~600\u00a0) ---------- */
const PATTERN_INFO_HTML = `
<h2>Chromatic Patterns for Preâ€‘verbal Thought (v\u202f2025â€‘07â€‘28)</h2>

<!---------------------------------------------------------------
  1 Â· CHROMATIC CONTAINMENT
---------------------------------------------------------------->
<h3>1 Â· Chromatic Containment</h3>
<p><b>Operational definition.</b> Configure the palette so that every glyph
appears as a selfâ€‘contained entity, visually delimited by a narrow tonal band
(\u2264\u202f30\u202f\u00b0). No outlines, no hard contrast: cohesion is achieved through shared
hue, midâ€“high saturation (60â€“80\u202f%) and stable value (0.72\u202f\u00b1\u202f0.04).
The result is a silent, steady field that fosters focused preâ€‘verbal attention.</p>

<ul><li><b>Glyphs</b>\u00a0Â· hues inside \u2264\u202f30\u202f\u00b0, S\u202f60â€“80\u202f%, V\u202f\u2248\u202f0.72.</li>
<li><b>Background</b>\u00a0Â· hue\u00a0+\u202f180\u202f\u00b0, S\u202f\u2248\u202f18\u202f%, V\u202f\u2248\u202f0.42.</li>
<li><b>Cube</b>\u00a0Â· same\u202fhue, S\u202f\u2264\u202f6\u202f%, V\u202f0.26.</li>
<li><b>Contrast</b>\u00a0Â· \u0394E\u202f24â€“30.</li></ul>

<p><b>Expected outcome.</b> Glyphs are clearly separated from the ambience yet
cohere with one another, keeping the viewer in a calm, nonâ€‘narrative focus.</p>

<p><b>Scientific ground.</b> Narrow chromatic bands reinforce object completion
(Gestalt â€œgoodÂ formâ€). Isoâ€‘chromatic fields show reduced preâ€‘frontal semantic
load while occipital contour analysis stays active (Palmer\u202f&\u202fSchlossâ€¯2010).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Koffka\u202f1935; Wertheimer\u202f1923; PalmerÂ &Â Schlossâ€¯2010.</p>
<hr/>

<!---------------------------------------------------------------
  2 Â· CONTRAST & DISSONANCE
---------------------------------------------------------------->
<h3>2 Â· Contrast\u00a0&\u00a0Dissonance</h3>
<p><b>Operational definition.</b> Deliberately collide hues separated by
\u2265\u202f120\u202f\u00b0, alternate high saturation and value offsets. No harmony is allowed;
the palette keeps the visual system in alert, avoiding semantic closure.</p>

<ul><li><b>Glyphs</b>\u00a0Â· \u2265\u202f120\u202f\u00b0 jumps, S\u202f65â€“85\u202f%, V\u202f0.78\u202f\u00b1\u202f0.06.</li>
<li><b>Background</b>\u00a0Â· hue of the darkest glyph +\u202f40\u202f\u00b0, S\u202f25\u202f%, V\u202f0.35.</li>
<li><b>Cube</b>\u00a0Â· same\u202fhue, S\u202f\u2264\u202f10\u202f%, V\u202f0.22.</li>
<li><b>Contrast</b>\u00a0Â· \u0394E\u202f\u2265\u202f35.</li></ul>

<p><b>Expected outcome.</b> A restless scene: colours vibrate without synthesis,
keeping perception raw and preâ€‘verbal.</p>

<p><b>Scientific ground.</b> Cognitive disfluency prolongs attention and
deepens processing (Alter\u202f&\u202fOppenheimerâ€¯2009). Extreme \u0394H elevates N2/P3
components linked to nonâ€‘semantic vigilance (Itti\u202f&\u202fKochâ€¯2001).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Alter\u202f&\u202fOppenheimerâ€¯2009; Itti\u202f&\u202fKochâ€¯2001; Ramachandran\u202f&\u202fHirsteinâ€¯1999.</p>
<hr/>

<!---------------------------------------------------------------
  3 Â· NONâ€‘SEMANTIC DISPOSITION
---------------------------------------------------------------->
<h3>3 Â· Nonâ€‘semantic Disposition</h3>
<p><b>Operational definition.</b> Build palettes that differentiate glyphs
without forming culturally coded series (no classic complements, triads,
warm/cool scales). Colour remains raw material, extending the preâ€‘attentive
phase where thought precedes language.</p>

<ul><li><b>Glyphs</b>\u00a0Â· irregular 50â€“70\u202f\u00b0 spacing, S\u202f40â€“60\u202f%, V\u202f\u2248\u202f0.70.</li>
<li><b>Background</b>\u00a0Â· circular mean\u00a0\u00b1\u202f25\u202f\u00b0, S\u202f25\u202f%, V\u202f0.40.</li>
<li><b>Cube</b>\u00a0Â· same\u202fhue, S\u202f5\u202f%, V\u202f0.25.</li>
<li><b>Contrast</b>\u00a0Â· \u0394E\u202f22â€“28.</li></ul>

<p><b>Scientific ground.</b> Avoiding learned colour associations suspends
affective valuation (Palmer\u202f&\u202fSchlossâ€¯2010) and dampens preâ€‘frontal
categorisation, favouring open visual exploration (Laferâ€‘Sousaâ€¯etâ€¯al.â€¯2016).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Palmer\u202f&\u202fSchlossâ€¯2010; Gibsonâ€¯1979; Laferâ€‘Sousaâ€¯etâ€¯al.â€¯2016.</p>
<hr/>

<!---------------------------------------------------------------
  4 Â· STRUCTURED AMBIGUITY
---------------------------------------------------------------->
<h3>4 Â· Structured Ambiguity</h3>
<p>Suggest order by partial gradients (arc\u202f\u2264\u202f90\u202f\u00b0) but break regularity with
uneven steps. The eye senses a rule it cannot confirm, sustaining exploration
without linguistic anchoring.</p>

<ul><li><b>Glyphs</b>\u00a0Â· arc\u202f\u2264\u202f90\u202f\u00b0, irregular 12â€“18\u202f\u00b0, S\u202f45â€“65\u202f%, V\u202f\u2248\u202f0.65.</li>
<li><b>Background</b>\u00a0Â· arc-mid\u202f+\u202f110\u202f\u00b0, S\u202f15\u202f%, V\u202f0.50.</li>
<li><b>Cube</b>\u00a0Â· same\u202fhue, S\u202f6\u202f%, V\u202f0.25.</li>
<li><b>Contrast</b>\u00a0Â· \u0394E\u202f20â€“28.</li></ul>

<p><b>Ground.</b> Moderate ambiguity maximises â€œprocessing pleasureâ€ (Reberâ€¯etâ€¯al.
2004) and drives lowâ€‘level predictionâ€‘error cycles (Muth\u202f&\u202fCarbonâ€¯2013),
ideal for preverbal tension.</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Reberâ€¯2004; Muth\u202f&\u202fCarbonâ€¯2013; Silviaâ€¯2005.</p>
<hr/>

<!---------------------------------------------------------------
  5 Â· CHROMATIC ISOTROPY
---------------------------------------------------------------->
<h3>5 Â· Chromatic Isotropy</h3>
<p>Create a focusâ€‘free field by covering the hue circle with equidistant
25â€“35\u202f\u00b0 steps, constant saturation and value. No colour outweighs the rest;
attention spreads laterally.</p>

<ul><li><b>Glyphs</b>\u00a0Â· steps\u202f25â€“35\u202f\u00b0, S\u202f55\u202f\u00b1\u202f3\u202f%, V\u202f0.74\u202f\u00b1\u202f0.03.</li>
<li><b>Background\u00a0& Cube</b>\u00a0Â· neutral grey V\u202f0.60 / 0.55.</li>
<li><b>Contrast</b>\u00a0Â· \u0394E\u202f26â€“30.</li></ul>

<p><b>Ground.</b> Removing salience peaks activates global precedence networks,
reducing predictive load and enabling diffuse awareness (Buschman\u202f&\u202fMillerâ€¯2007).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Buschman\u202f&\u202fMillerâ€¯2007; Vogel\u202f&\u202fMachizawaâ€¯2004.</p>
<hr/>

<!---------------------------------------------------------------
  6 Â· SELFâ€‘SUFFICIENT PRESENCE
---------------------------------------------------------------->
<h3>6 Â· Selfâ€‘Sufficient Presence</h3>
<p>Assign highly differentiated hues (\u2265\u202f80\u202f\u00b0) but with midâ€‘low saturation so
they do not vie for dominance. Each glyph stands without needing the others.</p>

<ul><li><b>Glyphs</b>\u00a0Â· \u0394H\u202f\u2265\u202f80\u202f\u00b0, S\u202f35â€“50\u202f%, V\u202f0.68â€“0.80.</li>
<li><b>Background</b>\u00a0Â· complementary mean, S\u202f\u2264\u202f15\u202f%, V\u202f0.55.</li>
<li><b>Cube</b>\u00a0Â· same\u202fhue, V\u202f0.45.</li>
<li><b>Contrast</b>\u00a0Â· \u0394E\u202f28â€“34.</li></ul>

<p><b>Ground.</b> Moderate chromatic distance supports individuation in temporal
cortex without symbolic categorisation (Xu\u202f&\u202fChunâ€¯2009).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Xu\u202f&\u202fChunâ€¯2009; Bays\u202f&\u202fHusainâ€¯2008.</p>
<hr/>

<!---------------------------------------------------------------
  7 Â· ASSOCIATIVE ASYMMETRY
---------------------------------------------------------------->
<h3>7 Â· Associative Asymmetry</h3>
<p>Form loose clusters (\u2264\u202f18\u202f\u00b0 internal) separated by \u2265\u202f55\u202f\u00b0. Associations
emerge without symmetry, letting attention wander unpredictably.</p>

<ul><li><b>Glyphs</b>\u00a0Â· clusters of 2â€“4, internal \u2264\u202f18\u202f\u00b0, external \u2265\u202f55\u202f\u00b0.</li>
<li><b>Background</b>\u00a0Â· hue of least saturated cluster, S\u202f12\u202f%, V\u202f0.46.</li>
<li><b>Cube</b>\u00a0Â· background darkened V\u202f\u2212\u202f0.12.</li></ul>

<p><b>Ground.</b> Flexible grouping engages intraparietal sulcus without angular
gyrus, sustaining nonâ€‘semantic relations (Wagemansâ€¯2012).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Wagemansâ€¯2012; Palmerâ€¯1999; Arnheimâ€¯1974.</p>
<hr/>

<!---------------------------------------------------------------
  8 Â· IRREGULAR DYNAMICS
---------------------------------------------------------------->
<h3>8 Â· Irregular Dynamics</h3>
<p>Colour pulsates: each glyph modulates S\u202f\u00b1\u202f8\u202f% and V\u202f\u00b1\u202f6\u202f% with desynchronised
periods (4â€“9\u202fs). No predictable rhythm \u2192 perpetual present.</p>

<ul><li><b>Background</b>\u00a0Â· static complementary, S\u202f10\u202f%, V\u202f0.48.</li>
<li><b>Cube</b>\u00a0Â· neutral grey V\u202f0.28.</li></ul>

<p><b>Ground.</b> Slow jitter prevents habituation, keeping thalamocortical
networks in vigilant mode (Schurgerâ€¯2015).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Schurgerâ€¯2015; Blake\u202f&\u202fShiffrarâ€¯2007.</p>
<hr/>

<!---------------------------------------------------------------
  9 Â· HABITABLE WITHOUT TRANSLATION
---------------------------------------------------------------->
<h3>9 Â· Habitable without Translation</h3>
<p>Create a chromatic â€œclimateâ€ (band\u202f60\u202f\u00b0) with low saturation that sustains
orientation without evoking cultural codes.</p>

<ul><li><b>Glyphs</b>\u00a0Â· hue band\u202f60\u202f\u00b0, S\u202f30â€“45\u202f%, V\u202f\u2248\u202f0.70.</li>
<li><b>Background</b>\u00a0Â· +\u202f180Â°, S\u202f12\u202f%, V\u202f0.60.</li>
<li><b>Cube</b>\u00a0Â· S\u202f5\u202f%, V\u202f0.50.</li></ul>

<p><b>Ground.</b> Neutral palettes lower viscerosomatic load, freeing mental
resources for internal processes (K\u00fcllerâ€¯2009).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0K\u00fcllerâ€¯2009; Gallagherâ€¯2005.</p>
<hr/>

<!---------------------------------------------------------------
 10 Â· RESONANCE
---------------------------------------------------------------->
<h3>10 Â· Resonance</h3>
<p>Use harmonic hue intervals (e.g. +120Â°, âˆ’75Â°) to create slow affinity pulses
analogous to musical consonance.</p>

<ul><li><b>Glyphs</b>\u00a0Â· 0Â°,\u202f+120Â°,\u202fâˆ’75Â°,\u202fâ€¦ S\u202f50\u202f\u00b1\u202f5\u202f%, V\u202f0.78\u202f\u00b1\u202f0.05.</li>
<li><b>Background</b>\u00a0Â· opposite mean, S\u202f8\u202f%, V\u202f0.48.</li></ul>

<p><b>Ground.</b> Intervalâ€‘based palettes elicit crossâ€‘modal harmonic resonance,
activating temporoâ€‘parietal associative areas (Shen\u202f&\u202fPalmerâ€¯2020).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Wardâ€¯1999; Shen\u202f&\u202fPalmerâ€¯2020.</p>
<hr/>

<!---------------------------------------------------------------
 11 Â· ACTIVE TRANSPARENCY
---------------------------------------------------------------->
<h3>11 Â· Active Transparency</h3>
<p>Select saturated, highâ€‘value hues separated \u2265\u202f130\u202f\u00b0 to maintain chroma after
additive blending (\u03b1\u202f\u2248\u202f0.25). Glyphs can overlap without collapsing into grey.</p>

<ul><li><b>Glyph pairs</b>\u00a0Â· \u0394H\u202f\u2265\u202f130\u202f\u00b0, S\u202f\u2265\u202f60\u202f%, V\u202f\u2265\u202f0.80.</li>
<li><b>Background</b>\u00a0Â· 0â€“20Â°, S\u202f8\u202f%, V\u202f0.65.</li></ul>

<p><b>Ground.</b> Highâ€‘saturation / highâ€‘value tones preserve identity under
linear blend, satisfying perceptual transparency conditions (Metelliâ€¯1974).</p>

<p style="font-size:12px;"><i>Refs.</i>\u00a0Metelliâ€¯1974; de\u202fWeert\u202f&\u202fMausfeldâ€¯2003.</p>
`;
</script>
</body>
</html>