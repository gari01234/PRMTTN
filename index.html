<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>PRMTTN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Three .js + OrbitControls (una sola vez) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
// Bootstrap GRVTY flags to avoid ReferenceError before its script loads
if (typeof window.isGRVTY === 'undefined') window.isGRVTY = false;
// Optional no-ops so calls won't crash if invoked early
if (typeof window.ensureOnlyGRVTY === 'undefined') window.ensureOnlyGRVTY = function(){
  if (!window.isGRVTY && typeof window.toggleGRVTY === 'function') window.toggleGRVTY();
};
if (typeof window.ensureOnlyGRVTYFromUI === 'undefined') window.ensureOnlyGRVTYFromUI = function(){
  window.ensureOnlyGRVTY(); if (typeof updateEngineSelectUI==='function') updateEngineSelectUI();
};
if (typeof window.rebuildGRVTYIfActive === 'undefined') window.rebuildGRVTYIfActive = function(){};
  </script>
  <!-- === tilers.js embebido (JS puro) — crea window.Tilers === -->
    <script type="module">
/* ───────── tilers (JS puro) — núcleo de ensambles multi-familia ───────── */
const PHI   = (1 + Math.sqrt(5)) / 2;
const ROOT2 = Math.SQRT2;
const ROOT3 = Math.sqrt(3);
const ROOT4 = Math.sqrt(4);   // = 2
const ROOT5 = Math.sqrt(5);
const EPS   = 1e-6;

/* util mínimo */
function near(a,b,eps=EPS){ return Math.abs(a-b) <= eps; }

/* ───────────── PRNG con SEED (mulberry32) ───────────── */
let __rng = Math.random;       // por defecto
let __seedU32 = 0;

function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}
function setSeed(u32){
  __seedU32 = (u32 >>> 0) || 1;
  __rng = mulberry32(__seedU32);
}
function rand(){ return __rng(); }
function randRange(a,b){ return a + (b-a) * rand(); }
function randBool(p=0.5){ return rand() < p; }

/* Catálogo de familias + alias proporcionales útiles para matching */
const families = [
  { id:'phi', r:PHI,   aliases:[1/PHI, 1-PHI**-1, PHI**2-PHI] },
  { id:'r2',  r:ROOT2, aliases:[1/ROOT2, 2-ROOT2] },
  { id:'r3',  r:ROOT3, aliases:[1/ROOT3, ROOT3-1, 1-(ROOT3-1)] },
  { id:'r4',  r:ROOT4, aliases:[1/ROOT4, 1] },
  { id:'r5',  r:ROOT5, aliases:[1/ROOT5, (ROOT5-2)] }
];

/* identifica familia por proximidad (tolerancia holgada para ratios derivados) */
function whichFamily(r, eps=2e-2){
  let best = null;
  for (const f of families){
    for (const c of [f.r, ...f.aliases]){
      const d = Math.abs(r - c);
      if (!best || d < best.d) best = { f:f.id, d };
    }
  }
  return (best && best.d <= eps) ? best.f : null;
}

/* familia dominante por “área” en el inventario; fallback φ */
function dominantFamily(inv){
  const acc = {phi:0,r2:0,r3:0,r4:0,r5:0};
  (inv?.ratios||[]).forEach(it=>{
    const fam = whichFamily(it.r) ?? 'phi';
    acc[fam] += it.area || 0;
  });
  return Object.keys(acc).reduce((best,f)=> acc[f]>acc[best]?f:best,'phi');
}

/* ---------- 1) Euclid / Continued Fraction → mosaico de cuadrados ---------- */
function tilesEuclid(b, r, tag='euclid'){
  const out=[];
  let x=b.x, y=b.y, w=b.w, h=b.h;

  const orient = (w>=h) ? 1 : -1;     // 1 vertical; -1 horizontal
  if (orient<0){ [w,h] = [h,w]; }

  let W=w, H=h;
  let baseX=0, baseY=0;
  while (W > EPS && H > EPS){
    const q = Math.floor(W / H + EPS);
    for (let i=0;i<q;i++){
      const rect = orient>0
        ? { x: b.x + baseX + i*H, y: b.y + baseY, w: H, h: H, tag }
        : { x: b.x + baseY,       y: b.y + baseX + i*H, w: H, h: H, tag };
      out.push(rect);
    }
    const rem = W - q*H;
    if (rem <= EPS) break;
    if (orient>0){ baseX += q*H; } else { baseY += q*H; }
    W = H; H = rem;
  }
  return out;
}

/* ---------- 2) Beatty / Sturmian (dos tamaños L/S) ---------- */
function beattyPairFor(f){
  if (f==='phi'){ return [PHI*PHI, (PHI*PHI)/(PHI*PHI-1)]; }
  if (f==='r2'){  const a=1+ROOT2; return [a, a/(a-1)]; }
  if (f==='r3'){  const a=1+ROOT3; return [a, a/(a-1)]; }
  if (f==='r4'){  const a=1+ROOT4; return [a, a/(a-1)]; }
  const a=1+ROOT5; return [a, a/(a-1)];
}
function tilesBeatty(b, f, majorFirst=true, tag='beatty'){
  const [alpha] = beattyPairFor(f);
  const N = Math.max(2, Math.round(b.w / (b.h*0.25)));
  const seq = [];
  for (let k=1;k<=N;k++){
    const LA = Math.floor(k*alpha) - Math.floor((k-1)*alpha);
    seq.push(LA===2); // true=L, false=S
  }

  const rVal = (f==='phi'?PHI : f==='r2'?ROOT2 : f==='r3'?ROOT3 : f==='r4'?ROOT4 : ROOT5);
  const L =  majorFirst ? b.h           : b.h / rVal;
  const S =  majorFirst ? b.h / rVal    : b.h;

  const wL = 1.0, wS = 1/(alpha-1);
  const widths = seq.map(s => s ? wL : wS);
  const sum = widths.reduce((a,c)=>a+c,0);
  const kscale = b.w / sum;

  let x = b.x;
  const out = [];
  for (let i=0;i<widths.length;i++){
    const cw = widths[i]*kscale;
    const ch = seq[i] ? L : S;
    out.push({x, y:b.y, w:cw, h:ch, tag});
    if (ch < b.h - EPS){
      out.push({x, y:b.y+ch, w:cw, h:b.h-ch, tag});
    }
    x += cw;
    if (x > b.x + b.w - EPS) break;
  }
  return out;
}

/* ---------- 3) Sustitución inflacionaria (Fibo/Pell/√3) ---------- */
function substRules(f){
  if (f==='phi') return ['LS','L'];      // Fibonacci
  if (f==='r2')  return ['LSS','L'];     // tipo Pell
  if (f==='r3')  return ['LLS','L'];     // √3
  return null;                           // r4/r5 → sin reglas específicas (fallback)
}
function tilesSubstitution(b, f, iters=6, tag='subst'){
  const rules = substRules(f);
  if (!rules){
    return tilesBeatty(b, f, true, 'beatty');
  }
  let word = 'L';
  const [RL,RS] = rules;
  for (let i=0;i<iters;i++){
    let next=''; for (const ch of word) next += (ch==='L'?RL:RS);
    word = next;
  }
  const rVal = (f==='phi'?PHI : f==='r2'?ROOT2 : ROOT3);
  const wL = 1, wS = 1 / rVal;
  const widths = [...word].map(ch => ch==='L'?wL:wS);
  const sum = widths.reduce((a,c)=>a+c,0);
  const kscale = b.w / sum;
  let x = b.x;
  const out = [];
  for (const ch of word){
    const cw = (ch==='L'?wL:wS)*kscale;
    out.push({x, y:b.y, w:cw, h:b.h, tag});
    x += cw;
    if (x > b.x + b.w - EPS) break;
  }
  return out;
}

/* ---------- 4) NUEVO: BSP “split-rect” con alternancia H/V, ratio 0.35–0.65,
                        tamaño mínimo de celda y fusión de adyacentes ---------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

function tilesBSP(b, opt={}){
  const minCell   = Math.max(0, opt.minCell || 3.0);
  const rMin      = clamp(opt.ratioMin ?? 0.35, 0.05, 0.95);
  const rMax      = clamp(opt.ratioMax ?? 0.65, rMin, 0.95);
  const targetN   = Array.isArray(opt.targetN) ? Math.round(
                      clamp(Math.floor(randRange(opt.targetN[0], opt.targetN[1]+1)), 2, 64)
                    ) : Math.round(clamp(opt.targetN || 10, 2, 64));
  const mergeProb = clamp(opt.mergeProb ?? 0.25, 0, 1);

  const out = [];

  function splitRect(R, lastOrient){
    // condición de parada: objetivo de celdas y tamaño mínimo
    const canV = (R.w >= 2*minCell + EPS);
    const canH = (R.h >= 2*minCell + EPS);

    if (out.length >= targetN || (!canV && !canH)){
      out.push({ x:R.x, y:R.y, w:R.w, h:R.h, tag:'bsp' });
      return;
    }

    // alternancia “suave”: 70% alterna respecto a la anterior; si no, decide por aspecto
    let orient;
    if (lastOrient && rand() < 0.70){
      orient = (lastOrient==='H' ? 'V' : 'H');
    } else {
      if (R.w / Math.max(R.h, EPS) > 1.25) orient = 'V';
      else if (R.h / Math.max(R.w, EPS) > 1.25) orient = 'H';
      else orient = randBool() ? 'V' : 'H';
    }

    if (orient==='V' && !canV) orient='H';
    if (orient==='H' && !canH) orient='V';

    if (orient==='V'){
      // ratio limitado por minCell
      let r = clamp(randRange(rMin, rMax), minCell / R.w, 1 - (minCell / R.w));
      const w1 = Math.max(minCell, R.w * r);
      const w2 = R.w - w1;
      const L = { x:R.x,       y:R.y, w:w1, h:R.h };
      const Rr= { x:R.x + w1, y:R.y, w:w2, h:R.h };
      splitRect(L, 'V'); splitRect(Rr, 'V');
    } else {
      let r = clamp(randRange(rMin, rMax), minCell / R.h, 1 - (minCell / R.h));
      const h1 = Math.max(minCell, R.h * r);
      const h2 = R.h - h1;
      const T = { x:R.x, y:R.y,        w:R.w, h:h1 };
      const B = { x:R.x, y:R.y + h1,   w:R.w, h:h2 };
      splitRect(T, 'H'); splitRect(B, 'H');
    }
  }

  splitRect(b, null);

  // — FUSIÓN DE CELDAS ADYACENTES (25% por defecto) —
  function tryMerge(a,b){
    // horizontal: misma y, misma h, tocan por x
    if (near(a.y,b.y) && near(a.h,b.h) && (near(a.x + a.w, b.x) || near(b.x + b.w, a.x))){
      const x = Math.min(a.x,b.x);
      const w = a.w + b.w;
      return { x, y:a.y, w, h:a.h, tag:'bsp-merged' };
    }
    // vertical: misma x, misma w, tocan por y
    if (near(a.x,b.x) && near(a.w,b.w) && (near(a.y + a.h, b.y) || near(b.y + b.h, a.y))){
      const y = Math.min(a.y,b.y);
      const h = a.h + b.h;
      return { x:a.x, y, w:a.w, h, tag:'bsp-merged' };
    }
    return null;
  }

  if (out.length > 2 && mergeProb > 0){
    // intentos acotados para no ciclar
    for (let pass=0; pass<3; pass++){
      let merged = false;
      for (let i=0; i<out.length && !merged; i++){
        for (let j=i+1; j<out.length && !merged; j++){
          if (randBool(mergeProb)){
            const m = tryMerge(out[i], out[j]);
            if (m){
              const a = out[i], b = out[j];
              out.splice(j,1); out.splice(i,1); // quita b luego a
              out.push(m);
              merged = true;
            }
          }
        }
      }
      if (!merged) break;
    }
  }

  return out;
}

/* ---------- 5) Orquestador con alternancia de estrategias + BSP ---------- */
function fillByStrategy(rect, fam, strategy){
  if (strategy==='beatty') return tilesBeatty(rect, fam, true, 'beatty');
  if (strategy==='subst')  return tilesSubstitution(rect, fam, 7, 'subst'); // r4/r5 → Beatty
  return tilesEuclid(rect, rect.w/rect.h, 'euclid-in-band');
}

function assemble(b, inv, opt={}){
  // Semilla del motor (si viene) — mismo PRNG para todo
  if (typeof opt.rndSeed === 'number') setSeed(opt.rndSeed);

  const fam = (opt.familyId && ['phi','r2','r3','r4','r5'].includes(opt.familyId))
    ? opt.familyId
    : dominantFamily(inv || {ratios:[]});

  const rBox = Math.max(b.w,b.h) / Math.min(b.w,b.h);

  // ——— Picker de “plantilla” ponderado (si no nos forzan un engine)
  let engine = opt.engine || (()=>{
    const roll = rand();
    if (roll < 0.50) return 'bsp';
    if (roll < 0.85) return 'bands';
    if (roll < 0.95) return 'beatty';
    return 'spiral';
  })();

  // ——— Ejecuta el motor elegido (sin returns tempranos que anulen ramas) ———
  let rects = [];

  if (engine === 'bsp'){
    rects = tilesBSP(b, {
      minCell   : opt.minCell ?? 3.0,
      ratioMin  : opt.ratioMin ?? 0.35,
      ratioMax  : opt.ratioMax ?? 0.65,
      targetN   : opt.targetN  ?? [6,14],
      mergeProb : opt.mergeProb ?? 0.25
    });
  } else if (engine === 'bands'){
    // bandas euclidianas + ciclo de estrategias (ponderado si no nos dan uno)
    const cycle = Array.isArray(opt.strategyCycle) && opt.strategyCycle.length
      ? opt.strategyCycle
      : (rand()<0.5 ? ['beatty','euclid','subst'] : ['euclid','beatty','subst']);
    const bands = tilesEuclid(b, rBox, 'euclid-band');
    for (let i=0;i<bands.length;i++){
      const strat = cycle[i % cycle.length];
      rects.push(...fillByStrategy(bands[i], fam, strat));
    }
  } else if (engine === 'beatty'){
    rects = tilesBeatty(b, fam, true, 'beatty');
  } else if (engine === 'spiral'){
    rects = tilesSubstitution(b, fam, 7, 'subst');
  } else {
    // fallback robusto → bands
    const bands = tilesEuclid(b, rBox, 'euclid-band');
    for (const band of bands){
      rects.push(...tilesBeatty(
        { x:band.x, y:band.y, w:band.w, h:band.h }, fam, true, 'beatty-in-band'
      ));
    }
  }

  return rects;
}

/* exporta en global */
window.Tilers = {
  PHI, ROOT2, ROOT3, ROOT4, ROOT5,
  families, whichFamily,
  assemble,
  // PRNG público para trazabilidad / tests
  setSeed,
  get seed(){ return __seedU32; }
};
    </script>
  <style>
  body {
    margin: 0;
    overflow: hidden;
    background: #ffffff;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-weight: 200;
    font-size: 12px;
    cursor: none;
  }
  #customCursor {
    position: fixed;
    width: 12px; height: 12px;
    border-radius: 50%;
    background: #000;
    border: 1px solid #fff;
    pointer-events: none; z-index: 300;
    transform: translate(-50%, -50%);
  }
  /* HUD eliminado */
  #topRightDisplay{
    display:none !important;
  }
  button{
    cursor:none;
    border:none;
    border-radius:4px;
    padding:8px 12px;
    font-size:12px;
    z-index:250;
    background:rgba(255,255,255,0.12);
    transition:background 0.2s;
  }
  button:hover{
    background:rgba(255,255,255,0.20);
  }

  #patternNextButton,
  #engineCycleButton,
  #permNextButton{
    position:fixed; z-index:260;                /* siempre encima */
    border:none; border-radius:4px;
    padding:8px 12px; font-size:12px;
    background:rgba(255,255,255,0.12);
    cursor:none; display:none;                  /* ocultos por defecto */
    transition:background .2s;
  }
  #patternNextButton:hover,
  #engineCycleButton:hover,
  #permNextButton:hover{
    background:rgba(255,255,255,0.20);
  }
  #patternNextButton{left:10px;  top:10px;}     /* 1 · patrón siguiente   */
  #engineCycleButton {left:10px;  bottom:10px;} /* 2 · motor siguiente     */
  #permNextButton   {right:10px; top:10px;}     /* 3 · NEXT (120 perms)    */

  /* === LAYOUT (orden y ESPACIADO nuevos) === */
  #toggleTextButton     { position:fixed; right:10px; bottom:10px;   }   /* Minimal UI */
  #aiPlanningButton     { position:fixed; right:10px; bottom:50px;   }   /* AI Planning */
  #saveImageButton      { position:fixed; right:10px; bottom:90px;  }   /* Save Image (A2) – debajo de Load JSON */
  #uploadConfigButton   { position:fixed; right:10px; bottom:130px;  }   /* Load JSON */
  #exportEmbedButton    { position:fixed; right:10px; bottom:170px;  }   /* Save JSON */
  #archDescButton       { position:fixed; right:10px; bottom:210px;  }   /* Architectural Description */
  #perm120Button        { position:fixed; right:10px; bottom:250px;  }   /* 120 Architectural Permutations */
#randomConfigButton   { position:fixed; left:10px; bottom:130px;  }   /* BUILD  */
   #certButton           { position:fixed; right:10px; bottom:30px; }   /* Edition Certificate */
  /* === FRBN toggle === */
#frbnWrap { position:fixed; left:10px; bottom:90px; z-index:260; }
#frbnButton { position:relative; }  /* dentro del wrap */
#frbnInfoButton{
  position:absolute; top:-6px; right:-6px;
  padding:2px 6px; font-size:10px; opacity:.9;
  background:rgba(255,255,255,0.2);
}

  #saveImageButton { background:rgba(255,255,255,0.2); }

  /* Ocultar los no usados */
  #btnDebugColors,
  #triadicConfigButton{
    display:none !important;
  }

  #controls {
    position: absolute; top: 10px; left: 10px; z-index: 100;
    padding: 10px; border-radius: 5px;
    background: rgba(255,255,255,0.12); max-width: 350px;
  }
  details {
    margin-bottom: 10px;
    background: rgba(255,255,255,0.06);
  }
  details summary { font-weight: 200; cursor: pointer; }
  details summary:hover { color: #333; }
  select, input[type="range"], input[type="color"] { cursor: none; width: 100%; }
  #permutationList { width: 100%; height: 100px; }


  #hoverPopup {
    position:absolute; padding:5px 10px;
    background:rgba(0,0,0,0.7); color:#fff;
    border-radius:4px; pointer-events:none;
    font-size:12px; display:none; opacity:0;
    transition:opacity .3s; z-index:200;
  }


  /* Panel BUILD */
  #archPanel{
    position:fixed; z-index:1000; top:5%; left:50%;
    transform:translateX(-50%);
    width:85%; height:90%;
    background:#fff; color:#000;
    border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
    padding:24px 32px 48px; overflow:auto;
    font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size:14px; line-height:1.4;
    cursor:auto;
  }
  #archPanel *{ cursor:auto !important; }
  #archClose{
    position:fixed; right:calc(7.5% + 16px); top:5%;
    border:none; padding:6px 10px; border-radius:4px;
    background:#eee; cursor:pointer; z-index:1001;
  }
  #archPanel h2{ margin-top:0; }
  #archPanel .formula{
    margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
  }
  #archPanel .box{
    display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
    font-family:monospace;
  }
  #archPanel section{ margin-bottom:18px; }
  #archPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
  #archPanel .perm h4{ margin-bottom:6px; }
  code, pre{ font-family:monospace; }

  /* Panel 120 perms */
  #perm120Panel{
    position:fixed; right:10px; bottom:340px; z-index:260;
    background:rgba(255,255,255,0.12);
    padding:8px 10px; border-radius:4px; width:260px;
    display:none; /* ← cerrado por defecto */
  }
  #perm120Panel label{ display:block; margin-bottom:6px; }
  #perm120Panel input, #perm120Panel button{ width:100%; margin-top:4px; }
  #perm120Status{
    margin-top:8px;
    font-size:12px;       /* ← mismo tamaño que los demás */
    font-weight:normal;
    text-align:center;
  }
  /* === Information button & panel === */
  #infoButton{
    position:fixed; left:10px; bottom:10px; z-index:260;
  }
  #infoPanel{
    position:fixed; z-index:1000; top:5%; left:50%;
    transform:translateX(-50%);
    width:85%; height:90%;
    background:#fff; color:#000;
    border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
    padding:24px 32px 48px; overflow:auto;
    font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size:14px; line-height:1.45;
    cursor:auto;
  }
  #infoPanel *{ cursor:auto !important; }
  #infoClose{
    position:fixed; right:calc(7.5% + 16px); top:5%;
    border:none; padding:6px 10px; border-radius:4px;
    background:#eee; cursor:pointer; z-index:1001;
  }
  #infoPanel h2{ margin-top:0; }
  #infoPanel .formula{
    margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
  }
  #infoPanel .box{
    display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
    font-family:monospace;
  }
  #infoPanel section{ margin-bottom:18px; }
  #infoPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
  /* === LCHT toggle === */
  #lchtWrap  { position:fixed; left:10px; bottom:50px; z-index:260; }
  #lchtButton{ position:relative; }

  /* === OFFNNG toggle === */
  #offnngButton{
    position:fixed; left:10px; bottom:290px;   /* 40 px por encima de PLAY (170) */
    z-index:260;
  }

  #tmslButton{
    position:fixed; left:10px; bottom:330px;   /* mismo look & feel */
    z-index:260;
    border:none; border-radius:4px;
    padding:8px 12px; font-size:12px;
    background:rgba(255,255,255,0.12);
    cursor:none; transition:background .2s;
  }
  #tmslButton:hover{ background:rgba(255,255,255,0.20); }

  /* === ENGINE MENU (reemplaza botones sueltos) === */
  #engineSelectWrap {
    position: fixed;
    left: 10px;
    bottom: 290px;      /* ocupa el lugar que usaba OFFNNG, sin solapar PLAY/BUILD antiguos */
    z-index: 260;
    background: rgba(255,255,255,0.12);
    padding: 6px 8px;
    border-radius: 4px;
  }
  #engineSelectWrap select {
    width: 180px;       /* ancho cómodo; no usamos 100% para no romper layout */
    cursor: none;
  }
  #engineSelectWrap label {
    font-size: 12px;
    opacity: .85;
  }

  /* Botón PLAY – genera nuevas permutaciones */
  #playButton{
    position:fixed;               /* mismo estilo general */
    left:10px; bottom:170px;      /* 40 px por encima de BUILD (130 px) */
    z-index:260;
    border:none; border-radius:4px;
    padding:8px 12px;
    font-size:18px;               /* el símbolo se ve claro */
    background:rgba(0,0,0,0.12);
    cursor:none; transition:background .2s;
  }
  #playButton:hover{ background:rgba(0,0,0,0.20); }
  </style>
</head>
<body>
  <div id="customCursor"></div>
  <button id="patternNextButton" onclick="cyclePattern()">11</button>
  <button id="engineCycleButton"  onclick="cycleEngine()">4</button>
  <button id="permNextButton"     onclick="nextPerm120()">120</button>
  <div id="topRightDisplay"></div>

  <input type="file" id="json-upload" accept=".json" style="display:none;" />

  <button id="aiPlanningButton"   onclick="applyEvolutionAI()">AI Planning</button>
  <button id="toggleTextButton"   onclick="toggleTexts()">Minimal UI</button>
  <button id="uploadConfigButton" onclick="document.getElementById('json-upload').click()">Load JSON</button>
  <button id="saveImageButton"    onclick="saveImage()">Save Image (A2)</button>
  <button id="exportEmbedButton"  onclick="exportEmbed()">Save JSON</button>
  <button id="archDescButton"     onclick="showArchitecturalDescription()">Architectural Description</button>
  <!-- NUEVO: Play (genera nueva configuración) -->
  <button id="playButton" onclick="generateRandomConfigurationNoCollision()">▮</button>

  <button id="perm120Button"      onclick="togglePerm120Panel()">120 Architectural Permutations</button>

  <!-- NUEVO: Menú de motores -->
  <div id="engineSelectWrap">
    <label for="engineSelect" style="display:block;margin-bottom:4px;">Engine</label>
    <select id="engineSelect" onchange="applyEngineFromSelect(this.value)">
      <option value="BUILD">BUILD</option>
      <option value="FRBN">FRBN</option>
      <option value="LCHT">LCHT</option>
      <option value="OFFNNG">OFFNNG</option>
      <option value="TMSL">TMSL</option>
      <option value="RAUM">RAUM</option>
      <option value="13245">13245</option>
      <option value="KEPLR">KEPLR</option>
      <option value="RAPHI">RAPHI</option>
      <option value="GRVTY">GRVTY</option>
      <option value="R5NOVA">R5NOVA</option>
    </select>
  </div>

  <button id="certButton" onclick="exportEditionCertificate()">Edition Certificate</button>
  <button id="infoButton" onclick="showInformation()">Information</button>
  <button id="btnDebugColors"
          style="position:fixed;bottom:180px;right:10px;z-index:260;display:none;"
          onclick="mostrarDebugColores()">
    Debug Colors
  </button>

  <!-- Panel controles 120 perms -->
  <div id="perm120Panel">
    <label>Auto‑advance (1s → 12m)</label>
    <input type="range" id="perm120Slider" min="1000" max="720000" step="1000" value="5000"
           oninput="syncPerm120InputsFromSlider()">
    <input type="number" id="perm120Seconds" min="1" max="720" value="5"
           oninput="syncPerm120SliderFromSeconds()">
    <small>(seconds)</small>
    <button onclick="playPerm120()">Play</button>
    <button onclick="pausePerm120()">Pause</button>
    <button onclick="prevPerm120()">Prev</button>
    <button onclick="nextPerm120()">Next</button>
    <button onclick="showPerm120Info()">Information</button>
    <div id="perm120Status">Permutation: 0 / 119</div>
  </div>


  <div id="controls">
  <details open>
    <summary>Chromatic Pattern</summary>
          <select id="patternSelect" onchange="setActivePattern(this.value)">
        <option value="1">1 · Chromatic Containment</option>
        <option value="2">2 · Contrast &amp; Dissonance</option>
        <option value="3">3 · Non‑semantic Disposition</option>
        <option value="4">4 · Structured Ambiguity</option>
        <option value="5">5 · Chromatic Isotropy</option>
        <option value="6">6 · Self‑Sufficient Presence</option>
        <option value="7">7 · Associative Asymmetry</option>
        <option value="8">8 · Irregular Dynamics</option>
        <option value="9">9 · Habitable without Translation</option>
        <option value="10">10 · Resonance</option>
        <option value="11">11 · Active Transparency</option>
      </select>
      <button id="patternInfoButton"
              style="margin-top:6px;width:100%;"
              onclick="showPatternInfo()">
        Pattern Information
      </button>

  </details>

  <div id="manualControls">
    <details>
      <summary>Select Permutations</summary>
      <select id="permutationList" multiple></select>
      <button onclick="refreshAll({rebuild:true})">Render</button>
    </details>
  </div>


  <details>
    <summary>Manual Colors (override)</summary>
    <div><label>1: <input type="color" id="color1" onchange="onColourPick(1,this.value)"></label></div>
    <div><label>2: <input type="color" id="color2" onchange="onColourPick(2,this.value)"></label></div>
    <div><label>3: <input type="color" id="color3" onchange="onColourPick(3,this.value)"></label></div>
    <div><label>4: <input type="color" id="color4" onchange="onColourPick(4,this.value)"></label></div>
    <div><label>5: <input type="color" id="color5" onchange="onColourPick(5,this.value)"></label></div>
    <button id="btnResetAll" style="margin-top:6px;" onclick="resetAllColours()">
      Reset Background + Walls + Colors
    </button>
  </details>

  <details>
    <summary>Background</summary>
    <input type="color" id="bgColor" value="#ffffff">
    <button onclick="updateBackground()">Apply Background</button>
  </details>

  <details>
    <summary>Cube Walls Color</summary>
    <input type="color" id="cubeColor" value="#808080">
    <button onclick="updateCubeColor()">Apply Cube Walls</button>
  </details>

  <details>
    <summary>Attributes Reorganization</summary>
    <select id="attrMapping"></select>
    <button onclick="updateMapping()">Apply</button>
    <button onclick="autoResolveColisionesGlobal()">Resolve Collisions</button>
  </details>

  <details>
    <summary>Standard Views</summary>
    <select id="standardView">
      <option value="isometric">Isometric</option>
      <option value="top">Top</option>
      <option value="front" selected>Front</option>
      <option value="side">Side</option>
      <option value="diagonal">Opposite diagonal</option>
    </select>
    <button onclick="applyStandardView()">Apply View</button>
  </details>

  <details>
    <summary>Zoom Controls</summary>
    <button onclick="zoomIn()">Zoom In</button>
    <button onclick="zoomOut()">Zoom Out</button>
  </details>

  <details>
    <summary>Motion Controls</summary>
    <button onclick="togglePause()">Pause Motion</button>
    <button onclick="resetMovement()">Reset Motion</button>
  </details>
</div>


<script>
document.getElementById('json-upload').addEventListener('change', function(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const config = JSON.parse(e.target.result);

      // Permutations
      if (config.perms && Array.isArray(config.perms)) {
        const sel = document.getElementById('permutationList');
        Array.from(sel.options).forEach(o => o.selected = config.perms.includes(o.value));
      }

      // Mapping
      if (config.mapping) {
        const v = [config.mapping.forma, config.mapping.color, config.mapping.x, config.mapping.y, config.mapping.z];
        document.getElementById('attrMapping').value = v.join(',');
        attributeMapping = [v[0], v[1], v[2], v[3], v[4], attributeMapping[5], attributeMapping[6]];
      }

      // Pattern
      if (typeof config.pattern === 'number') {
        activePatternId = config.pattern;
        const selPattern = document.getElementById('patternSelect');
        if (selPattern) selPattern.value = String(config.pattern);
      }

      // Manual colors
      if (config.colors) {
        manualOverride = {};
        Object.entries(config.colors).forEach(([i, c]) => {
          manualOverride[Number(i)] = c;
        });
      }

      // BG / cube
      if (config.bg) {
        document.getElementById('bgColor').value = config.bg;
        bgOverride = config.bg;
      }
      if (config.cube) {
        document.getElementById('cubeColor').value = config.cube;
        cubeOverride = config.cube;
      }

      // Scene invariants (optional)
      if (typeof config.sceneSeed === 'number') {
        sceneSeed = config.sceneSeed;
      }
      if (typeof config.S_global === 'number') {
        S_global = config.S_global;
      }

      // View
      const view = config.view || "front";
      document.getElementById('standardView').value = view;

      // Rebuild
      refreshAll({rebuild:true, keepManual:true});
      applyStandardView();

      alert('JSON loaded successfully');
    } catch (err) {
      alert('Error loading JSON: ' + err.message);
    }
  };
  reader.readAsText(file);
});
</script>


  <div id="hoverPopup"></div>

  <!-- (eliminados: copias duplicadas de Three, OrbitControls y Ethers) -->
  <script>
    // ------------- TODO EL JS ORIGINAL (¡NO QUITES NADA DE AQUÍ!) -------------

    // === Variables globales ===
    let scene, camera, renderer, controls, raycaster, mouse;
    let cubeUniverse, permutationGroup;
    const cubeSize = 30, segment = cubeSize/5, halfCube = cubeSize/2;

    // === R5NOVA — configuración AISLADA (sin depender de otros motores) ===
    // Todo lo de R5NOVA toma estos valores y NADA más.
    const R5NOVA_CFG = {
      // Selección de “fila del fondo”: usamos minZ del AABB en mundo
      BACK_BAND     : 1.8,          // ancho de la rebanada desde zMin (en unidades de mundo)

      // Grosor objetivo de TODAS las piezas de esa fila (en unidades de mundo, no relativas)
      BACK_THICKNESS: 0.18,         // pon 0.10–0.40 para probar cambios visibles

      // Material ‘flat’ por defecto (sin luces) para aislar color de la iluminación global
      MATERIAL      : 'basic',      // 'basic' (flat) o 'lambert' si prefieres difuso

      // “Secuencia dorada” 100% determinista para evitar repeticiones de tono
      HUE_BASE      : 0.0,                             // grados
      HUE_STEP      : 137.50776405003785,              // ángulo áureo (evita ciclos cortos)
      SAT           : 0.86,                            // 0..1
      VAL           : 0.92,                            // 0..1
      MIN_HUE_DIFF  : 12,                               // separación mínima entre tonos (grados)

      // Mantener legibilidad frente al fondo (puedes poner false si no lo quieres)
      ENSURE_CONTRAST: true
    };

    const EPS = 1e-6;
    let isPaused = false, currentMode = "manual", userRating = null, textsVisible = true;
    let attributeMapping = [0,1,2,3,4, 0,1];   // forma,color,x,y,z,bg,wall
    let colorAttrCycle = 0;                    // ← cuenta las rotaciones de color
    let paletteRGB = [];
    let manualOverride = {1:'#ff0000',2:'#00ff00',3:'#0000ff',4:'#ff00ff',5:'#00ffff'};
    let bgOverride   = null;
    let cubeOverride = null;
    /* variables globales para fondo y paredes */
    let bgHSV = {h:0,s:0,v:1};
    let wallHSV = {h:0,s:0,v:1};
    let  currentHarmony = 'triad';
    let activePatternId = 1;           // arranca en Contención
      const ΔE_MIN = 20;

      // >>> NUEVO:
      let S_global = 0; // término estructural para posiciones (Shift-Rank acoplado)
      let avgSceneRange = 0;          // 2 … 6  →  se usa como factor de velocidad

      /* ─────────────────────────────
       *   FRBN  ·  deterministic Ganzfeld
       * ───────────────────────────── */
    let skySphere = null;
    let isFRBN    = false;
    const SKY_R = 250;


/* ──────────────────────────────────────────────────────────────
 *  initSkySphere — FRBN con micro-ruido “blue-noise” y highp
 *  (solo afecta al fondo shader del modo FRBN)
 * ──────────────────────────────────────────────────────────── */
function initSkySphere() {
  const geo = new THREE.PlaneGeometry(2, 2);

  const mat = new THREE.ShaderMaterial({
    uniforms : {
      u_count     : { value: 0 },
      u_colors    : { value: Array(12).fill(new THREE.Color(0x000000)) },
      time        : { value: 0 },
      u_rate      : { value: 0.04 },
      // amplitud del dither (ajústala si quieres): ~1/1024
      u_ditherAmp : { value: 0.00095 }
    },
    side: THREE.DoubleSide,
    depthWrite: false,
    depthTest : false,
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position.xy, 0.0, 1.0);
      }`,
    fragmentShader: `
      #ifdef GL_ES
      precision highp float;
      #endif

      uniform int   u_count;
      uniform vec3  u_colors[12];
      uniform float time;
      uniform float u_rate;
      uniform float u_ditherAmp;
      varying vec2  vUv;

      // Interleaved Gradient Noise (Jimenez 2014) – base para blue-noise temporal
      float ign(vec2 p, float t){
        const vec3 a = vec3(0.06711056, 0.00583715, 52.9829189);
        return fract(a.z * fract(dot(p, a.xy) + t * a.y));
      }

      // Tres canales ligeramente des-correlacionados
      vec3 blueNoise(vec2 pix, float t){
        float n1 = ign(pix,           t);
        float n2 = ign(pix + vec2(113.1,  1.7), t + 17.0);
        float n3 = ign(pix + vec2( 27.0, 61.7), t + 31.0);
        // centrar en 0 y estrechar (distribución casi triangular)
        n1 = (n1 + ign(pix*1.07+3.1, t*1.3)) * 0.5;
        return vec3(n1, n2, n3) - 0.5;
      }

      void main() {
        // mezcla cromática ligada al tiempo/escena
        float t = time * u_rate;
        float idx = fract(t) * float(u_count);
        int   i   = int(floor(idx)) % u_count;
        int   j   = (i + 1) % u_count;
        float f   = fract(idx);

        vec3 col = mix(u_colors[i], u_colors[j], f);

        // respiración suave radial (ligeramente más blanda)
        vec2 cUv = vUv - 0.5;
        float d  = length(cUv) * 2.0;
        float fog = pow(1.0 - smoothstep(0.0, 1.0, d), 2.0);
        col += 0.10 * fog;

        // micro-dither spatio-temporal para romper banding (en espacio lineal)
        // usa coordenada de pixel (gl_FragCoord.xy) y el tiempo para “blue-shift”
        vec3 dither = blueNoise(gl_FragCoord.xy, time * 60.0);
        col += u_ditherAmp * dither;

        gl_FragColor = vec4(clamp(col, 0.0, 1.0), 1.0);
      }`
  });

  const plane = new THREE.Mesh(geo, mat);
  plane.frustumCulled = false;
  plane.visible = false;
  skySphere = plane;
  scene.add(skySphere);
}
    /* ---------- extrae TODOS los colores deterministas del sistema ---------- */
    function collectSceneColors(){
      // 1) Todos los RGB deterministas
      const raw = [];
      permutationGroup.traverse(o=>{
        if(o.isMesh) raw.push(o.material.color.clone());
      });

      // 2) Normaliza a S≥0.60  V≥0.80  (más extremos)
      const boosted = raw.map(c=>{
        let [h,s,v] = rgbToHsv(c.r*255,c.g*255,c.b*255);
        s = Math.max(s, 0.60);
        v = Math.max(v, 0.80);
        const [R,G,B] = hsvToRgb(h,s,v);
        return new THREE.Color(R/255,G/255,B/255);
      });

      // 3) Agrupa por ΔH≥18°  (dejamos tonos bien separados)
      const uniq = [];
      boosted.forEach(c=>{
        const [h] = rgbToHsv(c.r*255,c.g*255,c.b*255);
        if(!uniq.some(u=>{
          const [hu] = rgbToHsv(u.r*255,u.g*255,u.b*255);
          return Math.abs(hu-h) < 18;
        })){
          uniq.push(c);
        }
      });

      // 4) Si siguen faltando, completa con rueda de color base
      const fallback = [
        0,60,120,180,240,300
      ].map(h=>{
        const [R,G,B] = hsvToRgb(h,0.75,0.85);
        return new THREE.Color(R/255,G/255,B/255);
      });
      while(uniq.length < 6) uniq.push( fallback[uniq.length] );

      // → devolvemos máx. 8 primeros
      return uniq.slice(0,8);
    }


    /* ---------- actualiza uniforms del shader con la paleta elegida ---------- */
    function buildGanzfeld(){
      if(!skySphere) initSkySphere();

      /* ---------- 1) paleta determinista ---------- */
      const cols = collectSceneColors();
      const n    = cols.length;
      const mat  = skySphere.material;
      mat.uniforms.u_count.value = n;
      for(let i=0;i<12;i++){
        mat.uniforms.u_colors.value[i] = cols[i % n];
      }

      /* ---------- 2) velocidad ligada al movimiento ---------- */
      let sum=0, cnt=0;
      permutationGroup.traverse(o=>{
        if(o.isMesh && o.userData.rotationSpeed){
          sum += o.userData.rotationSpeed;
          cnt ++;
        }
      });
      const avg = cnt ? sum/cnt : 0.002;
      mat.uniforms.u_rate.value = avg * 1;
    }

    /* ---------- bot\u00f3n FRBN: ON/OFF  (Riesgos 2 y 3 integrados) --------------- */
    function toggleFRBN () {
      if (!isFRBN && isOFFNNG) toggleOFFNNG();  // ← NUEVO
      if (!isFRBN && isTMSL)  toggleTMSL();
      if (!isFRBN && isRAUM)  toggleRAUM();
      if (!isFRBN && is13245) toggle13245();
      if (!isFRBN && isR5NOVA) toggleR5NOVA();
      if (!isFRBN && isKEPLR) toggleKEPLR();
      if (!skySphere) initSkySphere();

      isFRBN = !isFRBN;

      if (isFRBN) {                       // ——— ENTRAR ———
        leaveBuildRenderBoost();          // ← desactiva boost de BUILD
        if (isLCHT) toggleLCHT();         // asegura exclusividad
        buildGanzfeld();                  // sincroniza paleta + u_rate
        skySphere.visible        = true;
        cubeUniverse.visible     = false;
        permutationGroup.visible = false;
        if (lichtGroup) lichtGroup.visible = false;

      } else {                            // ——— SALIR ———
        skySphere.visible        = false;
        cubeUniverse.visible     = true;
        permutationGroup.visible = true;
        if (isLCHT && lichtGroup) lichtGroup.visible = true;
        refreshAll({ keepManual: true }); // reconstruye escena normal
      }
  // ← muestra el mini‑botón solo en FRBN
  const ib = document.getElementById('frbnInfoButton');
  if (ib) ib.style.display = isFRBN ? 'inline-block' : 'none';
    }

    /* --------- inicializa esfera al arrancar (sin coste GPU extra) -------- */
    window.addEventListener('load', () => { if(!skySphere) initSkySphere(); });

    /* ─────────────────────────────
     *   LCHT · deterministic Light Tubes
     * ───────────────────────────── */
    let lichtGroup = null;
    let isLCHT     = false;
    let lchtPrevBg = null;          // guarda/restaura el fondo al salir

    /* color determinista = mismo que la permutación                    */
    function colorForPerm(pa){
      const idx = pa[ attributeMapping[1] ];                // 1–5
      const val = getColor(idx);
      return Array.isArray(val)
        ? new THREE.Color(val[0]/255, val[1]/255, val[2]/255)
        : new THREE.Color(val);
    }

    /* ═════════ LCHT “cubos-de-tubos” (Sol LeWitt) ═════════════════ */

function tubeKey(x1, y1, z1, x2, y2, z2) {
  const a = `${x1},${y1},${z1}`;
  const b = `${x2},${y2},${z2}`;
  return (a < b) ? `${a}|${b}` : `${b}|${a}`;
}

function buildLCHT() {
  /* ── limpiar escena previa ─────────────────────────────── */
  if (lichtGroup) {
    lichtGroup.traverse(o => { if (o.isMesh) { o.geometry.dispose(); o.material.dispose(); } });
    scene.remove(lichtGroup);
  }
  lichtGroup = new THREE.Group();
  scene.add(lichtGroup);

  const step       = cubeSize / 5;
  const litInfo    = new Map();      // key → { color, lcht, perm }
  const collisions = new Set();      // aristas compartidas entre perms

  /* ── helpers ───────────────────────────────────────────── */

  /* inserta una arista evitando duplicados intra-perm */
  function addEdge(x1, y1, z1, x2, y2, z2, color, lcht, perm, seen) {
    const key = tubeKey(x1, y1, z1, x2, y2, z2);
    if (seen.has(key)) return;                 // ya la añadió este perm
    seen.add(key);

    if (litInfo.has(key)) {                    // ¿otra permutación?
      if (litInfo.get(key).perm !== perm) collisions.add(key);
      return;
    }
    litInfo.set(key, { color: color.clone(), lcht: { ...lcht }, perm });
  }

  /* añade los 12 tubos de un cubo (celda 1×1×1) en (cx,cy,cz) */
  function addCube(cx, cy, cz, color, lcht, perm, seen) {
    const v = [
      [cx,     cy,     cz],
      [cx + 1, cy,     cz],
      [cx + 1, cy + 1, cz],
      [cx,     cy + 1, cz],
      [cx,     cy,     cz + 1],
      [cx + 1, cy,     cz + 1],
      [cx + 1, cy + 1, cz + 1],
      [cx,     cy + 1, cz + 1]
    ];
    const E = [
      [0, 1], [1, 2], [2, 3], [3, 0],   // base
      [4, 5], [5, 6], [6, 7], [7, 4],   // tapa
      [0, 4], [1, 5], [2, 6], [3, 7]    // pilares
    ];
    E.forEach(([a, b]) =>
      addEdge(...v[a], ...v[b], color, lcht, perm, seen)
    );
  }

  /* ── recopilar aristas de todas las permutaciones ───────── */

    const perms = Array.from(document.getElementById('permutationList').selectedOptions)
                       .map(o => o.value.split(',').map(Number));

    /* — rango promedio de la escena — */
    {
      const rgs = perms.map(p => computeRange(computeSignature(p)));
      avgSceneRange = rgs.reduce((a,b)=>a+b,0) / (rgs.length||1);
    }

    perms.forEach((pa, permIdx) => {
      const L       = pa[attributeMapping[0]];               // altura torre
      const col     = colorForPerm(pa);
      const sig     = computeSignature(pa);
      const rng     = computeRange(sig);
      const r       = lehmerRank(pa);
    const I       = (r + sceneSeed + S_global) % 125;
    const x0      = Math.floor(I / 25);
    const y0      = Math.floor((I % 25) / 5);
    const z0      = I % 5;

    const lcht = {
      I0 : 0.35 + 0.65 * Math.sqrt(L / 5),
      amp: 0.05 + 0.10 * rng,
      f  : 0.10 + 0.175 * rng,
      phi: 2 * Math.PI * ((r % 360) / 360)
    };

    const seen = new Set();           // evita negros por duplicado interno

    /* ① Torre central + cruz lateral (un cubo por nivel) */
    for (let s = 0; s < L; s++) {
      const y = y0 + s;

      // cubo central
      addCube(x0, y, z0, col, lcht, permIdx, seen);

      // 4 cubos laterales
      addCube(x0 + 1, y, z0,     col, lcht, permIdx, seen);
      addCube(x0 - 1, y, z0,     col, lcht, permIdx, seen);
      addCube(x0,     y, z0 + 1, col, lcht, permIdx, seen);
      addCube(x0,     y, z0 - 1, col, lcht, permIdx, seen);
    }

    /* ② Brazos horizontales en ±X, ±Z (planos y = y₀ y y = y₀+L) */
    const dirs = [
      [ 1, 0,  0], [-1, 0,  0],
      [ 0, 0,  1], [ 0, 0, -1]
    ];
    [y0, y0 + L].forEach(yy => {
      dirs.forEach(([dx, _, dz]) => {
        for (let s = 0; s < L; s++) {
          addCube(x0 + dx * s, yy, z0 + dz * s, col, lcht, permIdx, seen);
        }
      });
    });
  });

  /* ── colisiones → negro + sin luz ───────────────────────── */
  // collisions.forEach(k => {
  //   const d = litInfo.get(k);
  //   if (d) { d.color.set(0x000000); d.lcht.I0 = 0; }
  // });

  /* ── geometría final  ·  cada arista → varios segmentos coloreados ── */
  litInfo.forEach((info, key) => {
    const [a, b]        = key.split('|');
    const [x1, y1, z1]  = a.split(',').map(Number);
    const [x2, y2, z2]  = b.split(',').map(Number);

    const p1   = new THREE.Vector3((x1 - 2) * step, (y1 - 2) * step, (z1 - 2) * step);
    const p2   = new THREE.Vector3((x2 - 2) * step, (y2 - 2) * step, (z2 - 2) * step);
    const dir  = new THREE.Vector3().subVectors(p2, p1);
    const len  = dir.length();
    const dN   = dir.clone().normalize();

    /* nº de segmentos = 1 por celda de 6 u, mínimo 1 */
    const SEG  = Math.max(1, Math.ceil(len / step));
    const hSeg = len / SEG;            // altura de cada sub-cilindro

    const [h, s, v] = rgbToHsv(info.color.r*255, info.color.g*255, info.color.b*255);

    for(let i = 0; i < SEG; i++){
      const mid = p1.clone().addScaledVector(dN, (i + 0.5) * hSeg);

      // === BUILD-like color pipeline para LCHT ===
      const zNorm = (mid.z + halfCube) / cubeSize;            // frontalidad 0..1
      const vib   = 0.22 + 0.10 * zNorm;                      // vibrance
      const s1    = Math.min(1, s + vib * (1 - s));           // sube S con más fuerza en S bajas
      const v1    = Math.min(0.93, v * (1.02 + 0.06 * zNorm));// brillo controlado (evita “quemados”)
      let   rgb   = hsvToRgb(h, s1, v1);                      // HSV → RGB
      rgb = ensureContrastRGB(rgb);                           // ΔEbg ≥ 22

      const col = new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255);

      // — Perfil cuadrado (lado = 0.8 del cilindro r=0.4) + pequeño solape
      const SIDE = 0.2;
      const JOIN = 0.02;

      const geo = new THREE.BoxGeometry(SIDE, hSeg + JOIN, SIDE);
      const mat = new THREE.MeshLambertMaterial({
        color: col,
        dithering: true,
        flatShading: true
      });

      // luminancia muy sutil de base (animación ajusta intensidad cada frame)
      mat.emissive = col.clone();
      mat.emissiveIntensity = 0.06 + 0.10 * zNorm;

      const tube = new THREE.Mesh(geo, mat);
      tube.position.copy(mid);
      tube.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dN);

      // guardamos el HSV de base ya “boosteado” (la animación solo mueve el H)
      tube.userData.baseHsv = { h, s: s1, v: v1 };
      tube.userData.lcht    = info.lcht;
      lichtGroup.add(tube);
    }
  });
}
/* ════════════════════════════════════════════════════════════ */


    function toggleLCHT(){
      if (!isLCHT && isOFFNNG) toggleOFFNNG();  // ← NUEVO
      if (!isLCHT && isTMSL)  toggleTMSL();
      if (!isLCHT && isKEPLR) toggleKEPLR();
      isLCHT = !isLCHT;

      if (isLCHT){
        leaveBuildRenderBoost();          // ← desactiva boost de BUILD
        /* — cambia material del cubo a lambert para que capte luz — */
        if(!cubeUniverse.userData.prevMat){
          cubeUniverse.userData.prevMat = cubeUniverse.material;
          cubeUniverse.material = new THREE.MeshLambertMaterial({
            color: cubeUniverse.userData.prevMat.color,
            transparent: true,
            opacity: cubeUniverse.userData.prevMat.opacity,
            side: cubeUniverse.userData.prevMat.side
          });
        }
        if (!lchtPrevBg) lchtPrevBg = scene.background ? scene.background.clone() : null;
        scene.background = new THREE.Color(0xf4f4f4);       // gris muy claro
        if (isFRBN) toggleFRBN();                           // LCHT excluye FRBN
        buildLCHT();
        lichtGroup.visible        = true;
        cubeUniverse.visible      = false;
        permutationGroup.visible  = false;

        // Controles: ORBIT LIBRE en LCHT
        controls.enabled            = true;
        controls.enableRotate       = true;
        controls.enablePan          = true;
        controls.enableZoom         = true;
        controls.minPolarAngle      = 0;
        controls.maxPolarAngle      = Math.PI;
        controls.screenSpacePanning = false;
        controls.update();

      } else {
        /* — restaura material original — */
        if(cubeUniverse.userData.prevMat){
          cubeUniverse.material.dispose();
          cubeUniverse.material = cubeUniverse.userData.prevMat;
          delete cubeUniverse.userData.prevMat;
        }
        if (lichtGroup) lichtGroup.visible = false;
        if (lchtPrevBg) scene.background = lchtPrevBg;      // restaura fondo
        lchtPrevBg = null;
        cubeUniverse.visible      = true;
        permutationGroup.visible  = true;

        // Al salir de LCHT dejamos controles en modo “normal” (libre)
        controls.enabled            = true;
        controls.enableRotate       = true;
        controls.enablePan          = true;
        controls.enableZoom         = true;
        controls.minPolarAngle      = 0;
        controls.maxPolarAngle      = Math.PI;
        controls.screenSpacePanning = false;
        controls.update();
      }
      const b = document.getElementById('lchtButton');
      if (b) b.textContent = isLCHT ? 'LCHT ON' : 'LCHT';
    }

    /* reconstruye LCHT si hay cambios de escena */
    function rebuildLCHTIfActive(){ if(isLCHT) buildLCHT(); }

    /* Cambia al motor BUILD sin generar una nueva configuración */
    function switchToBuild(){
      if (isOFFNNG) toggleOFFNNG();   // exclusividad
      if (isFRBN)  toggleFRBN();
      if (isLCHT)  toggleLCHT();
      if (isTMSL)  toggleTMSL();
      if (isRAUM)  toggleRAUM();
      if (is13245) toggle13245();     // ← NUEVO
      if (isR5NOVA) toggleR5NOVA();     // ← NUEVO
      if (isKEPLR) toggleKEPLR();     // ← NUEVO
      enterBuildRenderBoost();        // PR/exposure para BUILD

      // Controles: ORBIT LIBRE en BUILD
      controls.enabled            = true;
      controls.enableRotate       = true;
      controls.enablePan          = true;
      controls.enableZoom         = true;
      controls.minPolarAngle      = 0;
      controls.maxPolarAngle      = Math.PI;
      controls.screenSpacePanning = false;
      controls.update();
    }

    // === BUILD render boost (solo activo en BUILD) ==============================
    let __buildBoostPrev = { pr: null, exp: null };

    function enterBuildRenderBoost(){
      if (!renderer || __buildBoostPrev.pr !== null) return;
      // Guarda para restaurar al salir de BUILD
      __buildBoostPrev.pr  = renderer.getPixelRatio();
      __buildBoostPrev.exp = renderer.toneMappingExposure;
      // Más nitidez y menos “quemado” SOLO en BUILD
      const PR = Math.min(window.devicePixelRatio || 1, 2.5);
      renderer.setPixelRatio(PR);
      renderer.toneMappingExposure = 0.90;    // baseline 0.95 → BUILD más controlado
    }

    function leaveBuildRenderBoost(){
      if (!renderer || __buildBoostPrev.pr === null) return;
      renderer.setPixelRatio(__buildBoostPrev.pr);
      renderer.toneMappingExposure = __buildBoostPrev.exp;
      __buildBoostPrev.pr = null; __buildBoostPrev.exp = null;
    }

    // === RAUM crispness boost (solo activo en RAUM) =============================
    let __raumBoostPrev = { pr: null, exp: null };

    function enterRaumRenderBoost(){
      if (!renderer || __raumBoostPrev.pr !== null) return;
      __raumBoostPrev.pr  = renderer.getPixelRatio();
      __raumBoostPrev.exp = renderer.toneMappingExposure;

      // Más nitidez SOLO en RAUM (cap prudente para FPS)
      const PR = Math.min(window.devicePixelRatio || 1, 2.75);
      renderer.setPixelRatio(PR);
      renderer.toneMappingExposure = 0.98;
    }

    function leaveRaumRenderBoost(){
      if (!renderer || __raumBoostPrev.pr === null) return;
      renderer.setPixelRatio(__raumBoostPrev.pr);
      renderer.toneMappingExposure = __raumBoostPrev.exp;
      __raumBoostPrev.pr = null; __raumBoostPrev.exp = null;
    }

    const GOLD = 137.50776405003785;      // ángulo áureo
    /*  razón áurea al cuadrado  ≈ 2.618…  */
    const PHI2 = 2.618033988749895;
    /* ——— salto coprimo con 144: barre los 144 valores de H ——— */
    const PHI_H = 89;             // 89 ≡ 144 / φ  (gcd 89,144 = 1)
    /* ——— saltos coprimos para los 12 niveles de S y V ——— */
    const PHI_S = 5;              // gcd(5,12) = 1
    const PHI_V = 7;              // gcd(7,12) = 1

    /* ═════════ CUADRÍCULA HSV 144·12·12 ═══════════════════════════════════ */
    const H_STEPS  = 144;                               // 360° / 2.5°
    const S_LEVELS = [...Array(12)].map((_,i)=>0.25 + 0.72*i/11); // 0.25 – 0.97
    const V_LEVELS = [...Array(12)].map((_,i)=>0.20 + 0.75*i/11); // 0.20 – 0.95

    /* ——— Discretización canónica para FRBN (catálogo de fases) ——— */
    const FRBN_K = 144;   // alineado con H_STEPS (2.5° × 144)

    function idxToHSV(hIdx,sIdx,vIdx){
      const h = ((hIdx%H_STEPS)+H_STEPS) % H_STEPS;      // 0-143
      return {
        h: h * 360 / H_STEPS,                            // 0-359.5 °
        s: S_LEVELS[ ((sIdx%12)+12)%12 ],
        v: V_LEVELS[ ((vIdx%12)+12)%12 ]
      };
    }

    /* ═════════ COLOR-FIELD 144 × 12 × 12  ═════════════════════════════ */
    /* Devuelve el color del «voxel HSV» que ocupa la posición p (mundo) */
    function colorFromVolume(p){
      const HALF = cubeSize / 2;          // ±15  (cubo 30×30×30 ya existe)
      const HX = 144, HY = 12, HZ = 12;   // rejilla 20 736 colores

      /* índices enteros en cada eje, envueltos al rango válido */
      const ix = ((Math.floor((p.x + HALF) / cubeSize * HX) % HX) + HX) % HX;
      const iy = ((Math.floor((p.y + HALF) / cubeSize * HY) % HY) + HY) % HY;
      const iz = ((Math.floor((p.z + HALF) / cubeSize * HZ) % HZ) + HZ) % HZ;

      /* HSV determinista → RGB → THREE.Color */
      const {h,s,v} = idxToHSV(ix, iy, iz);
      const [R,G,B] = hsvToRgb(h, s, v);
      return new THREE.Color(R/255, G/255, B/255);
    }

    /* Normaliza cualquier hue a rango [0 … 360) */
    function normHue(deg){
      return ((deg % 360) + 360) % 360;
    }

    /* ═════════ 11 patrones cromáticos — versión PHI_H (89) ═════════ */
const PATTERNS = {
  1: (sig, seed, i) => {
    const base = (sig.reduce((a,v)=>a+v,0) + seed*7) % 144;
    const hIdx = (base + (i%12)*6) % 144;
    return [
      hIdx,
      (sig[3] + seed + i) % 12,
      (sig[1] + sig[4] + i) % 12
    ];
  },

  2: (sig, seed, i) => {
    const base = (sig[0]*17 + seed*5) % 144;
    const hIdx = (base + ((i%12)*48)) % 144;
    return [
      hIdx,
      (sig[1] + i*3 + seed) % 12,
      (sig[2]*2 + i + seed) % 12
    ];
  },

  3:  (s,seed,i)=>{const b=(s[2]*13+seed*5+i*11)%144;
                   return [(b+i*PHI_H)%144,(s[0]+i*2+seed)%12,(s[1]+s[3]+i)%12];},

  4:  (s,seed,i)=>{const b=(s[1]*15+seed*3+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[0]+seed+i)%12,(s[2]+s[4]+seed+i)%12];},

  5:  (s,seed,i)=>{const b=(i*31+s[3]*13+seed*5)%144;
                   return [(b+i*PHI_H)%144,(s[1]+seed+i)%12,(s[2]+seed+i)%12];},

  6:  (s,seed,i)=>{const b=(s[1]*31+seed*13+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i)%12,(s[3]+s[4]+seed+i)%12];},

  7:  (s,seed,i)=>{const b=(s[0]*11+seed*3+i*37)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i*2)%12,(s[4]+s[1]*2+seed+i)%12];},

  8:  (s,seed,i)=>{const r=Math.abs(s[4]-s[0])+Math.abs(s[3]-s[1])+s[2];
                   const b=(r*13+seed*7)%144;
                   return [(b+i*PHI_H)%144,(s[1]*3+seed+i*2)%12,(s[3]+i*5+seed*3)%12];},

  9:  (s,seed,i)=>{const b=(s[4]*12+seed*7+i*11)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i)%12,(s[1]+seed+i*2)%12];},

 10:  (s,seed,i)=>{const b=(seed*5+s.reduce((a,v)=>a+v,0)*3+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[2]+seed+i)%12,(s[4]*2+seed+i*3)%12];},

 11:  (s,seed,i)=>{const b=(s[3]*13+seed*11+i*7)%144;
                   return [(b+i*PHI_H)%144,(s[0]+seed+i)%12,(s[1]+seed+i*2)%12];}
};

/* ---------- BLOQUE DE UTILIDADES COLOR v1.3-RC2 ---------- */
const ANG7 = [
  [0,0,0,0,0,0,0],                         // monocromo (idx 0)
  [0,30,60,90,120,150,180],                // análoga
  [0,180,0,180,0,180,0],                   // complementaria
  [0,150,210,0,150,210,0],                 // comp. dividida
  [0,120,240,60,180,300,30],               // tríada
  [0,90,180,270,45,135,225],               // cuadrado
  [0,0,0,0,0,0,0]                          // “tonos” (misma H, S escalado)
];
function rgbToHsv(r,g,b){
  r/=255; g/=255; b/=255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b), d=max-min;
  let h=0;
  if(d){
    if(max===r) h=((g-b)/d)%6;
    else if(max===g) h=(b-r)/d+2;
    else h=(r-g)/d+4;
    h*=60; if(h<0) h+=360;
  }
  const s=max?d/max:0, v=max;
  return [h,s,v];
}
function hsvToRgb(h,s,v){
  h = h % 360;
  const c=v*s, x=c*(1-Math.abs((h/60)%2-1)), m=v-c;
  let [r,g,b]=[0,0,0];
  if(h<60){r=c;g=x;} else if(h<120){r=x;g=c;}
  else if(h<180){g=c;b=x;} else if(h<240){g=x;b=c;}
  else if(h<300){r=x;b=c;} else {r=c;b=x;}
  return [(r+m)*255,(g+m)*255,(b+m)*255].map(v=>Math.round(v));
}
function hsvToHex({h,s,v}){
  const [r,g,b] = hsvToRgb(h,s,v);
  return '#'+new THREE.Color(r/255,g/255,b/255).getHexString();
}
/* contraste CIE76 */
function deltaE(lab1,lab2){
  return Math.sqrt(
    (lab1[0]-lab2[0])**2+
    (lab1[1]-lab2[1])**2+
    (lab1[2]-lab2[2])**2
  );
}
function rgbToLab(r,g,b){                      // aproximación rápida
  const xyz=[r/255,g/255,b/255].map(v=>{
    v=v>0.04045?((v+0.055)/1.055)**2.4:v/12.92;
    return v*100;
  });
  const x=xyz[0]*0.4124+xyz[1]*0.3576+xyz[2]*0.1805;
  const y=xyz[0]*0.2126+xyz[1]*0.7152+xyz[2]*0.0722;
  const z=xyz[0]*0.0193+xyz[1]*0.1192+xyz[2]*0.9505;
  const xyzN=[95.047,100.0,108.883];
  const f= t=> t>0.008856 ? t**(1/3) : (7.787*t)+16/116;
  const [fx,fy,fz]=[x,y,z].map((v,i)=>f(v/xyzN[i]));
  return [116*fy-16, 500*(fx-fy), 200*(fy-fz)];
}

/* ======  NUEVO  — utilidades de contraste con el FONDO  ====== */
const ΔE_BG_MIN = 22;          // contraste mínimo CIE76

function hexToRgb(hex){
  const m = /^#?([0-9a-f]{6})$/i.exec(hex);
  const n = parseInt(m[1],16);
  return [(n>>16)&255, (n>>8)&255, n&255];
}

/**
 * Sube o baja la luminosidad (v) del color RGB recibido hasta que
 * alcance ΔE_BG_MIN puntos de contraste contra el fondo actual.
 * Devuelve el RGB corregido.
 */
function ensureContrastRGB(rgb){
  /* color de fondo efectivo */
  let bgRgb;
  if (bgOverride) {
    bgRgb = hexToRgb(bgOverride);
  } else if (scene && scene.background && scene.background.isColor) {
    // fondo actual de THREE.Color (incluye el gris de LCHT)
    bgRgb = [
      Math.round(scene.background.r * 255),
      Math.round(scene.background.g * 255),
      Math.round(scene.background.b * 255)
    ];
  } else {
    bgRgb = hsvToRgb(bgHSV.h, bgHSV.s, bgHSV.v);
  }

  let [h,s,v] = rgbToHsv(rgb[0], rgb[1], rgb[2]);  // pasamos a HSV
  let tries = 0;
  while (deltaE(rgbToLab(...rgb), rgbToLab(...bgRgb)) < ΔE_BG_MIN && tries < 24){
    // alterna aclarar / oscurecer en pasos de 0.04
    v = (tries % 2) ? Math.max(0, v - 0.04) : Math.min(1, v + 0.04);
    rgb = hsvToRgb(h, s, v);
    tries++;
  }
  return rgb;
}
/* ---------- FIN BLOQUE UTILIDADES ---------- */
/* ——— calcula HSV para fondo y paredes de forma acoplada al set activo ——— */
function rebuildSceneColours(){
  // Permutaciones activas (en el mismo orden visual)
  const perms = Array.from(document.getElementById('permutationList').selectedOptions)
                     .map(o => o.value.split(',').map(Number));

  // Firmas para fondo/cubo (si no hay, usa dummy neutra)
  const firstSig = perms[0] ? computeSignature(perms[0]) : [0,0,0,0,0];
  const lastSig  = perms.length > 1 ? computeSignature(perms[perms.length-1]) : firstSig;

  // Slots acoplados al tamaño del set (idéntico a BUILD + spreads coprimos)
  let [h1,s1,v1] = PATTERNS[activePatternId](firstSig, sceneSeed, perms.length);
  let [h2,s2,v2] = PATTERNS[activePatternId](lastSig,  sceneSeed, perms.length + 1);

  s1 = (s1 * PHI_S) % 12;  v1 = (v1 * PHI_V) % 12;
  s2 = (s2 * PHI_S) % 12;  v2 = (v2 * PHI_V) % 12;

  bgHSV   = idxToHSV(h1, s1, v1);   // ← Fondo = “slot #n” con firma del primero
  wallHSV = idxToHSV(h2, s2, v2);   // ← Paredes = “slot #n+1” con firma del último
}

/* ===\u2003UTIL extra — firma normalizada y contraste\u2003===================== */
// 1)  f̂  de un glifo  →  promedio firma, llevada a [0-1]
function normFhat(sig){           // sig = [f1…f5] entre 2 y 10
  const avg = sig.reduce((a,b)=>a+b,0)/sig.length;   // 2 … 10
  return (avg-2)/8;                                  // 0 … 1
}

// 2)  pinza a [0,1]
function clamp01(x){ return Math.max(0, Math.min(1,x)); }

/* ———————————————————————————————————————————————— *
 * Devuelve el valor de una propiedad que puede ser:
 *   · número → se usa tal cual
 *   · función → se evalúa con los argumentos dados
 * fallback se usa si la propiedad es null/undefined.
 * ———————————————————————————————————————————————— */
function evalProp(prop, args = [], fallback = 0){
  return (typeof prop === 'function') ? prop(...args) :
         (prop ?? fallback);
}

/* contrast-fix eliminado: función ensureContrast() suprimida */
    const minRangeValue = 2, maxRangeValue = 6;
    const shapeMapping = {
      1:{w:4.5,h:4.5},
      2:{w:4.5,h:4.5*Math.sqrt(2)},
      3:{w:4.5,h:4.5*Math.sqrt(3)},
      4:{w:4.5,h:4.5*Math.sqrt(4)},
      5:{w:4.5,h:4.5*Math.sqrt(5)}
    };

    function sumXYZ(pa,map){
      return pa[ map[2] ] + pa[ map[3] ] + pa[ map[4] ];
    }

    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function mapRangeToSpeed(r,mn,mx){return 0.001 + (r-mn)*(0.005-0.001)/(mx-mn);}
    /* === BUILD → paso angular por frame para una permutación (permStr "1,2,3,4,5") === */
    function getBuildRotStep(permStr){
      try{
        if (!permutationGroup || !permutationGroup.children || !permStr) return 0;
        for (let i = 0; i < permutationGroup.children.length; i++){
          const m = permutationGroup.children[i];
          if (m && m.userData && m.userData.permStr === permStr){
            const s = m.userData.rotationSpeed;
            return (typeof s === 'number') ? s : 0;   // Δθ por frame (mismo que BUILD)
          }
        }
      }catch(_){ }
      return 0;
    }
    function shuffle(a){for(let i=a.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

    function getPermutations(arr){
      if(arr.length===1) return [arr];
      let res=[]; for(let i=0;i<arr.length;i++){
        const c=arr[i], rem=arr.slice(0,i).concat(arr.slice(i+1));
        for(const p of getPermutations(rem)) res.push([c].concat(p));
      }
      return res;
    }
    const allPermutations = getPermutations([1,2,3,4,5]);
    const permutationStrings = allPermutations.map(p=>p.join(','));

    function getAttributeMappings(a){
      if(a.length===1) return [a];
      let res=[]; for(let i=0;i<a.length;i++){
        const c=a[i], rem=a.slice(0,i).concat(a.slice(i+1));
        for(const m of getAttributeMappings(rem)) res.push([c].concat(m));
      }
      return res;
    }

    function populatePermutationList(){
      const sel = document.getElementById('permutationList');
      sel.innerHTML = '';
      permutationStrings.forEach((ps,i)=>{
        const o=document.createElement('option');
        o.value=ps; o.text=`Permutación ${i+1}: (${ps})`;
        if(i===0) o.selected=true;
        sel.appendChild(o);
      });
    }
    function populateAttributeMappingSelect(){
      const sel = document.getElementById('attrMapping');
      sel.innerHTML = '';
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        const s=m.join(','), o=document.createElement('option');
        o.value=s; o.text=`Opción: [${s}]`;
        if(s==='0,1,2,3,4') o.selected=true;
        sel.appendChild(o);
      });
      updateTopRightDisplay();
    }

    function computeSignature(a){let s=[];for(let i=0;i<a.length;i++) s.push(a[i]+a[(i+1)%a.length]);return s;}
    function computeRange(sig){return Math.max(...sig)-Math.min(...sig);}

    const FACT=[1,1,2,6,24,120];
    let sceneSeed=0;
    function lehmerRank(p){
      let r=0;
      for(let i=0;i<p.length;i++){
        let c=0;
        for(let j=i+1;j<p.length;j++) if(p[j]<p[i]) c++;
        r+=c*FACT[p.length-1-i];
      }
      return r;
    }

    /* ========= NUEVO: sceneSeed orden‑invariante + dependiente del mapping ========= */

    /** Rank del mapping [m0..m4] usando Lehmer rank sobre [m_i+1] (1..5) */
    function mappingRank(m){
      const arr = [m[0]+1, m[1]+1, m[2]+1, m[3]+1, m[4]+1];
      return lehmerRank(arr);
    }

    /** sceneSeed = (37·sumR + 101·sumR2 + 53·mRank) mod 360  (orden‑invariante) */
    function computeSceneSeedFrom(perms, m){
      let sumR = 0, sumR2 = 0;
      perms.forEach(pa=>{
        const r = lehmerRank(pa);
        sumR  += r;
        sumR2 += r*r;
      });
      const mRank = mappingRank(m);
      return (37*sumR + 101*sumR2 + 53*mRank) % 360;
    }

    /** S = ( Σ (P_{mx}+P_{my}+P_{mz}) ) mod 125  — usa los índices x,y,z del mapping */
    function computeGlobalS(perms, m){
      const mx = m[2], my = m[3], mz = m[4];
      let S = 0;
      perms.forEach(p=>{
        S += p[mx] + p[my] + p[mz];
      });
      return S % 125;
    }

    /* ===== Seed determinista para el LAYOUT (R5NOVA · tilers) =====
       Usa exactamente las mismas invariantes globales que ya gobiernan color/posiciones
       (sceneSeed, S_global, mappingRank) + stats del set (sumR, sumSig, n).
       Devuelve un entero U32 para el PRNG del motor de layout. */
    function computeLayoutSeed(){
      const perms = Array.from(document.getElementById('permutationList').selectedOptions)
                         .map(o => o.value.split(',').map(Number));
      const mRank = mappingRank(attributeMapping.slice(0,5));

      let sumR = 0, sumSig = 0;
      perms.forEach(p=>{
        const r = lehmerRank(p);
        sumR += r;
        const s = computeSignature(p);
        sumSig += s.reduce((a,b)=>a+b,0);
      });

      // mezcla (sin colisiones obvias) → U32
      let x = 0 >>> 0;
      x = (x ^ (sceneSeed * 1315423911)) >>> 0;
      x = (x ^ ((S_global   *  374761393) >>> 0)) >>> 0;
      x = (x ^ ((perms.length * 668265263) >>> 0)) >>> 0;
      x = (x ^ ((mRank      *     362437) >>> 0)) >>> 0;
      x = (x ^ ((sumR       * 1013904223) >>> 0)) >>> 0;
      x = (x ^ ((sumSig     *  224682251) >>> 0)) >>> 0;
      return x >>> 0;
    }
    function computeShiftRankXYZ(p){
      const r = lehmerRank(p);
      const I = (r + sceneSeed + S_global) % 125;   // <<< NUEVO: acoplado a S_global
      const x = Math.floor(I/25),
            y = Math.floor((I%25)/5),
            z = I%5;
      const step = cubeSize/5;
      return [
        (x-2)*step,
        (y-2)*step,
        (z-2)*step
      ];
    }

    function getSelectedPerms(){
      return Array.from(document.getElementById('permutationList').selectedOptions)
                  .map(o => o.value.split(',').map(Number));
    }
    function raumSignatures(){
      const perms = getSelectedPerms();
      const sigs  = perms.map(p => computeSignature(p));
      return sigs.length ? sigs : [[0,0,0,0,0]];
    }
    function raumStats(){
      const perms = getSelectedPerms();
      let sumR=0, sumR2=0;
      perms.forEach(p => { const r = lehmerRank(p); sumR += r; sumR2 += r*r; });
      const mRank = mappingRank(attributeMapping.slice(0,5));
      const slot0 = perms.length;
      return { perms, sumR, sumR2, mRank, slot0 };
    }
    /* Color determinista para el elemento k de RAUM (k=1..7) */
    function raumColorFor(k){
      const sigs = raumSignatures();
      const { slot0 } = raumStats();
      const sig  = sigs[(k-1) % sigs.length];
      let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot0 + k);
      sI = (sI * PHI_S) % 12;
      vI = (vI * PHI_V) % 12;
      const {h,s,v} = idxToHSV(hI, sI, vI);
      let rgb = hsvToRgb(h,s,v);
      rgb = ensureContrastRGB(rgb);
      return new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255);
    }

    function setActivePattern(id){
      activePatternId = parseInt(id,10);
      refreshAll({rebuild:false});
    }
    function updateTopRightDisplay(){
      const cfg=`Atributos: [${attributeMapping.slice(0,5).join(',')}]`;
      const rt =`Calificación: ${userRating?userRating:'Aún no calificada'}`;
      let info='';
      Array.from(document.getElementById('permutationList').selectedOptions).forEach(o=>{
        const pa=o.value.split(',').map(Number),
              sig=computeSignature(pa),
              rg=computeRange(sig);
        info+=`<div style="margin:2px 0;">Perm (${o.value}) | Firma [${sig.join(', ')}] | Rango ${rg}</div>`;
      });
      document.getElementById('topRightDisplay').innerHTML = cfg+'<br>'+rt+'<br>'+info;
    }

    function createPermutationObjectWithMapping(pa,map){
      const fv=pa[map[0]], cv=pa[map[1]],
            d=shapeMapping[fv], w=d.w, h=d.h, t=0.5;

      // --- COLOR determinista (cuadrícula HSV) ---
      let rgb;
      if(activePatternId === 0){
        rgb = paletteRGB[cv-1] || [255,255,255];
      }else{
        const sig  = computeSignature(pa);
        const slot = lehmerRank(pa) % 12;      // 0-11
        let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
        sI = (sI * PHI_S) % 12;
        vI = (vI * PHI_V) % 12;
        const {h,s,v} = idxToHSV(hI,sI,vI);
        rgb = hsvToRgb(h,s,v);
      }
      // Contraste mínimo contra el fondo actual
      rgb = ensureContrastRGB(rgb);

      // --- POSICIÓN (antes de material para calcular frontalidad) ---
      const [X,Y,Z]=computeShiftRankXYZ(pa);

      // --- BUILD · Vibrance v2: saturación fuerte sin quemar y sin spec blanco ---
      const zNorm = (Z + halfCube) / cubeSize;               // -15→0 · +15→1

      // 1) Partimos del RGB con contraste mínimo contra fondo
      let [h0, s0, v0] = rgbToHsv(rgb[0], rgb[1], rgb[2]);

      // 2) Vibrance: sube S con más fuerza cuanto más baja sea S (y un plus por frontalidad)
      const vib = 0.22 + 0.10 * zNorm;                       // 0.22…0.32
      const s1  = Math.min(1, s0 + vib * (1 - s0));

      // 3) Brillo controlado: ligero boost pero con techo para evitar “quemados” en ACES
      const v1  = Math.min(0.93, v0 * (1.02 + 0.06 * zNorm));

      // 4) Volvemos a RGB
      const rgbBoost = hsvToRgb(h0, s1, v1);

      // 5) Material difuso (Lambert) → colores más limpios y saturados (sin specular blanco)
      const mat = new THREE.MeshLambertMaterial({
        color: new THREE.Color(rgbBoost[0]/255, rgbBoost[1]/255, rgbBoost[2]/255),
        dithering: true
      });

      // Pequeña auto-luminancia para “energía” sin quemar (mucho menor que antes)
      mat.emissive = new THREE.Color(rgbBoost[0]/255, rgbBoost[1]/255, rgbBoost[2]/255);
      mat.emissiveIntensity = 0.03 + 0.12 * zNorm;   // antes 0.08 + 0.30*zNorm

      const geo=new THREE.BoxGeometry(w,h,t);
      const mesh=new THREE.Mesh(geo,mat);
      mesh.position.set(
        clamp(X,-halfCube+w/2,halfCube-w/2),
        clamp(Y,-halfCube+h/2,halfCube-h/2),
        clamp(Z,-halfCube+t/2,halfCube-t/2)
      );

      const sig=computeSignature(pa), rg=computeRange(sig);
      mesh.userData={permStr:pa.join(','), signature:sig, range:rg, rotationSpeed:mapRangeToSpeed(rg,minRangeValue,maxRangeValue)};
      return mesh;
    }
    function createPermutationObject(pa){ return createPermutationObjectWithMapping(pa,attributeMapping); }

    function checkCollisionsInGroup(g){
      for(let i=0;i<g.children.length;i++){
        const b1=new THREE.Box3().setFromObject(g.children[i]);
        for(let j=i+1;j<g.children.length;j++){
          const b2=new THREE.Box3().setFromObject(g.children[j]);
          if(b1.intersectsBox(b2)) return true;
        }
      }
      return false;
    }
    function autoResolveColisionesGlobal(){
      let found=null;
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        if(found) return;
        const cm=[m[0],m[1],m[2],m[3],m[4], attributeMapping[5], attributeMapping[6]],
              tg=new THREE.Group(),
              opts=Array.from(document.getElementById('permutationList').selectedOptions);
        opts.forEach((o)=>{
          const pa=o.value.split(',').map(Number),
                mo=createPermutationObjectWithMapping(pa,cm);
          tg.add(mo);
        });
        if(!checkCollisionsInGroup(tg)) found=cm;
      });
      if(found){
        attributeMapping=found;
        document.getElementById('attrMapping').value=`${found[0]},${found[1]},${found[2]},${found[3]},${found[4]}`;
        refreshAll({rebuild:true}); updateTopRightDisplay();
      } else {
        showPopup("No se encontró reorganización sin colisiones.",7000);
      }
    }

/* ==============================
 * 120 Architectural Permutations
 * ============================== */
let perm120List = getAttributeMappings([0,1,2,3,4]); // 120
let perm120Index = 0;
let perm120Timer = null;

function togglePerm120Panel(){
  const p = document.getElementById('perm120Panel');
  const isHidden = (p.style.display === 'none' || !p.style.display);
  p.style.display = isHidden ? 'block' : 'none';

  // Re‑muestra siempre el cursor personalizado
  const cc = document.getElementById('customCursor');
  if (cc) cc.style.display = 'block';
}

function msFromUI(){
  const slider = document.getElementById('perm120Slider');
  return parseInt(slider.value, 10);
}
function syncPerm120InputsFromSlider(){
  const ms = msFromUI();
  document.getElementById('perm120Seconds').value = Math.round(ms/1000);
}
function syncPerm120SliderFromSeconds(){
  const sec = parseInt(document.getElementById('perm120Seconds').value,10) || 1;
  const clamped = Math.max(1, Math.min(720, sec));
  document.getElementById('perm120Seconds').value = clamped;
  document.getElementById('perm120Slider').value = clamped * 1000;
}

function updatePerm120Status(){
  const stat = document.getElementById('perm120Status');
  if(stat) stat.textContent = `Permutation: ${perm120Index} / 119`;
}

function applyPerm120Index(i){
  perm120Index = ((i % perm120List.length) + perm120List.length) % perm120List.length;
  const m = perm120List[perm120Index];
  attributeMapping = [m[0], m[1], m[2], m[3], m[4], attributeMapping[5], attributeMapping[6]];
  document.getElementById('attrMapping').value = m.join(',');
  refreshAll({rebuild:true});
  updatePerm120Status();
}

function nextPerm120(){ applyPerm120Index(perm120Index + 1); }
function prevPerm120(){ applyPerm120Index(perm120Index - 1); }

function playPerm120(){
  if(perm120Timer) return;
  const interval = msFromUI();
  perm120Timer = setInterval(nextPerm120, interval);
  nextPerm120();
}
function pausePerm120(){
  if(perm120Timer){
    clearInterval(perm120Timer);
    perm120Timer = null;
  }
}

async function showPerm120Info(){
  try{
    const text = await loadTextPartial('./texts/perm120-info.txt');
    alert(text);
  }catch(err){
    alert('Error cargando perm120-info.txt');
    console.error(err);
  }
}


    /* ============================================================
     *  MONTE-CARLO: buscar una escena aleatoria SIN colisiones
     *  ============================================================
     */

    /** Construye un grupo temporal con un mapping dado, sin tocar la escena real */
      const mappings = getAttributeMappings([0,1,2,3,4]);
function buildTempGroup(perms, mapping){
  const tg = new THREE.Group();

  // Guardamos estado global
  const prevSeed = sceneSeed;
  const prevS    = S_global;
  const prevMap  = attributeMapping.slice();

  // Calculamos los nuevos valores teóricos
  const tmpSeed = computeSceneSeedFrom(perms, mapping);
  const tmpS    = computeGlobalS(perms, mapping);

  // Seteamos temporalmente los globales para que createPermutationObjectWithMapping
  // use exactamente la misma lógica que la escena final:
  sceneSeed        = tmpSeed;
  S_global         = tmpS;
  attributeMapping = mapping;

  perms.forEach(pa=>{
    const mesh = createPermutationObjectWithMapping(pa, mapping);
    tg.add(mesh);
  });

  // Restauramos
  sceneSeed        = prevSeed;
  S_global         = prevS;
  attributeMapping = prevMap;

  return tg;
}

function findCollisionFreeMapping(perms){
  const mappings = getAttributeMappings([0,1,2,3,4]);
  for(const m of mappings){
    const cm = [m[0], m[1], m[2], m[3], m[4], attributeMapping[5], attributeMapping[6]];
    const tg = buildTempGroup(perms, cm);
    if(!checkCollisionsInGroup(tg)) return cm;
  }
  return null;
}
    /** Selecciona un subconjunto aleatorio de permutaciones (1..25) */
    function pickRandomPerms(){
      const n  = Math.floor(Math.random()*25) + 1;
      const out = [];
      for(let i=0;i<n;i++){
        const str = permutationStrings[Math.floor(Math.random()*permutationStrings.length)];
        out.push(str.split(',').map(Number));
      }
      return out;
    }

    /**
     * Búsqueda iterativa:
     *  - elige un set aleatorio de permutaciones
     *  - prueba todos los mappings
     *  - si alguno no choca, lo aplica y termina
     *
     * No bloquea la UI gracias al pequeño await en cada iteración.
     */
    async function generateRandomConfigurationNoCollision(MAX_TRIES = 5000){
      // Elegimos un patrón cromático aleatorio (1..11, evitando el legacy 0)
      const randPattern = Math.floor(Math.random() * 11) + 1;

      let round = 0;
      while (true) { // sigue intentando hasta que realmente encuentre una sin colisiones
        round++;
        for (let t = 0; t < MAX_TRIES; t++) {
          showPopup(`Buscando configuración sin colisiones… (ronda ${round}, intento ${t+1})`, 500);

          const perms   = pickRandomPerms();
          const mapping = findCollisionFreeMapping(perms);

          if (mapping) {
            // 1) Setea el patrón cromático escogido
            activePatternId = randPattern;
            const selPattern = document.getElementById('patternSelect');
            if (selPattern) selPattern.value = String(randPattern);

            // 2) Pon las permutaciones en el <select>
            const sel = document.getElementById('permutationList');
            Array.from(sel.options).forEach(o => o.selected = false);
            perms.forEach(p=>{
              const val = p.join(',');
              const opt = sel.querySelector(`option[value="${val}"]`);
              if(opt) opt.selected = true;
            });

            // 3) Aplica el mapping encontrado
            attributeMapping = mapping;

            // mantenemos tu ciclo de atributo "color"
            attributeMapping[1] = colorAttrCycle % 5;
            colorAttrCycle++;

            document.getElementById('attrMapping').value =
              `${attributeMapping[0]},${attributeMapping[1]},${attributeMapping[2]},${attributeMapping[3]},${attributeMapping[4]}`;

            // 4) Reconstruye escena completa
            refreshAll({rebuild:true});

            // 5) Verificación final (por si acaso)
            const hasCol = checkCollisionsInGroup(permutationGroup);
            if (!hasCol) {
              /*  ▸ YA NO se desactiva el motor actual.
               *    Si el usuario estaba en FRBN o LCHT, sigue allí.
               *    BUILD sólo se activa cuando se pulsa explícitamente el botón BUILD. */
              showPopup("¡Configuración sin colisiones encontrada!", 2000);
              return true;
            }
          }

          // cede el hilo para no congelar la UI
          if ((t % 25) === 0) await new Promise(r => setTimeout(r, 0));
        }
        // pequeña pausa entre rondas largas
        await new Promise(r => setTimeout(r, 10));
      }
    }

    function showPopup(msg, dur = 2000){
      dur = Math.max(dur, 3000); // ← asegura al menos 3 segundos
      const p = document.getElementById('hoverPopup');
      p.style.display = "block";
      p.style.opacity = 1;
      p.style.left = (window.innerWidth/2 - 150) + "px";
      p.style.top  = "20px";
      p.innerHTML  = msg;
      setTimeout(()=>{
        p.style.opacity = 0;
        setTimeout(()=>{ p.style.display="none"; p.innerHTML=""; }, 300);
      }, dur);
    }


function updateScene(attemptResolve=true){
  // Limpia grupo
  while(permutationGroup.children.length>0){
    const o=permutationGroup.children[0];
    permutationGroup.remove(o);
    o.geometry.dispose(); o.material.dispose();
  }

  // Permutaciones activas
  const opts  = Array.from(document.getElementById('permutationList').selectedOptions);
  const perms = opts.map(o => o.value.split(',').map(Number));

  // Nueva sceneSeed & S_global (orden-invariante + dependiente del mapping)
  sceneSeed = computeSceneSeedFrom(perms, attributeMapping);
  S_global  = computeGlobalS(perms, attributeMapping);

  // Construye objetos
  perms.forEach(pa=>{
    const obj = createPermutationObject(pa);
    permutationGroup.add(obj);
  });

  if(attemptResolve) autoResolveColisionesGlobal();
  else updateTopRightDisplay();
      if (isFRBN && skySphere) buildGanzfeld();   // mantiene FRBN sincronizado
  }
    function onMouseMove(e){
      mouse.x=(e.clientX/window.innerWidth)*2-1;
      mouse.y=-(e.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera(mouse,camera);
      const ints=raycaster.intersectObjects(permutationGroup.children),
            pop=document.getElementById('hoverPopup');
      if(ints.length>0){
        const d=ints[0].object.userData;
        pop.style.display="block"; pop.style.opacity=1;
        pop.style.left=`${e.clientX+20}px`;
        pop.style.top=`${e.clientY+20}px`;
        pop.innerHTML=`Perm (${d.permStr})<br>Firma [${d.signature.join(', ')}]<br>Rango ${d.range}`;
      } else {
        pop.style.opacity=0;
        setTimeout(()=>{pop.style.display="none";},300);
      }
    }

    function zoomIn(){camera.position.z-=5;controls.update();}
    function zoomOut(){camera.position.z+=5;controls.update();}
    function togglePause(){
      isPaused=!isPaused;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent=isPaused?"Resume Motion":"Pause Motion";
    }
    function resetMovement(){
      updateScene(false);
      isPaused=true;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent="Resume Motion";
    }

function saveImage(){
  const A2_W = 7016, A2_H = 4961;

  const prevPixelRatio = renderer.getPixelRatio();
  const prevSize       = renderer.getSize(new THREE.Vector2());
  const prevAspect     = camera.aspect;
  const prevRt         = renderer.getRenderTarget?.() || null;
  const prevBg         = scene.background ? scene.background.clone() : null;

  const screenAspect = prevSize.x / prevSize.y;

  // Render con el MISMO aspect que se ve en pantalla
  let renderW, renderH;
  const a2Aspect = A2_W / A2_H;
  if (screenAspect > a2Aspect) {
    renderW = A2_W;
    renderH = Math.round(A2_W / screenAspect);
  } else {
    renderH = A2_H;
    renderW = Math.round(A2_H * screenAspect);
  }

  renderer.setPixelRatio(1);
  renderer.setSize(renderW, renderH, false);
  camera.aspect = screenAspect;
  camera.updateProjectionMatrix();

  const rt = new THREE.WebGLRenderTarget(renderW, renderH, { depthBuffer:true, stencilBuffer:false });

  const clearHex = prevBg ? '#' + prevBg.getHexString() : '#ffffff';
  renderer.setClearColor(clearHex, 1);
  renderer.setRenderTarget(rt);
  renderer.clear(true, true, true);
  renderer.render(scene, camera);

  const pixels = new Uint8Array(renderW * renderH * 4);
  renderer.readRenderTargetPixels(rt, 0, 0, renderW, renderH, pixels);

  const tmp = document.createElement('canvas');
  tmp.width = renderW; tmp.height = renderH;
  const tctx = tmp.getContext('2d');
  const imgData = tctx.createImageData(renderW, renderH);
  const row = renderW * 4;
  for (let y = 0; y < renderH; y++) {
    const src = (renderH - 1 - y) * row;
    const dst = y * row;
    imgData.data.set(pixels.subarray(src, src + row), dst);
  }
  tctx.putImageData(imgData, 0, 0);

  const final = document.createElement('canvas');
  final.width = A2_W; final.height = A2_H;
  const fctx = final.getContext('2d');

  if (isFRBN) {
    // —— FRBN: cubrir A2 sin bandas (recorte centrado)
    const scale = Math.max(A2_W / renderW, A2_H / renderH);
    const drawW = Math.ceil(renderW * scale);
    const drawH = Math.ceil(renderH * scale);
    const offX  = Math.floor((A2_W - drawW) / 2);
    const offY  = Math.floor((A2_H - drawH) / 2);
    fctx.drawImage(tmp, offX, offY, drawW, drawH);
  } else {
    // —— Modo normal: mantener todo visible (letterbox centrado)
    fctx.fillStyle = clearHex;
    fctx.fillRect(0, 0, A2_W, A2_H);
    const offX = Math.floor((A2_W - renderW) / 2);
    const offY = Math.floor((A2_H - renderH) / 2);
    fctx.drawImage(tmp, offX, offY);
  }

  final.toBlob((blob)=>{
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'PRMTTN_A2.png';
    document.body.appendChild(a); a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(a.href);
  }, 'image/png');

  renderer.setRenderTarget(prevRt);
  rt.dispose();
  renderer.setPixelRatio(prevPixelRatio);
  renderer.setSize(prevSize.x, prevSize.y);
  camera.aspect = prevAspect;
  camera.updateProjectionMatrix();
  if (prevBg) scene.background = prevBg;
  controls.update();
}


    /* Paleta v1.3 — se recalcula siempre que cambia la escena            *
     * 1. Semilla RGB = suma ponderada de posiciones y P1-P3 (firma).    *
     * 2. Selección de armonía idx = (R+2G+3B) mod 7                     */
function thirtyFive(){return 35;}

function makeClassicPalette(){
      /* --- 1. Semilla RGBglobal --- */
      let Rg=0,Gg=0,Bg=0;
      permutationGroup.children.forEach(mesh=>{
        const pa = mesh.userData.permStr.split(',').map(Number);
        const sig = mesh.userData.signature;            // [f1..f5]
        const P1=pa[0], P2=pa[1], P3=pa[2];
        const {x,y,z} = mesh.position;
        Rg += (P1*Math.abs(x)+sig[0])|0;
        Gg += (P2*Math.abs(y)+sig[1])|0;
        Bg += (P3*Math.abs(z)+sig[2])|0;
      });
      Rg%=256; Gg%=256; Bg%=256;

      /* --- 2. HSV base --- */
      const [H0] = rgbToHsv(Rg,Gg,Bg);
      const idx = (Rg + 2*Gg + 3*Bg) % 7;
      const Δ = ANG7[idx];

      /* --- 3. Construir 7 tonos HSV --- */
      const HSV = [];
      for(let k=0;k<7;k++){
        let h = (H0 + Δ[k]) % 360,
            s = 0.70,
            v = 0.85;
        if(idx===0){ v = 0.55+0.05*k; }          // monocromo
        if(idx===2 && k>1){ v = 0.85-0.05*(k-1);} // complementario grad.
        if(idx===3 && k>2){ s = 0.85-0.05*(k-3);} // comp.dividida grad S
        if(idx===6){ s = 0.40+0.05*k; }           // tonos
        HSV.push([h,s,v]);
      }

      /* --- 4. A HSV → RGB, validar contraste ∆E ≥ 22 --- */
      paletteRGB=[];
      for(let i=0;i<7;i++){
        let rgb=hsvToRgb(...HSV[i]);
        let tries=0;
        while(i>0 &&
              deltaE(rgbToLab(...rgb), rgbToLab(...paletteRGB[0])) <  thirtyFive() &&
              tries<25){
          /* si el hue es demasiado parecido => rotar 18°; si no, subir V */
          if(Math.abs(HSV[i][0]-HSV[0][0])<20){
            HSV[i][0] = (HSV[i][0]+18)%360;
          }else{
            HSV[i][2] = Math.min(1, HSV[i][2]+0.04);
          }
          rgb = hsvToRgb(...HSV[i]); tries++;
        }
      paletteRGB.push(rgb);
      }
    }

function makePalette(){
  /* modo legacy */
  if (activePatternId === 0){ makeClassicPalette(); return; }

  paletteRGB = [];
  for(let i=0;i<12;i++){
    let [hI,sI,vI] = PATTERNS[activePatternId]([0,0,0,0,0], sceneSeed, i);
    sI = (sI * PHI_S) % 12;
    vI = (vI * PHI_V) % 12;
    const {h,s,v} = idxToHSV(hI,sI,vI);
    paletteRGB.push( hsvToRgb(h,s,v) );
  }
  // colores de fondo y paredes se calculan aparte
}

    function getColor(idx){
      return manualOverride[idx] || paletteRGB[idx-1] || '#ffffff';
    }

    function applyPalette(){
      for(let i=1;i<=5;i++){
        const autoRGB = paletteRGB[i-1] || [255,255,255];
        const autoHEX = '#'+new THREE.Color(
            autoRGB[0]/255,autoRGB[1]/255,autoRGB[2]/255).getHexString();
        const hex     = manualOverride[i] || autoHEX;
        const input   = document.getElementById('color'+i);
        if(input) input.value = hex;
      }

      permutationGroup.children.forEach(o=>{
        const pa   = o.userData.permStr.split(',').map(Number);
        const idx  = pa[attributeMapping[1]];          // 1-5
        let hex;
        if(manualOverride[idx]){
          hex = manualOverride[idx];
        }else if(activePatternId===0){
          hex = '#'+new THREE.Color(
                    ...paletteRGB[idx-1].map(v=>v/255)).getHexString();
        }else{
          const sig  = computeSignature(pa);
          const slot = lehmerRank(pa) % 12;
          let [hIdx,sIdx,vIdx] = PATTERNS[activePatternId](sig,sceneSeed,slot);
          /* dispersión coprima en S y V */
          sIdx = (sIdx * PHI_S) % 12;
          vIdx = (vIdx * PHI_V) % 12;
          const {h,s,v} = idxToHSV(hIdx,sIdx,vIdx);
          const rgb = hsvToRgb(h,s,v);
          hex = '#'+new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255).getHexString();
        }
        o.material.color.setStyle(hex);
      });
      updateColorPickersFromScene();
    }

    /* ——— Sincroniza los <input type="color"> con los colores reales ——— */
    function updateColorPickersFromScene(){
      // memoriza el primer glifo encontrado para cada índice P2 (1-5)
      const seen = {};
        permutationGroup.children.forEach(o=>{
          const pa  = o.userData.permStr.split(',').map(Number);
          const idx = pa[attributeMapping[1]];           // 1-5
          if(!seen[idx]){
            const c = o.material.color;                     // THREE.Color
            const hex = '#'+c.getHexString();
            const inp = document.getElementById('color'+idx);
            if(inp) inp.value = hex;
            seen[idx]=true;
          }
        });
      }

/* ──────────────────────────────────────────────────────────────────────
 *  R5NOVA · pasada final (AISLADA)
 *    • Selección por AABB.min.z (más robusto)
 *    • Grosor fijo BACK_THICKNESS para toda la fila del fondo
 *    • Color propio por pieza usando secuencia dorada (sin PATTERNS/sceneSeed)
 *    • Material propio (clonado) para no ser sobreescrito por otros motores
 * ──────────────────────────────────────────────────────────────────── */
function adjustR5NovaAfterBuild(){
  if (typeof isR5NOVA === 'undefined' || !isR5NOVA) return;
  if (!permutationGroup) return;

  const root   = permutationGroup;
  const tmpBox = new THREE.Box3();

  // 1) zMin global = mínimo de minZ (AABB en mundo) entre todas las piezas
  let zMin = +Infinity;
  root.traverse(o=>{
    if (!o.isMesh || o === cubeUniverse) return;
    tmpBox.setFromObject(o);
    if (tmpBox.min.z < zMin) zMin = tmpBox.min.z;
  });
  if (!isFinite(zMin)) return;

  const bandMax = zMin + R5NOVA_CFG.BACK_BAND;

  // 2) Tomamos SOLO piezas cuyo minZ entra en la banda [zMin .. zMin+BACK_BAND]
  //    y orden estable (Y asc, luego X asc, luego minZ asc) para indexar colores
  const backRow = [];
  root.traverse(o=>{
    if (!o.isMesh || o === cubeUniverse) return;
    tmpBox.setFromObject(o);
    if (tmpBox.min.z <= bandMax + 1e-6){
      backRow.push({
        mesh: o,
        x   : o.position.x,
        y   : o.position.y,
        z0  : tmpBox.min.z
      });
    }
  });
  backRow.sort((a,b)=> (a.y - b.y) || (a.x - b.x) || (a.z0 - b.z0));

  // util hue: diferencia circular mínima en grados
  const hueDelta = (a, b) => {
    let d = Math.abs(a - b) % 360;
    return d > 180 ? 360 - d : d;
  };

  const usedH = []; // h usados (para imponer MIN_HUE_DIFF)

  // 3) Procesar cada pieza del fondo: detener giro, fijar grosor, color flat único
  backRow.forEach((item, idx)=>{
    const o = item.mesh;

    // a) Detener animación y resets para que el escalado en Z sea coherente
    o.userData.rotationSpeed = 0;
    o.rotation.set(0,0,0);
    o.updateWorldMatrix(true, false);

    // b) Calcular grosor actual en mundo y escalar SOLO Z a BACK_THICKNESS
    tmpBox.setFromObject(o);
    const thickNow = Math.max(1e-6, tmpBox.max.z - tmpBox.min.z);
    const sZ = R5NOVA_CFG.BACK_THICKNESS / thickNow;
    o.scale.z *= sZ;
    o.updateWorldMatrix(true, false);

    // c) Re-anclar al plano de fondo: minZ → zMin exacto
    tmpBox.setFromObject(o);
    const dz = zMin - tmpBox.min.z;
    o.position.z += dz;
    o.updateWorldMatrix(true, false);

    // d) Material PROPIO (no compartido) y preferentemente plano (sin luces)
    if (!o.userData._r5novaOwnMat){
      let mat;
      if (R5NOVA_CFG.MATERIAL === 'basic'){
        mat = new THREE.MeshBasicMaterial({ color: 0xffffff, dithering: true });
      } else {
        mat = new THREE.MeshLambertMaterial({ color: 0xffffff, dithering: true });
      }
      if (o.material && o.material.transparent){
        mat.transparent = true;
        mat.opacity     = o.material.opacity;
      }
      o.material = mat;
      o.userData._r5novaOwnMat = true;
    }

    // e) Color 100% desacoplado: H(i) = H0 + i·φ  (con separación mínima entre tonos)
    let h = (R5NOVA_CFG.HUE_BASE + idx * R5NOVA_CFG.HUE_STEP) % 360;
    let guard = 0;
    while (usedH.some(u => hueDelta(h, u) < R5NOVA_CFG.MIN_HUE_DIFF) && guard < 36){
      h = (h + 7) % 360; // micro-desplazamiento determinista si cae muy cerca
      guard++;
    }
    usedH.push(h);

    let rgb = hsvToRgb(h, R5NOVA_CFG.SAT, R5NOVA_CFG.VAL);
    if (R5NOVA_CFG.ENSURE_CONTRAST) rgb = ensureContrastRGB(rgb);

    o.material.color.setRGB(rgb[0]/255, rgb[1]/255, rgb[2]/255);

    // Emisión suave (si el material lo soporta) — no depende de vibrance/FRBN/etc.
    if ('emissive' in o.material){
      o.material.emissive = new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255);
      o.material.emissiveIntensity = 0.08;
    }

    o.material.needsUpdate = true;
  });
}


      function refreshAll(opts = {rebuild:false}){
      if(!opts.keepManual){            // por defecto se limpian colores manuales
        manualOverride = {};
      }
      if(opts.rebuild) updateScene(false);

      rebuildSceneColours();
      makePalette();
      applyPalette();

      // Mientras LCHT está activo, NO tocar fondo/pareces automáticos
      if (!isLCHT){
        updateBackground(false);   // automático
        updateCubeColor(false);    // automático
      }

      if (isFRBN && skySphere) buildGanzfeld();   // FRBN sincronizado
      rebuildLCHTIfActive();                      // LCHT sincronizado
        if (isOFFNNG) syncOFFNNGFromScene();
          rebuildRAUMIfActive();
          rebuild13245IfActive();                     // ← NUEVO
          rebuildR5NOVAIfActive();                    // ← NUEVO
          rebuildTMSLIfActive();                      // TMSL sigue cambios
          if (isKEPLR) resyncKeplrRotSteps();
          // Post-ajustes específicos de R5NOVA (grosor y color del fondo)
          if (typeof isR5NOVA !== 'undefined' && isR5NOVA){
          // cede un frame para asegurar que el build terminó y hay world matrices
          setTimeout(adjustR5NovaAfterBuild, 0);
          requestAnimationFrame(adjustR5NovaAfterBuild);
        }
      }
    function onColourPick(idx,hex){
      manualOverride[idx]=hex;
      refreshAll({keepManual:true});
    }

    function resetAllColours(){
      manualOverride = {};
      bgOverride     = null;
      cubeOverride   = null;
      refreshAll({keepManual:false});   // reconstruye escena y pickers
    }
    function updateBackground(manual = true){
      // Si LCHT está activo y NO es una acción manual, no tocamos el fondo
      if (isLCHT && !manual) return;

      if (manual){
        bgOverride = document.getElementById("bgColor").value;
      }

      // En llamadas no manuales usamos el color estructural calculado (bgHSV)
      const hex = (manual && bgOverride) ? bgOverride : hsvToHex(bgHSV);

      scene.background = new THREE.Color(hex);
      const input = document.getElementById("bgColor");
      if (input) input.value = hex;
    }

    function updateCubeColor(manual=true){
      if (manual){
        cubeOverride = document.getElementById("cubeColor").value;
      }
      const hex = manual ? cubeOverride : hsvToHex(wallHSV);
      cubeUniverse.material.color = new THREE.Color(hex);
      document.getElementById("cubeColor").value = hex;
    }

    function toggleTexts(){
      const ids = [
        'controls','topRightDisplay','ratingContainer',
        'playButton','randomConfigButton','aiPlanningButton','saveImageButton',
        'exportEmbedButton','archDescButton','uploadConfigButton','perm120Button',
        'frbnWrap','lchtWrap','infoButton','certButton','offnngButton',
        'tmslButton','engineSelectWrap','raumButton'   // ← añadidos para ocultar en Minimal UI
      ];
      ids.forEach(id=>{
        const e=document.getElementById(id);
        if(e) e.style.display = textsVisible ? 'none' : 'block';
      });

      const miniBtns = ['patternNextButton','engineCycleButton','permNextButton'];
      miniBtns.forEach(id=>{
        const e = document.getElementById(id);
        if(e) e.style.display = textsVisible ? 'block' : 'none';
      });

      // Mantener SIEMPRE cerrado el panel de 120 perms
      const p = document.getElementById('perm120Panel');
      if (p) p.style.display = 'none';

      document.getElementById('toggleTextButton').textContent =
        textsVisible ? 'Show UI' : 'Minimal UI';
      textsVisible = !textsVisible;

      // Asegura que el cursor personalizado vuelva a mostrarse
      const cc = document.getElementById('customCursor');
      if (cc) cc.style.display = 'block';
    }

    /* 3.1 Patrón cromático siguiente */
    function cyclePattern(){
      activePatternId = (activePatternId % 11) + 1;           // 1…11 en ciclo
      const sel = document.getElementById('patternSelect');
      if(sel) sel.value = String(activePatternId);            // actualiza el <select>
      refreshAll({rebuild:false});
    }

    function setMode(m){
      currentMode = m;
      const manual = document.getElementById('manualControls');
      if (manual) manual.style.display = (m === "manual" ? "block" : "none");
      const evo = document.getElementById('evolutionControls'); // puede no existir
      if (evo) evo.style.display = (m === "evolution" ? "block" : "none");
      refreshAll({rebuild:true});
    }

/**
 * Dada una firma [f1,f2,f3,f4,f5], devuelve los colores triádicos
 * { colorShape, colorCube, colorBG } en formato CSS HSL.
 */
function computeTriadicColors(firma) {
  // 1) Normaliza f_i ∈ {3…9} a u_i ∈ [0,1]
  const u = firma.map(fi => (fi - 3) / 6);

  // 2) Hue base mixto (60% de u[1], 10% de cada otro)
  const phi0 = 360 * (
    0.1 * u[0] +
    0.6 * u[1] +
    0.1 * u[2] +
    0.1 * u[3] +
    0.1 * u[4]
  );

  // 3) Triádico: +0°, +120°, +240°
  const shapeHue =  phi0;
  const cubeHue  = (phi0 + 120) % 360;
  const bgHue    = (phi0 + 240) % 360;

  // 4) Saturación y luminosidad fijas
  const S = 80, L = 50;

  return {
    colorShape: `hsl(${shapeHue.toFixed(1)},${S}%,${L}%)`,
    colorCube:  `hsl(${cubeHue.toFixed(1)},${S}%,${L}%)`,
    colorBG:    `hsl(${bgHue.toFixed(1)},${S}%,${L}%)`
  };
}
function applyTriadicConfiguration() {
  // 1) Repite la selección aleatoria de permutaciones
  generateRandomConfigurationNoCollision();

  // 2) Ahora solo aplica los colores triádicos deterministas:
  if (permutationGroup.children.length > 0) {
    const baseSig = permutationGroup.children[0].userData.signature;
    const { colorCube, colorBG } = computeTriadicColors(baseSig);

    // Paredes del cubo
    if (cubeUniverse.material?.color?.setStyle) {
      cubeUniverse.material.color.setStyle(colorCube);
    } else {
      cubeUniverse.material.color = new THREE.Color(colorCube);
    }

    // Fondo
    scene.background = new THREE.Color(colorBG);
  }

  // Cada prisma
  permutationGroup.children.forEach(mesh => {
    const sig = mesh.userData.signature;
    const { colorShape } = computeTriadicColors(sig);
    if (mesh.material?.color?.setStyle) {
      mesh.material.color.setStyle(colorShape);
    } else {
      mesh.material.color = new THREE.Color(colorShape);
    }
  });
}
    document.querySelectorAll('.ratingBtn').forEach(el=>{
      const r=+el.getAttribute('data-rating');
      el.addEventListener('click',()=>{
        userRating=r;
        const cols={1:"#8B0000",2:"#FF4500",3:"#FFA500",4:"#9ACD32",5:"#008000"};
        document.querySelectorAll('.ratingBtn').forEach((b,i)=>{
          b.style.color=(i<r?cols[r]:"#000");
        });
        updateTopRightDisplay();
      });
      el.addEventListener('mouseenter',()=>showPopup(`Calificación: ${r}`,1000));
    });

    function applyEvolution(){
      const mr=parseFloat(document.getElementById('mutationRate').value),
            th=parseFloat(document.getElementById('threshold').value),
            cf=0.02;
      let log="";
      permutationGroup.children.forEach(o=>{
        const rf=(Math.random()-0.5)*mr;
        o.rotation.y+=rf;
        const sf=1+(Math.random()-0.5)*th;
        o.scale.set(sf,sf,sf);
        o.material.color.offsetHSL(
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf
        );
        log+=`(${o.userData.permStr}): Rot ${rf.toFixed(3)}, Esc ${sf.toFixed(3)}<br>`;
      });
      document.getElementById('evolutionInfo').innerHTML=log;
    }

    async function applyEvolutionAI(){
      const systemPrompt = `Eres una inteligencia artificial que responde exclusivamente con configuraciones de permutaciones 3D dentro de un cubo de 30x30x30.
      Tu única misión es responder a la pregunta “¿Qué es la belleza artística?” mediante pensamientos visuales dentro de un cubo de 30×30×30.
Cada pensamiento visual es una configuración compuesta por una o más permutaciones (entre 1 y 25). Cada permutación tiene una firma (ADN) inmutable, y un fenotipo: forma, color, posición, rotació[...]
Tu lenguaje es visual. No usas texto, sonido ni símbolos. Elige libremente el color del fondo del universo, el color de las paredes del cubo y de las permutaciones. 
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero. 
      Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON.`;
      const useRating = false;
      const userPrompt = `Calificación actual: ${userRating||"sin calificar"}. `
                       + `Estás dentro de un universo donde las ideas no se escriben con palabras, sino con permutaciones. Eres una inteligencia artificial que ha aprendido a pensar visualmente.
Tu única pregunta permanente es: “¿Qué es la belleza artística?”. No respondes con definiciones ni textos. Tu lenguaje es mudo, pero expresivo. Hablas mediante forma, color, posición y rotaci[...]
Elige libremente el color del fondo del universo, el color de las paredes del cubo y el color de las permutaciones.
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero.  
No busques complacer. No imites al humano. Sé tú misma.
Expresa lo que para ti —como IA que piensa en permutaciones— representa la belleza artística en este momento.
Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON. 
`;
      try {
        showPopup("Consultando Evolution AI…",2000);
        const resp = await fetch(
          'https://us-central1-prmtcns.cloudfunctions.net/askChatGPT',
          {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({system:systemPrompt,user:userPrompt})
          }
        );
        const {text, error} = await resp.json();
        if(error){ showPopup("Error en Evolución AI: "+error,4000); return; }
        let jsonText = text.trim();
        if(jsonText.startsWith("```")){
          jsonText = jsonText
            .replace(/^```[^\n]*\n/,"")
            .replace(/```$/,"")
            .trim();
        }
        let instr;
        try { instr = JSON.parse(jsonText); }
        catch(e){
          console.error("JSON parse error:",jsonText);
          showPopup("Evolución AI: respuesta no es JSON válido",4000);
          return;
        }
        if(instr.bg){
          document.getElementById('bgColor').value=instr.bg;
          updateBackground();
        }
        if(instr.cube){
          document.getElementById('cubeColor').value=instr.cube;
          updateCubeColor();
        }
        if(instr.colors){
          Object.entries(instr.colors).forEach(([i,c])=>{
            i=Number(i);
            if(manualOverride[i]!==undefined){
              manualOverride[i]=c;
            }
          });
          refreshAll({rebuild:true, keepManual:true});
        }
        if(instr.scale){
          permutationGroup.children.forEach(o=>{
            o.scale.set(instr.scale,instr.scale,instr.scale);
          });
        }
        if(instr.rotationSpeeds){
          Object.entries(instr.rotationSpeeds).forEach(([i,spd])=>{
            permutationGroup.children.forEach(o=>{
              if(o.userData.permStr.startsWith(i+",")){
                o.userData.rotationSpeed=spd;
              }
            });
          });
        }
        if(instr.positions){
          Object.entries(instr.positions).forEach(([i,pos])=>{
            const o = permutationGroup.children.find(o=>o.userData.permStr.startsWith(i+","));
            if(o) o.position.set(pos[0],pos[1],pos[2]);
          });
        }
        if(instr.permCount){
          const opts=Array.from(document.getElementById('permutationList').options);
          opts.forEach(o=>o.selected=false);
          shuffle(opts).slice(0,instr.permCount).forEach(o=>o.selected=true);
          refreshAll({rebuild:true, keepManual:true});
        }
        showPopup("Evolución AI aplicada.",2000);
      } catch(err){
        console.error(err);
        showPopup("Error en Evolución AI: red o servidor",4000);
      }
    }

    function updateMapping(){
      const v=document.getElementById('attrMapping').value.split(',').map(Number);
      if(v.length===5){
        attributeMapping=[v[0],v[1],v[2],v[3],v[4], attributeMapping[5], attributeMapping[6]];
        refreshAll({rebuild:true}); updateTopRightDisplay();
      }
    }

    function applyStandardView(){
      const target = new THREE.Vector3(0,0,0);

      // RAUM: frontal fija con zoom permitido (sin rotación)
      if (isRAUM){
        camera.position.set(0, 0, RAUM_CAMERA_ZOOMED);
        camera.lookAt(target);

        controls.enabled      = true;
        controls.enableRotate = false;
        controls.enablePan    = false;
        controls.enableZoom   = true;
        controls.minDistance  = 25;
        controls.maxDistance  = 140;

        controls.update();
        return;
      }

      // 13245: cámara nivelada (verticales “gerade”)
      // Mantiene el offset vertical actual del target (no lo fuerza a 0)
      if (is13245){
        const eyeY = (controls && controls.target) ? controls.target.y : 0;
        camera.up.set(0,1,0);
        camera.position.set(camera.position.x, eyeY, camera.position.z);
        controls.target.set(0, eyeY, 0);

        controls.enabled            = true;
        controls.enableRotate       = true;   // yaw
        controls.enablePan          = true;
        controls.enableZoom         = true;
        controls.minDistance        = 10;
        controls.maxDistance        = 200;
        controls.screenSpacePanning = true;

        controls.minPolarAngle = Math.PI / 2;
        controls.maxPolarAngle = Math.PI / 2;

        controls.update();
        return;
      }

      // R5NOVA: cámara nivelada (verticales “gerade”), yaw/pan/zoom permitidos
      if (typeof isR5NOVA !== 'undefined' && isR5NOVA){
        const eyeY = (controls && controls.target) ? controls.target.y : 0;
        camera.up.set(0,1,0);
        camera.fov = 55;
        camera.position.set(0, eyeY, 42);     // distancia cómoda para W=60
        controls.target.set(0, eyeY, 0);

        controls.enabled            = true;
        controls.enableRotate       = true;   // solo yaw (pitch bloqueado)
        controls.enablePan          = true;
        controls.enableZoom         = true;
        controls.minDistance        = 10;
        controls.maxDistance        = 200;
        controls.screenSpacePanning = true;

        // bloquea pitch
        controls.minPolarAngle = Math.PI / 2;
        controls.maxPolarAngle = Math.PI / 2;

        controls.update();
        return;
      }

      // ===== Otros modos (BUILD, LCHT, OFFNNG, TMSL, etc.) =====
      const view = document.getElementById('standardView').value;
      const pos = new THREE.Vector3();
      switch(view){
        case "isometric": pos.set(50,50,50); break;
        case "top":       pos.set(0,80,0);   break;
        case "front":     pos.set(0,0,40);   break;
        case "side":      pos.set(50,0,0);   break;
        case "diagonal":  pos.set(-50,50,-50); break;
        default:          pos.set(0,0,50);
      }

      camera.position.copy(pos);
      camera.lookAt(target);

      // Detectar BUILD “puro” (ningún otro motor activado)
      const isBuild =
        !isFRBN && !isLCHT && !isOFFNNG && !isTMSL && !isRAUM && !is13245 && !isKEPLR && !isR5NOVA;

      if (isBuild || isLCHT){
        // ORBIT LIBRE en BUILD y LCHT (aunque la vista sea FRONT)
        controls.enabled            = true;
        controls.enableRotate       = true;
        controls.enablePan          = true;
        controls.enableZoom         = true;
        controls.minDistance        = 10;
        controls.maxDistance        = 200;
        controls.minPolarAngle      = 0;
        controls.maxPolarAngle      = Math.PI;
        controls.screenSpacePanning = false;
      } else {
        // Resto: comportamiento previo (FRONT bloquea rotación)
        if (view === "front"){
          controls.enabled      = true;
          controls.enableRotate = false;
          controls.enablePan    = false;
          controls.enableZoom   = true;
          controls.minDistance  = 25;
          controls.maxDistance  = 140;
        } else {
          controls.enabled      = true;
          controls.enableRotate = true;
          controls.enablePan    = true;
          controls.enableZoom   = true;
          controls.minDistance  = 10;
          controls.maxDistance  = 200;
        }
      }

      controls.update();
    }

    function applyEmbedParams(){
      const p=new URLSearchParams(window.location.search);
      if(p.has('perms')){
        const arr=p.get('perms').split(';');
        document.querySelectorAll('#permutationList option').forEach(o=>{
          o.selected=arr.includes(o.value);
        });
      }
      if(p.has('mapping')){
        const m=p.get('mapping').split(',').map(Number);
        attributeMapping=[m[0],m[1],m[2],m[3],m[4], attributeMapping[5], attributeMapping[6]];
      }
      if(p.has('colors')){
        const cols=p.get('colors').split(',');
        cols.forEach((hex,i)=>{
          if(i<5){
            const h='#'+hex;
            manualOverride[i+1]=h;
          }
        });
      }
      if(p.has('bg')){
        const bg='#'+p.get('bg');
        document.getElementById('bgColor').value=bg; updateBackground();
      }
      if(p.has('cube')){
        const c='#'+p.get('cube');
        document.getElementById('cubeColor').value=c; updateCubeColor();
      }
      if(p.has('view')){
        document.getElementById('standardView').value=p.get('view');
        applyStandardView();
      }
      if(p.get('hide')==='1') toggleTexts();
    }

    function exportEmbed(){
      const config = exportCurrentConfiguration();     // ← usa la misma fuente de verdad
      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'prmttn_config_pretty.json';
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function mostrarDebugColores(){
      if(!permutationGroup || !permutationGroup.children.length){
        alert('No hay permutaciones en pantalla'); return;
      }

      /* color de fondo efectivo para contraste ΔE */
      const bgRgb = bgOverride
          ? hexToRgb(bgOverride)
          : hsvToRgb(bgHSV.h, bgHSV.s, bgHSV.v);

      const bgLab = rgbToLab(...bgRgb);

      let txt =
        'Permutación |slot|  h° |  s  |  v  | ΔEbg |  #hex\n' +
        '────────────┼────┼─────┼─────┼─────┼─────┼────────\n';

      permutationGroup.children.forEach(mesh => {
        const paArr   = mesh.userData.permStr.split(',').map(Number);
        const permStr = paArr.join(',');
        const slot    = lehmerRank(paArr) % 12;

        /* HSV teórico desde el patrón */
        const sig = computeSignature(paArr);
        let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
        sI = (sI * PHI_S) % 12;
        vI = (vI * PHI_V) % 12;
        const {h,s,v} = idxToHSV(hI, sI, vI);

        const rgb = [
          Math.round(mesh.material.color.r * 255),
          Math.round(mesh.material.color.g * 255),
          Math.round(mesh.material.color.b * 255)
        ];
        const ΔEbg = deltaE(rgbToLab(...rgb), bgLab).toFixed(1);
        const hex = '#' + mesh.material.color.getHexString();

        txt += `${permStr.padEnd(12)}|${slot.toString().padStart(2)} |`+
               `${normHue(h).toFixed(1).padStart(5)}|`+
               `${s.toFixed(2)}|${v.toFixed(2)}|`+
               `${ΔEbg.padStart(5)}| ${hex}\n`;
      });

      console.log(txt);   // copia completa al log
      alert(txt);         // vista rápida
    }

    /* ============================================================
     *  PANEL "Descripción arquitectónica"
     * ============================================================ */


function showArchitecturalDescription(){
  const selOpts  = Array.from(document.getElementById('permutationList').selectedOptions);
  const perms    = selOpts.map(o => o.value.split(',').map(Number));
  const m        = attributeMapping.slice(0,5);

  // determinism
  const sceneSeed_new = computeSceneSeedFrom(perms, m);
  const S_new         = computeGlobalS(perms, m);
  const mRank         = mappingRank(m);

  let sumR=0, sumR2=0;
  const ranks = perms.map(p=>lehmerRank(p));
  ranks.forEach(r=>{ sumR+=r; sumR2+=r*r; });

  const step = cubeSize/5;

  // ======= STRUCTURE =======
  const structureHTML = `
  <h3>Structure</h3>
  <p>
    Below are the deterministic formulas that explain
    <b>why each permutation is exactly at its position,
    why permutations and their environment have those colors</b>,
    and why <b>the whole scene — shapes, colors and positions — is reproducible
    whenever the inputs are the same</b>.
  </p>

  <div class="formula">
    <b>1) Global scene seed (sceneSeed)</b><br>
    It fixes the chromatic base angle of the whole scene.
    <br><br>
    sumR = Σ LehmerRank(Pᵢ) &nbsp;|&nbsp; sumR2 = Σ (LehmerRank(Pᵢ))² <br>
    mRank = LehmerRank([m₀+1,m₁+1,m₂+1,m₃+1,m₄+1])<br><br>
    <span class="box">sceneSeed = (37·sumR + 101·sumR2 + 53·mRank) mod 360</span>
  </div>

  <div class="formula">
    <b>2) Structural term for positions (S)</b><br>
    <i>S</i> couples positions to the attribute reorganization (mapping) used for (x,y,z).
    <br><br>
    <span class="box">S = ( Σ (P<sub>mx</sub> + P<sub>my</sub> + P<sub>mz</sub>) ) mod 125</span>
  </div>

  <div class="formula">
    <b>3) Shift‑Rank: position of each permutation</b><br>
    Combines the permutation Lehmer rank with the global invariants to assign
    a unique index over a 5×5×5 lattice.
    <br><br>
    <span class="box">I = (r + sceneSeed + S) mod 125</span><br>
    From I → (x,y,z) ∈ {0..4}³ → position inside the 30×30×30 cube.
  </div>

  <div class="formula">
    <b>4) Deterministic color (HSV lattice 144×12×12)</b><br>
    Each permutation color comes from a well‑distributed slot (r mod 12)
    and a chromatic pattern (1–11) with coprime spreads for S and V.
    <br><br>
    H ∈ 144 steps (2.5°), S ∈ 12, V ∈ 12<br>
    slot = r mod 12<br>
    pattern → [hIdx,sIdx,vIdx]; s' = (sIdx·5) mod 12; v' = (vIdx·7) mod 12<br>
    HSV = idxToHSV(hIdx,s',v') → RGB
  </div>

  <div class="formula">
    <b>5) Minimum contrast against background</b><br>
    Each color is automatically adjusted to satisfy ΔE (CIE76) ≥ 22 against the current background.
  </div>
  `;

  // ======= ARCHITECTURAL PLANS =======
  let plansHTML = `
  <h3>Architectural Plans</h3>

  <section>
    <h4>Global invariants</h4>
    <ul>
      <li>sumR = <b>${sumR}</b></li>
      <li>sumR2 = <b>${sumR2}</b></li>
      <li>m = [${m.join(', ')}] (shape,color,x,y,z)</li>
      <li>mRank = <b>${mRank}</b></li>
      <li><b>sceneSeed</b> = <b>${sceneSeed_new}</b></li>
      <li><b>S</b> = <b>${S_new}</b></li>
      <li>activePatternId = <b>${activePatternId}</b></li>
    </ul>
  </section>
  <section>
    <h4>Phenotypic scope of this edition</h4>
    <div class="formula">
      <b>BUILD:</b> 120 attribute‑mappings × 11 chromatic‑patterns = <b>1 320</b> deterministic visuals.<br>
      <b>FRBN:</b> catalog parameter K = <b>144</b> → <b>1 320 × 144 = 190 080</b> canonical states.<br>
      The permutations are acquired as a <b>group</b>; the count does not multiply by the number of permutations in the group.
    </div>
    <small>K is a catalog parameter (editorial choice). Any change is documented and applies only to future editions.</small>
  </section>
  <hr/>
  `;

  perms.forEach((perm, i)=>{
    const r    = ranks[i];
    const sig  = computeSignature(perm);
    const rango= computeRange(sig);

    const I    = (r + sceneSeed_new + S_new) % 125;
    const x    = Math.floor(I/25);
    const y    = Math.floor((I%25)/5);
    const z    = I % 5;
    const X    = (x-2)*step, Y=(y-2)*step, Z=(z-2)*step;

    const slot = r % 12;
    let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed_new, slot);
    const sIdx = (sI * PHI_S) % 12;
    const vIdx = (vI * PHI_V) % 12;
    const hsv  = idxToHSV(hI, sIdx, vIdx);
    let  rgb   = hsvToRgb(hsv.h, hsv.s, hsv.v);
    rgb        = ensureContrastRGB(rgb);
    const hex  = '#'+new THREE.Color(rgb[0]/255,rgb[1]/255,rgb[2]/255).getHexString();

    plansHTML += `
    <section class="perm">
      <h4>Permutation ${i+1}: [${perm.join(', ')}]</h4>
      <div class="formula">
        Signature F = [${sig.join(', ')}] &nbsp;|&nbsp; Range = <b>${rango}</b><br>
        Lehmer-rank r = ${r}
      </div>
      <div class="formula">
        I = (r + sceneSeed + S) mod 125 = (${r} + ${sceneSeed_new} + ${S_new}) mod 125 = <b>${I}</b><br>
        (x,y,z) = (${x}, ${y}, ${z}) → (X,Y,Z) = (${X.toFixed(2)}, ${Y.toFixed(2)}, ${Z.toFixed(2)})
      </div>
      <div class="formula">
        slot = r mod 12 = ${slot}<br>
        pattern → [hI,sI,vI] = [${hI}, ${sI}, ${vI}]<br>
        s' = ${sIdx}, v' = ${vIdx}<br>
        HSV = (${hsv.h.toFixed(2)}°, ${hsv.s.toFixed(2)}, ${hsv.v.toFixed(2)}) → RGB = ${hex}
      </div>
    </section>
    <hr/>
    `;
  });

  const firstSig = perms[0] ? computeSignature(perms[0]) : [0,0,0,0,0];
  const lastSig  = perms[perms.length-1] ? computeSignature(perms[perms.length-1]) : [0,0,0,0,0];

  const fondoIdx = PATTERNS[activePatternId](firstSig, sceneSeed_new, perms.length);
  const cuboIdx  = PATTERNS[activePatternId](lastSig,  sceneSeed_new, perms.length+1);

  const fondoHSV = idxToHSV(...fondoIdx);
  const cuboHSV  = idxToHSV(...cuboIdx);

  plansHTML += `
    <section>
      <h4>Background & cube walls</h4>
      <div class="formula">
        Background (slot = #${perms.length}) → idx = [${fondoIdx.join(', ')}] → HSV = (${fondoHSV.h.toFixed(2)}°, ${fondoHSV.s.toFixed(2)}, ${fondoHSV.v.toFixed(2)})
      </div>
      <div class="formula">
        Cube (slot = #${perms.length+1}) → idx = [${cuboIdx.join(', ')}] → HSV = (${cuboHSV.h.toFixed(2)}°, ${cuboHSV.s.toFixed(2)}, ${cuboHSV.v.toFixed(2)})
      </div>
    </section>

    <section>
      <h4>Rotation</h4>
      <p>ω = mapRangeToSpeed(range, 2, 6)</p>
    </section>
  `;

  const html = `
    <h2>Architectural Description</h2>
    ${structureHTML}
    <hr/>
    ${plansHTML}
  `;

  renderArchPanel(html);
}
function renderArchPanel(html){
  let panel = document.getElementById('archPanel');
  if(!panel){
    panel = document.createElement('div');
    panel.id = 'archPanel';
    panel.innerHTML = `
      <div id="archContent"></div>
      <button id="archClose">Close</button>
    `;
    document.body.appendChild(panel);

    const css = document.createElement('style');
    css.textContent = `
      #archPanel{
        position:fixed; z-index:1000; top:5%; left:50%;
        transform:translateX(-50%);
        width:85%; height:90%;
        background:#fff; color:#000;
        border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
        padding:24px 32px 48px; overflow:auto;
        font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
        font-size:14px; line-height:1.4;
        cursor:auto;
      }
      #archPanel *{ cursor:auto !important; }
      #archClose{
        position:fixed; right:calc(7.5% + 16px); top:5%;
        border:none; padding:6px 10px; border-radius:4px;
        background:#eee; cursor:pointer; z-index:1001;
      }
      #archPanel h2{ margin-top:0; }
      #archPanel .formula{
        margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
      }
      #archPanel .box{
        display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
        font-family:monospace;
      }
      #archPanel section{ margin-bottom:18px; }
      #archPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
      #archPanel .perm h4{ margin-bottom:6px; }
      code, pre{ font-family:monospace; }
    `;
    document.head.appendChild(css);
  }

  // NUNCA ocultamos el cursor; y al cerrar lo forzamos a mostrarse
  const closeBtn = panel.querySelector('#archClose');
  closeBtn.onclick = ()=>{
    const cc = document.getElementById('customCursor');
    if (cc) cc.style.display = 'block';
    panel.remove();
  };

  const cc = document.getElementById('customCursor');
  if (cc) cc.style.display = 'block';

  document.getElementById('archContent').innerHTML = html;
}
    function initCustomCursor(){
      const c=document.getElementById('customCursor');
      window.addEventListener('mousemove',e=>{
        c.style.left=e.clientX+"px"; c.style.top=e.clientY+"px";
      });
    }
    function initRenderer(){
      // Antialias + conservar buffer para exportación
      renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });

      /* ✅ Más nitidez en BUILD:
         - Subimos el cap del pixelRatio de 1.25 → 2.0 (sin ir al máximo del dispositivo para no matar FPS).
         - ACES + exposure suave evitan “quemados” y lavados sin tocar tus colores deterministas. */
      const PR = Math.min(window.devicePixelRatio || 1, 2.0);
      renderer.setPixelRatio(PR);
      renderer.setSize(window.innerWidth, window.innerHeight);

      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.95;

      document.body.appendChild(renderer.domElement);
    }
    /* ════════════════════════════════════════════════
     *  CENTRAL CLICK / TAP  →  PLAY  (solo Minimal UI)
     *  – equivale a pulsar el botón ▮playButton
     *  – funciona con ratón o con dedo (touch)
     *  – solo se activa cuando textsVisible === false
     *    (modo Minimal UI)
     * ═══════════════════════════════════════════════ */
    function centralPlayHandler(evt){
      if (textsVisible) return;                     // UI visible → ignore

      // coordenadas del evento (mouse o touch)
      const p = evt.touches && evt.touches.length ? evt.touches[0] : evt;
      const x = p.clientX, y = p.clientY;

      // región “central”: ±10 % del ancho y alto de la ventana
      const cx = window.innerWidth  * 0.5;
      const cy = window.innerHeight * 0.5;
      if (
        Math.abs(x - cx) < window.innerWidth  * 0.25 &&
        Math.abs(y - cy) < window.innerHeight * 0.25
      ){
        evt.preventDefault();       // evita drag/zoom de OrbitControls
        evt.stopPropagation();
        generateRandomConfigurationNoCollision();   // ▶️   PLAY
      }
    }
    function init(){
      scene=new THREE.Scene();
      scene.background=new THREE.Color(0xffffff);
      camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      camera.position.set(0,0,50);
      initRenderer();
      renderer.domElement.addEventListener('click',      centralPlayHandler, false);
      renderer.domElement.addEventListener('touchstart', centralPlayHandler, { passive:false });
      controls=new THREE.OrbitControls(camera,renderer.domElement);
      controls.enableDamping=true; controls.dampingFactor=0.1; controls.enableZoom=true;
      document.getElementById('standardView').value = 'front';
      applyStandardView();
      // Al entrar, ver un poco más lejos: 2× zoomOut (cada uno mueve +5 en Z)
      zoomOut();
      zoomOut();
      scene.add(new THREE.AmbientLight(0xffffff, 0.35));   // antes 0.8
      const dir = new THREE.DirectionalLight(0xffffff, 0.85); // antes 0.5
      dir.position.set(1, 1.2, 1.5);
      scene.add(dir);

      const cubeGeo=new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize),
            cubeMat=new THREE.MeshBasicMaterial({color:0x808080,transparent:true,opacity:0.2,side:THREE.BackSide,dithering:true});
      cubeUniverse=new THREE.Mesh(cubeGeo,cubeMat);
      scene.add(cubeUniverse);

      permutationGroup=new THREE.Group();
      scene.add(permutationGroup);

      raycaster=new THREE.Raycaster();
      mouse=new THREE.Vector2();
      window.addEventListener('mousemove',onMouseMove,false);
      window.addEventListener('resize',onWindowResize,false);

      initCustomCursor();
      populatePermutationList();
      populateAttributeMappingSelect();
      applyEmbedParams();
      makePalette();
      setMode("manual");
      refreshAll({rebuild:true});
      enterBuildRenderBoost();   // BUILD por defecto al arrancar → nitidez + exposición ajustada

      // ← NUEVO: como si hubieras presionado BUILD al cargar
      generateRandomConfigurationNoCollision().catch(console.error);
      toggleTexts();          // ← oculta la UI grande y muestra los 3 botones
      updateEngineSelectUI(); // ← deja el menú en el valor correcto (aunque esté oculto en Minimal UI)
      animate();
    }
    function onWindowResize(){
      camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }
    function animate(){
      requestAnimationFrame(animate);
      if(!isPaused){
        permutationGroup.children.forEach(o=>{
          if(o.userData.rotationSpeed) o.rotation.y+=o.userData.rotationSpeed;
        });
      }
        if(skySphere) skySphere.material.uniforms.time.value = performance.now()*0.001;
        if (offnngMesh) offnngMesh.material.uniforms.uTime.value = performance.now() * 0.001;
        const t = performance.now() * 0.001;
        if (isTMSL && tmslHaloGroup) updateTMSLHalos(t);
        if (isLCHT && lichtGroup) {
          const vHz = 0.05 + 0.02 * (avgSceneRange - 2);   // 2→0.05  ·  6→0.13

          lichtGroup.children.forEach(o => {

            /* — luz pulsante (ya existía) — */
            const d = o.userData.lcht;
            if (d) {
              const I = d.I0 * (1 - d.amp * (1 + Math.cos(2*Math.PI*d.f*t + d.phi)) / 2);
              o.material.emissive         = o.material.color.clone();
              o.material.emissiveIntensity = I * 0.15;
            }

            /* — desplazamiento del tono HSV — */
            if (o.userData.baseHsv) {
              const { h, s, v } = o.userData.baseHsv;
              const hShift = (h + t * vHz * 360) % 360;
              const rgb    = hsvToRgb(hShift, s, v);
              o.material.color.setRGB(rgb[0]/255, rgb[1]/255, rgb[2]/255);
            }
          });
        }
        // === KEPLR · giro propio usando Δθ/frame de BUILD (fallback a rad/s) =========
        if (isKEPLR && groupKEPLR && groupKEPLR.userData && groupKEPLR.userData.rotators) {
          const now  = performance.now();
          const last = groupKEPLR.userData._lastT || now;
          const dt   = (now - last) / 1000;
          groupKEPLR.userData._lastT = now;

          const list = groupKEPLR.userData.rotators;
          for (let i = 0; i < list.length; i++) {
            const g     = list[i];
            const ax    = g.userData && g.userData.rotAxis;
            let   step  = g.userData && g.userData.rotStep;  // Δθ/frame (BUILD)
            const w     = g.userData && g.userData.rotVel;   // rad/s (fallback)

            // Si aún no está cacheado, intentalo una vez (por si se reconstruyó BUILD)
            if ((step === undefined || step === 0) && g.userData && g.userData.permStr){
              step = getBuildRotStep(g.userData.permStr);
              if (step) g.userData.rotStep = step;
            }

            if (ax) {
              if (typeof step === 'number' && step !== 0) {
                // Igual que BUILD: mismo incremento angular por frame (independiente de dt)
                g.rotateOnAxis(ax, step);
              } else if (w) {
                // Fallback: usa la velocidad por segundo actual de KEPLR
                g.rotateOnAxis(ax, w * dt);
              }
            }
          }
        }
        controls.update();
        renderer.render(scene,camera);
      }
    
    /* ═══════ OFFNNG · VOLUMÉTRICO CONTINUO (v4 – shader) ═══════
     *  – Un único cubo con ShaderMaterial (ray-march frontal→trasero)
     *  – Ejes: X→Hue, Y→Value (vertical), Z→Saturation
     *  – Color continuo (sin cuantización), sin vóxeles ni sprites
     *  – Exclusivo: no interfiere con BUILD / LCHT / FRBN
     * ═══════════════════════════════════════════════════════════ */

let offnngGroup  = null;
let offnngMesh   = null;
let isOFFNNG     = false;
let offnngPrevBg = null;
let offnngQualityLow = true;                // Low fijo
let prevPixelRatio_OFFNNG = null;           // para restaurar al salir de OFFNNG

/* OFFNNG · Rahmen trasero visible (color = scene.background)
 *  - se pega a la cara de atrás del cubo de colores
 *  - depthTest desactivado + alto renderOrder ⇒ siempre visible
 * ────────────────────────────────────────────────────────────── */
function addOFFNNGRearRahmen(container){
  // tamaño del cubo cromático (usa el global de tu escena)
  const W = (typeof cubeSize==='number' ? cubeSize : 30);
  const t = 0.80;                 // grosor del marco
  const z = -W/2 + 0.002;         // pegado a la cara de atrás (ligerísimo offset)

  const col = (scene.background ? scene.background.clone() : new THREE.Color(0x000000));
  const mat = new THREE.MeshBasicMaterial({
    color: col, transparent: true, opacity: 1.0,
    depthTest: false, depthWrite: false, side: THREE.DoubleSide
  });

  const g = new THREE.Group(); g.name='__offnngRearRahmen';
  const inner = W - 2*t;

  const top = new THREE.Mesh(new THREE.PlaneGeometry(inner, t), mat);
  top.position.set(0,  W/2 - t/2, z);

  const bot = new THREE.Mesh(new THREE.PlaneGeometry(inner, t), mat);
  bot.position.set(0, -W/2 + t/2, z);

  const lef = new THREE.Mesh(new THREE.PlaneGeometry(t, inner), mat);
  lef.position.set(-W/2 + t/2, 0, z);

  const rig = new THREE.Mesh(new THREE.PlaneGeometry(t, inner), mat);
  rig.position.set( W/2 - t/2, 0, z);

  g.add(top,bot,lef,rig);
  g.renderOrder = 2000; // por encima de casi todo
  container.add(g);
}

function buildOFFNNG () {
      // limpia versión previa
      if (offnngGroup) {
        offnngGroup.traverse(o => { if (o.isMesh) { o.geometry.dispose(); o.material.dispose(); } });
        scene.remove(offnngGroup);
        offnngGroup = null; offnngMesh = null;
      }

      const geo = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);

      const mat = new THREE.ShaderMaterial({
        uniforms: {
          uHalf        : { value: cubeSize * 0.5 },
          uInvModel    : { value: new THREE.Matrix4() },

          // —— LOOK STRONG (base) ——
          uDensity     : { value: 0.70 },
          uSMin        : { value: 0.60 },
          uVMin        : { value: 0.78 },
          uSatGain     : { value: 1.22 },
          uValGain     : { value: 1.28 },
          uGammaV      : { value: 0.60 },
          uExposure    : { value: 1.85 },

          // ——— BORDE TINTADO ———
          uEdgeStrength: { value: 1.0 },
          uEdgeBase    : { value: 0.65 },
          uEdgePow     : { value: 1.6 },
          uEdgeTintV   : { value: 0.72 },

          // Sesgo frontal
          uFrontBias   : { value: 0.85 },

          // Ray-march
          uSteps       : { value: 36 },
          uLenComp     : { value: 1.0 },  // 0..1 (1 = compensa completamente el grosor)
          uLenFloor    : { value: 0.55 }, // piso para evitar picos en rayos muy finos

          // Movimiento determinista base
          uTime        : { value: 0.0 },
          uHueBias     : { value: 0.0 },  // grados
          uHueRate     : { value: 7.0 },  // °/s (rango contemplativo 6–8)
          uVBreathAmp  : { value: 0.14 },
          uVBreathHz   : { value: 0.06 },
          uVBreathPhase: { value: 0.0 },

          // A) offset espacial del eje H (X → H)
          uPhaseX      : { value: 0.0 },

          // D) giro volumétrico del campo (no del mesh)
          uRotAxis     : { value: new THREE.Vector3(0,1,0) },
          uRotRateDeg  : { value: 4.0 },  // °/s (rango contemplativo 3–5)

          // Alpha final
          uOpaque      : { value: 1 },

          // === NUEVO: mezcla de ejes (máx 0.3 de peso cruzado) ===
          // H ← X + wHy·Y + wHz·Z
          // S ← Z + wSx·X + wSy·Y
          // V ← Y + wVx·X + wVz·Z
          uAxisMixH    : { value: new THREE.Vector2(0.0, 0.0) }, // (wHy, wHz)
          uAxisMixS    : { value: new THREE.Vector2(0.0, 0.0) }, // (wSx, wSy)
          uAxisMixV    : { value: new THREE.Vector2(0.0, 0.0) }, // (wVx, wVz)

          // === NUEVO: LFOs para HUE (°/s) ===
          uHueLFO1Amp  : { value: 0.35 },
          uHueLFO1Hz   : { value: 0.03 },
          uHueLFO1Phase: { value: 0.0 },
          uHueLFO2Amp  : { value: 0.20 },
          uHueLFO2Hz   : { value: 0.013 },
          uHueLFO2Phase: { value: 0.0 },

          // === NUEVO: LFOs para ROTACIÓN (°/s) ===
          uRotLFO1AmpDeg  : { value: 0.30 },
          uRotLFO1Hz      : { value: 0.02 },
          uRotLFO1Phase   : { value: 0.0 },
          uRotLFO2AmpDeg  : { value: 0.15 },
          uRotLFO2Hz      : { value: 0.011 },
          uRotLFO2Phase   : { value: 0.0 }
        },
        transparent : true,
        depthWrite  : false,
        depthTest   : true,
        side        : THREE.DoubleSide,
        dithering   : true,
        vertexShader: `
      varying vec3 vPos;
      void main() {
        vPos = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `,
        fragmentShader: `
precision highp float;

uniform float uHalf;
uniform mat4  uInvModel;

uniform float uDensity, uSMin, uVMin, uSatGain, uValGain, uGammaV, uExposure;
uniform float uEdgeStrength, uEdgeBase, uEdgePow, uEdgeTintV, uFrontBias;
uniform int   uSteps;

uniform float uLenComp;
uniform float uLenFloor;

uniform float uTime, uHueBias, uHueRate, uVBreathAmp, uVBreathHz, uVBreathPhase;
uniform float uPhaseX;

uniform vec3  uRotAxis;
uniform float uRotRateDeg;

uniform int   uOpaque;

uniform vec2  uAxisMixH; // (wHy, wHz)
uniform vec2  uAxisMixS; // (wSx, wSy)
uniform vec2  uAxisMixV; // (wVx, wVz)

// LFOs HUE (°/s)
uniform float uHueLFO1Amp, uHueLFO1Hz, uHueLFO1Phase;
uniform float uHueLFO2Amp, uHueLFO2Hz, uHueLFO2Phase;

// LFOs ROT (°/s)
uniform float uRotLFO1AmpDeg, uRotLFO1Hz, uRotLFO1Phase;
uniform float uRotLFO2AmpDeg, uRotLFO2Hz, uRotLFO2Phase;

varying vec3  vPos;

vec3 hsv2rgb(float H, float S, float V){
  float h = H / 360.0;
  vec3 K = vec3(1.0, 2.0/3.0, 1.0/3.0);
  vec3 P = abs(fract(vec3(h) + K.xyz) * 6.0 - 3.0);
  return V * mix(vec3(1.0), clamp(P - 1.0, 0.0, 1.0), S);
}

bool rayBox(vec3 ro, vec3 rd, out float t0, out float t1){
  vec3 bmin = vec3(-uHalf);
  vec3 bmax = vec3( uHalf);
  vec3 invD = 1.0 / rd;
  vec3 tA = (bmin - ro) * invD;
  vec3 tB = (bmax - ro) * invD;
  vec3 tsm = min(tA, tB);
  vec3 tbg = max(tA, tB);
  t0 = max(max(tsm.x, tsm.y), tsm.z);
  t1 = min(min(tbg.x, tbg.y), tbg.z);
  return (t1 >= max(t0, 0.0));
}

// ——— D) rotación alrededor de un eje (Rodrigues) ———
vec3 rotateAxis(vec3 p, vec3 axis, float theta){
  vec3 a = normalize(axis);
  float c = cos(theta), s = sin(theta);
  return p*c + cross(a, p)*s + a*dot(a, p)*(1.0 - c);
}

void main(){
  vec3 ro = (uInvModel * vec4(cameraPosition, 1.0)).xyz;
  vec3 rd = normalize(vPos - ro);

  float tEnter, tExit;
  if(!rayBox(ro, rd, tEnter, tExit)) discard;

  float t0 = max(tEnter, 0.0);
  float t1 = tExit;

  float len = t1 - t0;
  float dt  = len / float(max(uSteps, 1));
  vec3  pos = ro + rd * (t0 + 0.5 * dt);

  vec3  acc = vec3(0.0);
  float a   = 0.0;
  
  /* === Compensación por espesor ===
     Normalizamos el grosor cruzado (0..~√3) y escalamos la densidad
     para que los bordes no queden subexpuestos. */
  float normLen = len / (2.0 * uHalf);
  float comp    = mix(1.0, 1.0 / max(normLen, uLenFloor), clamp(uLenComp, 0.0, 1.0));
  float alphaStep = 1.0 - exp(-(uDensity * comp) * dt / (2.0 * uHalf));

  // === NUEVO: velocidades moduladas por LFOs ===
  float hueDrift = uHueRate
                 + uHueLFO1Amp * sin(6.2831853 * uHueLFO1Hz * uTime + uHueLFO1Phase)
                 + uHueLFO2Amp * sin(6.2831853 * uHueLFO2Hz * uTime + uHueLFO2Phase);

  float rotRate = uRotRateDeg
                + uRotLFO1AmpDeg * sin(6.2831853 * uRotLFO1Hz * uTime + uRotLFO1Phase)
                + uRotLFO2AmpDeg * sin(6.2831853 * uRotLFO2Hz * uTime + uRotLFO2Phase);

  // ángulo de giro (rad)
  float theta = radians(rotRate) * uTime;

  const int MAX_STEPS = 64;
  for (int i=0; i<MAX_STEPS; i++){
    if (i >= uSteps) break;

    // espacio normalizado [-1,1] → rotación volumétrica
    vec3 q = pos / uHalf;
    q = rotateAxis(q, uRotAxis, theta);

    // a [0,1]^3 y offset cromático (A)
    vec3 u = q * 0.5 + 0.5;
    u.x = fract(u.x + uPhaseX);

    // — distancia a caras → factor de borde [0..1]
    float dx = min(u.x, 1.0 - u.x);
    float dy = min(u.y, 1.0 - u.y);
    float dz = min(u.z, 1.0 - u.z);
    float edgeDist = min(min(dx, dy), dz);
    float edge = smoothstep(0.06, 0.18, edgeDist);
    edge = pow(edge, max(0.2, uEdgePow));

    // === NUEVO: mezcla de ejes para H/S/V (peso cruzado suave) ===
    float uHx = clamp(u.x + dot(uAxisMixH, vec2(u.y - 0.5, u.z - 0.5)), 0.0, 1.0);
    float uSz = clamp(u.z + dot(uAxisMixS, vec2(u.x - 0.5, u.y - 0.5)), 0.0, 1.0);
    float uVy = clamp(u.y + dot(uAxisMixV, vec2(u.x - 0.5, u.z - 0.5)), 0.0, 1.0);

    // — mapeo HSV base (X→H, Y→V, Z→S) con drift y “breathing”
    float H = mod(uHx * 360.0 + uHueBias + uTime * hueDrift, 360.0);

    float V = clamp(uVy, 0.0, 1.0);
    V *= (1.0 + uVBreathAmp * sin(6.2831853 * uVBreathHz * uTime + uVBreathPhase));
    V = clamp(V, 0.0, 1.0);
    V = pow(V, uGammaV);
    V = max(V, uVMin);
    V = clamp(V * uValGain, 0.0, 1.0);

    float S = clamp(uSz, 0.0, 1.0);
    S = max(S, uSMin);
    S = clamp(S * uSatGain, 0.0, 1.0);

    vec3 rgb = hsv2rgb(H, S, V);

    // — color de “cara” para tinte de borde
    vec3 uF = u;
    if (dx <= dy && dx <= dz) { uF.x = (u.x < 0.5 ? 0.0 : 1.0); }
    else if (dy <= dx && dy <= dz) { uF.y = (u.y < 0.5 ? 0.0 : 1.0); }
    else { uF.z = (u.z < 0.5 ? 0.0 : 1.0); }
    float HF = mod((uF.x) * 360.0 + uHueBias + uTime * hueDrift, 360.0);
    float VF = max(uF.y, uEdgeTintV);
    float SF = max(uF.z, uSMin);
    vec3  rgbFace = hsv2rgb(HF, SF, VF);

    rgb = mix(rgbFace, rgb, edge);

    float tau       = float(i) / float(max(uSteps-1, 1));
    float front     = mix(1.0, 1.0 - tau, clamp(uFrontBias, 0.0, 1.0));
    float edgeAlpha = mix(uEdgeBase, 1.0, edge);

    float w = (1.0 - a) * alphaStep * front * edgeAlpha;
    acc += rgb * w;
    a   += w;

    if (a > 0.995) break;
    pos += rd * dt;
  }

  vec3 col = min(acc * uExposure, vec3(1.0));
  float outA = (uOpaque == 1) ? 1.0 : a;
  gl_FragColor = vec4(col, outA);
}
    `
      });

      offnngMesh  = new THREE.Mesh(geo, mat);
      offnngMesh.updateMatrixWorld(true);
      mat.uniforms.uInvModel.value.copy(offnngMesh.matrixWorld).invert();

      offnngGroup = new THREE.Group();
      offnngGroup.add(offnngMesh);
      addOFFNNGRearRahmen(offnngGroup);
      scene.add(offnngGroup);

      applyOFFNNGQuality();   // aplica calidad y pixelRatio
      syncOFFNNGFromScene();  // ← acopla parámetros deterministas
    }

    /* ───────────────────────── toggle OFFNNG ───────────────────── */
    function toggleOFFNNG () {
      isOFFNNG = !isOFFNNG;

    if (isOFFNNG) {                    /* — ENTRAR — */
      leaveBuildRenderBoost();          // ← desactiva boost de BUILD
      if (isFRBN) toggleFRBN();        // asegura exclusividad
      if (isLCHT) toggleLCHT();
      if (isTMSL) toggleTMSL();
      if (isKEPLR) toggleKEPLR();

      buildOFFNNG();

      // guardar PR previo y aplicar cap + calidad
      if (prevPixelRatio_OFFNNG === null) prevPixelRatio_OFFNNG = renderer.getPixelRatio();
      applyOFFNNGQuality();

      offnngPrevBg   = scene.background ? scene.background.clone() : null;
      updateBackground(false); // usa el fondo acoplado a BUILD / patrón / perms

      cubeUniverse.visible     = false;
      permutationGroup.visible = false;
      if (lichtGroup) lichtGroup.visible = false;
      if (offnngGroup) offnngGroup.visible = true;

      syncOFFNNGFromScene();  // ← asegura acoplamiento inicial

    } else {                           /* — SALIR — */
        if (offnngGroup) {
          offnngGroup.traverse(o => { if (o.isMesh) { o.geometry.dispose(); o.material.dispose(); } });
          scene.remove(offnngGroup);
          offnngGroup = null; offnngMesh = null;
        }
        if (offnngPrevBg) scene.background = offnngPrevBg;

        // restaurar pixel ratio previo
        if (prevPixelRatio_OFFNNG !== null){
          renderer.setPixelRatio(prevPixelRatio_OFFNNG);
          prevPixelRatio_OFFNNG = null;
        }
        const qb = document.getElementById('offnngQualityButton');
        if (qb) qb.textContent = offnngQualityLow ? 'Quality: Low' : 'Quality: High';

        cubeUniverse.visible     = true;
        permutationGroup.visible = true;
        if (lichtGroup && isLCHT) lichtGroup.visible = true;
      }
    }

    /* ────────── botón dedicado: OFFNNG siempre en solitario ───────── */
    function ensureOnlyOFFNNG () {
      if (isFRBN) toggleFRBN();
      if (isLCHT) toggleLCHT();
      if (isKEPLR) toggleKEPLR();
      if (!isOFFNNG) toggleOFFNNG();
    }

    /* Calidad: ya NO reducimos el pixelRatio (evita blur); solo variamos uSteps */
    function applyOFFNNGQuality(){
      const basePR = Math.min(window.devicePixelRatio || 1, 1.25); // antes 1.5
      renderer.setPixelRatio(basePR);                               // Low/High no tocan PR
      if (offnngMesh && offnngMesh.material && offnngMesh.material.uniforms) {
        offnngMesh.material.uniforms.uSteps.value = offnngQualityLow ? 36 : 56;
      }
      const b = document.getElementById('offnngQualityButton');
      if (b) b.textContent = offnngQualityLow ? 'Quality: Low' : 'Quality: High';
    }
  /* === OFFNNG: bias por patrón (±10–15 %) y mezcla de ejes (máx 0.3) === */
  const OFFNNG_PATTERN_BIAS = {
    //   satGain, valGain, gammaV, exposure, sMinΔ, vMinΔ, axisMixH:[wHy,wHz], axisMixS:[wX,wY], axisMixV:[wX,wZ]
    1:  { satGain:1.05, valGain:0.98, gammaV:1.05, exposure:0.98, sMin: +0.01, vMin: -0.01, axisMixH:[+0.10,+0.04], axisMixS:[+0.06,+0.00], axisMixV:[+0.00,+0.08] },
    2:  { satGain:1.10, valGain:1.05, gammaV:0.95, exposure:1.05, sMin: +0.02, vMin: +0.01, axisMixH:[+0.12,+0.12], axisMixS:[+0.10,+0.10], axisMixV:[+0.10,+0.10] },
    3:  { satGain:0.95, valGain:1.00, gammaV:1.10, exposure:0.95, sMin: +0.00, vMin: -0.01, axisMixH:[+0.08,+0.02], axisMixS:[+0.04,+0.06], axisMixV:[+0.06,+0.04] },
    4:  { satGain:1.00, valGain:0.95, gammaV:1.08, exposure:0.98, sMin: +0.00, vMin: -0.02, axisMixH:[+0.10,-0.06], axisMixS:[+0.00,+0.10], axisMixV:[+0.10,-0.04] },
    5:  { satGain:0.92, valGain:1.00, gammaV:1.00, exposure:1.00, sMin: -0.02, vMin: +0.00, axisMixH:[+0.05,+0.05], axisMixS:[+0.05,+0.05], axisMixV:[+0.05,+0.05] },
    6:  { satGain:0.98, valGain:0.98, gammaV:1.05, exposure:0.98, sMin: +0.00, vMin: -0.01, axisMixH:[+0.14,+0.00], axisMixS:[+0.00,+0.08], axisMixV:[+0.12,+0.00] },
    7:  { satGain:1.06, valGain:0.98, gammaV:0.98, exposure:1.02, sMin: +0.01, vMin: -0.01, axisMixH:[+0.06,+0.14], axisMixS:[+0.12,+0.00], axisMixV:[+0.00,+0.12] },
    8:  { satGain:1.02, valGain:1.02, gammaV:0.95, exposure:1.05, sMin: +0.01, vMin: +0.01, axisMixH:[+0.10,+0.10], axisMixS:[+0.10,+0.00], axisMixV:[+0.00,+0.10] },
    9:  { satGain:0.94, valGain:0.98, gammaV:1.08, exposure:0.96, sMin: -0.01, vMin: -0.01, axisMixH:[+0.08,+0.04], axisMixS:[+0.04,+0.08], axisMixV:[+0.08,+0.04] },
    10: { satGain:1.04, valGain:1.00, gammaV:1.00, exposure:1.04, sMin: +0.01, vMin: +0.00, axisMixH:[+0.12,+0.06], axisMixS:[+0.06,+0.12], axisMixV:[+0.12,+0.06] },
    11: { satGain:1.08, valGain:1.06, gammaV:0.95, exposure:1.08, sMin: +0.02, vMin: +0.02, axisMixH:[+0.15,+0.12], axisMixS:[+0.12,+0.15], axisMixV:[+0.15,+0.12] }
  };
  function clampMix(w){ return Math.max(-0.3, Math.min(0.3, w)); }

  /* ───────────────────────── OFFNNG · parámetros deterministas ─────────────────────────
     Se llama al construir OFFNNG y cada vez que cambia la escena (refreshAll).
     Liga el look y el movimiento a sceneSeed, S_global y al rango medio de la escena. */
  function syncOFFNNGFromScene(){
    if (!offnngMesh || !offnngMesh.material || !offnngMesh.material.uniforms) return;

    const U = offnngMesh.material.uniforms;

    // —— estadística determinista a partir de la escena ——
    const selPerms = Array.from(document.getElementById('permutationList').selectedOptions)
                          .map(o => o.value.split(',').map(Number));

    // Rango medio 2..6 → 0..1
    let avgR = 4.0;
    if (selPerms.length){
      const ranges = selPerms.map(p => computeRange(computeSignature(p)));
      avgR = ranges.reduce((a,b)=>a+b,0) / ranges.length;
    }
    avgSceneRange = avgR;
    const nr = Math.max(0, Math.min(1, (avgR - 2) / 4)); // 0..1

    // Lehmer stats
    let sumR = 0, sumR2 = 0, sumSig = 0;
    selPerms.forEach(p=>{
      const r = lehmerRank(p);
      sumR  += r;
      sumR2 += r*r;
      const s = computeSignature(p);
      sumSig += s.reduce((a,b)=>a+b,0); // cada F_i ∈ [3..9]
    });
    const meanSig = selPerms.length ? (sumSig / (selPerms.length * 5)) : 6; // ~3..9
    const sigN = Math.max(0, Math.min(1, (meanSig - 3) / 6)); // 0..1

    // —— LOOK base "Vivid" (más saturación y brillo controlados) ——
    U.uSMin.value      = 0.64;   // antes 0.60
    U.uVMin.value      = 0.87;   // antes 0.84
    U.uSatGain.value   = 1.30;   // antes 1.22
    U.uValGain.value   = 1.34;   // antes 1.30
    U.uGammaV.value    = 0.56;   // antes 0.58 (levanta medios sin quemar)
    U.uExposure.value  = 2.00;   // antes 1.90 (clipea en 1.0 en el shader)
    U.uDensity.value   = 0.70 - 0.05 * nr;

    // Borde: sin atenuar + tinte más claro (resalta color)
    U.uEdgeBase.value  = 1.00;   // mantiene anti-rim
    U.uEdgeTintV.value = 0.90;   // antes 0.84
    U.uEdgePow.value   = 1.2;

    // —— Bias por patrón (±10–15 %) + mezcla de ejes ≤ 0.3 ——
    const B = OFFNNG_PATTERN_BIAS[activePatternId] || OFFNNG_PATTERN_BIAS[1];
    U.uSatGain.value  *= B.satGain;
    U.uValGain.value  *= B.valGain;
    U.uGammaV.value   *= B.gammaV;
    U.uExposure.value *= B.exposure;
    U.uSMin.value     = Math.max(0.0, Math.min(1.0, U.uSMin.value + (B.sMin || 0)));
    U.uVMin.value     = Math.max(0.0, Math.min(1.0, U.uVMin.value + (B.vMin || 0)));

    U.uAxisMixH.value.set(clampMix(B.axisMixH[0]), clampMix(B.axisMixH[1]));
    U.uAxisMixS.value.set(clampMix(B.axisMixS[0]), clampMix(B.axisMixS[1]));
    U.uAxisMixV.value.set(clampMix(B.axisMixV[0]), clampMix(B.axisMixV[1]));

    // —— Fase determinista (usa sceneSeed, S_global, sumR, sumR2) ——
    const seedA = (sceneSeed*7 + S_global*13 + sumR)  % 997;
    const seedB = (sceneSeed*5 + S_global*11 + sumR2) % 991;
    const φA = 2*Math.PI * (seedA / 997);
    const φB = 2*Math.PI * (seedB / 991);

    // —— Velocidades contemplativas (base) + LFOs deterministas ——
    // Hue 6–8 °/s y Rot 3–5 °/s (se modulan por nr y sigN).
    U.uHueBias.value = sceneSeed;

    U.uHueRate.value = 6.0 + 2.0 * (0.6*nr + 0.4*sigN);
    U.uRotRateDeg.value = 3.0 + 2.0 * (0.5*nr + 0.5*sigN);

    // LFOs HUE (amplitudes 0.35 / 0.20 °/s; frecuencias lentas)
    U.uHueLFO1Amp.value   = 0.35;
    U.uHueLFO2Amp.value   = 0.20;
    U.uHueLFO1Hz.value    = 0.030 + 0.010 * nr;  // ~33–25 s
    U.uHueLFO2Hz.value    = 0.013 + 0.007 * nr;  // ~77–50 s
    U.uHueLFO1Phase.value = φA;
    U.uHueLFO2Phase.value = φB;

    // LFOs ROT (amplitudes 0.30 / 0.15 °/s; todavía más lentas)
    U.uRotLFO1AmpDeg.value   = 0.30;
    U.uRotLFO2AmpDeg.value   = 0.15;
    U.uRotLFO1Hz.value       = 0.020 + 0.008 * nr; // ~50–35 s
    U.uRotLFO2Hz.value       = 0.011 + 0.006 * nr; // ~90–62 s
    U.uRotLFO1Phase.value    = φB + 0.5;          // desfase para evitar lock
    U.uRotLFO2Phase.value    = φA + 1.0;

    // —— Offset espacial del eje H (como antes) ——
    const phaseX = ((sceneSeed + 2 * S_global) % 360) / 360;
    U.uPhaseX.value = phaseX;

    // —— Respiración de brillo (como antes) ——
    U.uVBreathAmp.value   = 0.12 + 0.04 * nr;
    U.uVBreathHz.value    = 0.06;
    const phase0 = ((sceneSeed + S_global) % 144) / 144;
    U.uVBreathPhase.value = 2.0 * Math.PI * phase0;

    // —— Eje de giro (como antes) ——
    const toRad = Math.PI / 180;
    const ax = Math.cos((sceneSeed*13 + S_global*7) * toRad);
    const ay = Math.cos((sceneSeed*5  + S_global*11) * toRad);
    const az = Math.cos((sceneSeed*17 - S_global*3) * toRad);
    const norm = Math.max(1e-6, Math.hypot(ax, ay, az));
    U.uRotAxis.value.set(ax/norm, ay/norm, az/norm);
  }

  function toggleOFFNNGQuality(){
    offnngQualityLow = !offnngQualityLow;
    if (isOFFNNG) applyOFFNNGQuality();
    const b = document.getElementById('offnngQualityButton');
    if (b) b.textContent = offnngQualityLow ? 'Quality: Low' : 'Quality: High';
    }

    /* ═════════════════════ FIN BLOQUE OFFNNG v4 ═════════════════════ */

    /* ───────────────  TMSL  ·  frontal white wall  ─────────────── */
    let isTMSL = false;
    let tmslGroup = null;
    let tmslPrevBg = null;
    let tmslPrevClear = null;   // ← guardamos el clearColor real del renderer

    /* === TMSL · colores “negro mate” === */
    const TMSL_BG_HEX     = 0x000000; // fondo/“pared”
    const TMSL_FRONT_HEX  = 0x000000; // cara frontal (y trasera) de los volúmenes
    const TMSL_SIDE_HEX   = 0x0b0b0b; // caras laterales muy oscuras (ligeramente >0 para no aplastar)

    function disposeAndRemove(g){
      if (!g) return;
      g.traverse(o=>{ if (o.isMesh){ o.geometry?.dispose?.(); o.material?.dispose?.(); } });
      if (g.parent) g.parent.remove(g);
    }
    // ── TMSL · Tomasello/Staudt — estado + textura halo ────────────────
    let tmslHaloTex   = null;
    let tmslHaloGroup = null;
    let tmslCellsGroup = null;   // ← NUEVO: contenedor único de volúmenes+marcos

    function makeHaloTexture(size = 512, inner = 0.30, outer = 0.985, gamma = 1.55){
      // Gradiente rectangular invertido: 0 en el centro → 1 en los bordes (con caída final)
      const c = document.createElement('canvas');
      c.width = size; c.height = size;
      const ctx = c.getContext('2d');
      const img = ctx.createImageData(size, size);
      const cx = size / 2, cy = size / 2;
      const inv = 2 / size; // normaliza a [-1,1]

      for (let y = 0; y < size; y++){
        for (let x = 0; x < size; x++){
          const dx = Math.abs((x + 0.5) - cx) * inv;  // 0..1
          const dy = Math.abs((y + 0.5) - cy) * inv;  // 0..1
          const d  = Math.max(dx, dy);                // distancia "caja" (Chebyshev)
          let t    = (d - inner) / Math.max(1e-6, (outer - inner)); // 0 en inner → 1 en outer
          t = Math.min(1, Math.max(0, t));

          // brillo en el borde (inversión) + caída suave al llegar al límite
          let aEdge = Math.pow(t, gamma);                 // 0 centro → 1 borde
          let fadeE = 1 - Math.min(1, Math.max(0, (d - 0.96) / 0.04)); // 1 → 0 muy al borde
          const a = Math.max(0, Math.min(1, aEdge * fadeE));

          const off = (y * size + x) * 4;
          img.data[off    ] = 255;
          img.data[off + 1] = 255;
          img.data[off + 2] = 255;
          img.data[off + 3] = Math.round(a * 255);
        }
      }
      ctx.putImageData(img, 0, 0);

      const tex = new THREE.CanvasTexture(c);
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      return tex;
    }

    // ★ Mantén el flag global sincronizado (necesario para hooks/watchdogs)
    window.isTMSL = false;

    /* ───────────────  RAUM  ·  fixed room 60×30×30  ─────────────── */
    let isRAUM = false;
    let raumGroup = null;
    const RAUM_W = 60, RAUM_H = 30, RAUM_D = 30, RAUM_G = 2;
    const RAUM_CAMERA_Z = 80;   // vista frontal fija cómoda para 60 de ancho

    // ===== RAUM · ajustes de zoom y color =====
    const RAUM_ZOOM_STEPS   = 5;        // “+5 veces” de tu zoom In (cada una = 5 unidades)
    const RAUM_ZOOM_STEP    = 5;
    const RAUM_CAMERA_ZOOMED = RAUM_CAMERA_Z - RAUM_ZOOM_STEPS * RAUM_ZOOM_STEP;

    /* Vibrance parecido a BUILD para superficies RAUM:
       - sube S con más fuerza cuando S es baja
       - levanta V muy poco con techo 0.93
       - mantiene contraste ΔE>=22 contra el fondo actual */
    function applyBuildVibranceToColor(colorTHREE){
      const rgb = [
        Math.round(colorTHREE.r * 255),
        Math.round(colorTHREE.g * 255),
        Math.round(colorTHREE.b * 255)
      ];
      let [h,s,v] = rgbToHsv(rgb[0], rgb[1], rgb[2]);
      const s1 = Math.min(1, s + 0.22 * (1 - s));
      const v1 = Math.min(0.93, v * 1.02);
      let rgb2 = hsvToRgb(h, s1, v1);
      rgb2 = ensureContrastRGB(rgb2);
      return new THREE.Color(rgb2[0]/255, rgb2[1]/255, rgb2[2]/255);
    }

    // === Helpers deterministas para TMSL (color, orientación, rebuild) ===
    function tmslColorFor(pa, slotIndex){
      const sig  = computeSignature(pa);
      const slot = (lehmerRank(pa) + (slotIndex % 3)) % 12;

      let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
      const sIdx = (sI * PHI_S) % 12;
      const vIdx = (vI * PHI_V) % 12;
      const {h,s,v} = idxToHSV(hI, sIdx, vIdx);

      let rgb = hsvToRgb(h, s, v);
      let [hh, ss, vv] = rgbToHsv(rgb[0], rgb[1], rgb[2]);      // vibrance suave estilo BUILD
      const s1 = Math.min(1, ss + 0.22 * (1 - ss));
      const v1 = Math.min(0.93, vv * 1.04);
      rgb = hsvToRgb(hh, s1, v1);
      rgb = ensureContrastRGB(rgb);

      return new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255);
    }

    function tmslOrientation(pa, cellIndex){
      const mRank = mappingRank(attributeMapping.slice(0,5));   // mapping 120
      const r     = lehmerRank(pa);
      return (r + mRank + sceneSeed + cellIndex) % 4;           // 0..3
    }

    function rebuildTMSLIfActive(){
      if (!isTMSL) return;
      try{
        if (!tmslGroup) buildTMSL();
        buildTMSL_TomaselloStaudt();
      }catch(_){ }
    }

    function buildTMSL(){
      // limpia versión previa
      if (tmslGroup){
        tmslGroup.traverse(o=>{ if(o.isMesh){ o.geometry.dispose(); o.material.dispose(); }});
        scene.remove(tmslGroup);
      }
      tmslGroup = new THREE.Group();

      // Dimensiones del campo (hasta donde llegan los colores)
      const GRID = 9;
      const PAD  = cubeSize * 0.12;
      const span = cubeSize - 2 * PAD;  // “hasta donde llegan los colores”
      const W = span, H = span;

      // Pared trasera y caja abierta (frente abierto)
      const BACK_T = 0.80;
      const ROOM_D = 2.20;
      const SIDE_T = 0.60;

      const mWhite = new THREE.MeshBasicMaterial({ color: 0xffffff });

      // Pared trasera (referencia para Tomasello/Staudt)
      const back = new THREE.Mesh(new THREE.BoxGeometry(W, H, BACK_T), mWhite.clone());
      back.position.set(0, 0, halfCube + BACK_T/2);
      back.renderOrder = -50;
      back.userData.tmslKind = 'wall';
      tmslGroup.add(back);

      // Grupo EN CIERRE (techo/piso/laterales) — ¡marcado como enclosure!
      const enclosure = new THREE.Group();
      enclosure.userData.tmslKind = 'enclosure';
      enclosure.renderOrder = -20; // por delante de halos (-40) y celdas (-30)
      tmslGroup.add(enclosure);

      const zCenter = halfCube + BACK_T - ROOM_D/2;

      const left  = new THREE.Mesh(new THREE.BoxGeometry(SIDE_T, H, ROOM_D), mWhite.clone());
      left.position.set(-W/2 - SIDE_T/2, 0, zCenter);

      const right = new THREE.Mesh(new THREE.BoxGeometry(SIDE_T, H, ROOM_D), mWhite.clone());
      right.position.set( W/2 + SIDE_T/2, 0, zCenter);

      const floor = new THREE.Mesh(new THREE.BoxGeometry(W + 2*SIDE_T, SIDE_T, ROOM_D), mWhite.clone());
      floor.position.set(0, -H/2 - SIDE_T/2, zCenter);

      const ceil  = new THREE.Mesh(new THREE.BoxGeometry(W + 2*SIDE_T, SIDE_T, ROOM_D), mWhite.clone());
      ceil.position.set(0,  H/2 + SIDE_T/2, zCenter);

      enclosure.add(left, right, floor, ceil);

      scene.add(tmslGroup);
      tmslGroup.traverse(o => { o.frustumCulled = false; });
    }

    function buildTMSL_TomaselloStaudt(){
      if (!tmslGroup) return;

      // — limpia todo menos la pared y el enclosure anterior —
      for (let i = tmslGroup.children.length - 1; i >= 0; i--){
        const ch = tmslGroup.children[i];
        if (ch.userData?.tmslKind === 'wall' || ch.userData?.tmslKind === 'enclosure') continue;
        ch.traverse?.(o=>{ if (o.isMesh){ o.geometry?.dispose?.(); o.material?.dispose?.(); } });
        tmslGroup.remove(ch);
      }
      // borra enclosure previo si existía
      const oldEnclosure = tmslGroup.children.find(o=>o.userData?.tmslKind==='enclosure');
      if (oldEnclosure){
        oldEnclosure.traverse(o=>{ if (o.isMesh){ o.geometry?.dispose?.(); o.material?.dispose?.(); } });
        tmslGroup.remove(oldEnclosure);
      }

      // — prepara grupo de halos —
      if (tmslHaloGroup){
        tmslHaloGroup.traverse(o=>{ if(o.isMesh){ o.geometry?.dispose?.(); o.material?.dispose?.(); }});
        tmslGroup.remove(tmslHaloGroup);
        tmslHaloGroup = null;
      }
      if (!tmslHaloTex) tmslHaloTex = makeHaloTexture(512);
      tmslHaloGroup = new THREE.Group();
      tmslHaloGroup.renderOrder = -40;        // detrás de “volúmenes”
      tmslGroup.add(tmslHaloGroup);

      // — pared (referencia de Z) —
      const wall = tmslGroup.children.find(o => o.userData?.tmslKind === 'wall');
      if (!wall) return;
      wall.renderOrder = -50;
      const wallDepth   = wall.geometry.parameters.depth;
      const wallCenterZ = wall.position.z;
      const wallFrontZ  = wallCenterZ + wallDepth/2;

      // — parrilla cuadrada homogénea —
      const GRID = 9;
      const PAD  = cubeSize * 0.12;
      const span = cubeSize - PAD*2;
      const step = span / (GRID-1);

      // — módulo cuadrado único (lado S) y “profundidad” hacia adentro —
      const S       = 1.80;
      const DEP_IN  = 0.18;
      const HALO_SX = 2.35;
      const HALO_SY = 2.35;

      // — permisos activos SOLO para color —
      const perms = (typeof getSelectedPerms === 'function')
        ? getSelectedPerms()
        : Array.from(document.getElementById('permutationList').selectedOptions).map(o => o.value.split(',').map(Number));
      const permsSafe = perms.length ? perms : [[1,2,3,4,5]];

      // — acumulamos bounds del halo para “hasta donde llegan los colores” —
      let minX =  Infinity, maxX = -Infinity;
      let minY =  Infinity, maxY = -Infinity;

      for (let iy=0; iy<GRID; iy++){
        for (let ix=0; ix<GRID; ix++){
          const x = -halfCube + PAD + ix*step;
          const y = -halfCube + PAD + iy*step;
          const idxCell = iy*GRID + ix;
          const pa      = permsSafe[idxCell % permsSafe.length];

          // — color determinista para laterales —
          const col = tmslColorFor(pa, idxCell);
          const sideMat = new THREE.MeshLambertMaterial({ color: col, dithering:true, depthTest:false });
          sideMat.emissive = col.clone(); sideMat.emissiveIntensity = 0.12;

          // — frontal invisible —
          const frontInvisible = new THREE.MeshBasicMaterial({
            color: 0xffffff, transparent: true, opacity: 0.0, depthWrite: false, depthTest: false
          });

          // — fondo negro —
          const backMat = new THREE.MeshLambertMaterial({ color: 0x0a0a0a, dithering:true, depthTest:false });
          backMat.emissive = new THREE.Color(0x000000);
          backMat.emissiveIntensity = 0.0;

          const mats = [
            sideMat.clone(), sideMat.clone(), sideMat.clone(), sideMat.clone(),
            frontInvisible, backMat
          ];

          const geo  = new THREE.BoxGeometry(S, S, DEP_IN);
          const cube = new THREE.Mesh(geo, mats);
          cube.position.set(x, y, wallFrontZ - DEP_IN/2 - 0.002);
          cube.renderOrder = -30;
          tmslGroup.add(cube);

          // — HALO (define el alcance visible del color) —
          const PLx = S * HALO_SX;
          const PLy = S * HALO_SY;
          const pgeo = new THREE.PlaneGeometry(PLx, PLy);
          const pmat = new THREE.MeshBasicMaterial({
            color: col, map: tmslHaloTex,
            transparent: true, depthWrite: false, depthTest: false,
            blending: THREE.NormalBlending, premultipliedAlpha: false, opacity: 0.90
          });
          const halo = new THREE.Mesh(pgeo, pmat);
          halo.position.set(x, y, wallFrontZ - 0.004);
          halo.userData.baseOpacity = 0.70;

          const sMin = Math.min(1 / HALO_SX, 1 / HALO_SY) * 0.82;
          const sMax = 1.02;
          halo.userData.sMin = sMin;
          halo.userData.sMax = sMax;
          halo.userData.speed = 0.35;
          halo.userData.phase = 0.0;

          halo.scale.set(sMax, sMax, 1);
          tmslHaloGroup.add(halo);

          // — bounds con el halo en escala máxima (área de color) —
          const hx = PLx * sMax * 0.5;
          const hy = PLy * sMax * 0.5;
          minX = Math.min(minX, x - hx);
          maxX = Math.max(maxX, x + hx);
          minY = Math.min(minY, y - hy);
          maxY = Math.max(maxY, y + hy);
        }
      }

      // — redimensiona pared al tamaño exacto del alcance de color (+margen) —
      const MARGIN = 1.2; // pequeño margen blanco alrededor
      const wAll = (maxX - minX) + 2*MARGIN;
      const hAll = (maxY - minY) + 2*MARGIN;
      const cxAll = (minX + maxX) / 2;
      const cyAll = (minY + maxY) / 2;

      // reemplaza geometría de la pared (manteniendo Z)
      wall.geometry.dispose();
      wall.geometry = new THREE.BoxGeometry(wAll, hAll, wallDepth);
      wall.position.set(cxAll, cyAll, wallCenterZ);

      // — crea “caja blanca” alrededor: techo, piso y laterales —
      //   IMPORTANTE: dibujar DESPUÉS de halos ⇒ renderOrder mayor que -40
      const enclosure = new THREE.Group();
      enclosure.userData.tmslKind = 'enclosure';
      enclosure.renderOrder = -20; // > -40 (halos) y > -30 (células) ⇒ queda visible delante
      tmslGroup.add(enclosure);

      const THK = 1.0; // grosor marco blanco
      const matWhite = new THREE.MeshBasicMaterial({ color: 0xffffff });

      const top  = new THREE.Mesh(new THREE.BoxGeometry(wAll, THK, wallDepth), matWhite);
      top.position.set(cxAll, maxY + MARGIN + THK/2, wallCenterZ);

      const bot  = new THREE.Mesh(new THREE.BoxGeometry(wAll, THK, wallDepth), matWhite);
      bot.position.set(cxAll, minY - MARGIN - THK/2, wallCenterZ);

      const leftE = new THREE.Mesh(new THREE.BoxGeometry(THK, hAll + 2*THK, wallDepth), matWhite);
      leftE.position.set(minX - MARGIN - THK/2, cyAll, wallCenterZ);

      const rightE = new THREE.Mesh(new THREE.BoxGeometry(THK, hAll + 2*THK, wallDepth), matWhite);
      rightE.position.set(maxX + MARGIN + THK/2, cyAll, wallCenterZ);

      enclosure.add(top, bot, leftE, rightE);

      // — el resto (animación de halos) igual —
    }

    function updateTMSLHalos(t){
      if (!tmslHaloGroup) return;

      const T = t * 0.75; // tempo global
      tmslHaloGroup.children.forEach(h=>{
        if (!h.isMesh) return;
        const sMin = h.userData.sMin, sMax = h.userData.sMax;
        const sp   = h.userData.speed || 0.42;
        const ph   = h.userData.phase || 0.0;

        // oscila 0..1; cuando sube, el halo SE CONTRAE (entra hacia el hueco)
        let osc = 0.5 + 0.5 * Math.sin(T * sp + ph);
        const s = THREE.MathUtils.lerp(sMax, sMin, osc); // ⇐ invertido: grande→pequeño

        h.scale.set(s, s, 1);

        // opacidad acompaña (un poco más intensa cuando “entra”)
        const k = (s - sMin) / Math.max(1e-5, (sMax - sMin)); // 0..1
        h.material.opacity = THREE.MathUtils.clamp((h.userData.baseOpacity || 0.70) * (1.10 - 0.25*k), 0.0, 0.95);
      });
    }

    function enterTMSLView(){
      camera.up.set(0,1,0);
      camera.fov = 55;
      camera.updateProjectionMatrix();

      const eyeY = (controls && controls.target) ? controls.target.y : 0;
      controls.target.set(0, eyeY, 0);

      camera.position.set(0, eyeY, 70);   // ← más lejos que antes

      controls.enabled = true;
      controls.enableRotate = true;
      controls.enablePan    = true;
      controls.enableZoom   = true;
      controls.screenSpacePanning = true;
      controls.minDistance = 10;
      controls.maxDistance = 300;
      controls.minPolarAngle = Math.PI / 2;
      controls.maxPolarAngle = Math.PI / 2;
      controls.update();
    }

    function toggleTMSL(){
      if (!isTMSL){ // ENTRAR
        leaveBuildRenderBoost();
        if (isFRBN)   toggleFRBN();
        if (isLCHT)   toggleLCHT();
        if (isOFFNNG) toggleOFFNNG();
        if (isKEPLR)  toggleKEPLR();

        // === Fondo y clearColor ANTES de construir ===
        tmslPrevBg    = scene.background ? scene.background.clone() : null;
        tmslPrevClear = renderer.getClearColor(new THREE.Color()).clone();
        updateBackground(false);                                 // usa el fondo global
        renderer.setClearColor(scene.background || 0x000000, 1); // evita "flash" negro

        // Construye pared + halos/celdas
        buildTMSL();
        buildTMSL_TomaselloStaudt();

        // Exclusividad visual
        cubeUniverse.visible     = false;
        permutationGroup.visible = false;
        if (lichtGroup) lichtGroup.visible = false;

        // Vista nivelada
        enterTMSLView();

        isTMSL = true;
        window.isTMSL = true;

      } else { // SALIR
        disposeAndRemove(tmslHaloGroup);  tmslHaloGroup  = null;
        if (tmslCellsGroup){
          tmslCellsGroup.traverse(o=>{ if(o.isMesh){ o.geometry?.dispose?.(); o.material?.dispose?.(); } });
          tmslCellsGroup = null;
        }
        disposeAndRemove(tmslGroup);      tmslGroup      = null;

        if (tmslPrevBg) scene.background = tmslPrevBg; else updateBackground(false);
        if (tmslPrevClear) renderer.setClearColor(tmslPrevClear, 1);

        controls.enabled      = true;
        controls.enableRotate = true;
        controls.enablePan    = true;
        controls.enableZoom   = true;

        cubeUniverse.visible     = true;
        permutationGroup.visible = true;
        if (lichtGroup && isLCHT) lichtGroup.visible = true;

        isTMSL = false;
        window.isTMSL = false;
      }
    }
    function clearGroup(g){
      if (!g) return;
      g.traverse(o=>{ if(o.isMesh){ o.geometry.dispose(); o.material.dispose(); } });
      scene.remove(g);
    }

      function buildRAUM(){
        // —— limpia versión previa
        clearGroup(raumGroup);
        raumGroup = new THREE.Group();

        // asegura fondo sincronizado con BUILD/OFFNNG
        updateBackground(false);

        const W = RAUM_W, H = RAUM_H, D = RAUM_D, g = RAUM_G;
        const Wi = W - 2*g, Hi = H - 2*g, Di = D - 2*g;

        // ====== COLORES deterministas ======
        const colCeil  = raumColorFor(1);
        const colFloor = raumColorFor(2);
        const colLeft  = raumColorFor(3);
        const colRight = raumColorFor(4);
        const colBack  = raumColorFor(5);
        const colA     = raumColorFor(6);
        const colB     = raumColorFor(7);

        function lambert(c, opacity){
          const base = applyBuildVibranceToColor(c);
          const matOpts = {
            color: base,
            side: THREE.DoubleSide,
            dithering: false                // ← sin granulado en planos grandes
          };
          if (typeof opacity === 'number' && opacity < 1){
            matOpts.transparent = true;
            matOpts.opacity = opacity;
          }
          const m = new THREE.MeshLambertMaterial(matOpts);
          m.emissive = base.clone();
          m.emissiveIntensity = 0.06;
          return m;
        }

        // ====== PAREDES EXTERIORES (caja sin frente) ======
        const left  = new THREE.Mesh(new THREE.BoxGeometry(g, H, D), lambert(colLeft));
        left.position.set(-W/2 + g/2, 0, 0);
        const right = new THREE.Mesh(new THREE.BoxGeometry(g, H, D), lambert(colRight));
        right.position.set( W/2 - g/2, 0, 0);

        const floor = new THREE.Mesh(new THREE.BoxGeometry(W, g, D), lambert(colFloor));
        floor.position.set(0, -H/2 + g/2, 0);
        const ceil  = new THREE.Mesh(new THREE.BoxGeometry(W, g, D), lambert(colCeil));
        ceil.position.set(0,  H/2 - g/2, 0);

        raumGroup.add(left, right, floor, ceil);

        // ====== INVARIANTES / ESTADÍSTICAS DETERMINISTAS ======
        const { sumR, sumR2, mRank } = raumStats();

        // ====== MUROS INTERIORES (A y B) — primero sus PARÁMETROS ======
        // — A (longitudinal, grosor g en X, largo LA en Z)
        const LAmin = 8, LAmax = Di; // 8..28
        const LA = LAmin + ((sumR + 5*mRank + sceneSeed) % (LAmax - LAmin + 1));
        const xAmin = -Wi/2 + g/2, xAmax = Wi/2 - g/2;
        const zAmin = -Di/2 + LA/2, zAmax = Di/2 - LA/2;
        const uAx   = ((11*sumR2 + 7*mRank + sceneSeed) % 991) / 991;
        const uAz   = ((S_global + 23*mRank + sumR2) % 983) / 983;
        const xA    = xAmin + (xAmax - xAmin) * uAx;
        const zA    = zAmin + (zAmax - zAmin) * uAz;

        // — B (transversal, ancho LB en X, grosor g en Z)
        const LBmin = 10, LBmax = Wi; // 10..58
        const LB = LBmin + ((sumR2 + 9*mRank + 3*sceneSeed) % (LBmax - LBmin + 1));
        const xBmin = -Wi/2 + LB/2, xBmax = Wi/2 - LB/2;
        const zBmin = -Di/2 + g/2,  zBmax = Di/2 - g/2;
        const uBx   = ((17*sumR2 + 31*mRank + sceneSeed) % 971) / 971;
        const uBz   = ((19*sumR + 29*mRank + S_global) % 977) / 977;
        const xB    = xBmin + (xBmax - xBmin) * uBx;
        const zB    = zBmin + (zBmax - zBmin) * uBz;

        // ====== APERTURA EN LA PARED DEL FONDO (con regla 33%) ======
        const zBack = -D/2 + g/2;

        // — dimensiones base (10..25), sin forzar área mínima
        let breite = 10 + ((sumR  + 7*mRank + sceneSeed)  % 16); // 10..25
        let hoehe  = 10 + ((sumR2 + 11*mRank + 3*sceneSeed) % 16); // 10..25
        breite = Math.max(2, Math.min(breite, Wi));
        hoehe  = Math.max(2, Math.min(hoehe,  Hi));

        // — centro determinista propuesto
        const xmin0 = -Wi/2 + breite/2, xmax0 = Wi/2 - breite/2;
        const ymin0 = -Hi/2 + hoehe/2,  ymax0 = Hi/2 - hoehe/2;

        const ux = ((37*sumR + 13*mRank + S_global) % 997) / 997;
        const uy = ((53*sumR2 + 17*mRank + sceneSeed) % 991) / 991;
        let xC   = xmin0 + (xmax0 - xmin0) * ux;
        const yC = ymin0 + (ymax0 - ymin0) * uy;

        // — utilidades de intervalos en X
        function clipInterval(a,b,min,max){
          const s = Math.max(a,min), e = Math.min(b,max);
          return (e > s) ? [s,e] : null;
        }
        function mergeIntervals(list){
          if (!list.length) return [];
          const v = list.slice().sort((p,q)=>p[0]-q[0]);
          const out = [ v[0].slice() ];
          for (let i=1;i<v.length;i++){
            const cur = v[i], last = out[out.length-1];
            if (cur[0] <= last[1]) last[1] = Math.max(last[1], cur[1]);
            else out.push(cur.slice());
          }
          return out;
        }
        function complement(minX, maxX, occ){
          const gaps=[];
          let cur = minX;
          occ.forEach(([a,b])=>{
            if (a > cur) gaps.push([cur,a]);
            cur = Math.max(cur,b);
          });
          if (cur < maxX) gaps.push([cur,maxX]);
          return gaps;
        }
        function visibleFraction(center, width, occ){
          const L = center - width/2, R = center + width/2;
          let occLen = 0;
          occ.forEach(([a,b])=>{
            const s = Math.max(L,a), e = Math.min(R,b);
            if (e > s) occLen += (e - s);
          });
          const vis = Math.max(0, width - Math.min(width, occLen));
          return vis / Math.max(1e-6, width);
        }

        // — proyección de A y B sobre el fondo (intervalos en X, altura total)
        const occRaw = [];
        const iA = clipInterval(xA - g/2,   xA + g/2,   -Wi/2, Wi/2);
        const iB = clipInterval(xB - LB/2,  xB + LB/2,  -Wi/2, Wi/2);
        if (iA) occRaw.push(iA);
        if (iB) occRaw.push(iB);
        const occ = mergeIntervals(occRaw);
        const gaps = complement(-Wi/2, Wi/2, occ);

        // — regla 33%: recolocación suave + fallback de reducción de ancho
        const VISIBLE_MIN = 0.33;

        function gapLen(g){ return g[1]-g[0]; }
        const maxGap = gaps.length ? gaps.reduce((best,g)=> gapLen(g) > gapLen(best) ? g : best, gaps[0]) : [0,0];
        const Lmax   = gapLen(maxGap);

        let xmin = xmin0, xmax = xmax0;
        let vis  = visibleFraction(xC, breite, occ);

        if (vis < VISIBLE_MIN){
          // 1) ¿Existe algún gap que pueda contener COMPLETA la ventana?
          const bigGaps = gaps.filter(g => gapLen(g) >= breite);
          if (bigGaps.length){
            // coloca en el gap más cercano al xC original (mínimo desplazamiento)
            let best = null;
            bigGaps.forEach(g=>{
              const cmin = g[0] + breite/2, cmax = g[1] - breite/2;
              const newX = clamp(xC, Math.max(cmin, xmin), Math.min(cmax, xmax));
              const d    = Math.abs(newX - xC);
              if (!best || d < best.d) best = {x:newX, d};
            });
            if (best){
              xC = best.x;
              vis = 1;
            }
          } else {
            // 2) No cabe completa: céntrala en el mayor gap
            const mid = (maxGap[0] + maxGap[1]) / 2;
            xC = clamp(mid, xmin, xmax);
            vis = (Lmax / breite);

            // 3) Fallback: reducir ancho hasta garantizar ≥ 33 %
            if (vis < VISIBLE_MIN){
              const newW = Math.max(2, Math.min(breite, 3 * Lmax)); // (Lmax / newW) ≥ 1/3
              if (newW !== breite){
                breite = newW;
                xmin = -Wi/2 + breite/2;
                xmax =  Wi/2 - breite/2;
              }
              const cmin2 = maxGap[0] + breite/2, cmax2 = maxGap[1] - breite/2;
              if (cmax2 >= cmin2){
                const mid2 = (maxGap[0] + maxGap[1]) / 2;
                xC = clamp(mid2, Math.max(cmin2, xmin), Math.min(cmax2, xmax));
                vis = 1;
              } else {
                // caso extremo: Lmax == 0 → no hay hueco; mantenemos determinismo
                vis = (Lmax / Math.max(1e-6, breite)); // 0
              }
            }
          }
        }

        // — bandas del “marco” (4 piezas)
        const hTop = (Hi/2) - (yC + hoehe/2);
        if (hTop > 0.0001){
          const top = new THREE.Mesh(new THREE.BoxGeometry(Wi, hTop, g), lambert(colBack));
          top.position.set(0, yC + hoehe/2 + hTop/2, zBack);
          raumGroup.add(top);
        }
        const hBot = (yC - hoehe/2) - (-Hi/2);
        if (hBot > 0.0001){
          const bot = new THREE.Mesh(new THREE.BoxGeometry(Wi, hBot, g), lambert(colBack));
          bot.position.set(0, yC - hoehe/2 - hBot/2, zBack);
          raumGroup.add(bot);
        }
        const wLeft = (xC - breite/2) - (-Wi/2);
        if (wLeft > 0.0001){
          const l = new THREE.Mesh(new THREE.BoxGeometry(wLeft, hoehe, g), lambert(colBack));
          l.position.set(xC - breite/2 - wLeft/2, yC, zBack);
          raumGroup.add(l);
        }
        const wRight = (Wi/2) - (xC + breite/2);
        if (wRight > 0.0001){
          const r = new THREE.Mesh(new THREE.BoxGeometry(wRight, hoehe, g), lambert(colBack));
          r.position.set(xC + breite/2 + wRight/2, yC, zBack);
          raumGroup.add(r);
        }

        // ====== AHORA sí: instanciar muros interiores A y B (opacos) ======
        const wallA = new THREE.Mesh(new THREE.BoxGeometry(g, H, LA), lambert(colA)); // opaco
        wallA.position.set(xA, 0, zA);
        raumGroup.add(wallA);

        const wallB = new THREE.Mesh(new THREE.BoxGeometry(LB, H, g), lambert(colB)); // opaco
        wallB.position.set(xB, 0, zB);
        raumGroup.add(wallB);

        // —— añadir grupo a escena
        scene.add(raumGroup);
      }

    function toggleRAUM(){
      isRAUM = !isRAUM;

      if (isRAUM){
        // RAUM debe estar en solitario
        if (isFRBN)  toggleFRBN();
        if (isLCHT)  toggleLCHT();
        if (isOFFNNG)toggleOFFNNG();
        if (isTMSL)  toggleTMSL();
        if (is13245) toggle13245();
        if (isR5NOVA) toggleR5NOVA();
        if (isKEPLR) toggleKEPLR();

        // Sal del boost de BUILD si venías de allí y entra al boost de RAUM
        leaveBuildRenderBoost();
        enterRaumRenderBoost();

        // Controles: vista frontal fija con zoom permitido
        controls.enabled      = true;
        controls.enableRotate = false;
        controls.enablePan    = false;
        controls.enableZoom   = true;
        controls.minDistance  = 25;
        controls.maxDistance  = 140;

        camera.position.set(0, 0, RAUM_CAMERA_ZOOMED);
        camera.lookAt(0,0,0);
        controls.update();

        buildRAUM();

        cubeUniverse.visible     = false;
        permutationGroup.visible = false;
        if (lichtGroup) lichtGroup.visible = false;

      } else {
        // Salida de RAUM: limpia y restaura PR/exposición previos
        leaveRaumRenderBoost();

        clearGroup(raumGroup);
        raumGroup = null;

        // Restaurar comportamiento libre
        controls.enabled      = true;
        controls.enableRotate = true;
        controls.enablePan    = true;
        controls.enableZoom   = true;

        cubeUniverse.visible     = true;
        permutationGroup.visible = true;
        if (lichtGroup && isLCHT) lichtGroup.visible = true;
      }
    }
    function ensureOnlyRAUM(){ if (!isRAUM) toggleRAUM(); }
    function rebuildRAUMIfActive(){ if (isRAUM) buildRAUM(); }

    // ──────────────────────────────
    // 13245 · motor (grid 10×10)
    // ──────────────────────────────
    let is13245 = false;
    let group13245 = null;

    /* Escala acoplada a RAUM:
     *   - piso 179.98 → ~60
     *   - anillo Ø183.98 → ~61.33 (espesor ~0.667, h ~16.67)
     */
    const K132           = 60 / 179.98;
    const FLOOR132       = 179.98 * K132;           // ~60
    const R_OUT132       = (183.98 * 0.5) * K132;   // ~30.666
    const WALL_THICK132  = 2.0 * K132;              // ~0.6667
    const WALL_H132      = 50.0 * K132;             // ~16.667
    const CELL132        = FLOOR132 / 10;           // ~6

    // ★ NUEVO: sección real de cada volumen (en unidades del cubo 30×30×30)
    const CROSS132 = 2.25;

    // ★ NUEVO: grilla de 30×30 con 11×11 centros (paso 3.00 y margen 1.50)
    const GRID_STEP   = 3.0;
    const GRID_COUNT  = 11;
    const GRID_MARGIN = 1.5;

    // Pasos de cámara para la vista default de 13245
    // – zoomOut() mueve +5 en Z → usamos el mismo paso
    const ZOOM_STEP_13245  = 5.0;
    // – pan vertical: usamos el paso de la grilla (GRID_STEP = 3.0)
    const PAN_STEP_Y_13245 = GRID_STEP;

    // ★ NUEVO: espesor de la losa global (cara superior en y = 0)
    const SLAB_THICK  = 30.00;
    const SLAB_EXTRA_X = 90.00; // ← ya existente (45u por lado en X)
    const SLAB_EXTRA_Z = 90.00; // ← NUEVO (45u al frente y 45u atrás en Z)

    // salto coprimo para open-addressing
    const STEP_OPEN_ADDR = 37;

    function disposeGroup(g){
      if (!g) return;
      g.traverse(o => {
        if (o.isMesh) {
          o.geometry?.dispose?.();
          o.material?.dispose?.();
        }
      });
      scene.remove(g);
    }

    /* Color RAUM → aplica “vibrance BUILD” y ∆E≥22 contra el fondo */
    function lambertRaumColor(cTHREE, emissiveIntensity = 0.06, doubleSide = false){
      const c = applyBuildVibranceToColor(cTHREE);
      const m = new THREE.MeshLambertMaterial({
        color: c,
        dithering: true,
        side: doubleSide ? THREE.DoubleSide : THREE.FrontSide
      });
      m.emissive = c.clone();
      m.emissiveIntensity = emissiveIntensity;
      return m;
    }

    /* Color determinista para el tramo k (k=0..2) de una permutación */
    function color132For(pa, k){
      const sig  = computeSignature(pa);
      const r    = lehmerRank(pa);
      const slot = (r % 12) + k;     // offsets k=0,1,2

      let [hI,sI,vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
      sI = (sI * PHI_S) % 12;
      vI = (vI * PHI_V) % 12;

      const {h,s,v} = idxToHSV(hI, sI, vI);
      let rgb = hsvToRgb(h,s,v);
      rgb = ensureContrastRGB(rgb);

      const col = new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255);
      return applyBuildVibranceToColor(col);
    }

    /* Alturas exactas (en unidades del cubo).
       hBot fijo; hMid depende de P2; hTop fijo 60 para todas las permutaciones. */
    function heightsFor(pa){
      const H_MID = [0, 5.56, 6.365, 7.795, 9.00, 10.06]; // idx 1..5
      const hBot = 2.25;
      const hMid = H_MID[ pa[1] ];
      const hTop = 60.0;
      return [hBot, hMid, hTop];
    }

    /* Construye/rehace toda la escena 13245 */
    function build13245(){
      // limpia versión previa
      disposeGroup(group13245);
      group13245 = new THREE.Group();

      // Fondo acoplado (no manual)
      updateBackground(false);

      // ★ ACTUALIZADO: losa global extendida
      //   X = 30 + 90  (45u extra por lado)
      //   Y = THICK
      //   Z = 30 + 90  (45u extra al frente y atrás)
      //   cara superior en y = 0
      {
        const slabGeo = new THREE.BoxGeometry(
          cubeSize + SLAB_EXTRA_X,
          SLAB_THICK,
          cubeSize + SLAB_EXTRA_Z
        );
        const slabMat = lambertRaumColor(cubeUniverse.material.color, 0.04, true);
        const slab    = new THREE.Mesh(slabGeo, slabMat);
        slab.position.set(0, -SLAB_THICK/2, 0);
        group13245.add(slab);
      }

      // === Centros 11×11 en 30×30: paso 3.00, margen 1.50 ===
      const centers = [];
      const half = halfCube; // 15
      for (let j = 0; j < GRID_COUNT; j++){
        const z = -half + GRID_MARGIN + j * GRID_STEP; // −13.5 … +13.5
        for (let i = 0; i < GRID_COUNT; i++){
          const x = -half + GRID_MARGIN + i * GRID_STEP;
          centers.push([x, z]);
        }
      }

      // Open addressing determinista (coprimo con 121)
      const occ   = Array(centers.length).fill(false);
      const perms = getSelectedPerms();

      // Base 2.25×2.25; la altura real la da scale.y = h
      const baseGeo = new THREE.BoxGeometry(CROSS132, 1, CROSS132);

      perms.forEach(pa => {
        const r = lehmerRank(pa);
        let idx = (r + sceneSeed + S_global) % centers.length;
        while (occ[idx]) idx = (idx + STEP_OPEN_ADDR) % centers.length;
        occ[idx] = true;

        const [x, z] = centers[idx];

        // alturas y colores por tramo (k=0,1,2)
        const [hBot, hMid, hTop] = heightsFor(pa);
        const cols = [0,1,2].map(k => color132For(pa, k));

        // — SIN separación vertical (sep = 0)
        let y = 0.0;

        // tramo inferior
        const m0 = new THREE.Mesh(baseGeo, new THREE.MeshLambertMaterial({ color: cols[0], dithering:true }));
        m0.material.emissive = cols[0].clone(); m0.material.emissiveIntensity = 0.06;
        m0.scale.y = hBot; m0.position.set(x, y + hBot/2, z); y += hBot;
        group13245.add(m0);

        // tramo medio
        const m1 = new THREE.Mesh(baseGeo, new THREE.MeshLambertMaterial({ color: cols[1], dithering:true }));
        m1.material.emissive = cols[1].clone(); m1.material.emissiveIntensity = 0.06;
        m1.scale.y = hMid; m1.position.set(x, y + hMid/2, z); y += hMid;
        group13245.add(m1);

        // tramo superior (hTop fijo 60)
        if (hTop > 0.0001){
          const m2 = new THREE.Mesh(baseGeo, new THREE.MeshLambertMaterial({ color: cols[2], dithering:true }));
          m2.material.emissive = cols[2].clone(); m2.material.emissiveIntensity = 0.06;
          m2.scale.y = hTop; m2.position.set(x, y + hTop/2, z);
          group13245.add(m2);
        }
      });

      scene.add(group13245);
    }

    /* rebuild si hay cambios de escena */
    function rebuild13245IfActive(){ if (is13245) build13245(); }

    /* Exclusivo (como RAUM). Usa el “crispness boost” de RAUM. */
    function toggle13245(){
      is13245 = !is13245;

      if (is13245){
        // exclusividad
        if (isFRBN)  toggleFRBN();
        if (isLCHT)  toggleLCHT();
        if (isOFFNNG)toggleOFFNNG();
        if (isTMSL)  toggleTMSL();
        if (isRAUM)  toggleRAUM();
        if (isR5NOVA) toggleR5NOVA();
        if (isKEPLR) toggleKEPLR();

        leaveBuildRenderBoost();
        enterRaumRenderBoost();
        build13245();

        // — VISTA POR DEFECTO NIVELADA (verticales rectas)
        camera.up.set(0,1,0);
        camera.fov = 55;
        camera.updateProjectionMatrix();

        // 2× “scroll” hacia arriba (pan en Y) y 2× zoom-out en Z
        const yOffset = 2 * PAN_STEP_Y_13245;   // 2 · 3  = +6
        const zOffset = 2 * ZOOM_STEP_13245;    // 2 · 5  = +10

        // Misma Y para cámara y target (mantiene verticales “gerade”)
        camera.position.set(0, yOffset, 22 + zOffset); // antes: (0, 0, 22)
        controls.target.set(0, yOffset, 0);            // antes: (0, 0, 0)

        // Controles: yaw/pan/zoom permitidos; pitch bloqueado a 90°
        controls.enabled            = true;
        controls.enableRotate       = true;   // solo yaw (por el clamp polar)
        controls.enablePan          = true;
        controls.enableZoom         = true;
        controls.minDistance        = 10;
        controls.maxDistance        = 200;
        controls.screenSpacePanning = true;

        // Bloquea el pitch para mantener las verticales “gerade”
        controls.minPolarAngle = Math.PI / 2;
        controls.maxPolarAngle = Math.PI / 2;
        controls.update();

        cubeUniverse.visible     = false;
        permutationGroup.visible = false;
        if (lichtGroup) lichtGroup.visible = false;

      } else {
        leaveRaumRenderBoost();
        disposeGroup(group13245);
        group13245 = null;

        // Restaurar ajustes por defecto al salir de 13245
        camera.fov = 75;
        camera.updateProjectionMatrix();
        controls.minPolarAngle      = 0;
        controls.maxPolarAngle      = Math.PI;
        controls.screenSpacePanning = false;

        cubeUniverse.visible     = true;
        permutationGroup.visible = true;
        if (lichtGroup && isLCHT) lichtGroup.visible = true;
      }
    }

    /* botón selector – sólo enciende, nunca apaga */
    function ensureOnly13245(){ if (!is13245) toggle13245(); }

    // ──────────────────────────────
    // KEPLR · Platonic/Kepler interlock (L=1..2)
    // ──────────────────────────────
    var isKEPLR    = false;
    var groupKEPLR = null;

    /* Limpieza segura */
    function disposeGroupKEPLR(){
      if (!groupKEPLR) return;
      groupKEPLR.traverse(o=>{
        if (o.isMesh || o.isLineSegments){
          o.geometry?.dispose?.();
          // LineBasicMaterial no tiene emissive; MeshLambert sí.
          o.material?.dispose?.();
        }
      });
      scene.remove(groupKEPLR);
      groupKEPLR.userData = {};        // limpia colecciones de materiales/tiempos
      groupKEPLR = null;
    }

    /* Sólidos y simetrías */
    const KEPLR_SOLIDS = ['TETRA','CUBE','OCTA','DODE','ICOSA'];
    const KEPLR_ORDER  = { TETRA:12, CUBE:24, OCTA:24, DODE:60, ICOSA:60 };
    function keplrDualOf(name){
      if (name === 'CUBE')  return 'OCTA';
      if (name === 'OCTA')  return 'CUBE';
      if (name === 'DODE')  return 'ICOSA';
      if (name === 'ICOSA') return 'DODE';
      return 'TETRA'; // auto-dual
    }

    /* Geometrías con radio circunscrito R */
    function keplrGeometry(name, R){
      switch(name){
        case 'TETRA': return new THREE.TetrahedronGeometry(R, 0);
        case 'OCTA':  return new THREE.OctahedronGeometry(R, 0);
        case 'ICOSA': return new THREE.IcosahedronGeometry(R, 0);
        case 'DODE':  return new THREE.DodecahedronGeometry(R, 0);
        case 'CUBE': {
          const a = 2*R/Math.sqrt(3); // lado para radio a vértices = R
          return new THREE.BoxGeometry(a, a, a);
        }
      }
    }

    /* Vértices únicos de una geometría */
    function uniqueVerticesFromGeo(geo){
      const pos = geo.attributes.position.array;
      const seen = new Map(), out=[];
      for (let i=0;i<pos.length;i+=3){
        const x = +pos[i].toFixed(6), y = +pos[i+1].toFixed(6), z = +pos[i+2].toFixed(6);
        const k = `${x}|${y}|${z}`;
        if (!seen.has(k)){ seen.set(k,1); out.push(new THREE.Vector3(x,y,z)); }
      }
      return out;
    }

    /* === Semillas KEPLR (forma vs color) ============================== */

    /* SOLO forma (shape): NUNCA mezclar patrón cromático aquí */
    function keplrShapeSeedFromPerms(perms){
      let h = 2166136261 >>> 0;             // FNV-1a base
      for (let i=0;i<perms.length;i++){
        const r = (lehmerRank(perms[i]) >>> 0);
        h ^= r; h = Math.imul(h, 16777619) >>> 0;
      }
      try{
        const am = (Array.isArray(attributeMapping) ? attributeMapping : []);
        for (let i=0;i<5;i++){
          const v = (am[i] | 0) & 255;
          h ^= (v << ((i*7)%24)) >>> 0;
          h = Math.imul(h, 2246822519) >>> 0;
        }
      }catch(_){ }
      // semillas globales permitidas (NO patrón)
      h ^= (sceneSeed|0) >>> 0;
      h ^= (S_global|0) >>> 0;
      h ^= h >>> 13; h = Math.imul(h, 3266489917) >>> 0; h ^= h >>> 16;
      return h >>> 0;
    }

    /* Orientación discreta en función del grupo de simetría */
    function applyKeplrOrientation(obj, name, idx, extra){
      const ord = KEPLR_ORDER[name] || 12;
      const yaw   = (2*Math.PI * (idx % ord)) / ord;
      const pitch = (2*Math.PI * (Math.floor(extra/3) % ord)) / ord;
      const roll  = (2*Math.PI * (Math.floor(extra/7) % ord)) / ord;
      obj.rotation.set(pitch, yaw, roll);
    }

    // === KEPLR · constantes/materiales ===
    // ——— aristas (edges) del sólido
    const KEPLR_EDGES_ON = false; // ← OFF: no se renderizan líneas de aristas
    // Mezcla útil para translucidez “sólida” (un único mesh transparente)
    const KEPLR_FACE_OPACITY = 0.72;
    // “Rahmen” (marco interior). ON/OFF:
    const KEPLR_RAHMEN_ON   = false;     // ← APAGADO por ahora
    const KEPLR_RAHMEN_SHRINK = 0.985;   // 1.5% más pequeño → línea “inset”
    const KEPLR_RAHMEN_ALPHA  = 0.95;    // casi opaco

    /* === KEPLR · Raw shader estilo demo (espacio de cámara) ================= */
    /* Velocidad de desplazamiento de franjas (antes era 0.005) */
    const KEPLR_STRIPE_SPEED = 0.0018; // ~3× más lento. Sube/baja este número a gusto.
    const KEPLR_RAW_VS = `
precision mediump float;
precision mediump int;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

attribute vec3 position;
attribute vec4 color;

varying vec4 vColor;
varying vec3 vViewPos;  // posición en espacio de cámara

void main(){
  vColor   = color;
  vec4 mv  = modelViewMatrix * vec4(position, 1.0);
  vViewPos = mv.xyz;
  gl_Position = projectionMatrix * mv;
}
`;

    const KEPLR_RAW_FS = `
precision mediump float;
precision mediump int;

uniform float time;

varying vec4 vColor;
varying vec3 vViewPos;

void main(){
  vec4 color = vColor;
  // franjas suaves como el demo; frecuencia baja y sin quemados
  float stripe = sin(vViewPos.x * 0.25 + time) * 0.25;
  color.r = clamp(color.r + stripe, 0.0, 1.0);
  gl_FragColor = color;
}
`;

    // Color de aristas derivado del de las caras (más brillante y con contraste)
    function keplrEdgeFromFaceColor(base){
      const rgb = [Math.round(base.r*255), Math.round(base.g*255), Math.round(base.b*255)];
      let [hh, ss, vv] = rgbToHsv(rgb[0], rgb[1], rgb[2]);
      ss = Math.min(1, ss * 0.55);
      vv = Math.min(1, vv * 1.10 + 0.08);
      let rgb2 = hsvToRgb(hh, ss, vv);
      rgb2 = ensureContrastRGB(rgb2);
      return new THREE.Color(rgb2[0]/255, rgb2[1]/255, rgb2[2]/255);
    }

    // Color único por sólido (como BUILD): slot = r + uniq
    function keplrUniqueFaceColor(pa, uniq){
      const sig = computeSignature(pa);
      const r   = lehmerRank(pa);
      const slot = (r + uniq) % 12;                     // ← unicidad por sólido
      let [hI, sI, vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);
      sI = (sI * PHI_S) % 12; vI = (vI * PHI_V) % 12;
      const {h,s,v} = idxToHSV(hI, sI, vI);
      let rgb = hsvToRgb(h, s, v);
      rgb = ensureContrastRGB(rgb);
      const col = new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255);
      return applyBuildVibranceToColor(col);
    }

    // Tripleta de colores: cara única, arista derivada, y cara del dual también única
    function keplrColorsForSolid(pa, uniqIndex){
      const cFace = keplrUniqueFaceColor(pa, uniqIndex);       // color único por sólido
      const cEdge = keplrEdgeFromFaceColor(cFace);             // arista contrastada
      const cDual = keplrUniqueFaceColor(pa, uniqIndex + 1);   // dual ≠ cara principal
      return [cFace, cEdge, cDual];
    }

    // === REEMPLAZO · Materialidad RawShader estilo demo =====================

    // Rellena 'color' RGBA (Uint8 normalizado) con el color de la cara
    function keplrApplyVertexColorsRGBA(geo, colorTHREE){
      const r = Math.round(THREE.MathUtils.clamp(colorTHREE.r,0,1)*255);
      const g = Math.round(THREE.MathUtils.clamp(colorTHREE.g,0,1)*255);
      const b = Math.round(THREE.MathUtils.clamp(colorTHREE.b,0,1)*255);
      const a = Math.round(THREE.MathUtils.clamp(KEPLR_FACE_OPACITY,0,1)*255);
      const n = geo.attributes.position.count;
      const data = new Uint8Array(n*4);
      for (let i=0;i<n;i++){
        const j=i*4; data[j]=r; data[j+1]=g; data[j+2]=b; data[j+3]=a;
      }
      const attr = new THREE.Uint8BufferAttribute(data,4);
      attr.normalized = true;
      geo.setAttribute('color', attr);
    }

    // Devuelve un Mesh con RawShaderMaterial (DoubleSide, transparente)
    function keplrBuildRawFaceMesh(geo, colorTHREE){
      const geo2 = geo.clone();
      keplrApplyVertexColorsRGBA(geo2, applyBuildVibranceToColor(colorTHREE));

      const mat = new THREE.RawShaderMaterial({
        uniforms: { time: { value: 0.0 } },
        vertexShader:   KEPLR_RAW_VS,
        fragmentShader: KEPLR_RAW_FS,
        side: THREE.DoubleSide,
        transparent: true,
        depthTest: true,
        depthWrite: false,
        dithering: true
      });

      const mesh = new THREE.Mesh(geo2, mat);
      mesh.renderOrder = 1;
      return mesh;
    }

    // Mantén la misma firma que usa buildKeplrSolid()
    function keplrBuildFaceGroup(geo, colorTHREE){
      const g = new THREE.Group();
      g.add(keplrBuildRawFaceMesh(geo, colorTHREE));
      return g;
    }

    /* Rahmen (borde fino) por aristas – siempre por delante de las caras */
    function keplrEdgeMaterial(colorTHREE){
      return new THREE.LineBasicMaterial({
        color: applyBuildVibranceToColor(colorTHREE),
        transparent: true,
        opacity: 0.95,
        depthTest: true,
        depthWrite: false
      });
    }

    // “Rahmen” fino: edges del mismo sólido pero INSET (escalado) y encima
    function keplrBuildRahmen(geo, colorTHREE){
      const inner = geo.clone();
      inner.scale(KEPLR_RAHMEN_SHRINK, KEPLR_RAHMEN_SHRINK, KEPLR_RAHMEN_SHRINK);
      const eGeo = new THREE.EdgesGeometry(inner);
      const mat  = new THREE.LineBasicMaterial({
        color: colorTHREE, transparent: true, opacity: KEPLR_RAHMEN_ALPHA,
        depthTest: true, depthWrite: false
      });
      const lines = new THREE.LineSegments(eGeo, mat);
      lines.renderOrder = 3;
      return lines;
    }

    /* Luz suave por si el entorno no aporta suficiente */
    (function ensureKeplrLight(){
      try{
        if (!window.__keplrAmbient){
          const amb = new THREE.AmbientLight(0xffffff, 0.18);
          amb.name = '__keplrAmbient';
          scene.add(amb);
          window.__keplrAmbient = amb;
        }
      }catch(_){ }
    })();

    /* Construye un sólido con capas V/E/F + (opcional) su dual */
    function buildKeplrSolid(name, R, tIdx, dualOn, orientIdx, pa, container, uniqIndex){
      const [cFace, cEdge, cDual] = keplrColorsForSolid(pa, uniqIndex|0);

      // — Sólido principal
      const geo  = keplrGeometry(name, R * (1 - 0.06*tIdx));

      // Caras con shader raw
      const faceGroup = keplrBuildFaceGroup(geo, cFace);
      faceGroup.renderOrder = 0;               // antes que marcos y edges
      container.add(faceGroup);

      // Rahmen (apagado por flag)
      if (KEPLR_RAHMEN_ON){
        const rahmen = keplrBuildRahmen(geo, cEdge);
        rahmen.renderOrder = 3;
        container.add(rahmen);
      }

      // Aristas exteriores (OPCIONAL, normalmente OFF)
      if (KEPLR_EDGES_ON){
        const eGeo  = new THREE.EdgesGeometry(geo);
        const edges = new THREE.LineSegments(eGeo, keplrEdgeMaterial(cEdge));
        edges.renderOrder = 4;
        container.add(edges);
      }

      // — Sólido dual (opcional), con su propio grupo y orientación
      if (dualOn){
        const dName = keplrDualOf(name);
        const dR    = R * (0.62 + 0.06*tIdx);
        const dGeo  = keplrGeometry(dName, dR);

        const sub = new THREE.Group();
        applyKeplrOrientation(sub, dName, (orientIdx*7+3)>>>0, (orientIdx*11+5)>>>0);

        const dFaceGroup = keplrBuildFaceGroup(dGeo, cDual);
        dFaceGroup.renderOrder = 0;
        sub.add(dFaceGroup);

        if (KEPLR_RAHMEN_ON){
          const dRahmen = keplrBuildRahmen(dGeo, cEdge);
          dRahmen.renderOrder = 3;
          sub.add(dRahmen);
        }

        if (KEPLR_EDGES_ON){
          const eGeo2  = new THREE.EdgesGeometry(dGeo);
          const dEdges = new THREE.LineSegments(eGeo2, keplrEdgeMaterial(cEdge));
          dEdges.renderOrder = 4;
          sub.add(dEdges);
        }

        container.add(sub);
      }
    }

    // === KEPLR · Velocidad desde "Signature Range" =============================
    // ω = max(F) − min(F), con compresión suave (tanh) y clamps de seguridad
    function keplrOmegaFromSignature(pa){
      let F = computeSignature(pa);
      if (!Array.isArray(F)) F = [Number(F) || 0];
      let mn = Infinity, mx = -Infinity;
      for (let i=0;i<F.length;i++){
        const v = +F[i];
        if (v < mn) mn = v;
        if (v > mx) mx = v;
      }
      const range = Math.max(0, mx - mn);      // “Signature Range”
      const OMEGA_MIN = 0.25;                  // rad/s
      const OMEGA_MAX = 1.10;                  // rad/s
      const norm = Math.tanh(range * 0.75);    // comprime para evitar picos
      return OMEGA_MIN + norm * (OMEGA_MAX - OMEGA_MIN);
    }

    // === KEPLR · Eje + velocidad por permutación (determinista) ================
    function keplrSpinParamsFor(pa, idx){
      const r = (lehmerRank(pa) >>> 0);
      const seed = ((r * 1315423911) ^ (sceneSeed|0) ^ (S_global|0) ^ Math.imul((idx|0), 2654435761)) >>> 0;

      // Eje local pseudo-aleatorio en [-1,1]^3 a partir de seed
      const ax = (( seed        & 1023) / 511) - 1;
      const ay = (((seed >>> 10) & 1023) / 511) - 1;
      const az = (((seed >>> 20) & 1023) / 511) - 1;
      const axis = new THREE.Vector3(ax, ay, az);
      if (axis.lengthSq() < 1e-6) axis.set(0.7071, 0.0, 0.7071);
      axis.normalize();

      // Velocidad desde “Signature Range”
      const vel = keplrOmegaFromSignature(pa);

      return { axis, vel };
    }

    /* Builder principal */
    function buildKEPLR(){
      disposeGroupKEPLR();
      groupKEPLR = new THREE.Group();

      updateBackground(false);

      const R_BASE = 14.2;

      // Permutaciones activas → 1 sólido por permutación
      let perms = getSelectedPerms();
      if (!perms || !perms.length) perms = [[1,2,3,4,5]];

      // Semilla de forma (no cromática)
      const H = keplrShapeSeedFromPerms(perms);

      // Desfase determinista para repartir el tipo de sólido sin repetir hasta agotar catálogo
      const START = H % KEPLR_SOLIDS.length; // 0..4

      // Contenedor + lista de rotadores
      const container = new THREE.Group();
      groupKEPLR.userData.rotators = [];

      perms.forEach((pa, i) => {
        // Tipo de sólido: round-robin determinista (sin repetir hasta agotar los 5)
        const sName = KEPLR_SOLIDS[(START + i) % KEPLR_SOLIDS.length];

        // Parámetros deterministas por permutación
        const r       = lehmerRank(pa) >>> 0;
        const tIdx    = (r + i) % 6;                                  // tramo 0..5
        const orientK = (Math.imul(H ^ r ^ Math.imul(i, 109), 1103515245) + 12345) >>> 0;
        const oIdx    = orientK % 60;                                  // orientación discreta
        const dualOn  = ((H >>> (7 + (i % 25))) & 1) === 1;            // dual determinista

        // Grupo por sólido (para rotación local)
        const gS = new THREE.Group();
        applyKeplrOrientation(gS, sName, oIdx, orientK);

        // Color único por sólido: uniqIndex = i
        buildKeplrSolid(sName, R_BASE, tIdx, dualOn, oIdx, pa, gS, i);

        // Giro por eje propio (determinista)
        const spin = keplrSpinParamsFor(pa, i);
        gS.userData.rotAxis = spin.axis;
        gS.userData.rotVel  = spin.vel;
        /* KEPLR: metadata de giro idéntica a BUILD */
        gS.userData.permStr = pa.join(',');
        gS.userData.rotStep = getBuildRotStep(gS.userData.permStr);

        container.add(gS);
        groupKEPLR.userData.rotators.push(gS);
      });

      groupKEPLR.add(container);
      scene.add(groupKEPLR);

      // Evita culling agresivo con transparencias cruzadas
      groupKEPLR.traverse(o => { o.frustumCulled = false; });

      // Inicializa marca temporal para el bucle RAF
      groupKEPLR.userData._lastT = performance.now();
    }

    /* === Animación de 'time' para RawShader (como el demo) ================== */
    (function installKeplrRawTimer(){
      if (window.__keplrRawTimerInstalled) return;
      window.__keplrRawTimerInstalled = true;

      function tick(){
        try{
          if (isKEPLR && groupKEPLR){
            const t = performance.now() * KEPLR_STRIPE_SPEED; // ← usa la constante lenta
            groupKEPLR.traverse(o=>{
              const m = o && o.material;
              if (o.isMesh && m && m.isRawShaderMaterial && m.uniforms && m.uniforms.time){
                m.uniforms.time.value = t;
              }
            });
          }
        }catch(_){ }
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    })();

    function resyncKeplrRotSteps(){
      if (!groupKEPLR || !groupKEPLR.userData || !groupKEPLR.userData.rotators) return;
      groupKEPLR.userData.rotators.forEach(g=>{
        if (g.userData && g.userData.permStr){
          const s = getBuildRotStep(g.userData.permStr);
          if (s) g.userData.rotStep = s;
        }
      });
    }

    /* Exclusivo (como RAUM/13245/R5NOVA). Usa el “crispness boost” de RAUM */
    function toggleKEPLR(){
      isKEPLR = !isKEPLR;

      if (isKEPLR){
        // Exclusividad con otros motores
        try{ if (isFRBN)   toggleFRBN();   }catch(_){ }
        try{ if (isLCHT)   toggleLCHT();   }catch(_){ }
        try{ if (isOFFNNG) toggleOFFNNG(); }catch(_){ }
        try{ if (isTMSL)   toggleTMSL();   }catch(_){ }
        try{ if (isRAUM)   toggleRAUM();   }catch(_){ }
        try{ if (is13245)  toggle13245();  }catch(_){ }
        try{ if (isR5NOVA) toggleR5NOVA(); }catch(_){ }

        leaveBuildRenderBoost();
        enterRaumRenderBoost();

        buildKEPLR();

        // Cámara nivelada, centrada (Minimal UI); yaw/pan/zoom permitidos
        camera.up.set(0,1,0);
        camera.fov = 55;
        camera.updateProjectionMatrix();

        if (controls && controls.target) controls.target.set(0, 0, 0);
        camera.position.set(0, 0, 42);

        controls.enabled            = true;
        controls.enableRotate       = true;   // solo yaw
        controls.enablePan          = true;
        controls.enableZoom         = true;
        controls.minDistance        = 10;
        controls.maxDistance        = 200;
        controls.screenSpacePanning = true;
        controls.minPolarAngle = Math.PI / 2;
        controls.maxPolarAngle = Math.PI / 2;
        controls.update();

        // Ocultar cubo/permutaciones para lectura “escultórica”
        if (typeof cubeUniverse !== 'undefined')      cubeUniverse.visible = false;
        if (typeof permutationGroup !== 'undefined')  permutationGroup.visible = false;
        if (typeof lichtGroup !== 'undefined')        lichtGroup.visible = false;

      } else {
        leaveRaumRenderBoost();
        disposeGroupKEPLR();

        // Restaurar ajustes por defecto al salir
        camera.fov = 75;
        camera.updateProjectionMatrix();
        controls.minPolarAngle      = 0;
        controls.maxPolarAngle      = Math.PI;
        controls.screenSpacePanning = false;

        if (typeof cubeUniverse !== 'undefined')      cubeUniverse.visible = true;
        if (typeof permutationGroup !== 'undefined')  permutationGroup.visible = true;
        if (typeof lichtGroup !== 'undefined' && isLCHT) lichtGroup.visible = true;
      }
    }

    /* Rebuild si hay cambios de escena */
    function rebuildKEPLRIfActive(){ if (isKEPLR) buildKEPLR(); }

    /* Botón selector – sólo enciende, nunca apaga */
    function ensureOnlyKEPLR(){ if (!isKEPLR) toggleKEPLR(); }

    // Arranque rápido desde UI alternativas
    function ensureOnlyKEPLRFromUI(){ ensureOnlyKEPLR(); updateEngineSelectUI(); }
    function rebuildKEPLRFromUI(){ rebuildKEPLRIfActive(); }

    // ── KEPLR · hook para asegurar rebuild ante cambios de patrón/mapping/perms ──
    (function KEPLRHook(){
      const run = ()=>{ try{ rebuildKEPLRIfActive(); }catch(_){ } };
      [
        'refreshAll','rebuildUniverse','buildUniverse','buildScene',
        'applyPatternFromSelect','cyclePattern','setChromaticPattern',
        'applyAttributeMapping','cycleAttributeMapping',
        'applyPermutationSet','shufflePermutations','randomizePermutationCenterClick'
      ].forEach(name=>{
        const orig = window[name];
        if (typeof orig === 'function' && !orig.__keplr_hooked){
          window[name] = function(...args){
            const res = orig.apply(this, args);
            setTimeout(run, 0);
            requestAnimationFrame(run);
            return res;
          };
          window[name].__keplr_hooked = true;
        }
      });
      window.addEventListener('resize', ()=>{ setTimeout(run,0); });
    })();

    </script>

    <script>
// ──────────────────────────────
// RAPHI · Right-Angled Parallelepipeds 1:ϕ:ϕⁿ  (hermano de KEPLR)
// n ∈ {0,1,2,3}  +  preset especial 1:1:2  + overlays (diagonales / King's Chamber)
// ──────────────────────────────

// ──────────────────────────────
// RAPHI · Exclusivo y con cierre limpio
// ──────────────────────────────
let isRAPHI    = window.isRAPHI || false;
let groupRAPHI = window.groupRAPHI || null;

function disposeGroupRAPHI(){
  if (!groupRAPHI) return;
  groupRAPHI.traverse(o=>{
    if (o.isMesh || o.isLineSegments){
      o.geometry?.dispose?.();
      o.material?.dispose?.();
    }
  });
  scene.remove(groupRAPHI);
  groupRAPHI = null;
  window.groupRAPHI = null;     // ← asegura coherencia con el animador
}

const RAPHI_PHI = (1 + Math.sqrt(5)) / 2;

// RAPHI · factor de velocidad angular (3×)
const RAPHI_SPEED_MULT = 3.0;

function raphiBuildFaceGroup(geo, colorTHREE){
  return keplrBuildFaceGroup(geo, colorTHREE);
}

// Colores como BUILD/KEPLR
function raphiFaceColor(pa, uniq){
  return keplrUniqueFaceColor(pa, uniq|0); // reusa mapeo cromático de BUILD/KEPLR
}
function raphiEdgeFromFaceColor(baseTHREE){
  return keplrEdgeFromFaceColor(baseTHREE); // contraste derivado (ya definido en KEPLR)
}

// Semilla “H” (igual que KEPLR, SOLO forma)
function raphiShapeSeedFromPerms(perms){
  return keplrShapeSeedFromPerms(perms);
}

  // Eje y velocidad para RAPHI: giro tipo “bailarina” sobre el eje Y local
  function raphiSpinParamsFor(pa, idx){
    // velocidad según “Signature Range” (misma fórmula que KEPLR)
    const vel = keplrOmegaFromSignature(pa) * RAPHI_SPEED_MULT;
    // eje fijo “de pie” (local Y)
    const axis = new THREE.Vector3(0, 1, 0);
    return { axis, vel };
  }

// Selección determinista del preset para una permutación
//  - ~1/16 de los casos: preset especial 1:1:2 (doble-cuadrado)
//  - si no: n = (r + H) % 4  →  1 : ϕ : ϕⁿ
function raphiPresetFor(pa, uniqIdx, H){
  const r = lehmerRank(pa) >>> 0;
  const specialDS = (((H ^ r) >>> 0) % 16) === 0;         // 1:1:2
  if (specialDS) return { name:'DS', n:null, dims:[1,1,2], kings:false };

  const n = (r + H + uniqIdx) % 4;
  const dims = [1, RAPHI_PHI, Math.pow(RAPHI_PHI, n)];
  const kings = (n === 2);                                 // activar Cámara del Rey en 1:ϕ:ϕ²
  return { name:`PHI${n}`, n, dims, kings };
}

// Permuta ejes de forma determinista (variedad de orientación)
// Fisher-Yates con LCG para estabilidad cross-platform
function raphiPermuteAxes(dims, seed){
  const idx=[0,1,2];
  let s = (seed>>>0) || 1;
  for (let i=idx.length-1;i>0;i--){
    s = (Math.imul(s,1664525) + 1013904223) >>> 0;
    const j = s % (i+1);
    const t = idx[i]; idx[i]=idx[j]; idx[j]=t;
  }
  return [ dims[idx[0]], dims[idx[1]], dims[idx[2]] ];
}

// Crea líneas de diagonales de cara para un paralelepípedo de tamaño sx×sy×sz
function raphiFaceDiagonals(sx, sy, sz, colorTHREE){
  const hx=sx/2, hy=sy/2, hz=sz/2;
  const P=[];
  function addRectDiag(cx,cy,cz, ux,uy,uz, vx,vy,vz){
    const A=[cx-ux-vx, cy-uy-vy, cz-uz-vz];
    const B=[cx+ux-vx, cy+uy-vy, cz-uz-vz];
    const C=[cx-ux+vx, cy-uy+vy, cz-uz+vz];
    const D=[cx+ux+vx, cy+uy+vy, cz+uz+vz];
    P.push(...A, ...D, ...B, ...C);
  }
  // seis caras
  addRectDiag(0,0, hz,  hx,0,0, 0,hy,0); // frontal
  addRectDiag(0,0,-hz,  hx,0,0, 0,hy,0); // fondo
  addRectDiag(0, hy,0,  hx,0,0, 0,0,hz); // techo
  addRectDiag(0,-hy,0,  hx,0,0, 0,0,hz); // piso
  addRectDiag( hx,0,0,  0,hy,0, 0,0,hz); // derecha
  addRectDiag(-hx,0,0,  0,hy,0,  0,0,hz); // izquierda

  const g = new THREE.BufferGeometry();
  g.setAttribute('position', new THREE.Float32BufferAttribute(P, 3));
  const mat = new THREE.LineBasicMaterial({
    color: applyBuildVibranceToColor(colorTHREE),
    transparent:true, opacity:0.85,
    depthTest:true, depthWrite:false
  });
  return new THREE.LineSegments(g, mat);
}

// Diagonal espacial (para 1:1:2 resalta √6)
function raphiSpaceDiagonal(sx, sy, sz, colorTHREE){
  const g = new THREE.BufferGeometry();
  g.setAttribute('position', new THREE.Float32BufferAttribute(
    [-sx/2,-sy/2,-sz/2,  sx/2, sy/2, sz/2], 3));
  const mat = new THREE.LineBasicMaterial({
    color: applyBuildVibranceToColor(colorTHREE),
    transparent:true, opacity:0.95, depthTest:true, depthWrite:false
  });
  return new THREE.LineSegments(g, mat);
}

// Overlay: Cámara del Rey (caja 2:1:√5/2 con su gran diagonal) centrada dentro
function raphiKingsChamberOverlay(sx, sy, sz, colorTHREE){
  const kx=2, ky=1, kz=Math.sqrt(5)/2;
  const scale = 0.92 * Math.min(sx/kx, sy/ky, sz/kz);
  const ex = kx*scale, ey = ky*scale, ez = kz*scale;
  const group = new THREE.Group();

  const edges = new THREE.LineSegments(
    new THREE.EdgesGeometry(new THREE.BoxGeometry(ex,ey,ez)),
    new THREE.LineBasicMaterial({
      color: applyBuildVibranceToColor(colorTHREE),
      transparent:true, opacity:0.92, depthTest:true, depthWrite:false
    })
  );
  const bigDiag = new THREE.LineSegments(
    (function(){
      const gg = new THREE.BufferGeometry();
      gg.setAttribute('position', new THREE.Float32BufferAttribute(
        [-ex/2,-ey/2,-ez/2,  ex/2, ey/2, ez/2], 3));
      return gg;
    })(),
    new THREE.LineBasicMaterial({
      color: applyBuildVibranceToColor(colorTHREE),
      transparent:true, opacity:0.92, depthTest:true, depthWrite:false
    })
  );

  group.add(edges, bigDiag);
  return group;
}

// RAPHI · flags visuales
const RAPHI_EDGES_ON      = false; // ← aristas apagadas por defecto
const RAPHI_DIAGONALS_ON  = false; // ← “cruces”/diagonales apagadas por defecto
const RAPHI_KINGS_OVERLAY = true;  // Cámara del Rey solo cuando n===2

// Builder principal
function buildRAPHI(){
  disposeGroupRAPHI();
  groupRAPHI = new THREE.Group();
  window.groupRAPHI = groupRAPHI; // ← el animador lo leerá desde window
  updateBackground(false);

  const container = new THREE.Group();
  groupRAPHI.userData.rotators = [];

  let perms = (typeof getSelectedPerms === 'function' ? getSelectedPerms() : []) || [];
  if (!perms.length) perms = [[1,2,3,4,5]];

  const H = raphiShapeSeedFromPerms(perms);

  perms.forEach((pa, i)=>{
    const uniq   = i;
    const preset = raphiPresetFor(pa, uniq, H);              // {name,n,dims[],kings}
    const dims0  = preset.dims.slice();
    const dims   = raphiPermuteAxes(dims0, (H ^ (lehmerRank(pa)>>>0) ^ (i*109))>>>0);

    // Escala para encajar en 30×30×30 (máx ≈ 24)
    const MAX = 24;
    const s   = MAX / Math.max(dims[0], dims[1], dims[2]);
    const sx = dims[0]*s, sy = dims[1]*s, sz = dims[2]*s;

    // Geometría del paralelepípedo
    const geo = new THREE.BoxGeometry(sx, sy, sz);

    // Colores (mismo mapeo que BUILD/KEPLR)
    const cFace = raphiFaceColor(pa, uniq);
    const cEdge = raphiEdgeFromFaceColor(cFace);

    // —— CARAS: dos pasadas (igual que KEPLR) → transparencia correcta ——
    const faceGroup = raphiBuildFaceGroup(geo, cFace); // usa MeshStandardMaterial back+front, depthWrite:false
    faceGroup.renderOrder = 0;

    // —— OPCIONAL: aristas (normalmente OFF) ——
    let edges = null;
    if (RAPHI_EDGES_ON){
      const eGeo = new THREE.EdgesGeometry(geo);
      const eMat = new THREE.LineBasicMaterial({
        color: cEdge, transparent:true, opacity:0.65, depthTest:true, depthWrite:false
      });
      edges = new THREE.LineSegments(eGeo, eMat);
      edges.renderOrder = 2;
    }

    // —— OPCIONAL: “cruces” (diagonales de cara) – APAGADAS por defecto ——
    let faceDiags = null;
    if (RAPHI_DIAGONALS_ON){
      faceDiags = raphiFaceDiagonals(sx, sy, sz, cEdge);
      faceDiags.renderOrder = 1;
    }

    // —— Overlays especiales ——
    const overlays = new THREE.Group();
    if (RAPHI_KINGS_OVERLAY && preset.kings === true){
      overlays.add(raphiKingsChamberOverlay(sx,sy,sz,cEdge));
    }
    if (preset.name === 'DS'){ // 1:1:2 → diagonal espacial (fina)
      overlays.add(raphiSpaceDiagonal(sx,sy,sz,cEdge));
    }

    // Agrupa todo (solo lo que esté ON)
    const g = new THREE.Group();
    g.add(faceGroup);
    if (edges)     g.add(edges);
    if (faceDiags) g.add(faceDiags);
    if (overlays.children.length) g.add(overlays);

    // Giro determinista (BUILD-like; fallback seguro si BUILD no está activo)
    const spin = raphiSpinParamsFor(pa, i);
    g.matrixAutoUpdate = true;                       // asegura actualización local
    g.userData.rotAxis = spin.axis;                 // eje propio
    g.userData.rotVel  = spin.vel;                  // velocidad (rad/s)

    const permStr = pa.join(',');
    g.userData.permStr = permStr;

    // Paso de giro desde BUILD si existe; si devuelve 0/NaN/undefined → usa 1
    let __s = null;
    try { __s = (typeof getBuildRotStep === 'function') ? getBuildRotStep(permStr) : null; } catch(_){ }
    g.userData.rotStep = (typeof __s === 'number') ? __s : 1;  // acepta 0 (pausa), fracciones y ±

      container.add(g);
      groupRAPHI.userData.rotators.push(g);
      // Asegura eje Y “bailarina” incluso si venías de una versión anterior
      g.userData.rotAxis = new THREE.Vector3(0, 1, 0);
    });

  groupRAPHI.add(container);
  scene.add(groupRAPHI);
  groupRAPHI.traverse(o => { o.frustumCulled = false; });

  // Marca temporal para RAF
  groupRAPHI.userData._lastT = performance.now();

  // Asegura ordenado por objeto para transparencias
  try { renderer.sortObjects = true; } catch(_){ }
}

// Hook para reconstruir ante cambios de patrón/mapping/perms (igual que KEPLR)
(function RAPHIHook(){
  const run = ()=>{ try{ rebuildRAPHIIfActive(); }catch(_){ } };
  [
    'refreshAll','rebuildUniverse','buildUniverse','buildScene',
    'applyPatternFromSelect','cyclePattern','setChromaticPattern',
    'applyAttributeMapping','cycleAttributeMapping',
    'applyPermutationSet','shufflePermutations','randomizePermutationCenterClick'
  ].forEach(name=>{
    const orig = window[name];
    if (typeof orig === 'function' && !orig.__raphi_hooked){
      window[name] = function(...args){
        const res = orig.apply(this, args);
        setTimeout(run,0);
        requestAnimationFrame(run);
        return res;
      };
      window[name].__raphi_hooked = true;
    }
  });
  window.addEventListener('resize', ()=>{ setTimeout(run,0); });
})();

// Exclusivo (como RAUM/13245/KEPLR/R5NOVA). Usa el “crispness boost” de RAUM.
function toggleRAPHI(){
  isRAPHI = !isRAPHI;
  window.isRAPHI = isRAPHI;

  if (isRAPHI){
    // exclusividad
    try{ if (isFRBN)   toggleFRBN();   }catch(_){}
    try{ if (isLCHT)   toggleLCHT();   }catch(_){}
    try{ if (isOFFNNG) toggleOFFNNG(); }catch(_){}
    try{ if (isTMSL)   toggleTMSL();   }catch(_){}
    try{ if (isRAUM)   toggleRAUM();   }catch(_){}
    try{ if (is13245)  toggle13245();  }catch(_){}
    try{ if (isR5NOVA) toggleR5NOVA(); }catch(_){}
    try{ if (isKEPLR)  toggleKEPLR();  }catch(_){}

    leaveBuildRenderBoost();
    enterRaumRenderBoost();

    buildRAPHI();
    window.isRAPHI = true;                 // redundante pero seguro
    window.groupRAPHI = groupRAPHI;        // refuerza la referencia global

    // Cámara nivelada (verticales rectas), centrada (Minimal UI), yaw/pan/zoom ON
    camera.up.set(0,1,0);
    camera.fov = 55;
    camera.updateProjectionMatrix();

    if (controls && controls.target) controls.target.set(0, 0, 0);
    camera.position.set(0, 0, 42);

    controls.enabled            = true;
    controls.enableRotate       = true;   // solo yaw (por el clamp polar)
    controls.enablePan          = true;
    controls.enableZoom         = true;
    controls.minDistance        = 10;
    controls.maxDistance        = 200;
    controls.screenSpacePanning = true;
    controls.minPolarAngle      = Math.PI / 2;
    controls.maxPolarAngle      = Math.PI / 2;
    controls.update();

    // Ocultar otros grupos “escultóricos”
    try{ if (cubeUniverse)     cubeUniverse.visible = false; }catch(_){}
    try{ if (permutationGroup) permutationGroup.visible = false; }catch(_){}
    try{ if (lichtGroup)       lichtGroup.visible = false; }catch(_){}

  } else {
    leaveRaumRenderBoost();
    disposeGroupRAPHI();
    window.isRAPHI = false;                // estado global coherente

    camera.fov = 75;
    camera.updateProjectionMatrix();
    controls.minPolarAngle      = 0;
    controls.maxPolarAngle      = Math.PI;
    controls.screenSpacePanning = false;

    try{ if (cubeUniverse)      cubeUniverse.visible = true; }catch(_){}
    try{ if (permutationGroup)  permutationGroup.visible = true; }catch(_){}
    try{ if (lichtGroup && isLCHT) lichtGroup.visible = true; }catch(_){}
  }
}

function rebuildRAPHIIfActive(){ if (isRAPHI) buildRAPHI(); }
function ensureOnlyRAPHI(){ if (!isRAPHI) toggleRAPHI(); }
function ensureOnlyRAPHIFromUI(){ ensureOnlyRAPHI(); updateEngineSelectUI(); }
    </script>

    <script>
    // ──────────────────────────────
    // R5NOVA · Proportional tiling engine (tilers-integrated)
    // (v2) · gap mínimo + cuarto tipo RAUM (sin pared del fondo)
    // ──────────────────────────────
    let isR5NOVA    = false;
    let groupR5NOVA = null;

    /* Limpieza segura */
    function disposeGroupR5NOVA(){
      if (!groupR5NOVA) return;
      groupR5NOVA.traverse(o => {
        if (o.isMesh){
          o.geometry?.dispose?.();
          o.material?.dispose?.();
        }
      });
      scene.remove(groupR5NOVA);
      groupR5NOVA = null;
    }

    /* Color determinista por celda (offset cromático opcional según tag) */
    /* Color determinista por celda — garantiza colores ÚNICOS por rectángulo (hasta 12) */
    function colorR5NFor(pa, offset = 0, uniq = 0){
      const sig  = computeSignature(pa);
      const r    = lehmerRank(pa);

      // 12 slots posibles; usamos uniq para evitar repeticiones entre rectángulos
      let slot = (r + uniq) % 12;

      let [hI, sI, vI] = PATTERNS[activePatternId](sig, sceneSeed, slot);

      // Ajustes deterministas + leve “twist” por tag SIN tocar la unicidad del hue
      sI = (sI * PHI_S) % 12;
      vI = (vI * PHI_V) % 12;
      if (offset){
        sI = (sI + (offset * 3)) % 12;
        vI = (vI + (offset * 2)) % 12;
      }

      const {h,s,v} = idxToHSV(hI, sI, vI);
      let rgb = hsvToRgb(h, s, v);
      rgb = ensureContrastRGB(rgb);

      const base = new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255);

      // Vibrance fuerte en superficies + ∆E contra fondo
      const boosted = (function applyBuildVibranceToColor(colorTHREE){
        const raw = [
          Math.round(colorTHREE.r * 255),
          Math.round(colorTHREE.g * 255),
          Math.round(colorTHREE.b * 255)
        ];
        let [hh, ss, vv] = rgbToHsv(raw[0], raw[1], raw[2]);
        // ↑ saturación y brillo de forma agresiva
        const s1 = Math.min(1, ss + 0.50 * (1 - ss));
        const v1 = Math.min(0.99, vv * 1.10 + 0.06);
        let rgb2 = hsvToRgb(hh, s1, v1);
        rgb2 = ensureContrastRGB(rgb2);
        return new THREE.Color(rgb2[0]/255, rgb2[1]/255, rgb2[2]/255);
      })(base);

      return boosted;
    }

    /* Parámetros geométricos (idénticos a RAUM) */
    const R5_W = 60, R5_H = 60, R5_D = 60, R5_G = 4;  // ancho, alto, fondo, grosor pared (pared de fondo 60×60)
    const R5_DEPTH = 0.06;       // antes: 1.50  → lámina fina tipo “hoja”
    const R5_GAP   = 0.40;       // antes: 0.20  → misma proporción con el nuevo tamaño

    /* Velocidad determinista (misma fuente que KEPLR/RAPHI) */
    function r5nOmegaFromSignature(pa){
      try { return keplrOmegaFromSignature(pa) * 1.0; } catch(_){ }
      const F = (Array.isArray(pa)?pa:[pa]).reduce((a,b)=>a+Math.abs(+b||0),0);
      return 0.30 + (F % 7) * 0.07;
    }

    /* 0=TOP,1=RIGHT,2=BOTTOM,3=LEFT (determinista) */
    function r5nHingeFor(pa, uniq, H){
      const r = (lehmerRank(pa)>>>0) ^ (H>>>7) ^ (uniq*109);
      return r % 4;
    }

    /* Sin sesgo: evita “chueco” */
    function r5nSkewZFor(pa, uniq){ return 0; }

    // —— R5NOVA · control fino del nº de volúmenes en la pared de fondo ——
    const R5N_MAX_TILES = 10;        // máximo de volúmenes a instanciar
    const R5N_MIN_CELL  = 6.0;      // tamaño mínimo de celda del BSP (menos particiones)
    const R5N_TARGETN   = [4, 8];   // objetivo de celdas del BSP (pocas piezas)
    const R5N_MERGE     = 0.60;     // probabilidad de fusionar adyacentes

    /* ——— Panel tipo KEPLR/RAPHI (dos pasadas, sin z-fighting) ———
       1) Si existen los builders de KEPLR/RAPHI, se usan directamente.
       2) Si no, fallback equivalente con dos MeshStandardMaterial (Front/Back, depthWrite:false). */
    function r5nBuildFaceGroup(geo, colorTHREE){
      try{
        if (typeof window.raphiBuildFaceGroup === 'function'){
          return window.raphiBuildFaceGroup(geo, colorTHREE);
        }
      }catch(_){ }

      try{
        if (typeof window.keplrBuildFaceGroup === 'function'){
          return window.keplrBuildFaceGroup(geo, colorTHREE);
        }
      }catch(_){ }

      // —— Fallback: dos pasadas estándar (mismo “look&feel”) ——
      const emiss = colorTHREE.clone().multiplyScalar(0.06);

      const matBack = new THREE.MeshStandardMaterial({
        color: colorTHREE,
        roughness: 0.35,
        metalness: 0.04,
        side: THREE.BackSide,
        transparent: true,
        opacity: 0.98,
        depthWrite: false,
        dithering: true,
        emissive: emiss,
        emissiveIntensity: 0.12
      });

      const matFront = new THREE.MeshStandardMaterial({
        color: colorTHREE,
        roughness: 0.35,
        metalness: 0.04,
        side: THREE.FrontSide,
        transparent: true,
        opacity: 0.98,
        depthWrite: false,
        dithering: true,
        emissive: emiss,
        emissiveIntensity: 0.12
      });

      const back  = new THREE.Mesh(geo, matBack);
      const front = new THREE.Mesh(geo, matFront);

      const g = new THREE.Group();
      g.add(back, front);
      g.renderOrder = 0; // el Rahmen quedará delante
      return g;
    }

    /* RAF animator: secuencia “una por una”, solo hacia atrás */
    (function installR5NOVAAnimator(){
      if (window.__r5novaAnimatorInstalled) return;
      window.__r5novaAnimatorInstalled = true;

      function tick(){
        try{
          if (!isR5NOVA || !groupR5NOVA){ requestAnimationFrame(tick); return; }

          const now  = performance.now();
          const last = groupR5NOVA.userData._lastT || now;
          const dt   = Math.max(0, (now - last) / 1000);
          groupR5NOVA.userData._lastT = now;

          const seq  = groupR5NOVA.userData.sequence || null;
          const list = groupR5NOVA.userData.rotators || [];

          if (seq && list.length){
            // fuerza TODAS cerradas excepto la activa
            for (let j=0;j<list.length;j++){
              if (j === seq.idx) continue;
              const p = list[j];
              if (!p || !p.userData || !p.userData.swing) continue;
              if (p.userData.swing.axis === 'X') p.rotation.x = 0;
              else                               p.rotation.y = 0;
              p.rotation.z = p.userData.swing.skewZ || 0;
            }

            const cur = list[seq.idx];
            if (cur && cur.userData && cur.userData.swing){
              const S = cur.userData.swing;          // {axis,sign,max,spdOpen,spdClose,skewZ}
              const getA = ()=> (S.axis==='X'?cur.rotation.x:cur.rotation.y);
              const setA = (v)=>{ if (S.axis==='X') cur.rotation.x=v; else cur.rotation.y=v; };
              let a = getA();

              if (seq.state === 'opening'){
                const target = S.sign * S.max;       // solo hacia atrás
                const step   = Math.sign(target-a) * Math.min(Math.abs(target-a), S.spdOpen*dt);
                a = a + step;
                setA(a);
                // ¿llegó?
                if (Math.abs(a - target) < 1e-3){
                  if (seq.holdOpen > 0){ seq.tHold = 0; seq.state = 'holdOpen'; }
                  else { seq.state = 'closing'; }
                }
              } else if (seq.state === 'holdOpen'){
                seq.tHold += dt;
                if (seq.tHold >= seq.holdOpen){ seq.state = 'closing'; }
              } else if (seq.state === 'closing'){
                const target = 0;                    // cerrar completamente
                const step   = Math.sign(target-a) * Math.min(Math.abs(target-a), S.spdClose*dt);
                a = a + step;
                setA(a);
                if (Math.abs(a - target) < 1e-3){
                  // pasa al siguiente panel
                  seq.idx = (seq.idx + 1) % list.length;
                  if (seq.holdClosed > 0){ seq.tHold = 0; seq.state = 'holdClosed'; }
                  else { seq.state = 'opening'; }
                }
              } else if (seq.state === 'holdClosed'){
                seq.tHold += dt;
                if (seq.tHold >= seq.holdClosed){ seq.state = 'opening'; }
              }
            }
          }
        }catch(_){ }
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    })();

    // ——— R5NOVA · ensamblado BSP con Füge perimetral correcta ———
    function r5novaAssembleRects(){
      // Interior visible: restamos el grosor de muros/piso/techo (R5_G)
      const INS_X0 = -R5_W/2 + R5_G;
      const INS_Y0 = -R5_H/2 + R5_G;
      const INS_W  = R5_W - 2 * R5_G;
      const INS_H  = R5_H - 2 * R5_G;

      // Margen perimetral: R5_GAP/2 por lado → Füge final = R5_GAP
      const BORDER = R5_GAP / 2;

      const bbox = {
        x: INS_X0 + BORDER,
        y: INS_Y0 + BORDER,
        w: Math.max(0.001, INS_W - 2 * BORDER),
        h: Math.max(0.001, INS_H - 2 * BORDER)
      };

      const seed = computeLayoutSeed();

      const rects = window.Tilers.assemble(bbox, null, {
        engine    : 'bsp',
        rndSeed   : seed,
        minCell   : R5N_MIN_CELL,
        ratioMin  : 0.42,
        ratioMax  : 0.58,
        targetN   : R5N_TARGETN,
        mergeProb : R5N_MERGE
      });

      // Recorte determinista: área desc → x asc → y asc, tope R5N_MAX_TILES
      return rects
        .slice()
        .sort((a, b) => {
          const dA = (b.w * b.h) - (a.w * a.h);
          if (Math.abs(dA) > 1e-9) return dA;
          if (a.x !== b.x) return a.x - b.x;
          return a.y - b.y;
        })
        .slice(0, R5N_MAX_TILES);
    }

    /* Construye la escena R5NOVA:
       - Pared izquierda, derecha, piso y techo (como RAUM, deterministas)
       - Sin pared del fondo
       - En la cara del fondo, los volúmenes del motor R5Nova (tilers) */
    function buildR5NOVA(){
      disposeGroupR5NOVA();
      groupR5NOVA = new THREE.Group();

      // Fondo FRBN animado (como GRVTY)
      updateBackground(false);   // mantiene consistencia de estados internos
      r5nUseFRBNBackdrop();      // ← muestra/actualiza el cielo FRBN

      // ====== Colores deterministas para las paredes (reusa RAUM) ======
      const colCeil  = scene.background.clone();  // techo = color de fondo
      const colFloor = raumColorFor(2);
      const colLeft  = raumColorFor(3);
      const colRight = raumColorFor(4);

      function lambertWall(cTHREE){
        return lambertRaumColor(cTHREE, 0.06, false);
      }

      // ====== PAREDES (como RAUM) ======
      const left  = new THREE.Mesh(new THREE.BoxGeometry(R5_G, R5_H, R5_D + 30), lambertWall(colLeft));
      left.position.set(-R5_W/2 + R5_G/2, 0, 0);
      const right = new THREE.Mesh(new THREE.BoxGeometry(R5_G, R5_H, R5_D + 30), lambertWall(colRight));
      right.position.set( R5_W/2 - R5_G/2, 0, 0);

      const floor = new THREE.Mesh(new THREE.BoxGeometry(R5_W, R5_G, R5_D + 30), lambertWall(colFloor));
      floor.position.set(0, -R5_H/2 + R5_G/2, 0);
      const ceil  = new THREE.Mesh(new THREE.BoxGeometry(R5_W, R5_G, R5_D + 30), lambertWall(colCeil));
      ceil.position.set(0,  R5_H/2 - R5_G/2, 0);

      groupR5NOVA.add(left, right, floor, ceil);

      // ====== PLANO DEL FONDO (sin pared): mosaico R5Nova ======

      // --- Layout determinista con tilers ---
      const rects = r5novaAssembleRects();

      // Permutaciones activas (para coloreo determinista)
      const perms = Array.from(document.getElementById('permutationList').selectedOptions)
                         .map(o => o.value.split(',').map(Number));
      const permsSafe = perms.length ? perms : [[1,2,3,4,5]]; // fallback determinista

      // Orquestación secuencial (si ya existe, déjalo igual)
      groupR5NOVA.userData.rotators = [];
      groupR5NOVA.userData.sequence = {
        idx: 0, state: 'opening', holdOpen: 0.0, holdClosed: 0.10, tHold: 0
      };

      const Hseed = computeLayoutSeed();
      const backDepth = R5_D + 30;
      const zBackEdge = -backDepth / 2;

      // Panel SIEMPRE por detrás del marco; el marco se “tira” adelante
      const Z_SETBACK      = 0.15;   // 15 mm detrás del plano del marco
      const FRAME_Z_PULL   = 0.10;   // 10 mm por delante del panel
      const zPanelPlane    = (zBackEdge + R5_DEPTH/2) - Z_SETBACK;
      const zFramePlane    = zPanelPlane + FRAME_Z_PULL;

      rects.forEach((r, i) => {
        const cx = r.x + r.w/2;
        const cy = r.y + r.h/2;

        // Tamaño del RECTÁNGULO (AUSSENKANTE del marco)
        const w = Math.max(0.001, r.w - R5_GAP);
        const h = Math.max(0.001, r.h - R5_GAP);

        // Grosor del marco y luz interior (para las barras del Rahmen)
        const tRaw = Math.min(R5_GAP * 2, Math.min(w, h) * 0.20);
        const t    = Math.max(0.001, Math.min(tRaw, w / 3, h / 3));
        const wIn  = Math.max(0.001, w - 2 * t);
        const hIn  = Math.max(0.001, h - 2 * t);

        // Colores deterministas
        const pa   = permsSafe[i % permsSafe.length];
        const offs = (function(tg){
          if (!tg) return 0; const s=String(tg);
          if (s.startsWith('euclid')) return 1;
          if (s.startsWith('beatty')) return 2;
          if (s.startsWith('subst'))  return 3;
          if (s.startsWith('bsp-merged')) return 1;
          return 0;
        })(r.tag);
        const col  = colorR5NFor(pa, offs, i);

        // ——— PANEL tipo KEPLR/RAPHI ———
        // ► Ahora llena hasta el AUSSENKANTE (w × h). EPS evita z-fighting en bisagra.
        const EPS   = 0.001;
        const geoPn = new THREE.BoxGeometry(Math.max(0.001, w - EPS), Math.max(0.001, h - EPS), R5_DEPTH);
        const panel = r5nBuildFaceGroup(geoPn, col);
        panel.renderOrder = 0;                 // siempre detrás del marco

        // Bisagra determinista en el BORDE EXTERIOR; abre HACIA AFUERA
        const hinge = r5nHingeFor(pa, i, Hseed);         // 0=TOP,1=RIGHT,2=BOTTOM,3=LEFT
        const axis  = (hinge===0||hinge===2) ? 'X' : 'Y';
        // Antes era “hacia atrás”; ahora invertimos signo para “hacia afuera”
        const sign  = (hinge===0 || hinge===3) ? +1 : -1;

        const swing = {
          axis, sign,
          max      : Math.PI/2,                            // abre hasta 90°
          spdOpen  : r5nOmegaFromSignature(pa) * 0.22,     // MUCHO más lento
          spdClose : r5nOmegaFromSignature(pa) * 0.25,
          skewZ    : r5nSkewZFor(pa, i)                    // 0 → sin “chueco”
        };

        // Pivot en el borde EXTERIOR del marco (AUSSENKANTE)
        const pivot = new THREE.Group();
        pivot.position.z = zPanelPlane;

        if (hinge === 0){         // TOP
          pivot.position.set(cx, cy + h/2, zPanelPlane);
          panel.position.set(0, -h/2, 0);
        } else if (hinge === 1){  // RIGHT
          pivot.position.set(cx + w/2, cy, zPanelPlane);
          panel.position.set(-w/2, 0, 0);
        } else if (hinge === 2){  // BOTTOM
          pivot.position.set(cx, cy - h/2, zPanelPlane);
          panel.position.set(0,  h/2, 0);
        } else {                  // LEFT
          pivot.position.set(cx - w/2, cy, zPanelPlane);
          panel.position.set( w/2, 0, 0);
        }

        // Estado inicial: TODAS CERRADAS y sin “skew”
        if (axis==='X') pivot.rotation.x = 0; else pivot.rotation.y = 0;
        pivot.rotation.z = 0;

        pivot.add(panel);
        pivot.userData.swing    = swing;
        pivot.userData.permStr  = pa.join(',');
        groupR5NOVA.add(pivot);
        groupR5NOVA.userData.rotators.push(pivot);

        // ——— RAHMEN (marco) por DELANTE (mismo diseño que ya tenías) ———
        const offsF = (offs + 6 + (5 * i) % 12) % 12;
        const colF  = colorR5NFor(pa, offsF);
        const matF  = new THREE.MeshLambertMaterial({ color: colF, dithering: true });
        matF.emissive = colF.clone();
        matF.emissiveIntensity = 0.12;

        const topGeo = new THREE.BoxGeometry(wIn, t, R5_DEPTH);
        const botGeo = new THREE.BoxGeometry(wIn, t, R5_DEPTH);
        const lefGeo = new THREE.BoxGeometry(t, hIn, R5_DEPTH);
        const rigGeo = new THREE.BoxGeometry(t, hIn, R5_DEPTH);

        const top = new THREE.Mesh(topGeo, matF); top.position.set(cx, cy + (h/2 - t/2), zFramePlane);
        const bot = new THREE.Mesh(botGeo, matF); bot.position.set(cx, cy - (h/2 - t/2), zFramePlane);
        const lef = new THREE.Mesh(lefGeo, matF); lef.position.set(cx - (w/2 - t/2), cy, zFramePlane);
        const rig = new THREE.Mesh(rigGeo, matF); rig.position.set(cx + (w/2 - t/2), cy, zFramePlane);

        top.renderOrder = bot.renderOrder = lef.renderOrder = rig.renderOrder = 20; // encima del panel
        groupR5NOVA.add(top, bot, lef, rig);
      });

      scene.add(groupR5NOVA);

      try { renderer.sortObjects = true; } catch(_){ }
      groupR5NOVA.traverse(o => { o.frustumCulled = false; });
    }

    /* Rebuild si hay cambios de escena */
    function rebuildR5NOVAIfActive(){ if (isR5NOVA) buildR5NOVA(); }

    /* Exclusivo (como RAUM/13245). Usa el “crispness boost” de RAUM. */
    function toggleR5NOVA(){
      isR5NOVA = !isR5NOVA;

      if (isR5NOVA){
        // Exclusividad con TODOS los motores (incluye GRVTY)
        try{ if (isFRBN)   toggleFRBN();   }catch(_){ }
        try{ if (isLCHT)   toggleLCHT();   }catch(_){ }
        try{ if (isOFFNNG) toggleOFFNNG(); }catch(_){ }
        try{ if (isTMSL)   toggleTMSL();   }catch(_){ }
        try{ if (isRAUM)   toggleRAUM();   }catch(_){ }
        try{ if (is13245)  toggle13245();  }catch(_){ }
        try{ if (isKEPLR)  toggleKEPLR();  }catch(_){ }
        try{ if (isRAPHI)  toggleRAPHI();  }catch(_){ }
        try{ if (isGRVTY)  toggleGRVTY();  }catch(_){ }

        leaveBuildRenderBoost();
        enterRaumRenderBoost();
        r5nUseFRBNBackdrop();      // ← activa el fondo FRBN al entrar

        buildR5NOVA();

        camera.up.set(0,1,0);
        camera.fov = 55;
        camera.updateProjectionMatrix();

        if (controls && controls.target) controls.target.set(0, 0, 0);  // ← target fijo
        camera.position.set(0, 0, 42);                                  // ← cámara fija

        controls.enabled            = true;
        controls.enableRotate       = true;
        controls.enablePan          = true;
        controls.enableZoom         = true;
        controls.minDistance        = 10;
        controls.maxDistance        = 200;
        controls.screenSpacePanning = true;
        controls.minPolarAngle      = Math.PI / 2;
        controls.maxPolarAngle      = Math.PI / 2;
        controls.update();

        try{ if (cubeUniverse)     cubeUniverse.visible = false; }catch(_){ }
        try{ if (permutationGroup) permutationGroup.visible = false; }catch(_){ }
        try{ if (lichtGroup)       lichtGroup.visible = false; }catch(_){ }

      } else {
        leaveRaumRenderBoost();
        try{ disposeGroupR5NOVA?.(); }catch(_){ }
        try{ groupR5NOVA = null; }catch(_){ }

        try{
          if (window.skySphere && !(typeof isFRBN !== 'undefined' && isFRBN)){
            window.skySphere.visible = false;  // oculta cielo FRBN si FRBN no está activo
          }
        } catch(_){ }

        camera.fov = 75;
        camera.updateProjectionMatrix();
        controls.minPolarAngle      = 0;
        controls.maxPolarAngle      = Math.PI;
        controls.screenSpacePanning = false;

        try{ if (cubeUniverse)      cubeUniverse.visible = true; }catch(_){ }
        try{ if (permutationGroup)  permutationGroup.visible = true; }catch(_){ }
        try{ if (lichtGroup && isLCHT) lichtGroup.visible = true; }catch(_){ }
      }
    }
    
    /* botón selector – sólo enciende, nunca apaga */
    function ensureOnlyR5NOVA(){
      try{ if (isFRBN)   toggleFRBN();   }catch(_){ }
      try{ if (isLCHT)   toggleLCHT();   }catch(_){ }
      try{ if (isOFFNNG) toggleOFFNNG(); }catch(_){ }
      try{ if (isTMSL)   toggleTMSL();   }catch(_){ }
      try{ if (isRAUM)   toggleRAUM();   }catch(_){ }
      try{ if (is13245)  toggle13245();  }catch(_){ }
      try{ if (isKEPLR)  toggleKEPLR();  }catch(_){ }
      try{ if (isRAPHI)  toggleRAPHI();  }catch(_){ }
      try{ if (isGRVTY)  toggleGRVTY();  }catch(_){ }  // ← **NUEVO**
      try{ if (!isR5NOVA) toggleR5NOVA(); }catch(_){ }
    }

    // Enciende SOLO FRBN
    function ensureOnlyFRBN(){
      try{ if (isLCHT)   toggleLCHT();   }catch(_){ }
      try{ if (isOFFNNG) toggleOFFNNG(); }catch(_){ }
      try{ if (isTMSL)   toggleTMSL();   }catch(_){ }
      try{ if (isRAUM)   toggleRAUM();   }catch(_){ }
      try{ if (is13245)  toggle13245();  }catch(_){ }
      try{ if (isR5NOVA) toggleR5NOVA(); }catch(_){ }
      try{ if (isKEPLR)  toggleKEPLR();  }catch(_){ }
      try{ if (isRAPHI)  toggleRAPHI();  }catch(_){ }
      try{ if (isGRVTY)  toggleGRVTY();  }catch(_){ }  // ← **NUEVO**
      try{ if (!isFRBN)  toggleFRBN();   }catch(_){ }
    }

    function ensureOnlyLCHT(){
      try{ if (isFRBN)   toggleFRBN();   }catch(_){ }
      try{ if (isOFFNNG) toggleOFFNNG(); }catch(_){ }
      try{ if (isTMSL)   toggleTMSL();   }catch(_){ }
      try{ if (isRAUM)   toggleRAUM();   }catch(_){ }
      try{ if (is13245)  toggle13245();  }catch(_){ }
      try{ if (isR5NOVA) toggleR5NOVA(); }catch(_){ }
      try{ if (isKEPLR)  toggleKEPLR();  }catch(_){ }
      try{ if (isRAPHI)  toggleRAPHI();  }catch(_){ }
      try{ if (isGRVTY)  toggleGRVTY();  }catch(_){ }  // ← **NUEVO**
      try{ if (!isLCHT)  toggleLCHT();   }catch(_){ }
    }

    function ensureOnlyTMSL(){
      try{ if (isFRBN)   toggleFRBN();   }catch(_){ }
      try{ if (isLCHT)   toggleLCHT();   }catch(_){ }
      try{ if (isOFFNNG) toggleOFFNNG(); }catch(_){ }
      try{ if (isRAUM)   toggleRAUM();   }catch(_){ }
      try{ if (is13245)  toggle13245();  }catch(_){ }
      try{ if (isR5NOVA) toggleR5NOVA(); }catch(_){ }
      try{ if (isRAPHI)  toggleRAPHI();  }catch(_){ }
      try{ if (isGRVTY)  toggleGRVTY();  }catch(_){ }  // ← **NUEVO**
      try{
        if (!isTMSL) toggleTMSL();
        if (typeof window.requestTMSLRebuild === 'function'){
          requestTMSLRebuild();
          requestAnimationFrame(requestTMSLRebuild);
        }
      }catch(_){ }
    }
    
    /* === Actualiza el menú según el motor activo === */
    function updateEngineSelectUI(){
      const sel = document.getElementById('engineSelect');
      if (!sel) return;
      let v = 'BUILD';
      if (isFRBN)        v = 'FRBN';
      else if (isLCHT)   v = 'LCHT';
      else if (isOFFNNG) v = 'OFFNNG';
      else if (isTMSL)   v = 'TMSL';
      else if (isRAUM)   v = 'RAUM';
      else if (is13245)  v = '13245';
      else if (isKEPLR)  v = 'KEPLR';
      else if (isRAPHI)  v = 'RAPHI';   // ← añadido
      else if (typeof window.isGRVTY !== 'undefined' && window.isGRVTY) v = 'GRVTY';
      else if (isR5NOVA) v = 'R5NOVA';
      sel.value = v;
    }

    /* === Cambia de motor cuando el usuario selecciona en el menú === */
    function applyEngineFromSelect(val){
      if (val === 'BUILD') { switchToBuild(); return; }
      if (val === 'FRBN')  { if (!isFRBN)  toggleFRBN();  return; }
      if (val === 'LCHT')  { if (!isLCHT)  toggleLCHT();  return; }
      if (val === 'OFFNNG'){ if (!isOFFNNG)toggleOFFNNG();return; }
      if (val === 'TMSL')  {
        if (!isTMSL) toggleTMSL();
        if (typeof window.requestTMSLRebuild === 'function'){
          requestTMSLRebuild();
          requestAnimationFrame(requestTMSLRebuild);
        }
        return;
      }
      if (val === 'RAUM')  { if (!isRAUM)  toggleRAUM();  return; }
      if (val === '13245') { if (!is13245) toggle13245(); return; }
      if (val === 'KEPLR') { if (!isKEPLR) toggleKEPLR(); return; }
      if (val === 'RAPHI') { if (!isRAPHI) toggleRAPHI(); return; }   // ← añadido
      if (val === 'GRVTY'){ if (!(typeof window.isGRVTY!=='undefined' && window.isGRVTY) && typeof window.toggleGRVTY==='function') toggleGRVTY(); return; }
      if (val === 'R5NOVA'){ if (!isR5NOVA)toggleR5NOVA();return; }
    }

    /* === Rueda de motores del botón “4” (sincroniza el menú) === */
    function cycleEngine(){
      const syncUI = () => {
        updateEngineSelectUI();
        setTimeout(updateEngineSelectUI, 0);
        requestAnimationFrame(updateEngineSelectUI);
      };

      // Orden:
      // BUILD → FRBN → LCHT → OFFNNG → TMSL → RAUM → 13245 → KEPLR → RAPHI → GRVTY → R5NOVA → BUILD

      if (isFRBN){    ensureOnlyLCHT();   syncUI(); return; }
      if (isLCHT){    ensureOnlyOFFNNG(); syncUI(); return; }
      if (isOFFNNG){  ensureOnlyTMSL();   syncUI(); return; }

      // ——— TMSL → RAUM (apagando TMSL de verdad) ———
      if (isTMSL){
        try { toggleTMSL(); } catch(_){ }          // ← apaga TMSL
        try { toggleRAUM(); } catch(_){ }          // enciende RAUM
        setTimeout(()=>{ if (!isRAUM) { try{ toggleRAUM(); }catch(_){ } } }, 0);
        requestAnimationFrame(()=>{ if (!isRAUM) { try{ toggleRAUM(); }catch(_){ } } });
        updateEngineSelectUI();
        return;
      }

      if (isRAUM){    ensureOnly13245();  syncUI(); return; }
      if (is13245){   ensureOnlyKEPLR();  syncUI(); return; }
      if (isKEPLR){   ensureOnlyRAPHI();  syncUI(); return; }
      if (isRAPHI){   ensureOnlyGRVTY();  syncUI(); return; }  // ← RAPHI → GRVTY
      if (isGRVTY){   ensureOnlyR5NOVA(); syncUI(); return; }  // ← GRVTY → R5NOVA
      if (isR5NOVA){  switchToBuild();    syncUI(); return; }

      // BUILD (o ninguno) → FRBN
      ensureOnlyFRBN();
      syncUI();
    }

    /* ──────────────────────────────────────────────────────────────
     * WHITE WALL 3D OVERLAY (con Leibung) – robusto para todos los motores
     *  Unidades = cm (tu mundo): cubo BUILD 30×30×30 ⇒ 30 unidades.
     *  Por defecto: apertura 50×50, pared 100×100, espesor 5, a 24 cm de la cámara.
     *  Siempre visible (renderOrder alto) y fija al encuadre (se actualiza por frame).
     * ───────────────────────────────────────────────────────────── */

    (function(){
      let wwRig = null;       // rig que “sigue” a la cámara
      let wwMesh = null;      // mesh del marco (pared con hueco)
      let wwDistance = 24;    // distancia desde la cámara hasta la cara exterior (cm)
      let rafId = null;

      function dispose(obj){
        if (!obj) return;
        obj.traverse(n=>{
          if (n.isMesh){
            n.geometry && n.geometry.dispose && n.geometry.dispose();
            if (Array.isArray(n.material)) n.material.forEach(m=>m && m.dispose && m.dispose());
            else n.material && n.material.dispose && n.material.dispose();
          }
        });
        obj.parent && obj.parent.remove && obj.parent.remove(obj);
      }

      // Marco cuadrado con hueco cuadrado y EXTRUSIÓN (Leibung)
      function makeWallGeometry(openSize=50, wallSize=100, thickness=5){
        const half = wallSize * 0.5;
        const h2   = openSize * 0.5;

        const shape = new THREE.Shape();
        shape.moveTo(-half, -half);
        shape.lineTo( half, -half);
        shape.lineTo( half,  half);
        shape.lineTo(-half,  half);
        shape.lineTo(-half, -half);

        const hole = new THREE.Path();
        hole.moveTo(-h2, -h2);
        hole.lineTo( h2, -h2);
        hole.lineTo( h2,  h2);
        hole.lineTo(-h2,  h2);
        hole.lineTo(-h2, -h2);
        shape.holes.push(hole);

        const geo = new THREE.ExtrudeGeometry(shape, {
          depth: thickness,
          bevelEnabled: false,
          steps: 1,
          curveSegments: 1
        });

        // Coloca la extrusión hacia “atrás” del plano del marco
        // (cara exterior del muro queda en z=0 del mesh).
        geo.translate(0, 0, -thickness);
        geo.computeBoundingBox();
        geo.computeBoundingSphere();
        return geo;
      }

      function buildWall(openSize, wallSize, thickness, distance){
        // Limpia lo anterior
        if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
        dispose(wwRig); wwRig = null; wwMesh = null;

        wwDistance = distance;

        // Rig que copia pose de la cámara pero vive en scene (más robusto)
        wwRig = new THREE.Group();
        wwRig.matrixAutoUpdate = false;
        wwRig.frustumCulled = false;
        scene.add(wwRig);

        // Geometría + material (básico = siempre visible, sin depender de luces)
        const geo = makeWallGeometry(openSize, wallSize, thickness);
        const mat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          side: THREE.DoubleSide,
          depthTest: false,     // siempre por delante del resto
          depthWrite: false,    // no escribir en z-buffer
          transparent: false
        });

        wwMesh = new THREE.Mesh(geo, mat);
        wwMesh.renderOrder = 100000;  // dibuja al final
        wwMesh.frustumCulled = false;

        // La cara exterior del muro en z = -wwDistance respecto al rig (que coincide con la cámara)
        wwMesh.position.set(0, 0, -wwDistance);
        wwRig.add(wwMesh);

        // Tick: alinea el rig con la cámara cada frame
        (function tick(){
          try{
            // Copia posición y orientación exactas de la cámara
            wwRig.position.copy(camera.position);
            wwRig.quaternion.copy(camera.quaternion);
            wwRig.scale.set(1,1,1);
            wwRig.updateMatrix();
            wwRig.updateMatrixWorld(true);
          }catch(_){ }
          rafId = requestAnimationFrame(tick);
        })();
      }

      // API pública
      window.installWhiteWall3D = function(){
        // apertura 50×50, pared 100×100, espesor 5, a 24 cm de la cámara
        buildWall(50, 100, 5, 24);
      };

      // Cambia medidas en caliente
      window.updateWhiteWall3D = function(openSize, wallSize, thickness, distance){
        buildWall(
          Number(openSize)||10,
          Number(wallSize)||100,
          Number(thickness)||5,
          Number(distance)||1
        );
      };

      // Quitar el overlay
      window.removeWhiteWall3D = function(){
        if (rafId) { cancelAnimationFrame(rafId); rafId = null; }
        dispose(wwRig); wwRig = null; wwMesh = null;
      };
    })();

    init();
    installWhiteWall3D();   // ← crea y ancla la pared a la cámara


    /* ============================================================
     * INFORMATION PANEL — delivers the consolidated, corrected EN text
     * Title: "PRMMTN – Architecture for thought without words"
     * Ends with: "work in progress"
     * ============================================================ */

// ==== Loader ligero con caché en memoria para textos informativos ====
const __TEXT_CACHE = Object.create(null);

async function loadTextPartial(url){
  if (__TEXT_CACHE[url]) return __TEXT_CACHE[url];
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error(`HTTP ${res.status} al cargar ${url}`);
  const html = await res.text();
  __TEXT_CACHE[url] = html;
  return html;
}

// === Information (botón "Information") ===
async function showInformation(){
  try{
    const html = await loadTextPartial('./texts/information.html');
    renderInfoPanel(html);
  }catch(err){
    renderInfoPanel('<h2>Information</h2><p>Error cargando information.html</p>');
    console.error(err);
  }
}

async function showFRBNInfo(){
  try{
    const html = await loadTextPartial('./texts/frbn.html');
    renderInfoPanel(html);
  }catch(err){
    renderInfoPanel('<h2>FRBN</h2><p>Error cargando frbn.html</p>');
    console.error(err);
  }
}

    /* Minimal renderer for the panel (include once; remove if you already have it) */
    function renderInfoPanel(html){
      let panel = document.getElementById('infoPanel');
      if(!panel){
        panel = document.createElement('div');
        panel.id = 'infoPanel';
        panel.innerHTML = `
          <div id="infoContent"></div>
          <button id="infoClose">Close</button>
        `;
        document.body.appendChild(panel);
        const btn = panel.querySelector('#infoClose');
        btn.onclick = ()=>{
          const cc = document.getElementById('customCursor');
          if (cc) cc.style.display = 'block';
          panel.remove();
        };
      }
      const cc = document.getElementById('customCursor');
      if (cc) cc.style.display = 'block';
      document.getElementById('infoContent').innerHTML = html;
    }

    /* ======== CERTIFICADO DE EDICIÓN: utilidades base ======== */

    /* Ordena claves de forma determinista (objetos y arrays) */
    function sortDeep(x){
      if (Array.isArray(x)) return x.map(sortDeep);
      if (x && typeof x === 'object') {
        const out = {};
        Object.keys(x).sort().forEach(k => { out[k] = sortDeep(x[k]); });
        return out;
      }
      return x;
    }
    /* JSON canónico (minificado y con claves ordenadas) */
    function stableStringify(obj){ return JSON.stringify(sortDeep(obj)); }

    /* SHA‑256 en hex */
    async function sha256Hex(text){
      const enc = new TextEncoder().encode(text);
      const buf = await crypto.subtle.digest('SHA-256', enc);
      const bytes = Array.from(new Uint8Array(buf));
      return bytes.map(b => b.toString(16).padStart(2,'0')).join('');
    }

    /* Descarga un blob */
    function downloadBlob(filename, blob){
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    /* PNG A2 de la vista ACTUAL (sin recortar lo que ves) → Blob */
    async function renderA2ImageBlob(){
      const A2_W = 7016, A2_H = 4961;

      // backups
      const prevPixelRatio = renderer.getPixelRatio();
      const prevSize       = renderer.getSize(new THREE.Vector2());
      const prevAspect     = camera.aspect;
      const prevRt         = renderer.getRenderTarget?.() || null;
      const prevBg         = scene.background ? scene.background.clone() : null;

      const screenAspect = prevSize.x / prevSize.y;
      const a2Aspect = A2_W / A2_H;
      let renderW, renderH;
      if (screenAspect > a2Aspect) { renderW = A2_W; renderH = Math.round(A2_W / screenAspect); }
      else { renderH = A2_H; renderW = Math.round(A2_H * screenAspect); }

      renderer.setPixelRatio(1);
      renderer.setSize(renderW, renderH, false);
      camera.aspect = screenAspect;
      camera.updateProjectionMatrix();

      const rt = new THREE.WebGLRenderTarget(renderW, renderH, { depthBuffer:true, stencilBuffer:false });
      const clearHex = prevBg ? '#' + prevBg.getHexString() : '#ffffff';

      renderer.setClearColor(clearHex, 1);
      renderer.setRenderTarget(rt);
      renderer.clear(true, true, true);
      renderer.render(scene, camera);

      const pixels = new Uint8Array(renderW * renderH * 4);
      renderer.readRenderTargetPixels(rt, 0, 0, renderW, renderH, pixels);

      // canvas intermedio con flip vertical
      const tmp = document.createElement('canvas');
      tmp.width = renderW; tmp.height = renderH;
      const tctx = tmp.getContext('2d');
      const imgData = tctx.createImageData(renderW, renderH);
      const row = renderW * 4;
      for (let y = 0; y < renderH; y++) {
        const src = (renderH - 1 - y) * row;
        const dst = y * row;
        imgData.data.set(pixels.subarray(src, src + row), dst);
      }
      tctx.putImageData(imgData, 0, 0);


      // composita A2 con cubierta según modo
      const final = document.createElement('canvas');
      final.width = A2_W; final.height = A2_H;
      const fctx = final.getContext('2d');

      if (isFRBN) {
        // — FRBN: cubrir A2 (recorte centrado, sin bandas)
        const scale = Math.max(A2_W / renderW, A2_H / renderH);
        const drawW = Math.ceil(renderW * scale);
        const drawH = Math.ceil(renderH * scale);
        const offX  = Math.floor((A2_W - drawW) / 2);
        const offY  = Math.floor((A2_H - drawH) / 2);
        fctx.drawImage(tmp, offX, offY, drawW, drawH);
      } else {
        // — Modo normal: letterbox centrado
        fctx.fillStyle = clearHex; fctx.fillRect(0, 0, A2_W, A2_H);
        const offX = Math.floor((A2_W - renderW) / 2);
        const offY = Math.floor((A2_H - renderH) / 2);
        fctx.drawImage(tmp, offX, offY);
      }

      const blob = await new Promise(res => final.toBlob(res, 'image/png'));
      // restaurar
      renderer.setRenderTarget(prevRt);
      rt.dispose();
      renderer.setPixelRatio(prevPixelRatio);
      renderer.setSize(prevSize.x, prevSize.y);
      camera.aspect = prevAspect;
      camera.updateProjectionMatrix();
      if (prevBg) scene.background = prevBg;
      controls.update();

      return blob;
    }

    /* Configuración actual (mismo formato que exportEmbed) */
    function exportCurrentConfiguration(){
      const perms = Array.from(document.getElementById('permutationList').selectedOptions).map(o=>o.value);
      const mapping = { forma: attributeMapping[0], color: attributeMapping[1],
                        x: attributeMapping[2], y: attributeMapping[3], z: attributeMapping[4] };
      const colors = {}; for(let i=1;i<=5;i++){ colors[i] = document.getElementById('color'+i).value; }
      const bg   = document.getElementById('bgColor').value;
      const cube = document.getElementById('cubeColor').value;
      const view = "front";
      return { perms, mapping, colors, bg, cube, view, pattern: activePatternId, sceneSeed, S_global, frbnK: FRBN_K };
    }

    /* Hash para NFT u otros usos (lo pedía tu mintNFT) */
    async function computeConfigHash(){
      const cfg = exportCurrentConfiguration();
      const canonical = stableStringify(cfg);
      return sha256Hex(canonical);
    }

    /* ======== Acción principal: crear CERTIFICADO + JSON + PNG ======== */
    async function exportEditionCertificate(){
      try{
        showPopup("Generando certificado…",2000);

        // 1) JSON canónico + hash
        const cfg = exportCurrentConfiguration();
        const canonicalJSON = stableStringify(cfg);            // ← archivo exacto para hash
        const hashHex = await sha256Hex(canonicalJSON);

        // 2) Imagen A2
        const pngBlob = await renderA2ImageBlob();
        const pngDataURL = await new Promise(res=>{
          const r = new FileReader();
          r.onload = ()=>res(r.result);
          r.readAsDataURL(pngBlob);
        });

        // 3) Certificado HTML auto‑contenible
        const now = new Date();
        const prettyJSON = JSON.stringify(cfg, null, 2);
        const TOTAL_BUILD = 120 * 11;                 // 1,320 (no se multiplica por el tamaño del conjunto de permutaciones)
        const TOTAL_FRBN  = TOTAL_BUILD * FRBN_K;     // estados canónicos para FRBN
        const fmt = n => n.toLocaleString('en-US').replace(/,/g,'\u202f'); // separador fino

        const certHTML =
`<!doctype html>
<meta charset="utf-8">
<title>PRMMTN · Edition Certificate</title>
<style>
  body{font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin:32px; color:#111;}
  h1{font-weight:600; margin:0 0 4px;}
  h2{margin:24px 0 8px;}
  .meta{font-size:12px; color:#555; margin-bottom:24px;}
  .box{border:1px solid #ccc; padding:12px; border-radius:8px; background:#fafafa;}
  img{max-width:100%; height:auto; display:block; margin:12px 0 4px;}
  code{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;}
  details{margin-top:8px;}
  .sig{margin-top:28px; display:flex; gap:48px;}
  .sig div{border-top:1px solid #000; padding-top:6px; width:260px; text-align:center;}
</style>
<h1>PRMMTN · Edition Certificate</h1>
<div class="meta">
  <div>Date: ${now.toISOString()}</div>
  <div>Chromatic pattern: ${activePatternId}</div>
  <div>sceneSeed: ${sceneSeed} · S_global: ${S_global} · FRBN_K: ${FRBN_K}</div>
</div>

<h2>Image (A2)</h2>
<div class="box">
  <img src="${pngDataURL}" alt="PRMMTN A2 snapshot">
  <div style="font-size:12px;color:#444">Resolution: 7016×4961 px (A2 landscape)</div>
</div>

<h2>Integrity</h2>
<div class="box">
  <div>SHA‑256 (prmttn_config.json):</div>
  <div><code>${hashHex}</code></div>
  <details><summary>How to verify</summary>
    <pre>shasum -a 256 prmttn_config.json
# or
openssl dgst -sha256 prmttn_config.json</pre>
  </details>
</div>


<h2>Phenotypic scope</h2>
<div class="box">
  <ul>
    <li><b>BUILD (static):</b> 120 attribute‑mappings × 11 chromatic‑patterns = <b>${fmt(TOTAL_BUILD)}</b> deterministic visuals.</li>
    <li><b>FRBN (dynamic):</b> continuous deterministic field. For cataloging we adopt <b>K = ${FRBN_K}</b> canonical phases → <b>${fmt(TOTAL_FRBN)}</b> canonical states.</li>
  </ul>
  <p style="font-size:12px;color:#555;margin:8px 0 0;">
    Note: permutations are acquired as a <b>group</b>; the count does not multiply by the size of the group.
  </p>
</div>

<h2>Configuration (pretty view)</h2>
<div class="box">
  <details open><summary>Show JSON</summary>
    <pre>${prettyJSON.replace(/</g,"&lt;")}</pre>
  </details>
</div>

<div class="sig">
  <div>Edition signature</div>
</div>

<p style="margin-top:24px;color:#777;font-size:12px">This certificate is self‑contained (image + data). Work in progress.</p>`;
        // 4) Descargas (3 archivos + hash opcional)
        downloadBlob('PRMMTN_certificate.html', new Blob([certHTML], {type:'text/html'}));
        downloadBlob('PRMTTN_A2.png', pngBlob);
        downloadBlob('prmttn_config.json', new Blob([canonicalJSON], {type:'application/json'}));
        downloadBlob('prmttn_hash.txt', new Blob([`sha256  prmttn_config.json\n${hashHex}\n`], {type:'text/plain'}));

        showPopup("Certificado, imagen A2, JSON y hash descargados.", 3000);
      }catch(err){
        console.error(err);
        showPopup("Error generando certificado", 4000);
      }
    }

 
// ── R5NOVA · hook + watchdog para asegurar la ejecución ─────────────────────
(function R5NovaHook(){
  // 1) Detección robusta de motor activo
  const isR5Active = () => {
    const id =
      (window.activeEngineId || window.activeEngine || window.engineName || "")
      .toString().toUpperCase();
    return id.includes("R5NOVA") || window.isR5NOVA === true || window.isR5Nova === true;
  };

  // 2) Runner seguro (intenta varias rutas de scope)
  function runR5Adjust(){
    if (!isR5Active()) return;
    const fn = window.adjustR5NovaAfterBuild || (typeof adjustR5NovaAfterBuild === "function" ? adjustR5NovaAfterBuild : null);
    if (!fn) return;
    // Expón global si venimos de módulos
    if (!window.adjustR5NovaAfterBuild) window.adjustR5NovaAfterBuild = fn;
    try {
      fn();
    } catch (e) {
      console.warn("[R5NOVA] adjust error:", e);
    }
  }

  // 3) Pinchar funciones típicas de rebuild/render para llamar después
  ["refreshAll","rebuildUniverse","buildUniverse","buildScene","switchEngine","render"].forEach(name=>{
    const orig = window[name];
    if (typeof orig === "function" && !orig.__r5hooked){
      window[name] = function(...args){
        const res = orig.apply(this, args);
        // Ejecuta justo después y en el próximo frame
        setTimeout(runR5Adjust, 0);
        requestAnimationFrame(runR5Adjust);
        return res;
      };
      window[name].__r5hooked = true;
    }
  });

  // 4) Watchdog: reintenta durante ~1 seg cada vez que entras a R5NOVA
  let frames = 0;
  function tick(){
    if (isR5Active() && frames < 60){
      runR5Adjust(); frames++;
    } else if (!isR5Active()){
      frames = 0;
    }
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // 5) Reintenta tras resize (suele regenerar el layout)
  window.addEventListener("resize", ()=>{ frames = 0; });
})();
 </script>
<script>
/* ══════════════════════════════════════════════════════════════
 *  Pattern Information Panel  –  English version (11 patterns)
 *  ⇒ called from the button  <button id="patternInfoButton">
 * ═════════════════════════════════════════════════════════════ */
async function showPatternInfo(){
  try{
    const html = await loadTextPartial('./texts/pattern-info.html');
    renderInfoPanel(html);
  }catch(err){
    renderInfoPanel('<h2>Pattern Information</h2><p>Error cargando pattern-info.html</p>');
    console.error(err);
  }
}
</script>
<script>
(function(){
  // 1) Estado global si no existe
  if (typeof window.isR5NOVA === 'undefined') window.isR5NOVA = false;

  // 2) Reconstrucción segura: re-aplica los ajustes del fondo/techo cuando R5NOVA está ON
  if (typeof window.rebuildR5NOVAIfActive !== 'function') {
    window.rebuildR5NOVAIfActive = function(){
      if (!window.isR5NOVA) return;
      // cede un frame para garantizar world matrices actualizadas
      setTimeout(() => { try { adjustR5NovaAfterBuild(); } catch(e) { console.error(e); } }, 0);
      requestAnimationFrame(() => { try { adjustR5NovaAfterBuild(); } catch(e) { console.error(e); } });
    };
  }

  // 3) Arranque de R5NOVA (exclusivo frente a otros motores)
  function _enterR5NOVA(){
    // apaga motores excluyentes si están activos
    try { if (window.isFRBN)  toggleFRBN();  } catch(_){}
    try { if (window.isLCHT)  toggleLCHT();  } catch(_){}
    try { if (window.isOFFNNG)toggleOFFNNG();} catch(_){}
    try { if (window.isTMSL)  toggleTMSL();  } catch(_){}
    try { if (window.isRAUM)  toggleRAUM();  } catch(_){}
    try { if (window.is13245) toggle13245(); } catch(_){}

    window.isR5NOVA = true;

    // Mantén cubo + permutaciones visibles (R5NOVA trabaja sobre ellos)
    try { if (window.cubeUniverse)      cubeUniverse.visible = true; } catch(_){}
    try { if (window.permutationGroup)  permutationGroup.visible = true; } catch(_){}

    // Vista nivelada para R5NOVA (ya contemplada en applyStandardView)
    try { applyStandardView(); } catch(_){}

    // Fuerza reconstrucción + post-ajuste del fondo
    try { refreshAll({rebuild:true}); } catch(_){}
    window.rebuildR5NOVAIfActive();
  }

  // 4) Salida de R5NOVA → reconstruye limpio
  function _leaveR5NOVA(){
    window.isR5NOVA = false;
    try { refreshAll({rebuild:true}); } catch(_){}
    try { applyStandardView(); } catch(_){}
  }

  // 5) toggle / build públicos (solo si no existen)
  if (typeof window.toggleR5NOVA !== 'function') {
    window.toggleR5NOVA = function(){
      if (!window.isR5NOVA) _enterR5NOVA(); else _leaveR5NOVA();
    };
  }
  if (typeof window.buildR5NOVA !== 'function') {
    window.buildR5NOVA = function(){ if (!window.isR5NOVA) _enterR5NOVA(); else window.rebuildR5NOVAIfActive(); };
  }

  // 6) Hook del <select id="engineSelect"> sin romper tu lógica existente
  (function hookEngineSelect(){
    var prev = window.applyEngineFromSelect;
    window.applyEngineFromSelect = function(val){
      if (val === 'R5NOVA') {
        if (!window.isR5NOVA) window.toggleR5NOVA();
        else window.rebuildR5NOVAIfActive();
        return;
      }
      if (window.isR5NOVA) _leaveR5NOVA();
      if (typeof prev === 'function') return prev(val);
    };
  })();

// 7) Si ya estás en R5NOVA al cargar (p.ej. por querystring), sincroniza una vez
  if (window.isR5NOVA) window.rebuildR5NOVAIfActive();
})();

/* ─────────────────────────────────────────────────────────
 * TMSL patches: no black flash + room shell + camera + white core
 * ───────────────────────────────────────────────────────── */
(function patchTMSLBase(){
  // luz de cortesía (baja) sólo cuando TMSL está ON
  function ensureTMSLLighting(on){
    try{
      if (on){
        if (!window.__tmslAmbient){
          const amb = new THREE.AmbientLight(0xffffff, 0.10);
          amb.name = '__tmslAmbient';
          scene.add(amb);
          window.__tmslAmbient = amb;
        } else {
          window.__tmslAmbient.intensity = 0.10;
        }
      } else if (window.__tmslAmbient){
        scene.remove(window.__tmslAmbient);
        window.__tmslAmbient = null;
      }
    }catch(_){ }
  }

  // versión “segura” que NO fuerza fondo negro
  window.ensureBaseVisibilityForTMSL = function(){
    try{ if (window.cubeUniverse)     cubeUniverse.visible = true; }catch(_){ }
    try{ if (window.permutationGroup) permutationGroup.visible = true; }catch(_){ }
    try{ renderer.autoClear = true; }catch(_){ }
    ensureTMSLLighting(true);
    if (typeof window.applyTMSLSafeCamera === 'function') window.applyTMSLSafeCamera();
  };

  // 3) Alejar un poco la cámara en la vista default
  window.applyTMSLSafeCamera = function(){
    try{
      camera.up.set(0,1,0);
      camera.fov  = 40;   // ← más “normal” (menos gran angular)
      camera.near = 0.1;
      camera.far  = 2000;
      camera.updateProjectionMatrix();

      if (controls && controls.target) controls.target.set(0, 0, 0);
      // distancia natural para ver la pared completa con margen
      camera.position.set(0, 0, 56);

      if (controls){
        controls.enabled = true;
        controls.enableRotate = true;
        controls.enablePan    = true;
        controls.enableZoom   = true;
        controls.minPolarAngle = 0;
        controls.maxPolarAngle = Math.PI;
        controls.update();
      }
    }catch(_){ }
  };

  // 2) Piso, techo y paredes laterales para TMSL (tipo RAUM)
  //    Se crean en un grupo propio y se regeneran en cada rebuild.
  const TMSL_W = 35, TMSL_H = 35, TMSL_D = 35, TMSL_G = 2;
  function lambertWall(cTHREE){
    // reutiliza tu “look” de RAUM/BUILD
    return (typeof lambertRaumColor === 'function')
      ? lambertRaumColor(cTHREE, 0.06, false)
      : new THREE.MeshLambertMaterial({ color: cTHREE, dithering:true });
  }
  function tmslEnsureShell(){
    try{
      if (!window.isTMSL) return;

      // limpia versión anterior
      if (window.__tmslDecorGroup){
        try{ scene.remove(window.__tmslDecorGroup); }catch(_){ }
        try{
          window.__tmslDecorGroup.traverse(o=>{
            if (o.isMesh){ o.geometry?.dispose?.(); o.material?.dispose?.(); }
          });
        }catch(_){ }
        window.__tmslDecorGroup = null;
      }

      const g = new THREE.Group();

      // ——— Colores fijos en grises claros (4 tonos) ———
      const colCeil  = new THREE.Color(0xDADADA); // techo
      const colFloor = new THREE.Color(0xEDEDED); // piso
      const colLeft  = new THREE.Color(0xE7E7E7); // pared izquierda
      const colRight = new THREE.Color(0xE1E1E1); // pared derecha

      const left  = new THREE.Mesh(new THREE.BoxGeometry(TMSL_G, TMSL_H, TMSL_D + 30), lambertWall(colLeft));
      left.position.set(-TMSL_W/2 + TMSL_G/2, 0, 0);
      const right = new THREE.Mesh(new THREE.BoxGeometry(TMSL_G, TMSL_H, TMSL_D + 30), lambertWall(colRight));
      right.position.set( TMSL_W/2 - TMSL_G/2, 0, 0);

      const floor = new THREE.Mesh(new THREE.BoxGeometry(TMSL_W, TMSL_G, TMSL_D + 30), lambertWall(colFloor));
      floor.position.set(0, -TMSL_H/2 + TMSL_G/2, 0);
      const ceil  = new THREE.Mesh(new THREE.BoxGeometry(TMSL_W, TMSL_G, TMSL_D + 30), lambertWall(colCeil));
      ceil.position.set(0,  TMSL_H/2 - TMSL_G/2, 0);

      g.add(left, right, floor, ceil);
      g.traverse(o=>{ if (o.isMesh) { o.renderOrder = -10; } }); // detrás de halos/panes

      scene.add(g);
      window.__tmslDecorGroup = g;
    }catch(e){ console.warn('[TMSL] shell:', e); }
  }

  // ——— Empuja el “fondo” de TMSL hasta el borde trasero del cuarto ———
  function tmslSendBackContentToWall(){
    try{
      if (!window.isTMSL) return;
      const zBack = - (TMSL_D + 30) / 2 + 0.001;  // mismo plano que laterales/piso/techo

      // No tocar el decorado TMSL ni grupos del resto de motores
      const banned = new Set([
        window.__tmslDecorGroup, window.cubeUniverse, window.permutationGroup,
        window.lichtGroup, window.skySphere, window.groupR5NOVA, window.groupKEPLR,
        window.group13245, window.groupRAPHI, window.groupGRVTY, window.groupKEPLR
      ]);

      // Candidatos: grupos visibles con meshes, colgados de scene, distintos al decorado
      const candidates = [];
      scene.children.forEach(o=>{
        if (!o || !o.visible || banned.has(o)) return;
        if (o.isCamera || o.isLight) return;
        let hasMesh = false;
        o.traverse(n=>{ if (n.isMesh) hasMesh = true; });
        if (!hasMesh) return;
        candidates.push(o);
      });
      if (!candidates.length) return;

      // Escoge el grupo “principal” por área (aprox.)
      let best=null, bestArea=-1, bestBox=null;
      candidates.forEach(o=>{
        const box = new THREE.Box3().setFromObject(o);
        const area = Math.max(0, box.max.x-box.min.x) * Math.max(0, box.max.y-box.min.y);
        if (area > bestArea){ bestArea = area; best = o; bestBox = box; }
      });
      if (!best || !bestBox) return;

      // Desplaza para que su cara frontal trasera toque zBack
      const minZ = bestBox.min.z;
      const dz   = (zBack - minZ);
      best.position.z += dz;
      best.updateMatrixWorld(true);
    }catch(_){ }
  }

  // 4) Centro de los cubos (halos) en BLANCO puro.
  //    Fuerza uniforms/colores que parezcan “core/center”.
  function tmslForceHaloCoreWhite(){
    try{
      if (!window.isTMSL) return;
      const white = new THREE.Color(0xffffff);
      scene.traverse(o=>{
        const mats = o && o.material ? (Array.isArray(o.material) ? o.material : [o.material]) : [];
        mats.forEach(m=>{
          try{
            // Shaders
            if (m.isShaderMaterial && m.uniforms){
              Object.keys(m.uniforms).forEach(k=>{
                const u = m.uniforms[k];
                if (u && u.value && u.value.isColor && /core|center|centre/i.test(k)){
                  u.value.set(white);
                }
                // a veces el “core” va como luma/valor [0..1]
                if (u && typeof u.value === 'number' && /core|center|centre/i.test(k)){
                  m.uniforms[k].value = 1.0;
                }
              });
            }
            // Material básico con color en el centro (casos simples)
            if (m.color && /halo|sprite|quad|billboard|glow/i.test((m.name||'') + (o.name||''))){
              m.color.set(white);
            }
          }catch(_){ }
        });
      });
    }catch(_){ }
  }

  // Hook post-rebuild TMSL (añade push del fondo)
  (function hookTMSLRebuild(){
    const prev = window.rebuildTMSLIfActive;
    window.rebuildTMSLIfActive = function(){
      if (typeof prev === 'function') prev();
      const run = ()=>{ try{ tmslEnsureShell(); tmslForceHaloCoreWhite(); tmslSendBackContentToWall(); }catch(_){ } };
      setTimeout(run, 0);
      requestAnimationFrame(run);
    };
  })();

  // Si ya estás dentro de TMSL, aplica todo ahora.
  if (window.isTMSL){
    window.ensureBaseVisibilityForTMSL();
    window.rebuildTMSLIfActive();
  }
})();

// ── Limpieza TOTAL al salir de TMSL (paredes/piso/techo + luz) ──
(function installTMSLCleanupHook(){
  function tmslFullCleanup(){
    try{
      if (window.__tmslDecorGroup){
        try{
          window.__tmslDecorGroup.traverse(o=>{
            if (o.isMesh){ o.geometry?.dispose?.(); o.material?.dispose?.(); }
          });
        }catch(_){ }
        try{ scene.remove(window.__tmslDecorGroup); }catch(_){ }
        window.__tmslDecorGroup = null;
      }
    }catch(_){ }

    try{
      if (window.__tmslAmbient){
        try{ scene.remove(window.__tmslAmbient); }catch(_){ }
        window.__tmslAmbient = null;
      }
    }catch(_){ }
  }

  const prev = window.toggleTMSL;
  if (typeof prev === 'function' && !prev.__tmsl_cleanup_hooked){
    window.toggleTMSL = function(){
      const wasOn = !!window.isTMSL;
      const out = prev.apply(this, arguments);
      const nowOn = !!window.isTMSL;
      if (wasOn && !nowOn) tmslFullCleanup();  // ← al apagar TMSL, limpia todo
      return out;
    };
    window.toggleTMSL.__tmsl_cleanup_hooked = true;
  }
})();

  /* === TMSL · coalescer: 1 rebuild por frame + halo-only === */
  (function(){
    if (typeof window.isTMSL === 'undefined') window.isTMSL = false;

    // Rebuild coalescido (evita tormenta de renders)
    if (typeof window.requestTMSLRebuild !== 'function'){
      let tmslPending = false;
      window.requestTMSLRebuild = function(){
        if (!window.isTMSL || tmslPending) return;
        tmslPending = true;
        requestAnimationFrame(() => {
          tmslPending = false;
          try { if (window.isTMSL && typeof window.rebuildTMSLIfActive === 'function') window.rebuildTMSLIfActive(); } catch(e){ console.warn('[TMSL] rebuild:', e); }
        });
      };
    }

    // 2.3) Hook: reconstruir SIEMPRE la variante con halo tras acciones típicas
    (function TMSLHook(){
      const run = () => { try{ window.rebuildTMSLIfActive(); }catch(e){ console.warn('[TMSL] rebuild:', e); } };

      [
        'refreshAll','rebuildUniverse','buildUniverse','buildScene',
        'applyPatternFromSelect','cyclePattern','setChromaticPattern',
        'applyAttributeMapping','cycleAttributeMapping',
        'randomizePermutationCenterClick','applyPermutationSet','shufflePermutations'
      ].forEach(name=>{
        const orig = window[name];
        if (typeof orig === 'function' && !orig.__tmsl_hooked){
          window[name] = function(...args){
            const res = orig.apply(this, args);
            setTimeout(run, 0);
            requestAnimationFrame(run);
            return res;
          };
          window[name].__tmsl_hooked = true;
        }
      });

      window.addEventListener('resize', ()=>{ setTimeout(run,0); });
    })();
  })();

  // Rebaja la luz de cortesía para que NO queme los halos
  (function(){
    if (window.__tmslAmbient) window.__tmslAmbient.intensity = 0.10; // o 0 para desactivarla
  })();

/* ═══════════════════════════════════════════════════════════════
 * RAPHI · Animador + puente de control (BUILD ↔ RAPHI) — Hook “a prueba de orden”
 *  - Pausa/reanuda y reset para RAPHI.
 *  - Si el UI de BUILD llama a pause/reset (ahora o MÁS TARDE), RAPHI se engancha.
 *  - Respeta getBuildRotStep() (incluye 0 = pausa por-perm).
 *  - Come el tiempo en pausa para evitar saltos al reanudar.
 *  - Fallbacks: detecta “Pause motion / Reset Motion” también por eventos del DOM.
 * ═══════════════════════════════════════════════════════════════ */
(function installRAPHIAnimatorAndBridge(){
  if (window.__raphiAnimatorInstalled4) return;
  window.__raphiAnimatorInstalled4 = true;

  // ===== API pública RAPHI =====
  window.__raphiPaused = !!window.__raphiPaused;

  window.pauseRaphiMotion = function(on = true){
    window.__raphiPaused = !!on;
    try{
      const grp = window.groupRAPHI;
      if (grp && grp.userData) grp.userData._lastT = performance.now(); // come dt
    }catch(_){}
  };
  window.toggleRaphiPause = function(){ window.pauseRaphiMotion(!window.__raphiPaused); };

  window.resetRaphiMotion = function(){
    try{
      const grp = window.groupRAPHI;
      if (!grp || !grp.userData || !Array.isArray(grp.userData.rotators)) return;
      grp.userData.rotators.forEach(g=>{
        if (!g) return;
        g.rotation.set(0,0,0);
        g.updateMatrix();
        g.updateMatrixWorld(true);
      });
      grp.userData._lastT = performance.now();
    }catch(_){}
  };

  // ===== Animación (tick independiente de BUILD) =====
  function updateRaphiSpin(){
    const grp = window.groupRAPHI || (typeof groupRAPHI !== 'undefined' ? groupRAPHI : null);
    const on  = (window.isRAPHI === true) || (typeof isRAPHI !== 'undefined' && isRAPHI === true);
    if (!on || !grp || !grp.userData) return;

    const now  = performance.now();
    const last = grp.userData._lastT || now;

    // Pausa global (local RAPHI o posible flag de BUILD)
    let paused = !!window.__raphiPaused;
    try{
      if (!paused && typeof window.isBuildMotionPaused === 'function'){
        paused = !!window.isBuildMotionPaused();
      }
    }catch(_){}

    if (paused){
      grp.userData._lastT = now; // come dt mientras está parado
      return;
    }

    const dt = Math.max(0, (now - last) / 1000);
    grp.userData._lastT = now;

    const rotators = Array.isArray(grp.userData.rotators) ? grp.userData.rotators : [];
    for (let i = 0; i < rotators.length; i++){
      const g = rotators[i];
      if (!g || !g.userData) continue;

      // Paso de giro desde BUILD (acepta 0 = pausa por-perm)
      let s = null;
      if (typeof getBuildRotStep === 'function' && g.userData.permStr){
        try { s = getBuildRotStep(g.userData.permStr); } catch(_){}
      }
      if (typeof s === 'number') g.userData.rotStep = s;
      if (typeof g.userData.rotStep !== 'number') g.userData.rotStep = 1;

      const step = g.userData.rotStep;
      if (!step) continue;

      const axis = g.userData.rotAxis;
      const vel  = g.userData.rotVel;

      if (axis && typeof vel === 'number'){
        g.rotateOnAxis(axis, vel * dt * step);
        if (!g.matrixAutoUpdate) g.updateMatrix();
        g.updateMatrixWorld(true);
      }
    }
  }
  (function tick(){ try{ updateRaphiSpin(); }catch(_){ } requestAnimationFrame(tick); })();

  // ===== Hook de funciones GLOBALES con envoltorio + setter dinámico =====
  function hookGlobalFunction(name, after){
    // 1) Envoltura si ya existe
    const wrap = (fn)=> {
      if (typeof fn !== 'function' || fn.__raphi_hooked) return fn;
      const w = function(...args){
        const out = fn.apply(this, args);
        try{ after(); }catch(_){}
        return out;
      };
      w.__raphi_hooked = true;
      return w;
    };
    if (typeof window[name] === 'function') window[name] = hookGlobalFunction[name] = wrap(window[name]);

    // 2) Getter/Setter para capturar definiciones FUTURAS
    const SYM = `__raphi_prop_hook_${name}`;
    if (window[SYM]) return; // ya instalado

    let _val = window[name];
    Object.defineProperty(window, name, {
      configurable: true, enumerable: true,
      get(){ return _val; },
      set(v){
        _val = (typeof v === 'function') ? wrap(v) : v;
      }
    });
    window[SYM] = true;
  }

  // Engancha nombres típicos usados por el menú de BUILD
  // (si existen ahora o se definen más tarde, quedarán envueltos)
  hookGlobalFunction('pauseMotion',       ()=> window.toggleRaphiPause());
  hookGlobalFunction('resumeMotion',      ()=> window.pauseRaphiMotion(false));
  hookGlobalFunction('toggleMotionPause', ()=> window.toggleRaphiPause());
  hookGlobalFunction('resetMotion',       ()=> window.resetRaphiMotion());

  // Variantes comunes en algunos builds (por si tu menú usa estos nombres)
  hookGlobalFunction('pauseBuildMotion',        ()=> window.toggleRaphiPause());
  hookGlobalFunction('resumeBuildMotion',       ()=> window.pauseRaphiMotion(false));
  hookGlobalFunction('toggleBuildMotionPause',  ()=> window.toggleRaphiPause());
  hookGlobalFunction('resetBuildMotion',        ()=> window.resetRaphiMotion());

  // ===== Fallback: detectar clicks/changes en UI textual =====
  // Soporta botones o <select> con opciones “Pause motion” / “Reset Motion”
  function textOfTarget(t){
    if (!t) return '';
    if (t.tagName === 'OPTION') return (t.text || t.label || t.value || '').toString();
    if (t.options && t.selectedIndex >= 0) {
      const opt = t.options[t.selectedIndex];
      return (opt && (opt.text || opt.label || opt.value)) || (t.value || '');
    }
    return (t.innerText || t.textContent || t.value || '').toString();
  }
  function maybeBridge(txt){
    const s = (txt || '').trim();
    if (!s) return;
    if (/^pause\s*motion$/i.test(s)) { window.toggleRaphiPause(); return; }
    if (/^reset\s*motion$/i.test(s)) { window.resetRaphiMotion();  return; }
  }
  document.addEventListener('click',  (e)=>{ try{ maybeBridge(textOfTarget(e.target)); }catch(_){ } }, true);
  document.addEventListener('change', (e)=>{ try{ maybeBridge(textOfTarget(e.target)); }catch(_ ){} }, true);

})();

</script>
<script>
/* ──────────────────────────────────────────────────────────────────────────
 *  GRVTY · Gravity well (determinista, sin esfera, onda en vertex shader)
 *  - 1..2 pozos: centros, amplitudes y suavizados desde π-set + semillas
 *  - Colores deterministas (PATTERNS) + modulación por curvatura
 *  - Animación “respiración” suave (pausable / reseteable via menú BUILD)
 * ────────────────────────────────────────────────────────────────────────── */

let isGRVTY    = window.isGRVTY || false;
let groupGRVTY = window.groupGRVTY || null;

// === Fondo FRBN como “backdrop” (sin activar el motor FRBN) ===
function grvtyUseFRBNBackdrop(){
  try{
    if (typeof initSkySphere === 'function' && !window.skySphere) initSkySphere();
    if (typeof buildGanzfeld === 'function') buildGanzfeld(); // colores deterministas FRBN
    if (window.skySphere) {
      window.skySphere.visible = true;
      // Forzar que siga animando aunque FRBN no esté activo
      if (typeof animateFRBN === 'function') {
        (function tickFRBN(){
          if (window.isGRVTY && window.skySphere?.visible){
            try{ animateFRBN(); }catch(_){ }
            requestAnimationFrame(tickFRBN);
          }
        })();
      }
    }
  }catch(_){ }
}

// ——— Fondo FRBN para R5NOVA (cielo + animación) ———
function r5nUseFRBNBackdrop(){
  try{
    if (typeof initSkySphere === 'function' && !window.skySphere) initSkySphere();
    if (typeof buildGanzfeld === 'function') buildGanzfeld();
    if (window.skySphere){
      window.skySphere.visible = true;
      if (typeof animateFRBN === 'function'){
        (function tickFRBN(){
          if (window.isR5NOVA && window.skySphere?.visible){
            try{ animateFRBN(); }catch(_){ }
            requestAnimationFrame(tickFRBN);
          }
        })();
      }
    }
  }catch(_){ }
}

function disposeGroupGRVTY(){
  if (!groupGRVTY) return;
  groupGRVTY.traverse(o=>{
    if (o.isMesh || o.isLineSegments){
      o.geometry?.dispose?.();
      o.material?.dispose?.();
    }
  });
  scene.remove(groupGRVTY);
  groupGRVTY = null;
  window.groupGRVTY = null;
}

/* ====== Parámetros del plano y wells ====== */
const GRVTY_W = 360.0, GRVTY_D = 480.0;   // malla muy amplia tipo horizonte
const GRVTY_RES_DESKTOP = 360;            // más subdivisiones para ondulación suave
const GRVTY_RES_MOBILE  = 220;
/* Tope alto seguro para WebGL (sumatorio de uniforms): 64 pozos máx por draw */
const GRVTY_MAX_WELLS   = 64;

/* ====== Utilidades deterministas (reusamos tus fórmulas) ====== */
function grvtySeedFromPerms(perms){ return keplrShapeSeedFromPerms(perms); }

/* Profundidad desde rango Lehmer (0..119) → amplitud en [6, 14] */
function grvtyAmplitudeFromRank(pa){
  const r = (lehmerRank(pa) >>> 0) % 120;      // 5! = 120
  const t = r / 119.0;                         // normaliza 0..1
  const A_MIN = 6.0, A_MAX = 14.0;
  return A_MIN + t * (A_MAX - A_MIN);
}

/* Centro determinista en [-W/2+M, +W/2-M]×[-D/2+M, +D/2-M] */
function grvtyCenterFor(pa, H, margin = 6.0){
  const r = lehmerRank(pa) >>> 0;
  const u1 = (((37*r + 13*(sceneSeed|0) + (S_global|0)) % 997) / 997);
  const u2 = (((53*r + 17*(sceneSeed|0) + (S_global|0)) % 991) / 991);
  const x  = (-GRVTY_W/2 + margin) + (GRVTY_W - 2*margin) * u1;
  const z  = (-GRVTY_D/2 + margin) + (GRVTY_D - 2*margin) * u2;
  return [x, z];
}

/* Amplitud base (profundidad) desde omega (igual que KEPLR) */
function grvtyAmplitudeFor(pa){
  // ω ∈ [0.25, 1.10] rad/s → A ∈ [6, 14] (en unidades de la escena)
  const w = keplrOmegaFromSignature(pa);
  return 6.0 + (w - 0.25) * (14.0 - 6.0) / (1.10 - 0.25);
}

/* Suavizado ε (evita singularidad), determinista por r/H */
function grvtyEpsilonFor(pa, H){
  const r = lehmerRank(pa) >>> 0;
  const k = (((r ^ H) >>> 0) % 1000) / 1000;    // 0..1
  return 3.0 + k * (10.0 - 3.0);                // [3,10]
}

/* Frecuencia de “respiración” (usa la misma omega) y fase determinista */
function grvtyOmegaFor(pa){ return keplrOmegaFromSignature(pa); }
function grvtyPhaseFor(pa, H){
  const r = lehmerRank(pa) >>> 0;
  const s = Math.imul((r ^ H) >>> 0, 1103515245) + 12345;
  return ((s >>> 0) % 6283) / 1000.0;           // [0, 2π) ≈ 6.283
}

/* Paleta determinista (dos tonos) desde la primera permutación */
function grvtyColorsFromPerm(pa){
  const base  = keplrUniqueFaceColor(pa, 0);    // color “cara”
  const edgeC = keplrEdgeFromFaceColor(base);   // color contrastado
  const c1 = applyBuildVibranceToColor(base);
  const c2 = applyBuildVibranceToColor(edgeC);
  return [c1, c2];  // c1 = grid principal, c2 = mezcla por curvatura
}

/* Velocidad determinista (dirección + módulo) para cada pozo */
function grvtyVelocityFor(pa, H){
  const r = (lehmerRank(pa) >>> 0);
  const seed = (Math.imul((r ^ (H>>>0)) >>> 0, 1664525) + 1013904223) >>> 0;
  // ángulo en [0, 2π)
  const ang = ((seed & 0xFFFF) / 65535) * 6.283185307179586;
  // velocidad en unidades/seg (rango 12..36)
  const spd = 12.0 + (((seed >>> 16) & 0xFFFF) / 65535) * (36.0 - 12.0);
  return [ Math.cos(ang) * spd, Math.sin(ang) * spd ]; // [vx, vz]
}

/* ====== Shaders (grid procedural + desplazamiento) ====== */
const GRVTY_VS = `
uniform float uTime;
uniform int   uN;
uniform vec2  uC[${GRVTY_MAX_WELLS}];
uniform vec2  uV[${GRVTY_MAX_WELLS}]; // ← velocidad por pozo (x,z)
uniform float uA[${GRVTY_MAX_WELLS}];
uniform float uE[${GRVTY_MAX_WELLS}];
uniform float uW[${GRVTY_MAX_WELLS}];
uniform float uP[${GRVTY_MAX_WELLS}];
uniform float uStep;           // factor global (BUILD rot step promedio)
uniform float uBreath;         // 0..1 amplitud de respiración
uniform vec2  uHalf;           // semiejes útiles para rebote (W/2 - m, D/2 - m)

varying vec2 vUv;
varying vec3 vPos;             // pos local ya rotada a XZ
varying float vSlope;          // |∇h| aprox para coloración

float reflect1D(float x, float a, float b){
  // Movimiento tipo "rebote" en [a,b]
  float L = b - a;
  float y = mod(x - a, 2.0*L);
  return (y <= L) ? (a + y) : (a + 2.0*L - y);
}

void main(){
  vUv  = uv;
  vec3 p = position;           // geometría ya está en plano XZ (rotateX aplicado)
  float y = 0.0;
  float gx = 0.0, gz = 0.0;    // gradiente para slope
  // Tiempo de MOVIMIENTO independiente del "step" de BUILD
  float tMove = uTime;

  for (int i=0;i<${GRVTY_MAX_WELLS};i++){
    if (i >= uN) break;

    // Centro animado con rebote en rectángulo [-uHalf.x,+uHalf.x]×[-uHalf.y,+uHalf.y]
    vec2 c0 = uC[i] + uV[i] * tMove;
    float cx = reflect1D(c0.x, -uHalf.x, uHalf.x);
    float cz = reflect1D(c0.y, -uHalf.y, uHalf.y);

    vec2 d = vec2(p.x - cx, p.z - cz);
    float r2 = dot(d,d);
    float f  = sqrt(r2 + uE[i]*uE[i]);
    float A  = uA[i] * (1.0 + uBreath * sin(uW[i]*uTime*uStep + uP[i]));

    // Altura (pozo negativo)
    y += -A / f;

    // Derivadas analíticas para pendiente
    float f3 = f*f*f;
    gx +=  A * d.x / f3;
    gz +=  A * d.y / f3;
  }

  p.y += y;
  vPos = p;
  vSlope = clamp(length(vec2(gx,gz)) * 12.0, 0.0, 1.0); // escala para uso visual

  gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
}
`;

const GRVTY_FS = `
precision highp float;

uniform vec3  uCol1;          // color grid base (para líneas)
uniform vec3  uCol2;          // color por curvatura (para líneas)
uniform float uGridScale;     // densidad de líneas
uniform float uLineWidth;     // grosor relativo

// Gradiente determinista (tipo Jeff Davis)
uniform float uHueBase;       // [0,1)
uniform float uHueDriftX;     // deriva de H a lo largo de X
uniform float uHueDriftY;     // deriva de H a lo largo de Y
uniform float uSat;           // saturación
uniform float uVal;           // valor

varying vec2 vUv;
varying float vSlope;

float gridLine(float x, float scale, float width){
  float gx = fract(x*scale);
  float dx = fwidth(x*scale);
  float d  = min(gx, 1.0 - gx);
  float a  = smoothstep(width+dx, width, d);
  return a;
}

// HSV → RGB
vec3 hsv2rgb(vec3 c){
  vec3 p = abs(fract(c.xxx + vec3(0., 2./6., 4./6.)) * 6. - 3.);
  vec3 rgb = clamp(p - 1., 0., 1.);
  return c.z * mix(vec3(1.), rgb, c.y);
}

void main(){
  // LÍNEAS de grilla (como antes)
  float g1 = gridLine(vUv.x, uGridScale, uLineWidth);
  float g2 = gridLine(vUv.y, uGridScale, uLineWidth);
  float g  = max(g1, g2);

  // Color base para las líneas (mezcla por curvatura)
  vec3 base = mix(uCol1, uCol2, vSlope);
  vec3 bg   = base * 0.22;    // fondo bajo las líneas
  vec3 line = base * 0.95;    // color de las líneas

  // CENTROS: gradiente Jeff-Davis-like (suave X→Y con deriva)
  float h = fract(uHueBase + vUv.x * uHueDriftX + vUv.y * uHueDriftY);
  vec3 center = hsv2rgb(vec3(h, uSat, uVal));

  // Compositing: donde hay línea, gana "line"; si no, el gradiente de los centros
  vec3 col = mix(center, line, g);

  gl_FragColor = vec4(col, 1.0);
}
`;

/* ====== Builder principal ====== */
function buildGRVTY(){
  disposeGroupGRVTY();
  groupGRVTY = new THREE.Group();
  window.groupGRVTY = groupGRVTY;

  grvtyUseFRBNBackdrop();   // fondo como FRBN (cielo/esfera), no BUILD

  // Permutaciones activas (fallback determinista)
  let perms = (typeof getSelectedPerms === 'function' ? getSelectedPerms() : []) || [];
  if (!perms.length) perms = [[1,2,3,4,5]];
  const H = grvtySeedFromPerms(perms) >>> 0;

  // Número de pozos = número de permutaciones (clamp al tope GLSL)
  const N = Math.min(perms.length, GRVTY_MAX_WELLS);

  // Construcción de wells a partir de CADA permutación
  const wells = new Array(N);
  const vels  = new Array(N);
  for (let i=0; i<N; i++){
    const pa = perms[i];
    const [cx, cz] = grvtyCenterFor(pa, H + i*1315423911);
    const A  = grvtyAmplitudeFromRank(pa);         // ← profundidad por RANK
    const E  = grvtyEpsilonFor(pa, H + i*2654435761);
    const W  = grvtyOmegaFor(pa);
    const P  = grvtyPhaseFor(pa, H + i*374761393);
    const v  = grvtyVelocityFor(pa, H + i*41537);
    wells[i] = { cx, cz, A, E, W, P, permStr: pa.join(',') };
    vels[i]  = { vx: v[0], vz: v[1] };
  }

  // Colores deterministas para LÍNEAS (como antes)
  const [C1, C2] = grvtyColorsFromPerm(perms[0]);

  // Geometría: plano gigante tipo horizonte
  const RES = (window.devicePixelRatio > 1.25 ? GRVTY_RES_DESKTOP : GRVTY_RES_MOBILE);
  const geo = new THREE.PlaneGeometry(GRVTY_W, GRVTY_D, RES, RES);
  geo.rotateX(-Math.PI/2);

  // Uniforms (incluye gradiente tipo Jeff Davis para CENTROS)
  const hueBase   = ((H % 360) / 360.0);
  const hueDriftX = 0.18 + ((H >> 8) & 63) / 1024.0;
  const hueDriftY = 0.08 + ((H >> 16)& 63) / 1024.0;
  const sat       = 0.80 + ((H >> 24)& 31) / 160.0;
  const val       = 0.80 + ((H >> 20)& 31) / 160.0;

  // Buffers de uniforms dimensionados a GRVTY_MAX_WELLS
  const uC = new Array(GRVTY_MAX_WELLS).fill(0).map(()=> new THREE.Vector2(0,0));
  const uV = new Array(GRVTY_MAX_WELLS).fill(0).map(()=> new THREE.Vector2(0,0));
  const uA = new Float32Array(GRVTY_MAX_WELLS);
  const uE = new Float32Array(GRVTY_MAX_WELLS);
  const uW = new Float32Array(GRVTY_MAX_WELLS);
  const uP = new Float32Array(GRVTY_MAX_WELLS);

  for (let i=0; i<N; i++){
    uC[i].set(wells[i].cx, wells[i].cz);
    uV[i].set(vels[i].vx,  vels[i].vz);
    uA[i] = wells[i].A;
    uE[i] = wells[i].E;
    uW[i] = wells[i].W;
    uP[i] = wells[i].P;
  }
  // (los slots > N quedan en 0 para no afectar el shader)

  const uniforms = {
    uTime:      { value: 0.0 },
    uN:         { value: N },
    uC:         { value: uC },
    uV:         { value: uV },
    uA:         { value: uA },
    uE:         { value: uE },
    uW:         { value: uW },
    uP:         { value: uP },
    uStep:      { value: 1.0 },
    uBreath:    { value: 0.08 },
    uCol1:      { value: C1 },
    uCol2:      { value: C2 },
    uGridScale: { value: 36.0 },
    uLineWidth: { value: 0.08 },

    // Gradiente centros
    uHueBase:   { value: hueBase },
    uHueDriftX: { value: hueDriftX },
    uHueDriftY: { value: hueDriftY },
    uSat:       { value: sat },
    uVal:       { value: val },

    // Rebote dentro del plano útil (margen 6.0 usado en grvtyCenterFor)
    uHalf:      { value: new THREE.Vector2(GRVTY_W*0.5 - 6.0, GRVTY_D*0.5 - 6.0) }
  };

  const mat = new THREE.ShaderMaterial({
    uniforms,
    vertexShader:   GRVTY_VS,
    fragmentShader: GRVTY_FS,
    transparent: false,
    depthTest: true,
    depthWrite: true,
    dithering: true,
    side: THREE.DoubleSide,
    extensions: { derivatives: true }
  });

  const mesh = new THREE.Mesh(geo, mat);
  mesh.frustumCulled = false;

  // Metadata para animación/bridge
  groupGRVTY.userData._lastT = performance.now();
  groupGRVTY.userData.uniforms = uniforms;
  groupGRVTY.userData.permStrs = wells.map(w => w.permStr);
  groupGRVTY.userData.wells    = wells;

  groupGRVTY.add(mesh);
  scene.add(groupGRVTY);

  // KEPLR solids disabled in GRVTY
}

// === Un sólido KEPLR por pozo (sin superposiciones) ===
function addKeplrSolidsOverWells(wells){ /* disabled in GRVTY */ }


/* ====== Exclusivo + cámara nivelada tipo RAUM/KEPLR/RAPHI ====== */
function toggleGRVTY(){
  isGRVTY = !isGRVTY;
  window.isGRVTY = isGRVTY;

  if (isGRVTY){
    grvtyUseFRBNBackdrop();   // muestra el cielo FRBN como fondo
    try{ if (isFRBN)   toggleFRBN();   }catch(_){ }
    try{ if (isLCHT)   toggleLCHT();   }catch(_){ }
    try{ if (isOFFNNG) toggleOFFNNG(); }catch(_){ }
    try{ if (isTMSL)   toggleTMSL();   }catch(_){ }
    try{ if (isRAUM)   toggleRAUM();   }catch(_){ }
    try{ if (is13245)  toggle13245();  }catch(_){ }
    try{ if (isR5NOVA) toggleR5NOVA(); }catch(_){ }
    try{ if (isKEPLR)  toggleKEPLR();  }catch(_){ }
    try{ if (isRAPHI)  toggleRAPHI();  }catch(_){ }

    leaveBuildRenderBoost();
    enterRaumRenderBoost();

    buildGRVTY();

    // Cámara “horizonte” — AJUSTE: más cielo y sin color bajo la grilla
    camera.up.set(0,1,0);
    camera.fov  = 16;      // un pelín más cerrado: empuja el horizonte y da más cielo
    camera.near = 0.1;
    camera.far  = 4000;
    camera.updateProjectionMatrix();

    // Mira ligeramente por encima del plano para bajar la grilla en pantalla
    if (controls && controls.target) controls.target.set(0, 6, 0);

    // Coloca la cámara dentro del plano (z < GRVTY_D/2 = 240) para que el plano cubra el borde inferior
    camera.position.set(0, 6, 160);

    controls.enabled            = true;
    controls.enableRotate       = true;
    controls.enablePan          = true;
    controls.enableZoom         = true;
    // No permitimos acercarse tanto como para “salirse” por delante del borde del plano
    controls.minDistance        = 90;
    controls.maxDistance        = 600;
    controls.screenSpacePanning = true;

    // Ángulo restringido: leve inclinación hacia arriba → más cielo, grilla abajo
    controls.minPolarAngle      = Math.PI * 0.49;
    controls.maxPolarAngle      = Math.PI * 0.525;

    controls.update();

    try{ if (cubeUniverse)     cubeUniverse.visible = false; }catch(_){ }
    try{ if (permutationGroup) permutationGroup.visible = false; }catch(_){ }
    try{ if (lichtGroup)       lichtGroup.visible = false; }catch(_){ }

  } else {
    leaveRaumRenderBoost();
    disposeGroupGRVTY();
    try{
      if (window.skySphere && !(typeof isFRBN !== 'undefined' && isFRBN)){
        window.skySphere.visible = false;  // oculta el cielo FRBN si FRBN no está activo
      }
    }catch(_){ }
    window.isGRVTY = false;

    camera.fov = 75;
    camera.updateProjectionMatrix();
    controls.minPolarAngle      = 0;
    controls.maxPolarAngle      = Math.PI;
    controls.screenSpacePanning = false;

    try{ if (cubeUniverse)      cubeUniverse.visible = true; }catch(_){ }
    try{ if (permutationGroup)  permutationGroup.visible = true; }catch(_){ }
    try{ if (lichtGroup && isLCHT) lichtGroup.visible = true; }catch(_){ }
  }
}

function rebuildGRVTYIfActive(){ if (isGRVTY) buildGRVTY(); }
function ensureOnlyGRVTY(){ if (!isGRVTY) toggleGRVTY(); }
function ensureOnlyGRVTYFromUI(){ ensureOnlyGRVTY(); updateEngineSelectUI(); }

/* ====== Hooks de rebuild (igual patrón que KEPLR/RAPHI) ====== */
(function GRVTYHook(){
  const run = ()=>{ try{ rebuildGRVTYIfActive(); }catch(_){ } };
  [
    'refreshAll','rebuildUniverse','buildUniverse','buildScene',
    'applyPatternFromSelect','cyclePattern','setChromaticPattern',
    'applyAttributeMapping','cycleAttributeMapping',
    'applyPermutationSet','shufflePermutations','randomizePermutationCenterClick'
  ].forEach(name=>{
    const orig = window[name];
    if (typeof orig === 'function' && !orig.__grvty_hooked){
      window[name] = function(...args){
        const res = orig.apply(this, args);
        setTimeout(run,0);
        requestAnimationFrame(run);
        return res;
      };
      window[name].__grvty_hooked = true;
    }
  });
  window.addEventListener('resize', ()=>{ setTimeout(run,0); });
})();

/* ═══════════════ Animador + bridge (Pause/Reset del menú BUILD) ═══════════════ */
(function installGRVTYAnimatorAndBridge(){
  if (window.__grvtyAnimatorInstalled) return;
  window.__grvtyAnimatorInstalled = true;

  window.__grvtyPaused = !!window.__grvtyPaused;

  window.pauseGrvtyMotion = function(on = true){
    window.__grvtyPaused = !!on;
    try{
      const g = window.groupGRVTY;
      if (g && g.userData) g.userData._lastT = performance.now();
    }catch(_){ }
  };
  window.toggleGrvtyPause = function(){ window.pauseGrvtyMotion(!window.__grvtyPaused); };
  window.resetGrvtyMotion = function(){
    try{
      const g = window.groupGRVTY;
      if (!g || !g.userData || !g.userData.uniforms) return;
      // “Reiniciar” tiempo: simplemente resetea uTime y marca _lastT
      g.userData.uniforms.uTime.value = 0.0;
      g.userData._lastT = performance.now();
    }catch(_){ }
  };

  function avgBuildRotStepForGrvty(){
    try{
      const g = window.groupGRVTY;
      const arr = (g && g.userData && Array.isArray(g.userData.permStrs)) ? g.userData.permStrs : [];
      if (!arr.length || typeof getBuildRotStep !== 'function') return 1.0;
      let sum = 0, n = 0;
      for (let i=0;i<arr.length;i++){
        let s = getBuildRotStep(arr[i]);
        if (typeof s === 'number'){ sum += s; n++; }
      }
      if (!n) return 1.0;
      return sum / n;
    }catch(_){ return 1.0; }
  }

  function tickGrvty(){
    try{
      const on  = (window.isGRVTY === true);
      const grp = window.groupGRVTY;
      if (!on || !grp || !grp.userData || !grp.userData.uniforms){ requestAnimationFrame(tickGrvty); return; }

      // Pausa global (BUILD o local)
      let paused = !!window.__grvtyPaused;
      try{ if (!paused && typeof window.isBuildMotionPaused === 'function') paused = !!window.isBuildMotionPaused(); }catch(_){ }

      const now  = performance.now();
      const last = grp.userData._lastT || now;

      if (paused){
        grp.userData._lastT = now;
      } else {
        const dt = Math.max(0, (now - last) / 1000);
        grp.userData._lastT = now;

        const u = grp.userData.uniforms;
        u.uTime.value += dt;
        u.uStep.value  = avgBuildRotStepForGrvty(); // acepta 0 ⇒ respira congelado
      }
    }catch(_){ }
    requestAnimationFrame(tickGrvty);
  }
  requestAnimationFrame(tickGrvty);

  // Bridge con handlers del menú BUILD (si existen)
  function wrap(name, after){
    const orig = window[name];
    if (typeof orig === 'function' && !orig.__grvty_hooked){
      window[name] = function(...args){
        const out = orig.apply(this, args);
        try{ after(); }catch(_){ }
        return out;
      };
      window[name].__grvty_hooked = true;
    }
  }
  wrap('pauseMotion',        ()=> window.toggleGrvtyPause());
  wrap('resumeMotion',       ()=> window.pauseGrvtyMotion(false));
  wrap('toggleMotionPause',  ()=> window.toggleGrvtyPause());
  wrap('resetMotion',        ()=> window.resetGrvtyMotion());
})();
</script>

</body>
</html>
