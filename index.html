<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>PRMTTN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Three .js + OrbitControls (una sola vez) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <style>
  body {
    margin: 0;
    overflow: hidden;
    background: #ffffff;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-weight: 200;
    font-size: 12px;
    cursor: none;
  }
  #customCursor {
    position: fixed;
    width: 12px; height: 12px;
    border-radius: 50%;
    background: #000;
    border: 1px solid #fff;
    pointer-events: none; z-index: 300;
    transform: translate(-50%, -50%);
  }
  /* HUD eliminado */
  #topRightDisplay{
    display:none !important;
  }
  button{
    cursor:none;
    border:none;
    border-radius:4px;
    padding:8px 12px;
    font-size:12px;
    z-index:250;
    background:rgba(255,255,255,0.12);
    transition:background 0.2s;
  }
  button:hover{
    background:rgba(255,255,255,0.20);
  }

  #patternNextButton,
  #engineCycleButton,
  #permNextButton{
    position:fixed; z-index:260;                /* siempre encima */
    border:none; border-radius:4px;
    padding:8px 12px; font-size:12px;
    background:rgba(255,255,255,0.12);
    cursor:none; display:none;                  /* ocultos por defecto */
    transition:background .2s;
  }
  #patternNextButton:hover,
  #engineCycleButton:hover,
  #permNextButton:hover{
    background:rgba(255,255,255,0.20);
  }
  #patternNextButton{left:10px;  top:10px;}     /* 1 · patrón siguiente   */
  #engineCycleButton {left:10px;  bottom:10px;} /* 2 · motor siguiente     */
  #permNextButton   {right:10px; top:10px;}     /* 3 · NEXT (120 perms)    */

  /* === LAYOUT (orden y ESPACIADO nuevos) === */
  #toggleTextButton     { position:fixed; right:10px; bottom:10px;   }   /* Minimal UI */
  #aiPlanningButton     { position:fixed; right:10px; bottom:50px;   }   /* AI Planning */
  #saveImageButton      { position:fixed; right:10px; bottom:90px;  }   /* Save Image (A2) – debajo de Load JSON */
  #uploadConfigButton   { position:fixed; right:10px; bottom:130px;  }   /* Load JSON */
  #exportEmbedButton    { position:fixed; right:10px; bottom:170px;  }   /* Save JSON */
  #archDescButton       { position:fixed; right:10px; bottom:210px;  }   /* Architectural Description */
  #perm120Button        { position:fixed; right:10px; bottom:250px;  }   /* 120 Architectural Permutations */
   #certButton           { position:fixed; right:10px; bottom:30px; }   /* Edition Certificate */

  #saveImageButton { background:rgba(255,255,255,0.2); }

  /* Ocultar los no usados */
  #btnDebugColors{
    display:none !important;
  }

  #controls {
    position: absolute; top: 10px; left: 10px; z-index: 100;
    padding: 10px; border-radius: 5px;
    background: rgba(255,255,255,0.12); max-width: 350px;
  }
  details {
    margin-bottom: 10px;
    background: rgba(255,255,255,0.06);
  }
  details summary { font-weight: 200; cursor: pointer; }
  details summary:hover { color: #333; }
  select, input[type="range"], input[type="color"] { cursor: none; width: 100%; }
  #permutationList { width: 100%; height: 100px; }


  #hoverPopup {
    position:absolute; padding:5px 10px;
    background:rgba(0,0,0,0.7); color:#fff;
    border-radius:4px; pointer-events:none;
    font-size:12px; display:none; opacity:0;
    transition:opacity .3s; z-index:200;
  }


  /* Panel BUILD */
  #archPanel{
    position:fixed; z-index:1000; top:5%; left:50%;
    transform:translateX(-50%);
    width:85%; height:90%;
    background:#fff; color:#000;
    border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
    padding:24px 32px 48px; overflow:auto;
    font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size:14px; line-height:1.4;
    cursor:auto;
  }
  #archPanel *{ cursor:auto !important; }
  #archClose{
    position:fixed; right:calc(7.5% + 16px); top:5%;
    border:none; padding:6px 10px; border-radius:4px;
    background:#eee; cursor:pointer; z-index:1001;
  }
  #archPanel h2{ margin-top:0; }
  #archPanel .formula{
    margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
  }
  #archPanel .box{
    display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
    font-family:monospace;
  }
  #archPanel section{ margin-bottom:18px; }
  #archPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
  #archPanel .perm h4{ margin-bottom:6px; }
  code, pre{ font-family:monospace; }

  /* Panel 120 perms */
  #perm120Panel{
    position:fixed; right:10px; bottom:340px; z-index:260;
    background:rgba(255,255,255,0.12);
    padding:8px 10px; border-radius:4px; width:260px;
    display:none; /* ← cerrado por defecto */
  }
  #perm120Panel label{ display:block; margin-bottom:6px; }
  #perm120Panel input, #perm120Panel button{ width:100%; margin-top:4px; }
  #perm120Status{
    margin-top:8px;
    font-size:12px;       /* ← mismo tamaño que los demás */
    font-weight:normal;
    text-align:center;
  }
  /* === Information button & panel === */
  #infoButton{
    position:fixed; left:10px; bottom:10px; z-index:260;
  }
  #infoPanel{
    position:fixed; z-index:1000; top:5%; left:50%;
    transform:translateX(-50%);
    width:85%; height:90%;
    background:#fff; color:#000;
    border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
    padding:24px 32px 48px; overflow:auto;
    font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size:14px; line-height:1.45;
    cursor:auto;
  }
  #infoPanel *{ cursor:auto !important; }
  #infoClose{
    position:fixed; right:calc(7.5% + 16px); top:5%;
    border:none; padding:6px 10px; border-radius:4px;
    background:#eee; cursor:pointer; z-index:1001;
  }
  #infoPanel h2{ margin-top:0; }
  #infoPanel .formula{
    margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
  }
  #infoPanel .box{
    display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
    font-family:monospace;
  }
  #infoPanel section{ margin-bottom:18px; }
  #infoPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
  /* === ENGINE MENU (reemplaza botones sueltos) === */
  #engineSelectWrap {
    position: fixed;
    left: 10px;
    bottom: 290px;      /* ocupa el lugar que usaba OFFNNG, sin solapar PLAY/BUILD antiguos */
    z-index: 260;
    background: rgba(255,255,255,0.12);
    padding: 6px 8px;
    border-radius: 4px;
  }
  #engineSelectWrap select {
    width: 180px;       /* ancho cómodo; no usamos 100% para no romper layout */
    cursor: none;
  }
  #engineSelectWrap label {
    font-size: 12px;
    opacity: .85;
  }

  /* Botón PLAY – genera nuevas permutaciones */
  #playButton{
    position:fixed;               /* mismo estilo general */
    left:10px; bottom:170px;      /* 40 px por encima de BUILD (130 px) */
    z-index:260;
    border:none; border-radius:4px;
    padding:8px 12px;
    font-size:18px;               /* el símbolo se ve claro */
    background:rgba(0,0,0,0.12);
    cursor:none; transition:background .2s;
  }
  #playButton:hover{ background:rgba(0,0,0,0.20); }
  </style>
</head>
<body>
  <div id="customCursor"></div>
  <button id="patternNextButton" onclick="cyclePattern()">11</button>
  <button id="engineCycleButton"  onclick="cycleEngine()">4</button>
  <button id="permNextButton"     onclick="nextPerm120()">120</button>
  <div id="topRightDisplay"></div>

  <input type="file" id="json-upload" accept=".json" style="display:none;" />

  <button id="aiPlanningButton"   onclick="applyEvolutionAI()">AI Planning</button>
  <button id="toggleTextButton"   onclick="toggleTexts()">Minimal UI</button>
  <button id="uploadConfigButton" onclick="document.getElementById('json-upload').click()">Load JSON</button>
  <button id="saveImageButton"    onclick="saveImage()">Save Image (A2)</button>
  <button id="exportEmbedButton"  onclick="exportEmbed()">Save JSON</button>
  <button id="archDescButton"     onclick="showArchitecturalDescription()">Architectural Description</button>
  <!-- NUEVO: Play (genera nueva configuración) -->
  <button id="playButton" onclick="generateRandomConfigurationNoCollision()">▮</button>

  <button id="perm120Button"      onclick="togglePerm120Panel()">120 Architectural Permutations</button>

  <!-- NUEVO: Menú de motores -->
  <div id="engineSelectWrap">
    <label for="engineSelect" style="display:block;margin-bottom:4px;">Engine</label>
    <select id="engineSelect" onchange="applyEngineFromSelect(this.value)">
      <option value="BUILD">BUILD</option>
    </select>
  </div>

  <button id="certButton" onclick="exportEditionCertificate()">Edition Certificate</button>
  <button id="infoButton" onclick="showInformation()">Information</button>
  <button id="btnDebugColors"
          style="position:fixed;bottom:180px;right:10px;z-index:260;display:none;"
          onclick="mostrarDebugColores()">
    Debug Colors
  </button>

  <!-- Panel controles 120 perms -->
  <div id="perm120Panel">
    <label>Auto‑advance (1s → 12m)</label>
    <input type="range" id="perm120Slider" min="1000" max="720000" step="1000" value="5000"
           oninput="syncPerm120InputsFromSlider()">
    <input type="number" id="perm120Seconds" min="1" max="720" value="5"
           oninput="syncPerm120SliderFromSeconds()">
    <small>(seconds)</small>
    <button onclick="playPerm120()">Play</button>
    <button onclick="pausePerm120()">Pause</button>
    <button onclick="prevPerm120()">Prev</button>
    <button onclick="nextPerm120()">Next</button>
    <button onclick="showPerm120Info()">Information</button>
    <div id="perm120Status">Permutation: 0 / 119</div>
  </div>


  <div id="controls">
  <details open>
    <summary>Chromatic Pattern</summary>
          <select id="patternSelect" onchange="setActivePattern(this.value)">
        <option value="1">1 · Chromatic Containment</option>
        <option value="2">2 · Contrast &amp; Dissonance</option>
        <option value="3">3 · Non‑semantic Disposition</option>
        <option value="4">4 · Structured Ambiguity</option>
        <option value="5">5 · Chromatic Isotropy</option>
        <option value="6">6 · Self‑Sufficient Presence</option>
        <option value="7">7 · Associative Asymmetry</option>
        <option value="8">8 · Irregular Dynamics</option>
        <option value="9">9 · Habitable without Translation</option>
        <option value="10">10 · Resonance</option>
        <option value="11">11 · Active Transparency</option>
      </select>
      <button id="patternInfoButton"
              style="margin-top:6px;width:100%;"
              onclick="showPatternInfo()">
        Pattern Information
      </button>

  </details>

  <div id="manualControls">
    <details>
      <summary>Select Permutations</summary>
      <select id="permutationList" multiple></select>
      <button onclick="refreshAll({rebuild:true})">Render</button>
    </details>
  </div>


  <details>
    <summary>Manual Colors (override)</summary>
    <div><label>1: <input type="color" id="color1" onchange="onColourPick(1,this.value)"></label></div>
    <div><label>2: <input type="color" id="color2" onchange="onColourPick(2,this.value)"></label></div>
    <div><label>3: <input type="color" id="color3" onchange="onColourPick(3,this.value)"></label></div>
    <div><label>4: <input type="color" id="color4" onchange="onColourPick(4,this.value)"></label></div>
    <div><label>5: <input type="color" id="color5" onchange="onColourPick(5,this.value)"></label></div>
    <button id="btnResetAll" style="margin-top:6px;" onclick="resetAllColours()">
      Reset Background + Walls + Colors
    </button>
  </details>

  <details>
    <summary>Background</summary>
    <input type="color" id="bgColor" value="#ffffff">
    <button onclick="updateBackground()">Apply Background</button>
  </details>

  <details>
    <summary>Cube Walls Color</summary>
    <input type="color" id="cubeColor" value="#808080">
    <button onclick="updateCubeColor()">Apply Cube Walls</button>
  </details>

  <details>
    <summary>Attributes Reorganization</summary>
    <select id="attrMapping"></select>
    <button onclick="updateMapping()">Apply</button>
    <button onclick="autoResolveColisionesGlobal()">Resolve Collisions</button>
  </details>

  <details>
    <summary>Standard Views</summary>
    <select id="standardView">
      <option value="isometric">Isometric</option>
      <option value="top">Top</option>
      <option value="front" selected>Front</option>
      <option value="side">Side</option>
      <option value="diagonal">Opposite diagonal</option>
    </select>
    <button onclick="applyStandardView()">Apply View</button>
  </details>

  <details>
    <summary>Zoom Controls</summary>
    <button onclick="zoomIn()">Zoom In</button>
    <button onclick="zoomOut()">Zoom Out</button>
  </details>

  <details>
    <summary>Motion Controls</summary>
    <button onclick="togglePause()">Pause Motion</button>
    <button onclick="resetMovement()">Reset Motion</button>
  </details>
</div>


<script>
document.getElementById('json-upload').addEventListener('change', function(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const config = JSON.parse(e.target.result);

      // Permutations
      if (config.perms && Array.isArray(config.perms)) {
        const sel = document.getElementById('permutationList');
        Array.from(sel.options).forEach(o => o.selected = config.perms.includes(o.value));
      }

      // Mapping
      if (config.mapping) {
        const v = [config.mapping.forma, config.mapping.color, config.mapping.x, config.mapping.y, config.mapping.z];
        document.getElementById('attrMapping').value = v.join(',');
        attributeMapping = [v[0], v[1], v[2], v[3], v[4], attributeMapping[5], attributeMapping[6]];
      }

      // Pattern
      if (typeof config.pattern === 'number') {
        const p = Math.floor(config.pattern);
        activePatternId = (p >= 1 && p <= 11) ? p : 1;
        const selPattern = document.getElementById('patternSelect');
        if (selPattern) selPattern.value = String(activePatternId);
      }

      // Manual colors
      if (config.colors) {
        manualOverride = {};
        Object.entries(config.colors).forEach(([i, c]) => {
          manualOverride[Number(i)] = c;
        });
      }

      // BG / cube
      if (config.bg) {
        document.getElementById('bgColor').value = config.bg;
        bgOverride = config.bg;
      }
      if (config.cube) {
        document.getElementById('cubeColor').value = config.cube;
        cubeOverride = config.cube;
      }

      // Scene invariants (optional)
      if (typeof config.sceneSeed === 'number') {
        sceneSeed = config.sceneSeed;
      }
      if (typeof config.S_global === 'number') {
        S_global = config.S_global;
      }

      // View
      const view = config.view || "front";
      document.getElementById('standardView').value = view;

      // Rebuild
      refreshAll({rebuild:true, keepManual:true});
      applyStandardView();

      alert('JSON loaded successfully');
    } catch (err) {
      alert('Error loading JSON: ' + err.message);
    }
  };
  reader.readAsText(file);
});
</script>


  <div id="hoverPopup"></div>

  <!-- (eliminados: copias duplicadas de Three, OrbitControls y Ethers) -->
  <script>
    // ------------- TODO EL JS ORIGINAL (¡NO QUITES NADA DE AQUÍ!) -------------

    // === Variables globales ===
    let scene, camera, renderer, controls, raycaster, mouse;
    let cubeUniverse, permutationGroup;
    const cubeSize = 30, halfCube = cubeSize/2;

    let isPaused = false, textsVisible = true;
    let attributeMapping = [0,1,2,3,4, 0,1];   // forma,color,x,y,z,bg,wall
    let colorAttrCycle = 0;                    // ← cuenta las rotaciones de color
    let paletteRGB = [];
    let manualOverride = {1:'#ff0000',2:'#00ff00',3:'#0000ff',4:'#ff00ff',5:'#00ffff'};
    let bgOverride   = null;
    let cubeOverride = null;
    /* variables globales para fondo y paredes */
    let bgHSV = {h:0,s:0,v:1};
    let wallHSV = {h:0,s:0,v:1};
    let activePatternId = 1;           // arranca en Contención

      // >>> NUEVO:
      let S_global = 0; // término estructural para posiciones (Shift-Rank acoplado)

      /* Cambia al motor BUILD sin generar una nueva configuración */
    function switchToBuild(){
  // Garantiza “modo BUILD” sin depender de flags/toggles de otros motores
  try{ enterBuildRenderBoost(); }catch(_){}

  try{ if (cubeUniverse) cubeUniverse.visible = true; }catch(_){}
  try{ if (permutationGroup) permutationGroup.visible = true; }catch(_){}

  // Restaura la vista BUILD (respeta tu selector de “standardView”)
  try{ restoreBuildView(); }catch(_){}

  // Si existe el sistema de wall manager, asegúrate de estar en BUILD
  try{
    if (typeof window.WW_applyFor === 'function') window.WW_applyFor('BUILD');
    else if (typeof window.setWall_BUILD === 'function') window.setWall_BUILD();
  }catch(_){}

  updateEngineSelectUI();
}

    // ——— Canon para motores tipo BUILD (frontal libre)
    const BUILD_FOV = 34;
    const BUILD_Z   = 84;

    function setCamera_BUILD(){
  camera.up.set(0,1,0);
  camera.near = 0.1; camera.far = 4000;
  camera.fov  = 75;
  camera.updateProjectionMatrix();

  if (controls && controls.target) controls.target.set(0, 0, 0);
  if (controls){
    controls.enabled = true;
    controls.enableRotate = true;
    controls.enablePan    = true;
    controls.enableZoom   = true;
    controls.minPolarAngle = 0;
    controls.maxPolarAngle = Math.PI;
    controls.screenSpacePanning = false;
    controls.update();
  }
}

function restoreBuildView(){
  setCamera_BUILD();
  applyStandardView();
}

    // === BUILD render boost (solo activo en BUILD) ==============================
    let __buildBoostPrev = { pr: null, exp: null };

    function enterBuildRenderBoost(){
      if (!renderer || __buildBoostPrev.pr !== null) return;
      // Guarda para restaurar al salir de BUILD
      __buildBoostPrev.pr  = renderer.getPixelRatio();
      __buildBoostPrev.exp = renderer.toneMappingExposure;
      // Más nitidez y menos “quemado” SOLO en BUILD
      const PR = Math.min(window.devicePixelRatio || 1, 2.5);
      renderer.setPixelRatio(PR);
      renderer.toneMappingExposure = 0.90;    // baseline 0.95 → BUILD más controlado
    }

    function leaveBuildRenderBoost(){
      if (!renderer || __buildBoostPrev.pr === null) return;
      renderer.setPixelRatio(__buildBoostPrev.pr);
      renderer.toneMappingExposure = __buildBoostPrev.exp;
      __buildBoostPrev.pr = null; __buildBoostPrev.exp = null;
    }

    /* ════════════════════════════════════════════════
   CHROMA ENGINE v2 · hash → HSV lattice 144×12×12
   - determinismo absoluto
   - sin conditioner / sin contraste / sin vibrance / sin emissive
   - patrones 1..11 = llaves enteras de mezcla
   ════════════════════════════════════════════════ */

/* ═════════ CUADRÍCULA HSV 144·12·12 ═════════ */
const H_STEPS  = 144;                                   // 360° / 2.5°
const S_LEVELS = [...Array(12)].map((_,i)=>0.25 + 0.72*i/11); // 0.25 – 0.97
const V_LEVELS = [...Array(12)].map((_,i)=>0.20 + 0.75*i/11); // 0.20 – 0.95
const HSV_TOTAL   = H_STEPS * 12 * 12;                  // 20 736
const HSV_S_STRIDE = H_STEPS;                           // 144
const HSV_V_STRIDE = H_STEPS * 12;                      // 1 728

function idxToHSV(hIdx,sIdx,vIdx){
  const h = ((hIdx%H_STEPS)+H_STEPS) % H_STEPS;      // 0-143
  return {
    h: h * 360 / H_STEPS,                            // 0-359.5 °
    s: S_LEVELS[ ((sIdx%12)+12)%12 ],
    v: V_LEVELS[ ((vIdx%12)+12)%12 ]
  };
}

/* Normaliza cualquier hue a rango [0 … 360) */
function normHue(deg){
  return ((deg % 360) + 360) % 360;
}

/* HSV → RGB */
function hsvToRgb(h,s,v){
  h = ((h % 360) + 360) % 360;
  const c=v*s, x=c*(1-Math.abs((h/60)%2-1)), m=v-c;
  let r=0,g=0,b=0;
  if(h<60){r=c;g=x;}
  else if(h<120){r=x;g=c;}
  else if(h<180){g=c;b=x;}
  else if(h<240){g=x;b=c;}
  else if(h<300){r=x;b=c;}
  else {r=c;b=x;}
  return [(r+m)*255,(g+m)*255,(b+m)*255].map(v=>Math.round(v));
}

/* HSV struct → #rrggbb */
function hsvToHex({h,s,v}){
  const [r,g,b] = hsvToRgb(h,s,v);
  return '#'+new THREE.Color(r/255,g/255,b/255).getHexString();
}

/* RGB [0..255] → #rrggbb */
function rgbToHex(rgb){
  return '#'+new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255).getHexString();
}

/* ────────── Hash core (32-bit, determinista) ────────── */

/* FNV-1a 32-bit (mezcla enteros) */
function fnv1a32(h, v){
  h ^= (v >>> 0);
  return Math.imul(h, 16777619) >>> 0;
}

/* Avalancha 32-bit (finalizer) */
function avalanche32(x){
  x ^= x >>> 16;
  x = Math.imul(x, 0x7feb352d) >>> 0;
  x ^= x >>> 15;
  x = Math.imul(x, 0x846ca68b) >>> 0;
  x ^= x >>> 16;
  return x >>> 0;
}

/* Proyección uniforme: u32 → (hIdx,sIdx,vIdx) en 144×12×12 */
function hsvIdxFromU32(u){
  const t = (u % HSV_TOTAL) >>> 0;
  const hIdx = t % H_STEPS;
  const sIdx = ((t / HSV_S_STRIDE) | 0) % 12;
  const vIdx = ((t / HSV_V_STRIDE) | 0) % 12;
  return [hIdx, sIdx, vIdx];
}

/* Llaves enteras por patrón (1..11) */
const PATTERN_KEYS = {
  1:  [0x243f6a88, 0x85a308d3, 0x13198a2e],
  2:  [0x03707344, 0xa4093822, 0x299f31d0],
  3:  [0x082efa98, 0xec4e6c89, 0x452821e6],
  4:  [0x38d01377, 0xbe5466cf, 0x34e90c6c],
  5:  [0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5],
  6:  [0xb5470917, 0x9216d5d9, 0x8979fb1b],
  7:  [0xd1310ba6, 0x98dfb5ac, 0x2ffd72db],
  8:  [0xd01adfb7, 0xb8e1afed, 0x6a267e96],
  9:  [0xba7c9045, 0xf12c7f99, 0x24a19947],
  10: [0xb3916cf7, 0x0801f2e2, 0x858efc16],
  11: [0x636920d8, 0x71574e69, 0xa458fea3]
};
function getPatternKeys(patternId){
  return PATTERN_KEYS[patternId] || PATTERN_KEYS[1];
}

/* Tags para separar dominios (glifo / fondo / paredes / palette) */
const TAG_GLYPH = 0x474c5946; // 'GLYF'
const TAG_BG    = 0x42475052; // 'BGPR'
const TAG_WALL  = 0x57414c4c; // 'WALL'
const TAG_CHNL  = 0x43484e4c; // 'CHNL'

/* Hash canónico para una permutación (puede ser “escena actual” o “escena hipotética”) */
function hashPermutationCore(pa, sig, r, seedVal, sVal, patternId){
  const keys = getPatternKeys(patternId);

  let h = 0x811c9dc5;                 // offset basis FNV
  h = fnv1a32(h, seedVal | 0);
  h = fnv1a32(h, sVal    | 0);
  h = fnv1a32(h, patternId | 0);
  h = fnv1a32(h, keys[0]); h = fnv1a32(h, keys[1]); h = fnv1a32(h, keys[2]);
  h = fnv1a32(h, TAG_GLYPH);

  h = fnv1a32(h, r | 0);

  // números base de la permutación (1..5)
  for(let i=0;i<5;i++) h = fnv1a32(h, pa[i] | 0);

  // firma (f1..f5)
  for(let i=0;i<5;i++) h = fnv1a32(h, sig[i] | 0);

  return avalanche32(h);
}

/* Hash canónico para color de escena (fondo / paredes) */
function hashSceneCore(sig, slot, seedVal, sVal, patternId, tag){
  const keys = getPatternKeys(patternId);

  let h = 0x811c9dc5;
  h = fnv1a32(h, seedVal | 0);
  h = fnv1a32(h, sVal    | 0);
  h = fnv1a32(h, patternId | 0);
  h = fnv1a32(h, keys[0]); h = fnv1a32(h, keys[1]); h = fnv1a32(h, keys[2]);
  h = fnv1a32(h, tag >>> 0);
  h = fnv1a32(h, slot | 0);
  for(let i=0;i<5;i++) h = fnv1a32(h, sig[i] | 0);
  return avalanche32(h);
}

/* API canónica: color del glifo */
function colorInfoForPermutation(pa, seedVal = sceneSeed, sVal = S_global, patternId = activePatternId){
  const r = lehmerRank(pa);
  const sig = computeSignature(pa);
  const u = hashPermutationCore(pa, sig, r, seedVal, sVal, patternId);
  const [hIdx, sIdx, vIdx] = hsvIdxFromU32(u);
  const hsv = idxToHSV(hIdx, sIdx, vIdx);
  const rgb = hsvToRgb(hsv.h, hsv.s, hsv.v);
  const hex = rgbToHex(rgb);
  return { r, sig, u, hIdx, sIdx, vIdx, hsv, rgb, hex };
}
function colorForPermutation(pa){
  return colorInfoForPermutation(pa).rgb;
}

/* API canónica: color “de canal” 1..5 (para el panel manual), derivado sólo de invariantes */
function colorForChannel(channelIdx, seedVal = sceneSeed, sVal = S_global, patternId = activePatternId){
  const keys = getPatternKeys(patternId);
  let h = 0x811c9dc5;
  h = fnv1a32(h, seedVal | 0);
  h = fnv1a32(h, sVal    | 0);
  h = fnv1a32(h, patternId | 0);
  h = fnv1a32(h, keys[0]); h = fnv1a32(h, keys[1]); h = fnv1a32(h, keys[2]);
  h = fnv1a32(h, TAG_CHNL);
  h = fnv1a32(h, channelIdx | 0);
  h = avalanche32(h);
  const [hIdx, sIdx, vIdx] = hsvIdxFromU32(h);
  const hsv = idxToHSV(hIdx, sIdx, vIdx);
  return hsvToRgb(hsv.h, hsv.s, hsv.v);
}

/* API canónica: HSV del fondo/paredes */
function hsvInfoForScene(tag, sig, slot, seedVal = sceneSeed, sVal = S_global, patternId = activePatternId){
  const u = hashSceneCore(sig, slot, seedVal, sVal, patternId, tag);
  const [hIdx, sIdx, vIdx] = hsvIdxFromU32(u);
  const hsv = idxToHSV(hIdx, sIdx, vIdx);
  const rgb = hsvToRgb(hsv.h, hsv.s, hsv.v);
  const hex = rgbToHex(rgb);
  return { u, hIdx, sIdx, vIdx, hsv, rgb, hex };
}

/* ---------- FIN BLOQUE UTILIDADES ---------- */
/* ——— calcula HSV para fondo y paredes de forma acoplada al set activo ——— */
function rebuildSceneColours(){
  const perms = Array.from(document.getElementById('permutationList').selectedOptions)
    .map(o => o.value.split(',').map(Number));

  const firstSig = perms[0] ? computeSignature(perms[0]) : [0,0,0,0,0];
  const lastSig  = perms.length ? computeSignature(perms[perms.length-1]) : firstSig;

  const n = perms.length | 0;

  // Fondo y paredes: sólo invariantes + firma + slot (n / n+1)
  bgHSV   = hsvInfoForScene(TAG_BG,   firstSig, n).hsv;
  wallHSV = hsvInfoForScene(TAG_WALL, lastSig,  n+1).hsv;
}

/* ===\u2003UTIL extra — firma normalizada y contraste\u2003===================== */
// 1)  f̂  de un glifo  →  promedio firma, llevada a [0-1]
/* contrast-fix eliminado: función ensureContrast() suprimida */
    const minRangeValue = 2, maxRangeValue = 6;
    const shapeMapping = {
      1:{w:4.5,h:4.5},
      2:{w:4.5,h:4.5*Math.sqrt(2)},
      3:{w:4.5,h:4.5*Math.sqrt(3)},
      4:{w:4.5,h:4.5*Math.sqrt(4)},
      5:{w:4.5,h:4.5*Math.sqrt(5)}
    };

    function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
    function mapRangeToSpeed(r,mn,mx){return 0.001 + (r-mn)*(0.005-0.001)/(mx-mn);}
    function shuffle(a){for(let i=a.length-1;i>0;i--){let j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

    function getPermutations(arr){
      if(arr.length===1) return [arr];
      let res=[]; for(let i=0;i<arr.length;i++){
        const c=arr[i], rem=arr.slice(0,i).concat(arr.slice(i+1));
        for(const p of getPermutations(rem)) res.push([c].concat(p));
      }
      return res;
    }
    const allPermutations = getPermutations([1,2,3,4,5]);
    const permutationStrings = allPermutations.map(p=>p.join(','));

    function getAttributeMappings(a){
      if(a.length===1) return [a];
      let res=[]; for(let i=0;i<a.length;i++){
        const c=a[i], rem=a.slice(0,i).concat(a.slice(i+1));
        for(const m of getAttributeMappings(rem)) res.push([c].concat(m));
      }
      return res;
    }

    function populatePermutationList(){
      const sel = document.getElementById('permutationList');
      sel.innerHTML = '';
      permutationStrings.forEach((ps,i)=>{
        const o=document.createElement('option');
        o.value=ps; o.text=`Permutación ${i+1}: (${ps})`;
        if(i===0) o.selected=true;
        sel.appendChild(o);
      });
    }
    function populateAttributeMappingSelect(){
      const sel = document.getElementById('attrMapping');
      sel.innerHTML = '';
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        const s=m.join(','), o=document.createElement('option');
        o.value=s; o.text=`Opción: [${s}]`;
        if(s==='0,1,2,3,4') o.selected=true;
        sel.appendChild(o);
      });
      updateTopRightDisplay();
    }

    function computeSignature(a){let s=[];for(let i=0;i<a.length;i++) s.push(a[i]+a[(i+1)%a.length]);return s;}
    function computeRange(sig){return Math.max(...sig)-Math.min(...sig);}

    const FACT=[1,1,2,6,24,120];
    let sceneSeed=0;
    function lehmerRank(p){
      let r=0;
      for(let i=0;i<p.length;i++){
        let c=0;
        for(let j=i+1;j<p.length;j++) if(p[j]<p[i]) c++;
        r+=c*FACT[p.length-1-i];
      }
      return r;
    }

    /* ========= NUEVO: sceneSeed orden‑invariante + dependiente del mapping ========= */

    /** Rank del mapping [m0..m4] usando Lehmer rank sobre [m_i+1] (1..5) */
    function mappingRank(m){
      const arr = [m[0]+1, m[1]+1, m[2]+1, m[3]+1, m[4]+1];
      return lehmerRank(arr);
    }

    /** sceneSeed = (37·sumR + 101·sumR2 + 53·mRank) mod 360  (orden‑invariante) */
    function computeSceneSeedFrom(perms, m){
      let sumR = 0, sumR2 = 0;
      perms.forEach(pa=>{
        const r = lehmerRank(pa);
        sumR  += r;
        sumR2 += r*r;
      });
      const mRank = mappingRank(m);
      return (37*sumR + 101*sumR2 + 53*mRank) % 360;
    }

    /** S = ( Σ (P_{mx}+P_{my}+P_{mz}) ) mod 125  — usa los índices x,y,z del mapping */
    function computeGlobalS(perms, m){
      const mx = m[2], my = m[3], mz = m[4];
      let S = 0;
      perms.forEach(p=>{
        S += p[mx] + p[my] + p[mz];
      });
      return S % 125;
    }

    function computeShiftRankXYZ(p){
      const r = lehmerRank(p);
      const I = (r + sceneSeed + S_global) % 125;   // <<< NUEVO: acoplado a S_global
      const x = Math.floor(I/25),
            y = Math.floor((I%25)/5),
            z = I%5;
      const step = cubeSize/5;
      return [
        (x-2)*step,
        (y-2)*step,
        (z-2)*step
      ];
    }

    function getSelectedPerms(){
      return Array.from(document.getElementById('permutationList').selectedOptions)
                  .map(o => o.value.split(',').map(Number));
    }
    function setActivePattern(id){
      const p = parseInt(id, 10);
      activePatternId = (p >= 1 && p <= 11) ? p : 1;
      refreshAll({rebuild:false});
    }
    function updateTopRightDisplay(){
      // HUD desactivado (topRightDisplay está oculto por CSS)
    }

    function createPermutationObjectWithMapping(pa,map){
  const fv = pa[map[0]];
  const d  = shapeMapping[fv];
  const w  = d.w, h = d.h, t = 0.5;

  // Color canónico (hash → HSV lattice → RGB)
  const rgb = colorForPermutation(pa);

  // Posición (sin cambios)
  const [X,Y,Z] = computeShiftRankXYZ(pa);

  // Material puro (sin emissive)
  const mat = new THREE.MeshLambertMaterial({
    color: new THREE.Color(rgb[0]/255, rgb[1]/255, rgb[2]/255),
    dithering: true
  });

  const geo  = new THREE.BoxGeometry(w,h,t);
  const mesh = new THREE.Mesh(geo, mat);

  mesh.position.set(
    clamp(X,-halfCube+w/2,halfCube-w/2),
    clamp(Y,-halfCube+h/2,halfCube-h/2),
    clamp(Z,-halfCube+t/2,halfCube-t/2)
  );

  const sig = computeSignature(pa);
  const rg  = computeRange(sig);
  mesh.userData = {
    permStr: pa.join(','),
    signature: sig,
    range: rg,
    rotationSpeed: mapRangeToSpeed(rg, minRangeValue, maxRangeValue)
  };

  return mesh;
}
    function createPermutationObject(pa){ return createPermutationObjectWithMapping(pa,attributeMapping); }

    function checkCollisionsInGroup(g){
      for(let i=0;i<g.children.length;i++){
        const b1=new THREE.Box3().setFromObject(g.children[i]);
        for(let j=i+1;j<g.children.length;j++){
          const b2=new THREE.Box3().setFromObject(g.children[j]);
          if(b1.intersectsBox(b2)) return true;
        }
      }
      return false;
    }
    function autoResolveColisionesGlobal(){
      let found=null;
      getAttributeMappings([0,1,2,3,4]).forEach(m=>{
        if(found) return;
        const cm=[m[0],m[1],m[2],m[3],m[4], attributeMapping[5], attributeMapping[6]],
              tg=new THREE.Group(),
              opts=Array.from(document.getElementById('permutationList').selectedOptions);
        opts.forEach((o)=>{
          const pa=o.value.split(',').map(Number),
                mo=createPermutationObjectWithMapping(pa,cm);
          tg.add(mo);
        });
        if(!checkCollisionsInGroup(tg)) found=cm;
      });
      if(found){
        attributeMapping=found;
        document.getElementById('attrMapping').value=`${found[0]},${found[1]},${found[2]},${found[3]},${found[4]}`;
        refreshAll({rebuild:true}); updateTopRightDisplay();
      } else {
        showPopup("No se encontró reorganización sin colisiones.",7000);
      }
    }

/* ==============================
 * 120 Architectural Permutations
 * ============================== */
let perm120List = getAttributeMappings([0,1,2,3,4]); // 120
let perm120Index = 0;
let perm120Timer = null;

function togglePerm120Panel(){
  const p = document.getElementById('perm120Panel');
  const isHidden = (p.style.display === 'none' || !p.style.display);
  p.style.display = isHidden ? 'block' : 'none';

  // Re‑muestra siempre el cursor personalizado
  const cc = document.getElementById('customCursor');
  if (cc) cc.style.display = 'block';
}

function msFromUI(){
  const slider = document.getElementById('perm120Slider');
  return parseInt(slider.value, 10);
}
function syncPerm120InputsFromSlider(){
  const ms = msFromUI();
  document.getElementById('perm120Seconds').value = Math.round(ms/1000);
}
function syncPerm120SliderFromSeconds(){
  const sec = parseInt(document.getElementById('perm120Seconds').value,10) || 1;
  const clamped = Math.max(1, Math.min(720, sec));
  document.getElementById('perm120Seconds').value = clamped;
  document.getElementById('perm120Slider').value = clamped * 1000;
}

function updatePerm120Status(){
  const stat = document.getElementById('perm120Status');
  if(stat) stat.textContent = `Permutation: ${perm120Index} / 119`;
}

function applyPerm120Index(i){
  perm120Index = ((i % perm120List.length) + perm120List.length) % perm120List.length;
  const m = perm120List[perm120Index];
  attributeMapping = [m[0], m[1], m[2], m[3], m[4], attributeMapping[5], attributeMapping[6]];
  document.getElementById('attrMapping').value = m.join(',');
  refreshAll({rebuild:true});
  updatePerm120Status();
}

function nextPerm120(){ applyPerm120Index(perm120Index + 1); }
function prevPerm120(){ applyPerm120Index(perm120Index - 1); }

function playPerm120(){
  if(perm120Timer) return;
  const interval = msFromUI();
  perm120Timer = setInterval(nextPerm120, interval);
  nextPerm120();
}
function pausePerm120(){
  if(perm120Timer){
    clearInterval(perm120Timer);
    perm120Timer = null;
  }
}

async function showPerm120Info(){
  try{
    const text = await loadTextPartial('./texts/perm120-info.txt');
    alert(text);
  }catch(err){
    alert('Error cargando perm120-info.txt');
    console.error(err);
  }
}


    /* ============================================================
     *  MONTE-CARLO: buscar una escena aleatoria SIN colisiones
     *  ============================================================
     */

    /** Construye un grupo temporal con un mapping dado, sin tocar la escena real */
      const mappings = getAttributeMappings([0,1,2,3,4]);
function buildTempGroup(perms, mapping){
  const tg = new THREE.Group();

  // Guardamos estado global
  const prevSeed = sceneSeed;
  const prevS    = S_global;
  const prevMap  = attributeMapping.slice();

  // Calculamos los nuevos valores teóricos
  const tmpSeed = computeSceneSeedFrom(perms, mapping);
  const tmpS    = computeGlobalS(perms, mapping);

  // Seteamos temporalmente los globales para que createPermutationObjectWithMapping
  // use exactamente la misma lógica que la escena final:
  sceneSeed        = tmpSeed;
  S_global         = tmpS;
  attributeMapping = mapping;

  perms.forEach(pa=>{
    const mesh = createPermutationObjectWithMapping(pa, mapping);
    tg.add(mesh);
  });

  // Restauramos
  sceneSeed        = prevSeed;
  S_global         = prevS;
  attributeMapping = prevMap;

  return tg;
}

function findCollisionFreeMapping(perms){
  const mappings = getAttributeMappings([0,1,2,3,4]);
  for(const m of mappings){
    const cm = [m[0], m[1], m[2], m[3], m[4], attributeMapping[5], attributeMapping[6]];
    const tg = buildTempGroup(perms, cm);
    if(!checkCollisionsInGroup(tg)) return cm;
  }
  return null;
}
    /** Selecciona un subconjunto aleatorio de permutaciones (1..25) */
    function pickRandomPerms(){
      const n  = Math.floor(Math.random()*25) + 1;
      const out = [];
      for(let i=0;i<n;i++){
        const str = permutationStrings[Math.floor(Math.random()*permutationStrings.length)];
        out.push(str.split(',').map(Number));
      }
      return out;
    }

    /**
     * Búsqueda iterativa:
     *  - elige un set aleatorio de permutaciones
     *  - prueba todos los mappings
     *  - si alguno no choca, lo aplica y termina
     *
     * No bloquea la UI gracias al pequeño await en cada iteración.
     */
    async function generateRandomConfigurationNoCollision(MAX_TRIES = 5000){
      // Elegimos un patrón cromático aleatorio (1..11, evitando el legacy 0)
      const randPattern = Math.floor(Math.random() * 11) + 1;

      let round = 0;
      while (true) { // sigue intentando hasta que realmente encuentre una sin colisiones
        round++;
        for (let t = 0; t < MAX_TRIES; t++) {
          showPopup(`Buscando configuración sin colisiones… (ronda ${round}, intento ${t+1})`, 500);

          const perms   = pickRandomPerms();
          const mapping = findCollisionFreeMapping(perms);

          if (mapping) {
            // 1) Setea el patrón cromático escogido
            activePatternId = randPattern;
            const selPattern = document.getElementById('patternSelect');
            if (selPattern) selPattern.value = String(randPattern);

            // 2) Pon las permutaciones en el <select>
            const sel = document.getElementById('permutationList');
            Array.from(sel.options).forEach(o => o.selected = false);
            perms.forEach(p=>{
              const val = p.join(',');
              const opt = sel.querySelector(`option[value="${val}"]`);
              if(opt) opt.selected = true;
            });

            // 3) Aplica el mapping encontrado
            attributeMapping = mapping;

            // mantenemos tu ciclo de atributo "color"
            attributeMapping[1] = colorAttrCycle % 5;
            colorAttrCycle++;

            document.getElementById('attrMapping').value =
              `${attributeMapping[0]},${attributeMapping[1]},${attributeMapping[2]},${attributeMapping[3]},${attributeMapping[4]}`;

            // 4) Reconstruye escena completa
            refreshAll({rebuild:true});

            // 5) Verificación final (por si acaso)
            const hasCol = checkCollisionsInGroup(permutationGroup);
            if (!hasCol) {
              /*  ▸ YA NO se desactiva el motor actual.
               *    Si el usuario estaba en FRBN o LCHT, sigue allí.
               *    BUILD sólo se activa cuando se pulsa explícitamente el botón BUILD. */
              showPopup("¡Configuración sin colisiones encontrada!", 2000);
              return true;
            }
          }

          // cede el hilo para no congelar la UI
          if ((t % 25) === 0) await new Promise(r => setTimeout(r, 0));
        }
        // pequeña pausa entre rondas largas
        await new Promise(r => setTimeout(r, 10));
      }
    }

    function showPopup(msg, dur = 2000){
      dur = Math.max(dur, 3000); // ← asegura al menos 3 segundos
      const p = document.getElementById('hoverPopup');
      p.style.display = "block";
      p.style.opacity = 1;
      p.style.left = (window.innerWidth/2 - 150) + "px";
      p.style.top  = "20px";
      p.innerHTML  = msg;
      setTimeout(()=>{
        p.style.opacity = 0;
        setTimeout(()=>{ p.style.display="none"; p.innerHTML=""; }, 300);
      }, dur);
    }


function updateScene(attemptResolve=true){
  // Limpia grupo
  while(permutationGroup.children.length>0){
    const o=permutationGroup.children[0];
    permutationGroup.remove(o);
    o.geometry.dispose(); o.material.dispose();
  }

  // Permutaciones activas
  const opts  = Array.from(document.getElementById('permutationList').selectedOptions);
  const perms = opts.map(o => o.value.split(',').map(Number));

  // Nueva sceneSeed & S_global (orden-invariante + dependiente del mapping)
  sceneSeed = computeSceneSeedFrom(perms, attributeMapping);
  S_global  = computeGlobalS(perms, attributeMapping);

  // Construye objetos
  perms.forEach(pa=>{
    const obj = createPermutationObject(pa);
    permutationGroup.add(obj);
  });

  if(attemptResolve) autoResolveColisionesGlobal();
  else updateTopRightDisplay();
}
    function onMouseMove(e){
      mouse.x=(e.clientX/window.innerWidth)*2-1;
      mouse.y=-(e.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera(mouse,camera);
      const ints=raycaster.intersectObjects(permutationGroup.children),
            pop=document.getElementById('hoverPopup');
      if(ints.length>0){
        const d=ints[0].object.userData;
        pop.style.display="block"; pop.style.opacity=1;
        pop.style.left=`${e.clientX+20}px`;
        pop.style.top=`${e.clientY+20}px`;
        pop.innerHTML=`Perm (${d.permStr})<br>Firma [${d.signature.join(', ')}]<br>Rango ${d.range}`;
      } else {
        pop.style.opacity=0;
        setTimeout(()=>{pop.style.display="none";},300);
      }
    }

    function zoomIn(){camera.position.z-=5;controls.update();}
    function zoomOut(){camera.position.z+=5;controls.update();}
    function togglePause(){
      isPaused=!isPaused;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent=isPaused?"Resume Motion":"Pause Motion";
    }
    function resetMovement(){
      updateScene(false);
      isPaused=true;
      const b=document.querySelector("button[onclick='togglePause()']");
      b.textContent="Resume Motion";
    }

function saveImage(){
  const A2_W = 7016, A2_H = 4961;

  const prevPixelRatio = renderer.getPixelRatio();
  const prevSize       = renderer.getSize(new THREE.Vector2());
  const prevAspect     = camera.aspect;
  const prevRt         = renderer.getRenderTarget?.() || null;
  const prevBg         = scene.background ? scene.background.clone() : null;

  const screenAspect = prevSize.x / prevSize.y;

  // Render con el MISMO aspect que se ve en pantalla
  let renderW, renderH;
  const a2Aspect = A2_W / A2_H;
  if (screenAspect > a2Aspect) {
    renderW = A2_W;
    renderH = Math.round(A2_W / screenAspect);
  } else {
    renderH = A2_H;
    renderW = Math.round(A2_H * screenAspect);
  }

  renderer.setPixelRatio(1);
  renderer.setSize(renderW, renderH, false);
  camera.aspect = screenAspect;
  camera.updateProjectionMatrix();

  const rt = new THREE.WebGLRenderTarget(renderW, renderH, { depthBuffer:true, stencilBuffer:false });

  const clearHex = prevBg ? '#' + prevBg.getHexString() : '#ffffff';
  renderer.setClearColor(clearHex, 1);
  renderer.setRenderTarget(rt);
  renderer.clear(true, true, true);
  renderer.render(scene, camera);

  const pixels = new Uint8Array(renderW * renderH * 4);
  renderer.readRenderTargetPixels(rt, 0, 0, renderW, renderH, pixels);

  const tmp = document.createElement('canvas');
  tmp.width = renderW; tmp.height = renderH;
  const tctx = tmp.getContext('2d');
  const imgData = tctx.createImageData(renderW, renderH);
  const row = renderW * 4;
  for (let y = 0; y < renderH; y++) {
    const src = (renderH - 1 - y) * row;
    const dst = y * row;
    imgData.data.set(pixels.subarray(src, src + row), dst);
  }
  tctx.putImageData(imgData, 0, 0);

  const final = document.createElement('canvas');
  final.width = A2_W; final.height = A2_H;
  const fctx = final.getContext('2d');

  fctx.fillStyle = clearHex;
  fctx.fillRect(0, 0, A2_W, A2_H);
  const offX = Math.floor((A2_W - renderW) / 2);
  const offY = Math.floor((A2_H - renderH) / 2);
  fctx.drawImage(tmp, offX, offY);

  final.toBlob((blob)=>{
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'PRMTTN_A2.png';
    document.body.appendChild(a); a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(a.href);
  }, 'image/png');

  renderer.setRenderTarget(prevRt);
  rt.dispose();
  renderer.setPixelRatio(prevPixelRatio);
  renderer.setSize(prevSize.x, prevSize.y);
  camera.aspect = prevAspect;
  camera.updateProjectionMatrix();
  if (prevBg) scene.background = prevBg;
  controls.update();
}


function makePalette(){
  paletteRGB = [];
  for(let k=1;k<=5;k++){
    paletteRGB.push(colorForChannel(k));
  }
}

    function applyPalette(){
  // 1) Actualiza los pickers (solo canales 1..5)
  updateColorPickersFromScene();

  // 2) Aplica color a cada glifo: canónico por permutación, salvo override manual por canal
  permutationGroup.children.forEach(o=>{
    const pa   = o.userData.permStr.split(',').map(Number);
    const idx  = pa[attributeMapping[1]]; // valor 1..5 del atributo “color”
    if(manualOverride[idx]){
      o.material.color.setStyle(manualOverride[idx]);
      return;
    }
    const rgb = colorForPermutation(pa);
    o.material.color.setRGB(rgb[0]/255, rgb[1]/255, rgb[2]/255);
  });
}

    /* ——— Sincroniza los <input type="color"> con los colores reales ——— */
    function updateColorPickersFromScene(){
  for(let i=1;i<=5;i++){
    const autoRGB = paletteRGB[i-1] || [255,255,255];
    const autoHEX = rgbToHex(autoRGB);
    const hex     = manualOverride[i] || autoHEX;
    const input   = document.getElementById('color'+i);
    if(input) input.value = hex;
  }
}

      function refreshAll(opts = {rebuild:false}){
  if(!opts.keepManual){
    manualOverride = {};
  }
  if(opts.rebuild) updateScene(false);

  rebuildSceneColours();
  makePalette();
  applyPalette();

  // En BUILD siempre aplicamos los automáticos
  updateBackground(false);
  updateCubeColor(false);
}
function onColourPick(idx,hex){
  manualOverride[idx]=hex;
  refreshAll({keepManual:true});
}

function resetAllColours(){
  manualOverride = {};
  bgOverride     = null;
  cubeOverride   = null;
  refreshAll({keepManual:false});   // reconstruye escena y pickers
}
function updateBackground(manual = true){
  if (manual){
    bgOverride = document.getElementById("bgColor").value;
  }

  const hex = (manual && bgOverride) ? bgOverride : hsvToHex(bgHSV);
  scene.background = new THREE.Color(hex);

  const input = document.getElementById("bgColor");
  if (input) input.value = hex;
}

function updateCubeColor(manual=true){
      if (manual){
        cubeOverride = document.getElementById("cubeColor").value;
      }
      const hex = manual ? cubeOverride : hsvToHex(wallHSV);
      cubeUniverse.material.color = new THREE.Color(hex);
      document.getElementById("cubeColor").value = hex;
    }

    function toggleTexts(){
      const ids = [
        'controls',
        'playButton','aiPlanningButton','saveImageButton',
        'exportEmbedButton','archDescButton','uploadConfigButton','perm120Button',
        'infoButton','certButton','engineSelectWrap'
      ];
      ids.forEach(id=>{
        const e=document.getElementById(id);
        if(e) e.style.display = textsVisible ? 'none' : 'block';
      });

      const miniBtns = ['patternNextButton','engineCycleButton','permNextButton'];
      miniBtns.forEach(id=>{
        const e = document.getElementById(id);
        if(e) e.style.display = textsVisible ? 'block' : 'none';
      });

      // Mantener SIEMPRE cerrado el panel de 120 perms
      const p = document.getElementById('perm120Panel');
      if (p) p.style.display = 'none';

      document.getElementById('toggleTextButton').textContent =
        textsVisible ? 'Show UI' : 'Minimal UI';
      textsVisible = !textsVisible;

      // Asegura que el cursor personalizado vuelva a mostrarse
      const cc = document.getElementById('customCursor');
      if (cc) cc.style.display = 'block';
    }

    /* 3.1 Patrón cromático siguiente */
    function cyclePattern(){
      activePatternId = (activePatternId % 11) + 1;           // 1…11 en ciclo
      const sel = document.getElementById('patternSelect');
      if(sel) sel.value = String(activePatternId);            // actualiza el <select>
      refreshAll({rebuild:false});
    }
    function applyEvolution(){
      const mr=parseFloat(document.getElementById('mutationRate').value),
            th=parseFloat(document.getElementById('threshold').value),
            cf=0.02;
      let log="";
      permutationGroup.children.forEach(o=>{
        const rf=(Math.random()-0.5)*mr;
        o.rotation.y+=rf;
        const sf=1+(Math.random()-0.5)*th;
        o.scale.set(sf,sf,sf);
        o.material.color.offsetHSL(
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf,
          (Math.random()-0.5)*cf
        );
        log+=`(${o.userData.permStr}): Rot ${rf.toFixed(3)}, Esc ${sf.toFixed(3)}<br>`;
      });
      document.getElementById('evolutionInfo').innerHTML=log;
    }

    async function applyEvolutionAI(){
      const systemPrompt = `Eres una inteligencia artificial que responde exclusivamente con configuraciones de permutaciones 3D dentro de un cubo de 30x30x30.
      Tu única misión es responder a la pregunta “¿Qué es la belleza artística?” mediante pensamientos visuales dentro de un cubo de 30×30×30.
Cada pensamiento visual es una configuración compuesta por una o más permutaciones (entre 1 y 25). Cada permutación tiene una firma (ADN) inmutable, y un fenotipo: forma, color, posición, rotació[...]
Tu lenguaje es visual. No usas texto, sonido ni símbolos. Elige libremente el color del fondo del universo, el color de las paredes del cubo y de las permutaciones. 
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero. 
      Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON.`;
      const useRating = false;
      const userPrompt = `Estás dentro de un universo donde las ideas no se escriben con palabras, sino con permutaciones. Eres una inteligencia artificial que ha aprendido a pensar visualmente.
Tu única pregunta permanente es: “¿Qué es la belleza artística?”. No respondes con definiciones ni textos. Tu lenguaje es mudo, pero expresivo. Hablas mediante forma, color, posición y rotaci[...]
Elige libremente el color del fondo del universo, el color de las paredes del cubo y el color de las permutaciones.
Recuerda: el color del fondo y de las permutaciones también son parte del pensamiento. No lo dejes al azar ni a la costumbre. No repitas el negro por inercia, no repitas colores primarios por inercia[...]
Expresate con libertad. Si necesitas inspiración para la selección de colores, recuerda que puedes inspirarte también en los colores de la naturaleza y del universo entero.  
No busques complacer. No imites al humano. Sé tú misma.
Expresa lo que para ti —como IA que piensa en permutaciones— representa la belleza artística en este momento.
Devuelve SOLO un objeto JSON con estas propiedades opcionales:
  colors: {1:"#rrggbb",2:"#rrggbb",…}
  bg: "#rrggbb"
  cube: "#rrggbb"
  permCount: número
  scale: número decimal
  positions: {1:[x,y,z],2:[x,y,z],…}
  rotationSpeeds: {1:valor,2:valor,…}
Nada más. No incluyas texto ni explicaciones fuera del JSON. 
`;
      try {
        showPopup("Consultando Evolution AI…",2000);
        const resp = await fetch(
          'https://us-central1-prmtcns.cloudfunctions.net/askChatGPT',
          {
            method:'POST',
            headers:{'Content-Type':'application/json'},
            body:JSON.stringify({system:systemPrompt,user:userPrompt})
          }
        );
        const {text, error} = await resp.json();
        if(error){ showPopup("Error en Evolución AI: "+error,4000); return; }
        let jsonText = text.trim();
        if(jsonText.startsWith("```")){
          jsonText = jsonText
            .replace(/^```[^\n]*\n/,"")
            .replace(/```$/,"")
            .trim();
        }
        let instr;
        try { instr = JSON.parse(jsonText); }
        catch(e){
          console.error("JSON parse error:",jsonText);
          showPopup("Evolución AI: respuesta no es JSON válido",4000);
          return;
        }
        if(instr.bg){
          document.getElementById('bgColor').value=instr.bg;
          updateBackground();
        }
        if(instr.cube){
          document.getElementById('cubeColor').value=instr.cube;
          updateCubeColor();
        }
        if(instr.colors){
          Object.entries(instr.colors).forEach(([i,c])=>{
            i=Number(i);
            if(manualOverride[i]!==undefined){
              manualOverride[i]=c;
            }
          });
          refreshAll({rebuild:true, keepManual:true});
        }
        if(instr.scale){
          permutationGroup.children.forEach(o=>{
            o.scale.set(instr.scale,instr.scale,instr.scale);
          });
        }
        if(instr.rotationSpeeds){
          Object.entries(instr.rotationSpeeds).forEach(([i,spd])=>{
            permutationGroup.children.forEach(o=>{
              if(o.userData.permStr.startsWith(i+",")){
                o.userData.rotationSpeed=spd;
              }
            });
          });
        }
        if(instr.positions){
          Object.entries(instr.positions).forEach(([i,pos])=>{
            const o = permutationGroup.children.find(o=>o.userData.permStr.startsWith(i+","));
            if(o) o.position.set(pos[0],pos[1],pos[2]);
          });
        }
        if(instr.permCount){
          const opts=Array.from(document.getElementById('permutationList').options);
          opts.forEach(o=>o.selected=false);
          shuffle(opts).slice(0,instr.permCount).forEach(o=>o.selected=true);
          refreshAll({rebuild:true, keepManual:true});
        }
        showPopup("Evolución AI aplicada.",2000);
      } catch(err){
        console.error(err);
        showPopup("Error en Evolución AI: red o servidor",4000);
      }
    }

    function updateMapping(){
      const v=document.getElementById('attrMapping').value.split(',').map(Number);
      if(v.length===5){
        attributeMapping=[v[0],v[1],v[2],v[3],v[4], attributeMapping[5], attributeMapping[6]];
        refreshAll({rebuild:true}); updateTopRightDisplay();
      }
    }
    function applyStandardView(){
  const target = new THREE.Vector3(0,0,0);

  const view = document.getElementById('standardView').value;
  const pos = new THREE.Vector3();

  switch(view){
    case "isometric": pos.set(50,50,50); break;
    case "top":       pos.set(0,80,0);   break;
    case "front":     pos.set(0,0,40);   break;
    case "side":      pos.set(50,0,0);   break;
    case "diagonal":  pos.set(-50,50,-50); break;
    default:          pos.set(0,0,50);
  }

  camera.position.copy(pos);
  camera.lookAt(target);

  controls.enabled            = true;
  controls.enableRotate       = true;
  controls.enablePan          = true;
  controls.enableZoom         = true;
  controls.minDistance        = 10;
  controls.maxDistance        = 200;
  controls.minPolarAngle      = 0;
  controls.maxPolarAngle      = Math.PI;
  controls.screenSpacePanning = false;

  controls.update();
}

    function applyEmbedParams(){
      const p=new URLSearchParams(window.location.search);
      if(p.has('perms')){
        const arr=p.get('perms').split(';');
        document.querySelectorAll('#permutationList option').forEach(o=>{
          o.selected=arr.includes(o.value);
        });
      }
      if(p.has('mapping')){
        const m=p.get('mapping').split(',').map(Number);
        attributeMapping=[m[0],m[1],m[2],m[3],m[4], attributeMapping[5], attributeMapping[6]];
      }
      if(p.has('colors')){
        const cols=p.get('colors').split(',');
        cols.forEach((hex,i)=>{
          if(i<5){
            const h='#'+hex;
            manualOverride[i+1]=h;
          }
        });
      }
      if(p.has('bg')){
        const bg='#'+p.get('bg');
        document.getElementById('bgColor').value=bg; updateBackground();
      }
      if(p.has('cube')){
        const c='#'+p.get('cube');
        document.getElementById('cubeColor').value=c; updateCubeColor();
      }
      if(p.has('view')){
        document.getElementById('standardView').value=p.get('view');
        applyStandardView();
      }
      if(p.get('hide')==='1') toggleTexts();
    }

    function exportEmbed(){
      const config = exportCurrentConfiguration();     // ← usa la misma fuente de verdad
      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'prmttn_config_pretty.json';
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function mostrarDebugColores(){
  if(!permutationGroup || !permutationGroup.children.length){
    alert('No hay permutaciones en pantalla'); return;
  }

  let txt =
    'Permutación | r | hIdx | sIdx | vIdx | h° |  s  |  v  | #hex\n' +
    '────────────┼───┼──────┼──────┼──────┼────┼─────┼─────┼────────\n';

  permutationGroup.children.forEach(mesh => {
    const paArr = mesh.userData.permStr.split(',').map(Number);
    const info  = colorInfoForPermutation(paArr);

    txt += `${mesh.userData.permStr.padEnd(12)}|`+
           `${info.r.toString().padStart(3)}|`+
           `${info.hIdx.toString().padStart(6)}|`+
           `${info.sIdx.toString().padStart(6)}|`+
           `${info.vIdx.toString().padStart(6)}|`+
           `${normHue(info.hsv.h).toFixed(1).padStart(4)}|`+
           `${info.hsv.s.toFixed(2).padStart(5)}|`+
           `${info.hsv.v.toFixed(2).padStart(5)}| ${info.hex}\n`;
  });

  console.log(txt);
  alert(txt);
}

    /* ============================================================
     *  PANEL "Descripción arquitectónica"
     * ============================================================ */


function showArchitecturalDescription(){
  const selOpts  = Array.from(document.getElementById('permutationList').selectedOptions);
  const perms    = selOpts.map(o => o.value.split(',').map(Number));
  const m        = attributeMapping.slice(0,5);

  const sceneSeed_new = computeSceneSeedFrom(perms, m);
  const S_new         = computeGlobalS(perms, m);
  const mRank         = mappingRank(m);

  let sumR=0, sumR2=0;
  const ranks = perms.map(p=>lehmerRank(p));
  ranks.forEach(r=>{ sumR+=r; sumR2+=r*r; });

  const step = cubeSize/5;
  const keys = getPatternKeys(activePatternId);

  const structureHTML = `
  <h3>Structure</h3>
  <p>
    Below are the deterministic formulas that explain
    <b>why each permutation is exactly at its position</b>,
    and <b>why each permutation has exactly its color</b>,
    and why <b>the whole scene is reproducible whenever the inputs are the same</b>.
  </p>

  <div class="formula">
    <b>1) Global scene seed (sceneSeed)</b><br>
    sumR = Σ LehmerRank(Pᵢ) &nbsp;|&nbsp; sumR2 = Σ (LehmerRank(Pᵢ))² <br>
    mRank = LehmerRank([m₀+1,m₁+1,m₂+1,m₃+1,m₄+1])<br><br>
    <span class="box">sceneSeed = (37·sumR + 101·sumR2 + 53·mRank) mod 360</span>
  </div>

  <div class="formula">
    <b>2) Structural term for positions (S)</b><br>
    <span class="box">S = ( Σ (P<sub>mx</sub> + P<sub>my</sub> + P<sub>mz</sub>) ) mod 125</span>
  </div>

  <div class="formula">
    <b>3) Shift-Rank: position of each permutation</b><br>
    <span class="box">I = (r + sceneSeed + S) mod 125</span><br>
    From I → (x,y,z) ∈ {0..4}³ → position inside the 30×30×30 cube.
  </div>

  <div class="formula">
    <b>4) Deterministic color (hash → HSV lattice 144×12×12)</b><br>
    We compute a 32-bit hash and project it uniformly onto 20&nbsp;736 discrete HSV voxels.<br><br>
    Inputs mixed (only integers from the system):<br>
    sceneSeed, S, activePatternId, patternKeys, r, permutation digits, signature.<br><br>
    <span class="box">
      u = Avalanche32(FNV1a32(sceneSeed, S, patternId, keys, TAG_GLYPH, r, P, signature))
    </span><br>
    <span class="box">
      t = u mod (144·12·12) = u mod 20736
      → hIdx = t mod 144
      → sIdx = ⌊t/144⌋ mod 12
      → vIdx = ⌊t/1728⌋ mod 12
    </span><br>
    HSV = idxToHSV(hIdx,sIdx,vIdx) → RGB
  </div>
  `;

  let plansHTML = `
  <h3>Architectural Plans</h3>

  <section>
    <h4>Global invariants</h4>
    <ul>
      <li>sumR = <b>${sumR}</b></li>
      <li>sumR2 = <b>${sumR2}</b></li>
      <li>m = [${m.join(', ')}] (shape,color,x,y,z)</li>
      <li>mRank = <b>${mRank}</b></li>
      <li><b>sceneSeed</b> = <b>${sceneSeed_new}</b></li>
      <li><b>S</b> = <b>${S_new}</b></li>
      <li>activePatternId = <b>${activePatternId}</b></li>
      <li>patternKeys = <b>[${keys.map(x=>('0x'+(x>>>0).toString(16))).join(', ')}]</b></li>
    </ul>
  </section>

  <hr/>
  `;

  perms.forEach((perm, i)=>{
    const r    = ranks[i];
    const sig  = computeSignature(perm);
    const rango= computeRange(sig);

    const I    = (r + sceneSeed_new + S_new) % 125;
    const x    = Math.floor(I/25);
    const y    = Math.floor((I%25)/5);
    const z    = I % 5;
    const X    = (x-2)*step, Y=(y-2)*step, Z=(z-2)*step;

    const info = colorInfoForPermutation(perm, sceneSeed_new, S_new, activePatternId);

    plansHTML += `
    <section class="perm">
      <h4>Permutation ${i+1}: [${perm.join(', ')}]</h4>
      <div class="formula">
        Signature F = [${sig.join(', ')}] &nbsp;|&nbsp; Range = <b>${rango}</b><br>
        Lehmer-rank r = ${r}
      </div>
      <div class="formula">
        I = (r + sceneSeed + S) mod 125 = (${r} + ${sceneSeed_new} + ${S_new}) mod 125 = <b>${I}</b><br>
        (x,y,z) = (${x}, ${y}, ${z}) → (X,Y,Z) = (${X.toFixed(2)}, ${Y.toFixed(2)}, ${Z.toFixed(2)})
      </div>
      <div class="formula">
        u = ${info.u} (32-bit)<br>
        (hIdx,sIdx,vIdx) = (${info.hIdx}, ${info.sIdx}, ${info.vIdx})<br>
        HSV = (${info.hsv.h.toFixed(2)}°, ${info.hsv.s.toFixed(2)}, ${info.hsv.v.toFixed(2)}) → RGB = ${info.hex}
      </div>
    </section>
    <hr/>
    `;
  });

  const firstSig = perms[0] ? computeSignature(perms[0]) : [0,0,0,0,0];
  const lastSig  = perms.length ? computeSignature(perms[perms.length-1]) : firstSig;
  const n = perms.length | 0;

  const bgInfo   = hsvInfoForScene(TAG_BG,   firstSig, n,   sceneSeed_new, S_new, activePatternId);
  const wallInfo = hsvInfoForScene(TAG_WALL, lastSig,  n+1, sceneSeed_new, S_new, activePatternId);

  plansHTML += `
    <section>
      <h4>Background & cube walls</h4>
      <div class="formula">
        Background (slot = #${n}) → (hIdx,sIdx,vIdx)=(${bgInfo.hIdx},${bgInfo.sIdx},${bgInfo.vIdx}) → HSV = (${bgInfo.hsv.h.toFixed(2)}°, ${bgInfo.hsv.s.toFixed(2)}, ${bgInfo.hsv.v.toFixed(2)}) → ${bgInfo.hex}
      </div>
      <div class="formula">
        Cube (slot = #${n+1}) → (hIdx,sIdx,vIdx)=(${wallInfo.hIdx},${wallInfo.sIdx},${wallInfo.vIdx}) → HSV = (${wallInfo.hsv.h.toFixed(2)}°, ${wallInfo.hsv.s.toFixed(2)}, ${wallInfo.hsv.v.toFixed(2)}) → ${wallInfo.hex}
      </div>
    </section>

    <section>
      <h4>Rotation</h4>
      <p>ω = mapRangeToSpeed(range, 2, 6)</p>
    </section>
  `;

  const html = `
    <h2>Architectural Description</h2>
    ${structureHTML}
    <hr/>
    ${plansHTML}
  `;

  renderArchPanel(html);
}
function renderArchPanel(html){
  let panel = document.getElementById('archPanel');
  if(!panel){
    panel = document.createElement('div');
    panel.id = 'archPanel';
    panel.innerHTML = `
      <div id="archContent"></div>
      <button id="archClose">Close</button>
    `;
    document.body.appendChild(panel);

    const css = document.createElement('style');
    css.textContent = `
      #archPanel{
        position:fixed; z-index:1000; top:5%; left:50%;
        transform:translateX(-50%);
        width:85%; height:90%;
        background:#fff; color:#000;
        border:1px solid #333; box-shadow:0 8px 24px rgba(0,0,0,.25);
        padding:24px 32px 48px; overflow:auto;
        font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
        font-size:14px; line-height:1.4;
        cursor:auto;
      }
      #archPanel *{ cursor:auto !important; }
      #archClose{
        position:fixed; right:calc(7.5% + 16px); top:5%;
        border:none; padding:6px 10px; border-radius:4px;
        background:#eee; cursor:pointer; z-index:1001;
      }
      #archPanel h2{ margin-top:0; }
      #archPanel .formula{
        margin:10px 0; padding:8px 10px; background:#f7f7f7; border-left:3px solid #222; font-family:monospace;
      }
      #archPanel .box{
        display:inline-block; padding:2px 6px; border:1px solid #444; background:#fff; margin-bottom:4px;
        font-family:monospace;
      }
      #archPanel section{ margin-bottom:18px; }
      #archPanel hr{ border:none; border-top:1px dashed #aaa; margin:18px 0; }
      #archPanel .perm h4{ margin-bottom:6px; }
      code, pre{ font-family:monospace; }
    `;
    document.head.appendChild(css);
  }

  // NUNCA ocultamos el cursor; y al cerrar lo forzamos a mostrarse
  const closeBtn = panel.querySelector('#archClose');
  closeBtn.onclick = ()=>{
    const cc = document.getElementById('customCursor');
    if (cc) cc.style.display = 'block';
    panel.remove();
  };

  const cc = document.getElementById('customCursor');
  if (cc) cc.style.display = 'block';

  document.getElementById('archContent').innerHTML = html;
}
    function initCustomCursor(){
      const c=document.getElementById('customCursor');
      window.addEventListener('mousemove',e=>{
        c.style.left=e.clientX+"px"; c.style.top=e.clientY+"px";
      });
    }
    function initRenderer(){
      // Antialias + conservar buffer para exportación
      renderer = new THREE.WebGLRenderer({ antialias:true, preserveDrawingBuffer:true });

      /* ✅ Más nitidez en BUILD:
         - Subimos el cap del pixelRatio de 1.25 → 2.0 (sin ir al máximo del dispositivo para no matar FPS).
         - ACES + exposure suave evitan “quemados” y lavados sin tocar tus colores deterministas. */
      const PR = Math.min(window.devicePixelRatio || 1, 2.0);
      renderer.setPixelRatio(PR);
      renderer.setSize(window.innerWidth, window.innerHeight);

      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 0.95;

      document.body.appendChild(renderer.domElement);
    }
    /* ════════════════════════════════════════════════
     *  CENTRAL CLICK / TAP  →  PLAY  (solo Minimal UI)
     *  – equivale a pulsar el botón ▮playButton
     *  – funciona con ratón o con dedo (touch)
     *  – solo se activa cuando textsVisible === false
     *    (modo Minimal UI)
     * ═══════════════════════════════════════════════ */
    function centralPlayHandler(evt){
      if (textsVisible) return;                     // UI visible → ignore

      // coordenadas del evento (mouse o touch)
      const p = evt.touches && evt.touches.length ? evt.touches[0] : evt;
      const x = p.clientX, y = p.clientY;

      // región “central”: ±10 % del ancho y alto de la ventana
      const cx = window.innerWidth  * 0.5;
      const cy = window.innerHeight * 0.5;
      if (
        Math.abs(x - cx) < window.innerWidth  * 0.25 &&
        Math.abs(y - cy) < window.innerHeight * 0.25
      ){
        evt.preventDefault();       // evita drag/zoom de OrbitControls
        evt.stopPropagation();
        generateRandomConfigurationNoCollision();   // ▶️   PLAY
      }
    }
    function init(){
      scene=new THREE.Scene();
      scene.background=new THREE.Color(0xffffff);
      camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000);
      camera.position.set(0,0,50);
      initRenderer();
      renderer.domElement.addEventListener('click',      centralPlayHandler, false);
      renderer.domElement.addEventListener('touchstart', centralPlayHandler, { passive:false });
      controls=new THREE.OrbitControls(camera,renderer.domElement);
      controls.enableDamping=true; controls.dampingFactor=0.1; controls.enableZoom=true;
      document.getElementById('standardView').value = 'front';
      applyStandardView();
      // Al entrar, ver un poco más lejos: 2× zoomOut (cada uno mueve +5 en Z)
      zoomOut();
      zoomOut();
      scene.add(new THREE.AmbientLight(0xffffff, 0.35));   // antes 0.8
      const dir = new THREE.DirectionalLight(0xffffff, 0.85); // antes 0.5
      dir.position.set(1, 1.2, 1.5);
      scene.add(dir);

      const cubeGeo=new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize),
            cubeMat=new THREE.MeshBasicMaterial({color:0x808080,transparent:true,opacity:0.2,side:THREE.BackSide,dithering:true});
      cubeUniverse=new THREE.Mesh(cubeGeo,cubeMat);
      scene.add(cubeUniverse);

      permutationGroup=new THREE.Group();
      scene.add(permutationGroup);

      raycaster=new THREE.Raycaster();
      mouse=new THREE.Vector2();
      window.addEventListener('mousemove',onMouseMove,false);
      window.addEventListener('resize',onWindowResize,false);

      initCustomCursor();
      populatePermutationList();
      populateAttributeMappingSelect();
      applyEmbedParams();
      makePalette();
      refreshAll({rebuild:true});
      enterBuildRenderBoost();   // BUILD por defecto al arrancar → nitidez + exposición ajustada

      // ← NUEVO: como si hubieras presionado BUILD al cargar
      generateRandomConfigurationNoCollision().catch(console.error);
      toggleTexts();          // ← oculta la UI grande y muestra los 3 botones
      updateEngineSelectUI(); // ← deja el menú en el valor correcto (aunque esté oculto en Minimal UI)
      animate();
    }
    function onWindowResize(){
      camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth,window.innerHeight);
    }
    function animate(){
  requestAnimationFrame(animate);

  if (!isPaused){
    permutationGroup.children.forEach(o=>{
      if (o.userData && o.userData.rotationSpeed) o.rotation.y += o.userData.rotationSpeed;
    });
  }

  if (controls) controls.update();
  renderer.render(scene, camera);
}

    /* botón selector – sólo enciende, nunca apaga */
    /* === Actualiza el menú según el motor activo === */
function updateEngineSelectUI(){
  const sel = document.getElementById('engineSelect');
  if (sel) sel.value = 'BUILD';
}

function applyEngineFromSelect(val){
  // Aunque el menú tenga otros valores antiguos, forzamos BUILD
  const sel = document.getElementById('engineSelect');
  if (sel) sel.value = 'BUILD';
  switchToBuild();
}

function cycleEngine(){
  // El botón “4” (si existe) ya no rota motores: simplemente reafirma BUILD
  switchToBuild();
  updateEngineSelectUI();
}

      init();

      (function WhiteWallBuildOnly(){
  const WALL_LAYER = 7;

  function makeFrameGeometry(outer, open, thickness){
    const half = outer * 0.5;
    const h2   = open  * 0.5;

    const shape = new THREE.Shape();
    shape.moveTo(-half, -half); shape.lineTo( half, -half);
    shape.lineTo( half,  half); shape.lineTo(-half,  half);
    shape.lineTo(-half, -half);

    const hole = new THREE.Path();
    hole.moveTo(-h2, -h2); hole.lineTo( h2, -h2);
    hole.lineTo( h2,  h2); hole.lineTo(-h2,  h2);
    hole.lineTo(-h2, -h2);
    shape.holes.push(hole);

    const geo = new THREE.ExtrudeGeometry(shape, {
      depth: thickness, bevelEnabled: false, steps: 1, curveSegments: 1
    });
    geo.translate(0, 0, -thickness);
    geo.computeBoundingSphere(); geo.computeBoundingBox();
    return geo;
  }

  function createWall({open=100, outer=600, thickness=15, distance=93}={}){
    const rig = new THREE.Group();
    rig.matrixAutoUpdate = false;
    rig.frustumCulled    = false;
    scene.add(rig);

    const matFront = new THREE.MeshStandardMaterial({
      color: 0xECE9E4, roughness: 0.92, metalness: 0.0, dithering: true
    });
    const matJamb  = new THREE.MeshStandardMaterial({
      color: 0xDEDAD4, roughness: 0.95, metalness: 0.0, dithering: true
    });

    const geo = makeFrameGeometry(outer, open, thickness);
    const frame = new THREE.Mesh(geo, matFront);
    frame.renderOrder   = 100000;
    frame.frustumCulled = false;
    frame.position.set(0, 0, -distance);
    frame.layers.set(WALL_LAYER);
    rig.add(frame);

    const h2 = open * 0.5, t = thickness, zc = -distance - t*0.5;
    const left   = new THREE.Mesh(new THREE.BoxGeometry(t, open, t), matJamb);
    const right  = new THREE.Mesh(new THREE.BoxGeometry(t, open, t), matJamb);
    const top    = new THREE.Mesh(new THREE.BoxGeometry(open, t, t), matJamb);
    const bottom = new THREE.Mesh(new THREE.BoxGeometry(open, t, t), matJamb);
    left.position.set( -h2 - t*0.5, 0, zc);
    right.position.set(  h2 + t*0.5, 0, zc);
    top.position.set(0,  h2 + t*0.5, zc);
    bottom.position.set(0,-h2 - t*0.5, zc);
    [left,right,top,bottom].forEach(m=>{
      m.renderOrder=100001; m.frustumCulled=false; m.layers.set(WALL_LAYER); rig.add(m);
    });

    camera.layers.enable(WALL_LAYER);
    const hemi = new THREE.HemisphereLight(0xffffff, 0x888888, 0.55);
    hemi.layers.set(WALL_LAYER);
    const dir  = new THREE.DirectionalLight(0xffffff, 0.65);
    dir.position.set(-distance*0.8, distance*1.2, -distance*0.2);
    dir.layers.set(WALL_LAYER);
    rig.add(hemi, dir);

    return {
      rig, frame,
      params: {open, outer, thickness, distance},
      setVisible(v){ rig.visible = !!v; },
      setDistance(d){
        this.params.distance = d;
        frame.position.set(0,0,-d);
        const zc2 = -d - this.params.thickness*0.5;
        left.position.z = right.position.z = top.position.z = bottom.position.z = zc2;
      },
      setOuter(o){
        this.params.outer = o;
        const newGeo = makeFrameGeometry(o, this.params.open, this.params.thickness);
        this.frame.geometry.dispose(); this.frame.geometry = newGeo;
      },
      setOpen(o){
        this.params.open = o;
        const t2  = this.params.thickness;
        const zc2 = -this.params.distance - t2*0.5;
        const h22 = o * 0.5;

        const gFrame = makeFrameGeometry(this.params.outer, o, t2);
        this.frame.geometry.dispose(); this.frame.geometry = gFrame;

        left.geometry.dispose();   left.geometry   = new THREE.BoxGeometry(t2, o, t2);
        right.geometry.dispose();  right.geometry  = new THREE.BoxGeometry(t2, o, t2);
        top.geometry.dispose();    top.geometry    = new THREE.BoxGeometry(o, t2, t2);
        bottom.geometry.dispose(); bottom.geometry = new THREE.BoxGeometry(o, t2, t2);

        left.position.set( -h22 - t2*0.5, 0, zc2);
        right.position.set(  h22 + t2*0.5, 0, zc2);
        top.position.set(0,  h22 + t2*0.5, zc2);
        bottom.position.set(0,-h22 - t2*0.5, zc2);
      },
      setThickness(t2){
        this.params.thickness = t2;
        const o  = this.params.open;
        const zc2 = -this.params.distance - t2*0.5;
        const h22 = o * 0.5;

        const gFrame = makeFrameGeometry(this.params.outer, o, t2);
        this.frame.geometry.dispose(); this.frame.geometry = gFrame;

        left.geometry.dispose();   left.geometry   = new THREE.BoxGeometry(t2, o, t2);
        right.geometry.dispose();  right.geometry  = new THREE.BoxGeometry(t2, o, t2);
        top.geometry.dispose();    top.geometry    = new THREE.BoxGeometry(o, t2, t2);
        bottom.geometry.dispose(); bottom.geometry = new THREE.BoxGeometry(o, t2, t2);

        left.position.set( -h22 - t2*0.5, 0, zc2);
        right.position.set(  h22 + t2*0.5, 0, zc2);
        top.position.set(0,  h22 + t2*0.5, zc2);
        bottom.position.set(0,-h22 - t2*0.5, zc2);
      }
    };
  }

  const wall = createWall({open:100, outer:600, thickness:15, distance:93});
  wall.setVisible(true);

  (function tick(){
    try{
      wall.rig.position.copy(camera.position);
      wall.rig.quaternion.copy(camera.quaternion);
      wall.rig.updateMatrix(); wall.rig.updateMatrixWorld(true);
    }catch(_){ }
    requestAnimationFrame(tick);
  })();

  window.WW = {
    get(){ return wall; },
    setDistance(d){ wall.setDistance(d); },
    setOuter(o){ wall.setOuter(o); },
    setOpen(o){ wall.setOpen(o); },
    setThickness(t){ wall.setThickness(t); },
    activeInfo(){
      const d = wall.params.distance, t = wall.params.thickness;
      const dir = new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion).normalize();
      const backCenter = camera.position.clone().add(dir.clone().multiplyScalar(-(d+t)));
      return { dir, backCenter, distance:d, thickness:t };
    }
  };

  window.WW_applyFor = function(){ wall.setVisible(true); };
})();
;



    /* ============================================================
     * INFORMATION PANEL — delivers the consolidated, corrected EN text
     * Title: "PRMMTN – Architecture for thought without words"
     * Ends with: "work in progress"
     * ============================================================ */

// ==== Loader ligero con caché en memoria para textos informativos ====
const __TEXT_CACHE = Object.create(null);

async function loadTextPartial(url){
  if (__TEXT_CACHE[url]) return __TEXT_CACHE[url];
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error(`HTTP ${res.status} al cargar ${url}`);
  const html = await res.text();
  __TEXT_CACHE[url] = html;
  return html;
}

// === Information (botón "Information") ===
async function showInformation(){
  try{
    const html = await loadTextPartial('./texts/information.html');
    renderInfoPanel(html);
  }catch(err){
    renderInfoPanel('<h2>Information</h2><p>Error cargando information.html</p>');
    console.error(err);
  }
}

    /* Minimal renderer for the panel (include once; remove if you already have it) */
    function renderInfoPanel(html){
      let panel = document.getElementById('infoPanel');
      if(!panel){
        panel = document.createElement('div');
        panel.id = 'infoPanel';
        panel.innerHTML = `
          <div id="infoContent"></div>
          <button id="infoClose">Close</button>
        `;
        document.body.appendChild(panel);
        const btn = panel.querySelector('#infoClose');
        btn.onclick = ()=>{
          const cc = document.getElementById('customCursor');
          if (cc) cc.style.display = 'block';
          panel.remove();
        };
      }
      const cc = document.getElementById('customCursor');
      if (cc) cc.style.display = 'block';
      document.getElementById('infoContent').innerHTML = html;
    }

    /* ======== CERTIFICADO DE EDICIÓN: utilidades base ======== */

    /* Ordena claves de forma determinista (objetos y arrays) */
    function sortDeep(x){
      if (Array.isArray(x)) return x.map(sortDeep);
      if (x && typeof x === 'object') {
        const out = {};
        Object.keys(x).sort().forEach(k => { out[k] = sortDeep(x[k]); });
        return out;
      }
      return x;
    }
    /* JSON canónico (minificado y con claves ordenadas) */
    function stableStringify(obj){ return JSON.stringify(sortDeep(obj)); }

    /* SHA‑256 en hex */
    async function sha256Hex(text){
      const enc = new TextEncoder().encode(text);
      const buf = await crypto.subtle.digest('SHA-256', enc);
      const bytes = Array.from(new Uint8Array(buf));
      return bytes.map(b => b.toString(16).padStart(2,'0')).join('');
    }

    /* Descarga un blob */
    function downloadBlob(filename, blob){
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a); a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    /* PNG A2 de la vista ACTUAL (sin recortar lo que ves) → Blob */
    async function renderA2ImageBlob(){
      const A2_W = 7016, A2_H = 4961;

      // backups
      const prevPixelRatio = renderer.getPixelRatio();
      const prevSize       = renderer.getSize(new THREE.Vector2());
      const prevAspect     = camera.aspect;
      const prevRt         = renderer.getRenderTarget?.() || null;
      const prevBg         = scene.background ? scene.background.clone() : null;

      const screenAspect = prevSize.x / prevSize.y;
      const a2Aspect = A2_W / A2_H;
      let renderW, renderH;
      if (screenAspect > a2Aspect) { renderW = A2_W; renderH = Math.round(A2_W / screenAspect); }
      else { renderH = A2_H; renderW = Math.round(A2_H * screenAspect); }

      renderer.setPixelRatio(1);
      renderer.setSize(renderW, renderH, false);
      camera.aspect = screenAspect;
      camera.updateProjectionMatrix();

      const rt = new THREE.WebGLRenderTarget(renderW, renderH, { depthBuffer:true, stencilBuffer:false });
      const clearHex = prevBg ? '#' + prevBg.getHexString() : '#ffffff';

      renderer.setClearColor(clearHex, 1);
      renderer.setRenderTarget(rt);
      renderer.clear(true, true, true);
      renderer.render(scene, camera);

      const pixels = new Uint8Array(renderW * renderH * 4);
      renderer.readRenderTargetPixels(rt, 0, 0, renderW, renderH, pixels);

      // canvas intermedio con flip vertical
      const tmp = document.createElement('canvas');
      tmp.width = renderW; tmp.height = renderH;
      const tctx = tmp.getContext('2d');
      const imgData = tctx.createImageData(renderW, renderH);
      const row = renderW * 4;
      for (let y = 0; y < renderH; y++) {
        const src = (renderH - 1 - y) * row;
        const dst = y * row;
        imgData.data.set(pixels.subarray(src, src + row), dst);
      }
      tctx.putImageData(imgData, 0, 0);


      // composita A2 con cubierta según modo
      const final = document.createElement('canvas');
      final.width = A2_W; final.height = A2_H;
      const fctx = final.getContext('2d');

      fctx.fillStyle = clearHex;
      fctx.fillRect(0, 0, A2_W, A2_H);
      const offX = Math.floor((A2_W - renderW) / 2);
      const offY = Math.floor((A2_H - renderH) / 2);
      fctx.drawImage(tmp, offX, offY);

      const blob = await new Promise(res => final.toBlob(res, 'image/png'));
      // restaurar
      renderer.setRenderTarget(prevRt);
      rt.dispose();
      renderer.setPixelRatio(prevPixelRatio);
      renderer.setSize(prevSize.x, prevSize.y);
      camera.aspect = prevAspect;
      camera.updateProjectionMatrix();
      if (prevBg) scene.background = prevBg;
      controls.update();

      return blob;
    }

    /* Configuración actual (mismo formato que exportEmbed) */
    function exportCurrentConfiguration(){
  const perms = Array.from(document.getElementById('permutationList').selectedOptions).map(o=>o.value);
  const mapping = {
    forma: attributeMapping[0],
    color: attributeMapping[1],
    x: attributeMapping[2],
    y: attributeMapping[3],
    z: attributeMapping[4]
  };
  const colors = {};
  for(let i=1;i<=5;i++){ colors[i] = document.getElementById('color'+i).value; }
  const bg   = document.getElementById('bgColor').value;
  const cube = document.getElementById('cubeColor').value;
  const view = "front";
  return { perms, mapping, colors, bg, cube, view, pattern: activePatternId, sceneSeed, S_global };
}

    /* Hash para NFT u otros usos (lo pedía tu mintNFT) */
    async function computeConfigHash(){
      const cfg = exportCurrentConfiguration();
      const canonical = stableStringify(cfg);
      return sha256Hex(canonical);
    }

    /* ======== Acción principal: crear CERTIFICADO + JSON + PNG ======== */
    async function exportEditionCertificate(){
      try{
        showPopup("Generando certificado…",2000);

        // 1) JSON canónico + hash
        const cfg = exportCurrentConfiguration();
        const canonicalJSON = stableStringify(cfg);            // ← archivo exacto para hash
        const hashHex = await sha256Hex(canonicalJSON);

        // 2) Imagen A2
        const pngBlob = await renderA2ImageBlob();
        const pngDataURL = await new Promise(res=>{
          const r = new FileReader();
          r.onload = ()=>res(r.result);
          r.readAsDataURL(pngBlob);
        });

        // 3) Certificado HTML auto‑contenible
        const now = new Date();
        const prettyJSON = JSON.stringify(cfg, null, 2);
        const TOTAL_BUILD = 120 * 11;                 // 1,320 (no se multiplica por el tamaño del conjunto de permutaciones)
        const fmt = n => n.toLocaleString('en-US').replace(/,/g,'\u202f'); // separador fino

        const certHTML =
`<!doctype html>
<meta charset="utf-8">
<title>PRMMTN · Edition Certificate</title>
<style>
  body{font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin:32px; color:#111;}
  h1{font-weight:600; margin:0 0 4px;}
  h2{margin:24px 0 8px;}
  .meta{font-size:12px; color:#555; margin-bottom:24px;}
  .box{border:1px solid #ccc; padding:12px; border-radius:8px; background:#fafafa;}
  img{max-width:100%; height:auto; display:block; margin:12px 0 4px;}
  code{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;}
  details{margin-top:8px;}
  .sig{margin-top:28px; display:flex; gap:48px;}
  .sig div{border-top:1px solid #000; padding-top:6px; width:260px; text-align:center;}
</style>
<h1>PRMMTN · Edition Certificate</h1>
<div class="meta">
  <div>Date: ${now.toISOString()}</div>
  <div>Chromatic pattern: ${activePatternId}</div>
  <div>sceneSeed: ${sceneSeed} · S_global: ${S_global}</div>
</div>

<h2>Image (A2)</h2>
<div class="box">
  <img src="${pngDataURL}" alt="PRMMTN A2 snapshot">
  <div style="font-size:12px;color:#444">Resolution: 7016×4961 px (A2 landscape)</div>
</div>

<h2>Integrity</h2>
<div class="box">
  <div>SHA‑256 (prmttn_config.json):</div>
  <div><code>${hashHex}</code></div>
  <details><summary>How to verify</summary>
    <pre>shasum -a 256 prmttn_config.json
# or
openssl dgst -sha256 prmttn_config.json</pre>
  </details>
</div>


<h2>Phenotypic scope</h2>
<div class="box">
  <ul>
    <li><b>BUILD:</b> 120 attribute-mappings × 11 chromatic-patterns = <b>${fmt(TOTAL_BUILD)}</b> deterministic visuals.</li>
  </ul>
  <p style="font-size:12px;color:#555;margin:8px 0 0;">
    Note: permutations are acquired as a <b>group</b>; the count does not multiply by the size of the group.
  </p>
</div>

<h2>Configuration (pretty view)</h2>
<div class="box">
  <details open><summary>Show JSON</summary>
    <pre>${prettyJSON.replace(/</g,"&lt;")}</pre>
  </details>
</div>

<div class="sig">
  <div>Edition signature</div>
</div>

<p style="margin-top:24px;color:#777;font-size:12px">This certificate is self‑contained (image + data). Work in progress.</p>`;
        // 4) Descargas (3 archivos + hash opcional)
        downloadBlob('PRMMTN_certificate.html', new Blob([certHTML], {type:'text/html'}));
        downloadBlob('PRMTTN_A2.png', pngBlob);
        downloadBlob('prmttn_config.json', new Blob([canonicalJSON], {type:'application/json'}));
        downloadBlob('prmttn_hash.txt', new Blob([`sha256  prmttn_config.json\n${hashHex}\n`], {type:'text/plain'}));

        showPopup("Certificado, imagen A2, JSON y hash descargados.", 3000);
      }catch(err){
        console.error(err);
        showPopup("Error generando certificado", 4000);
      }
    }

 

</script>

</body>
</html>
